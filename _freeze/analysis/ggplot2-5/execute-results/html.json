{
  "hash": "c2509242dbfaf750a0dbf5179d8365ac",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"ggplot2 (Extending)\"\nauthor: \"John Benninghoff\"\ndate: '2022-12-18'\ndate-modified: '2023-11-11'\ncategories: [exercises, ggplot2]\norder: 305\noutput:\n  html_notebook:\n    theme:\n      version: 5\n      preset: bootstrap\n    css: assets/extra.css\n    pandoc_args: --shift-heading-level-by=1\n    toc: yes\n    toc_float:\n      collapsed: yes\n      smooth_scroll: no\n---\n\n\nWorkbook for completing quizzes and exercises from the \"Extending\" chapters of [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/index.html), third edition, with comparisons to solutions from [Solutions to ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book-solutions-3ed.netlify.app).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(wesanderson)\nlibrary(scales)\nlibrary(maps)\nlibrary(dplyr)\n\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  fig.align = \"center\"\n)\n```\n:::\n\n\n# Introduction\n\nThis workbook includes answers and solutions to the quizzes and exercises from [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/index.html) and [Solutions to ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book-solutions-3ed.netlify.app), organized by chapter. It includes excerpts from both books, copied here.\n\n**WARNING, SPOILERS!** If you haven't read the ggplot2 book and intend to complete the quizzes and exercises, don't read this notebook. It contains my (potentially wrong) answers to both.\n\n# 19 Programming with ggplot2\n\nA major requirement of a good data analysis is flexibility. If your data changes, or you discover something that makes you rethink your basic assumptions, you need to be able to easily change many plots at once. The main inhibitor of flexibility is code duplication. If you have the same plotting statement repeated over and over again, you'll have to make the same change in many different places. Often just the thought of making all those changes is exhausting! This chapter will help you overcome that problem by showing you how to program with ggplot2.\n\nTo make your code more flexible, you need to reduce duplicated code by writing functions. When you notice you're doing the same thing over and over again, think about how you might generalise it and turn it into a function. If you're not that familiar with how functions work in R, you might want to brush up your knowledge at <https://adv-r.hadley.nz/functions.html>. \n\n## 19.2.1 Exercises\n\n1.  Create an object that represents a pink histogram with 100 bins.\n\nAnswer: `pink_hist` applied to the price of `diamonds`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npink_hist <- geom_histogram(bins = 100, fill = \"pink\")\n\nggplot(diamonds, aes(price)) +\n  pink_hist\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-1-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nGG Solutions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npink_hist_ggs <- geom_histogram(\n  color = \"pink\",\n  bins = 100\n)\n```\n:::\n\n\nNote: I think the intent here is to set `fill`, not `color`.\n\n---\n\n2.  Create an object that represents a fill scale with the Blues \n    ColorBrewer palette.\n\nAnswer: `blues` applied to a `geom_bar()` example:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nblues <- scale_fill_brewer(palette = \"Blues\")\n\nggplot(mpg, aes(class, fill = drv)) +\n  geom_bar() +\n  theme_classic() +\n  blues\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nGG Solutions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfill_blues <- scale_fill_distiller(\n  palette = \"Blues\"\n)\n```\n:::\n\n\nNote that the documentation states:\n\n> The `distiller` scales extend `brewer` scales by smoothly interpolating 7 colours from any palette to a continuous scale.\n\n---\n\n3.  Read the source code for `theme_grey()`. What are its arguments? \n    How does it work?\n\nAnswer: `theme_grey()` has 4 arguments: `base_size`, `base_family`, `base_line_size`, and `base_rect_size`. It specifies a complete theme object, `t`, and uses the `%+replace%` function to modify an internal global, `ggplot_global$theme_all_null` using `t`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntheme_grey\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (base_size = 11, base_family = \"\", base_line_size = base_size/22, \n#>     base_rect_size = base_size/22) \n#> {\n#>     half_line <- base_size/2\n#>     t <- theme(line = element_line(colour = \"black\", linewidth = base_line_size, \n#>         linetype = 1, lineend = \"butt\"), rect = element_rect(fill = \"white\", \n#>         colour = \"black\", linewidth = base_rect_size, linetype = 1), \n#>         text = element_text(family = base_family, face = \"plain\", \n#>             colour = \"black\", size = base_size, lineheight = 0.9, \n#>             hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), \n#>             debug = FALSE), axis.line = element_blank(), axis.line.x = NULL, \n#>         axis.line.y = NULL, axis.text = element_text(size = rel(0.8), \n#>             colour = \"grey30\"), axis.text.x = element_text(margin = margin(t = 0.8 * \n#>             half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * \n#>             half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * \n#>             half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * \n#>             half_line/2), hjust = 0), axis.text.r = element_text(margin = margin(l = 0.8 * \n#>             half_line/2, r = 0.8 * half_line/2), hjust = 0.5), \n#>         axis.ticks = element_line(colour = \"grey20\"), axis.ticks.length = unit(half_line/2, \n#>             \"pt\"), axis.ticks.length.x = NULL, axis.ticks.length.x.top = NULL, \n#>         axis.ticks.length.x.bottom = NULL, axis.ticks.length.y = NULL, \n#>         axis.ticks.length.y.left = NULL, axis.ticks.length.y.right = NULL, \n#>         axis.minor.ticks.length = rel(0.75), axis.title.x = element_text(margin = margin(t = half_line/2), \n#>             vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line/2), \n#>             vjust = 0), axis.title.y = element_text(angle = 90, \n#>             margin = margin(r = half_line/2), vjust = 1), axis.title.y.right = element_text(angle = -90, \n#>             margin = margin(l = half_line/2), vjust = 1), legend.background = element_rect(colour = NA), \n#>         legend.spacing = unit(2 * half_line, \"pt\"), legend.spacing.x = NULL, \n#>         legend.spacing.y = NULL, legend.margin = margin(half_line, \n#>             half_line, half_line, half_line), legend.key = NULL, \n#>         legend.key.size = unit(1.2, \"lines\"), legend.key.height = NULL, \n#>         legend.key.width = NULL, legend.key.spacing = unit(half_line, \n#>             \"pt\"), legend.text = element_text(size = rel(0.8)), \n#>         legend.title = element_text(hjust = 0), legend.ticks.length = rel(0.2), \n#>         legend.position = \"right\", legend.direction = NULL, legend.justification = \"center\", \n#>         legend.box = NULL, legend.box.margin = margin(0, 0, 0, \n#>             0, \"cm\"), legend.box.background = element_blank(), \n#>         legend.box.spacing = unit(2 * half_line, \"pt\"), panel.background = element_rect(fill = \"grey92\", \n#>             colour = NA), panel.border = element_blank(), panel.grid = element_line(colour = \"white\"), \n#>         panel.grid.minor = element_line(linewidth = rel(0.5)), \n#>         panel.spacing = unit(half_line, \"pt\"), panel.spacing.x = NULL, \n#>         panel.spacing.y = NULL, panel.ontop = FALSE, strip.background = element_rect(fill = \"grey85\", \n#>             colour = NA), strip.clip = \"inherit\", strip.text = element_text(colour = \"grey10\", \n#>             size = rel(0.8), margin = margin(0.8 * half_line, \n#>                 0.8 * half_line, 0.8 * half_line, 0.8 * half_line)), \n#>         strip.text.x = NULL, strip.text.y = element_text(angle = -90), \n#>         strip.text.y.left = element_text(angle = 90), strip.placement = \"inside\", \n#>         strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(half_line/2, \n#>             \"pt\"), strip.switch.pad.wrap = unit(half_line/2, \n#>             \"pt\"), plot.background = element_rect(colour = \"white\"), \n#>         plot.title = element_text(size = rel(1.2), hjust = 0, \n#>             vjust = 1, margin = margin(b = half_line)), plot.title.position = \"panel\", \n#>         plot.subtitle = element_text(hjust = 0, vjust = 1, margin = margin(b = half_line)), \n#>         plot.caption = element_text(size = rel(0.8), hjust = 1, \n#>             vjust = 1, margin = margin(t = half_line)), plot.caption.position = \"panel\", \n#>         plot.tag = element_text(size = rel(1.2), hjust = 0.5, \n#>             vjust = 0.5), plot.tag.position = \"topleft\", plot.margin = margin(half_line, \n#>             half_line, half_line, half_line), complete = TRUE)\n#>     ggplot_global$theme_all_null %+replace% t\n#> }\n#> <bytecode: 0x11a376d50>\n#> <environment: namespace:ggplot2>\n```\n\n\n:::\n:::\n\n\nGG Solutions:\n\n- Its arguments include `base_size`, `base_family`, `base_line_size`, and `base_rect_size`\n- According to the help file, `theme_gray()` is the signature ggplot2 theme with a grey background and white gridlines and is designed to put the data forward yet make comparisons easy.\n\n---\n\n4.  Create `scale_colour_wesanderson()`. It should have a parameter to pick \n    the palette from the wesanderson package, and create either a continuous\n    or discrete scale.\n\nAnswer: to construct this function, it is helpful to review the code for `scale_color_brewer()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale_color_brewer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (name = waiver(), ..., type = \"seq\", palette = 1, direction = 1, \n#>     aesthetics = \"colour\") \n#> {\n#>     discrete_scale(aesthetics, name = name, palette = pal_brewer(type, \n#>         palette, direction), ...)\n#> }\n#> <bytecode: 0x1067cf8f8>\n#> <environment: namespace:ggplot2>\n```\n\n\n:::\n:::\n\n\nThe function is a wrapper for `discrete_scale()` and calls `scales::brewer_pal()`, which is a [function factory](https://adv-r.hadley.nz/function-factories.html):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscales::brewer_pal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (type = \"seq\", palette = 1, direction = 1) \n#> {\n#>     pal <- pal_name(palette, type)\n#>     force(direction)\n#>     function(n) {\n#>         if (n < 3) {\n#>             pal <- suppressWarnings(RColorBrewer::brewer.pal(n, \n#>                 pal))\n#>         }\n#>         else {\n#>             pal <- RColorBrewer::brewer.pal(n, pal)\n#>         }\n#>         pal <- pal[seq_len(n)]\n#>         if (direction == -1) {\n#>             pal <- rev(pal)\n#>         }\n#>         pal\n#>     }\n#> }\n#> <bytecode: 0x10618eea0>\n#> <environment: namespace:scales>\n```\n\n\n:::\n:::\n\n\nFirst we construct a discrete scale, using `Darjeeling1` as the default:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwesanderson_pal <- function(name, type) {\n  function(n) {\n    wes_palette(name, n, type)\n  }\n}\n\nscale_color_wesanderson_d <- function(..., name = \"Darjeeling1\", type = \"discrete\",\n                                      aesthetics = \"colour\") {\n  discrete_scale(aesthetics, \"wesanderson_d\", wesanderson_pal(name, type), ...)\n}\n```\n:::\n\n\nNote that these functions are limited by the number of colors in each wesanderson palette (4-7), which will generate an error if more colors are requested. The `wesanderson_pal` function could be revised to auto-enable `continuous` or `scale_color_wesanderson_d()` can be called with `type = \"continuous\"`.\n\nFor a continuous scale, it is helpful to review the code of `scale_color_viridis_c()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale_color_viridis_c\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (name = waiver(), ..., alpha = 1, begin = 0, end = 1, \n#>     direction = 1, option = \"D\", values = NULL, space = \"Lab\", \n#>     na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\") \n#> {\n#>     continuous_scale(aesthetics, name = name, palette = pal_gradient_n(pal_viridis(alpha, \n#>         begin, end, direction, option)(6), values, space), na.value = na.value, \n#>         guide = guide, ...)\n#> }\n#> <bytecode: 0x11906df90>\n#> <environment: namespace:ggplot2>\n```\n\n\n:::\n:::\n\n\nWe can add a continuous scale based using `Zissou1` as the default:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale_color_wesanderson_c <- function(...,\n                                      name = \"Zissou1\",\n                                      type = \"continuous\",\n                                      values = NULL,\n                                      space = \"Lab\",\n                                      na.value = \"grey50\",\n                                      guide = \"colourbar\",\n                                      aesthetics = \"colour\") {\n  continuous_scale(\n    aesthetics, \"wesanderson_c\",\n    gradient_n_pal(wesanderson_pal(name, type)(length(wes_palettes[[name]])), values, space),\n    na.value = na.value, guide = guide, ...\n  )\n}\n```\n:::\n\n\n`scale_colour_wesanderson_d()` applied to an `mpg` plot:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mpg, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  scale_color_wesanderson_d()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: The `scale_name` argument of `discrete_scale()` is deprecated as of ggplot2\n#> 3.5.0.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=816}\n:::\n:::\n\n\n`scale_colour_wesanderson_c()` applied to an `mpg` plot:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mpg, aes(displ, hwy, color = cyl)) +\n  geom_point() +\n  scale_color_wesanderson_c()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: The `scale_name` argument of `continuous_scale()` is deprecated as of ggplot2\n#> 3.5.0.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nNotes: while the exercise calls for a single function, this breaks the normal conventions for ggplot2. Such a function could be written by combining `scale_colour_wesanderson_d()` and `scale_colour_wesanderson_c()`.\n\nGG Solutions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale_colour_wesanderson <- function(palette = \"BottleRocket1\", ...) {\n  scale_color_manual(values = wesanderson::wes_palette(palette), ...)\n}\n# Working example\nggplot(mtcars, aes(wt, disp, color = factor(gear))) +\n  geom_point() +\n  scale_colour_wesanderson()\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=816}\n:::\n:::\n\n\n---\n\n## 19.3.4 Exercises\n\n1.  To make the best use of space, many examples in this book hide the axes \n    labels and legend. I've just copied-and-pasted the same code into multiple \n    places, but it would make more sense to create a reusable function. \n    What would that function look like?\n\nAnswer: `hide_ll()` does this, demonstrated with an `mpg` plot.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhide_ll <- function() {\n  list(\n    labs(x = NULL, y = NULL),\n    theme(legend.position = \"none\")\n  )\n}\n\nggplot(mpg, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  hide_ll()\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nGG Solutions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nremove_labels <- theme(\n  legend.position = \"none\",\n  axis.title.x = element_blank(),\n  axis.title.y = element_blank()\n)\n# Working Example\nggplot(mtcars, aes(wt, disp, color = factor(gear))) +\n  geom_point() +\n  remove_labels\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nNote: the GG Solutions answer is more verbose, but uses only a single function call (theme).\n\n---\n\n2.  Extend the `borders()` function to also add `coord_quickmap()` to the\n    plot.\n\nAnswer: `borders_quickmap()` implemented and demonstrated using a `borders()` example. In this case, the function passes all `...` variables to `borders()` and none to `coord_quickmap()` which avoids the complexity of handling arguments for both functions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nborders_quickmap <- function(...) {\n  list(\n    borders(...),\n    coord_quickmap()\n  )\n}\n\nus.cities |>\n  filter(capital == 2, !(country.etc %in% c(\"AK\", \"HI\"))) |>\n  ggplot(aes(long, lat)) +\n  geom_point() +\n  borders_quickmap(\"state\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nNote: because of the complexities, it's unlikely I'd ever implement something like [Additional arguments](https://ggplot2-book.org/programming.html#additional-arguments) - there are minimal gains compared to calling two functions with separate lists of parameters.\n\nGG Solutions: Not sure.\n\n---\n\n3.  Look through your own code. What combinations of geoms or scales do you\n    use all the time? How could you extract the pattern into a reusable \n    function?\n\nAnswer: a common pattern I use is `geom_smooth` with `lm` and `y ~ x`. An implementation of this using robust linear modeling from `MASS` is demonstrated below:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngeom_rlm <- function(mapping = NULL, data = NULL, stat = \"smooth\", position = \"identity\", ...,\n                     method = MASS::rlm, formula = y ~ x, se = TRUE,\n                     na.rm = FALSE,\n                     orientation = NA,\n                     show.legend = NA, inherit.aes = TRUE) {\n  geom_smooth(\n    mapping = mapping, data = data, stat = stat, position = position, ...,\n    method = method, formula = formula, se = se, na.rm = na.rm, orientation = orientation,\n    show.legend = show.legend, inherit.aes = TRUE\n  )\n}\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_rlm()\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nGG Solutions: no answer.\n\n---\n\n## 19.4.2 Exercises\n\n1.  Create a `distribution()` function specially designed for visualising \n    continuous distributions. Allow the user to supply a dataset and the\n    name of a variable to visualise. Let them choose between histograms,\n    frequency polygons, and density plots. What other arguments might you\n    want to include?\n\nAnswer: code below. In this case, it is useful to include `binwidth` and `bins`, used in creating both histograms and frequency polygons, and `na.rm`, used in all three. Defaults to histogram.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndistribution <- function(data, var, type = \"histogram\", binwidth = NULL, bins = NULL,\n                         na.rm = FALSE) {\n  gg <- ggplot(data, aes({{ var }}))\n\n  if (type == \"histogram\") {\n    gg <- gg + geom_histogram(binwidth = binwidth, bins = bins, na.rm = na.rm)\n  } else if (type == \"freqpoly\") {\n    gg <- gg + geom_freqpoly(binwidth = binwidth, bins = bins, na.rm = na.rm)\n  } else if (type == \"density\") {\n    gg <- gg + geom_density(na.rm = na.rm)\n  } else {\n    stop(\"`type` must be histogram, freqpoly, or density\")\n  }\n  gg\n}\n\ndistribution(diamonds, price, binwidth = 100)\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=816}\n:::\n\n```{.r .cell-code}\ndistribution(diamonds, price, type = \"freqpoly\", binwidth = 100)\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-18-2.png){fig-align='center' width=816}\n:::\n\n```{.r .cell-code}\ndistribution(diamonds, price, type = \"density\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-18-3.png){fig-align='center' width=816}\n:::\n:::\n\n\n---\n\n2.  What additional arguments should `pcp()` take? What are the downsides\n    of how `...` is used in the current code?\n\nAnswer: it would be useful to add arguments for the order of the variables, and a scale adjustment for value, drawing from examples on [Wikipedia](https://en.wikipedia.org/wiki/Parallel_coordinates). Using `...` for `geom_line()` prevents other unnamed parameters from being passed to other functions, like `ggplot()`.\n\n---\n\n## 19.5.1 Exercises\n    \n1.  How could you add a `geom_point()` layer to each element of the following \n    list?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplots <- list(\n  ggplot(mpg, aes(displ, hwy)),\n  ggplot(diamonds, aes(carat, price)),\n  ggplot(faithfuld, aes(waiting, eruptions, size = density))\n)\n```\n:::\n\n\nAnswer: easily done with `lapply`()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlapply(plots, function(g) g + geom_point())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=816}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> [[2]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-20-2.png){fig-align='center' width=816}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> [[3]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-20-3.png){fig-align='center' width=816}\n:::\n:::\n\n\n---\n\n2.  What does the following function do? What's a better name for it?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmystery <- function(...) {\n  Reduce(`+`, list(...), accumulate = TRUE)\n}\n\nmystery(\n  ggplot(mpg, aes(displ, hwy)) +\n    geom_point(),\n  geom_smooth(),\n  xlab(NULL),\n  ylab(NULL)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-21-1.png){fig-align='center' width=816}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> [[2]]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-21-2.png){fig-align='center' width=816}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> [[3]]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-21-3.png){fig-align='center' width=816}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> [[4]]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](ggplot2-5_files/figure-html/unnamed-chunk-21-4.png){fig-align='center' width=816}\n:::\n:::\n\n\nAnswer: a better name would be 'add layer and print'.\n\n---\n",
    "supporting": [
      "ggplot2-5_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}