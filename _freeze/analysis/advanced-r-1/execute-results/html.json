{
  "hash": "0d38b639c18daea1a08372721d917629",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advanced R (Foundations)\"\nauthor: \"John Benninghoff\"\ndate: '2022-06-12'\ndate-modified: '2022-07-31'\ncategories: [exercises, advanced-r]\norder: 201\noutput:\n  html_notebook:\n    theme:\n      version: 5\n      preset: bootstrap\n    css: assets/extra.css\n    pandoc_args: --shift-heading-level-by=1\n    toc: yes\n    toc_float:\n      collapsed: yes\n      smooth_scroll: no\n---\n\n\nWorkbook for completing quizzes and exercises from the \"Foundations\" chapters of [Advanced R](https://adv-r.hadley.nz/index.html), second edition, with comparisons to solutions from [Advanced R Solutions](https://advanced-r-solutions.rbind.io).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lobstr)\nlibrary(bench)\nlibrary(rlang)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)\n```\n:::\n\n\n# Introduction\n\nThis workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html) and [Advanced R Solutions](https://advanced-r-solutions.rbind.io), organized by chapter. It includes excerpts from both books, copied here.\n\n**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and exercises, don't read this notebook. It contains my (potentially wrong) answers to both.\n\n# 2 Names and values\n\nIn R, it is important to understand the distinction between an object and its name. Doing so will help you:\n\n* More accurately predict the performance and memory usage of your code. \n* Write faster code by avoiding accidental copies, a major source of slow code. \n* Better understand R's functional programming tools.\n\nThe goal of this chapter is to help you understand the distinction between names and values, and when R will copy an object.\n\n## 2 Quiz\n\n1.  Given the following data frame, how do I create a new column called \"3\"\n    that contains the sum of `1` and `2`? You may only use `$`, not `[[`.\n    What makes `1`, `2`, and `3` challenging as variable names?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)\n```\n:::\n\n\nAnswer: use the following code.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf2 <- data.frame(df, df$`1` + df$`2`)\nnames(df2) <- c(1, 2, 3)\n```\n:::\n\n\nUsing numbers as names is problematic due to them being interpreted as numeric constants by default.\n\n---\n\n2.  In the following code, how much memory does `y` occupy?\n   \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- runif(1e6)\ny <- list(x, x, x)\n```\n:::\n\n\nAnswer: 3 times the size of x, 24 MB. Note: this is incorrect, as shown by `obj_size` and `obj_addr`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nobj_size(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(y[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1309b0000\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(y[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1309b0000\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(y[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1309b0000\"\n```\n\n\n:::\n:::\n\n\n---\n\n3.  On which line does `a` get copied in the following example?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\na <- c(1, 5, 3, 2)\nobj_addr(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x10824de28\"\n```\n\n\n:::\n\n```{.r .cell-code}\nb <- a\nobj_addr(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x10824de28\"\n```\n\n\n:::\n\n```{.r .cell-code}\nb[[1]] <- 10\nobj_addr(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1082d0708\"\n```\n\n\n:::\n:::\n\n\nAnswer: the third line (copy-on-write). [copy-on-modify]\n\n## 2.2.2 Exercises\n\n1.  Explain the relationship between `a`, `b`, `c` and `d` in the following \n    code:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\n```\n:::\n\n\nAnswer: a, b, and c all point to the same object (1:10). d points to an identical object at a different address.\n\nAR Solutions: `a`, `b`, and `c` point to the same object (with the same address in memory). This object has the value `1:10`. `d` points to a different object with the same value.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nobj_addr(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x107f2da10\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x107f2da10\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x107f2da10\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x108033a18\"\n```\n\n\n:::\n:::\n\n\n---\n\n2.  The following code accesses the mean function in multiple ways. Do they all \n    point to the same underlying function object? Verify this with \n    `lobstr::obj_addr()`.\n    \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")\n```\n:::\n\n\nCheck the `obj_addr`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nobj_addr(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1058a22b8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(base::mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1058a22b8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(get(\"mean\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1058a22b8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(evalq(mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1058a22b8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(match.fun(\"mean\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1058a22b8\"\n```\n\n\n:::\n:::\n\n\nAnswer: they do.\n\nAR Solutions: Yes, they point to the same object. We confirm this by inspecting the address of the underlying function object.\n\n---\n\n3.  By default, base R data import functions, like `read.csv()`, will \n    automatically convert non-syntactic names to syntactic ones. Why might \n    this be problematic? What option allows you to suppress this behaviour?\n\nAnswer: this could introduce problematic names, like `1`. Setting `check.names = FALSE` suppresses this behavior.\n\nAR Solutions: Column names are often data, and the underlying `make.names()` transformation is non-invertible, so the default behaviour corrupts data. To avoid this, set `check.names = FALSE`.\n\n---\n\n4.  What rules does `make.names()` use to convert non-syntactic names into\n    syntactic ones?\n\nAnswer: from `?make.names`:\n\n> The character \"X\" is prepended if necessary. All invalid characters are translated to \".\". A missing value is translated to \"NA\". Names which match R keywords have a dot appended to them. Duplicated values are altered by make.unique.\n\nAR Solutions: A valid name must start with a letter or a dot (not followed by a number) and may further contain numbers and underscores (`\"_\"`s are allowed since R version 1.9.0).\n\nThree main mechanisms ensure syntactically valid names (see `?make.names`):\n\n1. Names that do not start with a letter or a dot will be prepended with an `\"X\"`.\n   The same holds for names that begin with a dot followed by a number.\n2. Additionally, non-valid characters are replaced by a dot.\n3. Reserved R keywords (see `?reserved`) are suffixed by a dot.\n\nInterestingly, some of these transformations are influenced by the current locale. From `?make.names`:\n\n> The definition of a letter depends on the current locale, but only ASCII digits are considered to be digits.\n\n---\n\n5.  I slightly simplified the rules that govern syntactic names. Why is `.123e1`\n    not a syntactic name? Read `?make.names` for the full details.\n\nAnswer: from `?make.names`:\n\n> A syntactically valid name consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number. Names such as \".2way\" are not valid, and neither are the reserved words.\n\nAR Solutions: `.123e1` is not a syntactic name, because it starts with one dot which is followed by a number. This makes it a double, `1.23`.\n\n---\n\n## 2.3.6 Exercises\n\n1.  Why is `tracemem(1:10)` not useful?\n\nAnswer: this is tracing an 'immutable' object which will always have the same address.\n\nAR Solutions: When `1:10` is called an object with an address in memory is created, but it is not bound to a name. Therefore, the object cannot be called or manipulated from R. As no copies will be made, it is not useful to track the object for copying.\n\n---\n\n2.  Explain why `tracemem()` shows two copies when you run this code.\n    Hint: carefully look at the difference between this code and the code \n    shown earlier in the section.\n     \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\nx <- c(1L, 2L, 3L)\ntracemem(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"<0x109486f88>\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx[[3]] <- 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> tracemem[0x109486f88 -> 0x1096381c8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \n#> tracemem[0x1096381c8 -> 0x10970b718]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main\n```\n\n\n:::\n\n```{.r .cell-code}\nuntracemem(x)\n```\n:::\n\n\nAnswer: unclear. The behavior in R 4.2.0 seems to have changed, since this code shows two copies:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\nx <- c(1, 2, 3)\ntracemem(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"<0x109a9f338>\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- x\ny[[3]] <- 4L\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> tracemem[0x109a9f338 -> 0x109b33248]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main\n```\n\n\n:::\n\n```{.r .cell-code}\ny[[3]] <- 5L\nuntracemem(x)\n```\n:::\n\n\nAR Solutions: Initially the vector `x` has integer type. The replacement call assigns a double to the third element of `x`, which triggers copy-on-modify.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1L, 2L, 3L)\ntracemem(x)\n#> <0x66a4a70>\n\nx[[3]] <- 4\n#> tracemem[0x55eec7b3af38 -> 0x55eec774cc18]:\n```\n:::\n\n\nWe can avoid the copy by sub-assigning an integer instead of a double:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1L, 2L, 3L)\ntracemem(x)\n#> <0x55eec6940ae0>\n\nx[[3]] <- 4L\n```\n:::\n\n\nPlease be aware that running this code in RStudio will result in additional copies because of the reference from the environment pane.\n\n---\n\n3.  Sketch out the relationship between the following objects:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\n\nprint(\"first object\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"first object\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x109adcfd0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(b[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x109adcfd0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(b[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x109adcfd0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(c[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x109adcfd0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"second object\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"second object\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x109bf4788\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(c[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x109bf4788\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"third object\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"third object\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x10fad8eb8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"fourth object (?)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"fourth object (?)\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(c[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"0x1067aa120\"\n```\n\n\n:::\n:::\n\n\nAnswer: four different objects with multiple names.\n\nAR Solutions: `a` contains a reference to an address with the value `1:10`. `b` contains a list of two references to the same address as `a`. `c` contains a list of `b` (containing two references to `a`), `a` (containing the same reference again) and a reference pointing to a different address containing the same value (`1:10`).\n\n---\n\n4.  What happens when you run this code? Draw a picture.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- list(1:10)\n\nx[[2]] <- x\n\nref(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █ [1:0x13cd5b908] <list> \n#> ├─[2:0x128fbccd0] <int> \n#> └─█ [3:0x105bc1b38] <list> \n#>   └─[2:0x128fbccd0]\n```\n\n\n:::\n:::\n\n\nInitially x is a list of one element, an int vector 1:10. Then a second list element is added, which points to the original int vector.\n\nAR Solutions: The initial reference tree of `x` shows that the name `x` binds to a list object. This object contains a reference to the integer vector `1:10`. When `x` is assigned to an element of itself, copy-on-modify takes place and the list is copied to a new address in memory. The list object previously bound to `x` is now referenced in the newly created list object. It is no longer bound to a name. The integer vector is referenced twice.\n\n---\n\n## 2.4.1 Exercises\n\n1.  In the following example, why are `object.size(y)` and `obj_size(y)`\n    so radically different? Consult the documentation of `object.size()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 8005648 bytes\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 80.90 kB\n```\n\n\n:::\n:::\n\n\nAnswer: `object.size()` \"does not detect if elements of a list are shared\", which is the case here. That is, it does not detect the list has been replicated 100 times, and overestimates by a factor of 100 compared to `object_size()`.\n\nAR Solutions: `object.size()` doesn't account for shared elements within lists. Therefore, the results differ by a factor of ~ 100.\n\n\n---\n\n2.  Take the following list. Why is its size somewhat misleading?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfuns <- list(mean, sd, var)\nobj_size(funs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 18.76 kB\n```\n\n\n:::\n:::\n\n\nAnswer: it doesn't seem misleading to me, but the list includes the function objects, not the return values. Also, it calculates the size discarding the overlap between the functions. Per the code below, there is some:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nobj_size(mean) + obj_size(sd) + obj_size(var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 19.29 kB\n```\n\n\n:::\n:::\n\n\nAR Solutions: All three functions are built-in to R as part of the `{base}` and `{stats}` packages and hence always available. So, what does it mean to measure the size of something that's already included in R?\n\n(There's typically a more general question about what you want to know when you ask for the size of something — do you want to know how much data you'd need to send to communicate the object to someone else (e.g. serialise it), or do you want to know how much memory you'd free if you deleted it?)\n\n---\n\n3.  Predict the output of the following code:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\na <- runif(1e6)\nobj_size(a) # 8,000,048 B ~ 8MB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\n# correct: from example above, runif(1e6) ~= 8MB\n\nb <- list(a, a)\nobj_size(b) # slightly larger than obj_size(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\n# correct: two lists containing numeric vectors\nobj_size(a, b) # slightly larger than obj_size(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\n# wrong: a is entirely contained within b\n\nb[[1]][[1]] <- 10\nobj_size(b) # copy of b, same size\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 16.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\n# wrong: double, since R copies an entire column, this adds the size of runif(1e6)\nobj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 16.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\n# wrong: a is still entirely contained with b\n\nb[[2]][[1]] <- 10\nobj_size(b) # copy of b, same size\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 16.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\n# wrong: same size since it's still 2 numeric vectors of 1e6 length\nobj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 24.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\n# wrong: there is no longer any overlap, so the size of obj_size(a, b) = obj_size(a) = obj_size(b)\n```\n:::\n\n\nAnswer: answers inline.\n\nAR Solutions:\n\n`a <- runif(1e6)`:\n\n- In R (on most platforms) a length-0 vector has 48 bytes of overhead.\n- A single double takes up an additional 8 bytes of memory.\n- So, a 1 million double should take up 8,000,048 bytes.\n\nFor `b <- list(a, a)` both list elements contain references to the same memory address. Therefore, no additional memory is required for the second list element. The list itself requires 64 bytes, 48 bytes for an empty list and 8 bytes for each element (`obj_size(vector(\"list\", 2))`). This lets us predict 8,000,048 B + 64 B = 8,000,112 B.\n\n`b[[1]][[1]] <- 10`: When we modify the first element of `b[[1]]` copy-on-modify occurs. Both elements will still have the same size (8,000,040 B), but the first one gets a new address in memory. As `b`'s elements don't share references anymore, its object size adds up to the sum of the elements and the length-2 list: 8,000,048 B + 8,000,048 B + 64 B = 16,000,160 B (16 MB). The second element of `b` still references the same address as `a`, so the combined size of `a` and `b` is the same as `b`.\n\n`b[[2]][[1]] <- 10`: When we modify the second element of `b`, this element will also point to a new memory address. This does not affect the size of the list. However, as `b` doesn't share references with `a` anymore, the memory usage of the combined objects increases.\n\n---\n\n## 2.5.3 Exercises\n\n1.  Explain why the following code doesn't create a circular list.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- list()\nx[[1]] <- x\n```\n:::\n\n\nAnswer: the name x is assigned to the empty list, and then the first element of x is mapped to the object that x points to, the empty list.\n\nAR Solutions: In this situation copy-on-modify prevents the creation of a circular list. Let us step through the details:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- list() # creates initial object\nobj_addr(x)\n#> [1] \"0x55862f23ab80\"\ntracemem(x)\n#> [1] \"<0x55862f23ab80>\"\nx[[1]] <- x # Copy-on-modify triggers new copy\n#> tracemem[0x55862f23ab80 -> 0x55862e8ce028]:\nobj_addr(x) # copied object has new memory address\n#> [1] \"0x55862e8ce028\"\nobj_addr(x[[1]]) # list element contains old memory address\n#> [1] \"0x55862f23ab80\"\n```\n:::\n\n\n---\n\n2.  Wrap the two methods for subtracting medians into two functions, then\n    use the 'bench' package [@bench] to carefully compare their speeds. How does\n    performance change as the number of columns increase?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx_medians <- function(ncol) {\n  x <- data.frame(matrix(runif(5 * 1e4), ncol = ncol))\n  medians <- vapply(x, median, numeric(1))\n  return(list(x = x, medians = medians))\n}\n\ndf_medians <- function(x, medians) {\n  # subtract medians using data.frame method\n  for (i in seq_along(medians)) {\n    x[[i]] <- x[[i]] - medians[[i]]\n  }\n  x\n}\n\nls_medians <- function(x, medians) {\n  y <- as.list(x)\n\n  for (i in seq_along(medians)) {\n    y[[i]] <- y[[i]] - medians[[i]]\n  }\n  y\n}\n\n# confirm they both work\nxm <- x_medians(5)\nhead(df_medians(xm$x, xm$medians), 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>             X1          X2          X3           X4         X5\n#> 1   0.04369877 -0.12343847 -0.48922113 -0.146598497 -0.2654805\n#> 2  -0.04546978 -0.19296387 -0.42382440  0.212102621  0.4025081\n#> 3  -0.17762408 -0.23940198 -0.21213014  0.264803931 -0.2605202\n#> 4  -0.11086655 -0.06925057  0.17140543  0.378969395 -0.1148295\n#> 5  -0.37466195  0.26574635  0.33328310  0.047525161 -0.3423237\n#> 6  -0.10997077 -0.33625997  0.10866945  0.377508526 -0.1747907\n#> 7  -0.45883611  0.40933670  0.08377487  0.007819048  0.1186564\n#> 8  -0.24768451  0.42040105 -0.05249180 -0.262106426 -0.4977060\n#> 9  -0.23342731 -0.45125163  0.21884938 -0.448117266 -0.3207032\n#> 10 -0.25681342 -0.10520468  0.48080027  0.475014569 -0.2819161\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(as.data.frame(ls_medians(xm$x, xm$medians)), 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>             X1          X2          X3           X4         X5\n#> 1   0.04369877 -0.12343847 -0.48922113 -0.146598497 -0.2654805\n#> 2  -0.04546978 -0.19296387 -0.42382440  0.212102621  0.4025081\n#> 3  -0.17762408 -0.23940198 -0.21213014  0.264803931 -0.2605202\n#> 4  -0.11086655 -0.06925057  0.17140543  0.378969395 -0.1148295\n#> 5  -0.37466195  0.26574635  0.33328310  0.047525161 -0.3423237\n#> 6  -0.10997077 -0.33625997  0.10866945  0.377508526 -0.1747907\n#> 7  -0.45883611  0.40933670  0.08377487  0.007819048  0.1186564\n#> 8  -0.24768451  0.42040105 -0.05249180 -0.262106426 -0.4977060\n#> 9  -0.23342731 -0.45125163  0.21884938 -0.448117266 -0.3207032\n#> 10 -0.25681342 -0.10520468  0.48080027  0.475014569 -0.2819161\n```\n\n\n:::\n\n```{.r .cell-code}\n# benchmark\nmark(df_medians(xm$x, xm$medians))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 df_medians(xm$x, xm$medians)   31.9µs   49.4µs    20500.     391KB     300.\n```\n\n\n:::\n\n```{.r .cell-code}\nmark(ls_medians(xm$x, xm$medians))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 ls_medians(xm$x, xm$medians)   9.55µs   25.7µs    42371.     391KB     480.\n```\n\n\n:::\n\n```{.r .cell-code}\nmark(as.data.frame(ls_medians(xm$x, xm$medians))) # as.data.frame introduces significant overhead\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                           <bch> <bch:>     <dbl> <bch:byt>    <dbl>\n#> 1 as.data.frame(ls_medians(xm$x, xm$m… 108µs  129µs     7697.     391KB     88.7\n```\n\n\n:::\n:::\n\n\nAnswer: with 5 columns, the list method is about twice as fast.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nxm <- x_medians(10)\nmark(df_medians(xm$x, xm$medians))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 df_medians(xm$x, xm$medians)   58.1µs   76.7µs    13646.     391KB     164.\n```\n\n\n:::\n\n```{.r .cell-code}\nmark(ls_medians(xm$x, xm$medians))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 ls_medians(xm$x, xm$medians)     11µs     27µs    43728.     391KB     495.\n```\n\n\n:::\n\n```{.r .cell-code}\nxm <- x_medians(20)\nmark(df_medians(xm$x, xm$medians))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 df_medians(xm$x, xm$medians)    111µs    132µs     7527.     400KB     86.8\n```\n\n\n:::\n\n```{.r .cell-code}\nmark(ls_medians(xm$x, xm$medians))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 ls_medians(xm$x, xm$medians)     13µs   25.1µs    40172.     392KB     455.\n```\n\n\n:::\n:::\n\n\nWith 10 columns, the list method is 3 times as fast. With 20, the list method is 5 times as fast. So, the list method is near constant time regardless of columns, whereas the data.frame method scales linearly with the number of columns.\n\nAR Solutions:\n\nWhen working directly with the data frame, the execution time grows quadratically with the number of columns in the input data. This is because (e.g.) the first column must be copied n times, the second column n-1 times, and so on. When working with a list, the execution time increases only linearly.\n\nObviously in the long run, linear growth creates shorter run-times, but there is some cost to this strategy — we have to convert between data structures with as.list() and list2DF(). Even though this is fast and probably doesn’t hurt much, the improved approach doesn’t really pay off in this scenario until we get to a data frame that is about 300 columns wide (with the exact value depending on the characteristics of the system running the code).\n\n---\n\n3.  What happens if you attempt to use `tracemem()` on an environment?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ne <- rlang::env()\ntry(tracemem(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in tracemem(e) : \n#>   'tracemem' is not useful for promise and environment objects\n```\n\n\n:::\n:::\n\n\nAnswer: it throws an error!\n\nAR Solutions: `tracemem()` cannot be used to mark and trace environments.\n\nThe error occurs because \"it is not useful to trace NULL, environments, promises, weak references, or external pointer objects, as these are not duplicated\" (see `?tracemem`). Environments are always modified in place.\n\n---\n\n# 3 Vectors\n\nThis chapter discusses the most important family of data types in base R: vectors. While you've probably already used many (if not all) of the different types of vectors, you may not have thought deeply about how they're interrelated. In this chapter, I won't cover individual vectors types in too much detail, but I will show you how all the types fit together as a whole. If you need more details, you can find them in R's documentation.\n\nVectors come in two flavours: atomic vectors and lists. They differ in terms of their elements' types: for atomic vectors, all elements must have the same type; for lists, elements can have different types. While not a vector, `NULL` is closely related to vectors and often serves the role of a generic zero length vector. This diagram, which we'll be expanding on throughout this chapter, illustrates the basic relationships:\n\nEvery vector can also have __attributes__, which you can think of as a named list of arbitrary metadata. Two attributes are particularly important. The __dimension__ attribute turns vectors into matrices and arrays and the __class__ attribute powers the S3 object system. While you'll learn how to use S3 in Chapter 13, here you'll learn about some of the most important S3 vectors: factors, date and times, data frames, and tibbles. And while 2D structures like matrices and data frames are not necessarily what come to mind when you think of vectors, you'll also learn why R considers them to be vectors.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n## 3.2.5 Exercises\n\n1. How do you create raw and complex scalars? (See `?raw` and \n   `?complex`.)\n\nAnswer: using either `raw()`, `complex()`, or `as.raw()`, `as.complex()`.\n\nAR Solutions: In R, scalars are represented as vectors of length one. However, there's no built-in syntax like there is for logicals, integers, doubles, and character vectors to create individual raw and complex values. Instead, you have to create them by calling a function. For raw vectors you can use either `as.raw()` or `charToRaw()` to create them from numeric or character values.\n\nIn the case of complex numbers, real and imaginary parts may be provided directly to the `complex()` constructor. You can create purely imaginary numbers (e.g.) `1i`, but there is no way to create complex numbers without `+` (e.g. `1i + 1`).\n\n---\n\n2. Test your knowledge of the vector coercion rules by predicting the output of\n   the following uses of `c()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(1, FALSE) # 1.0, 0.0 - double\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 0\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"a\", 1) # \"a\", \"1\" - character\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\" \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, 1L) # 1L, 1L - integer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(c(1, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(c(\"a\", 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(c(TRUE, 1L))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\"\n```\n\n\n:::\n:::\n\n\nAnswer: guesses inline. [correct!]\n\nAR Solutions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(1, FALSE) # will be coerced to double    -> 1 0\nc(\"a\", 1) # will be coerced to character -> \"a\" \"1\"\nc(TRUE, 1L) # will be coerced to integer   -> 1 1\n```\n:::\n\n\n---\n\n3. Why is `1 == \"1\"` true? Why is `-1 < FALSE` true? Why is `\"one\" < 2` false?\n\nAnswers:\n\n- `1 == \"1\"`: the 1 is coerced to \"1\"\n- `-1 < FALSE`: FALSE is coerced to 0\n- `\"one\" < 2: the 2 is coerced to \"2\"\n\n\nAR Solutions: These comparisons are carried out by operator-functions (`==`, `<`), which coerce their arguments to a common type. In the examples above, these types will be character, double and character: `1` will be coerced to `\"1\"`, `FALSE` is represented as `0` and `2` turns into `\"2\"` (and numbers precede letters in lexicographic order (may depend on locale)).\n\n---\n\n4. Why is the default missing value, `NA`, a logical vector? What's special\n   about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)\n\nAnswer: NA must be logical so that it can exist in a logical vector.\n\nAR Solutions: The presence of missing values shouldn't affect the type of an object. Recall that there is a type-hierarchy for coercion from character → double → integer → logical. When combining `NA`s  with other atomic types, the `NA`s will be coerced to integer (`NA_integer_`), double (`NA_real_`) or character (`NA_character_`) and not the other way round.  If `NA` were a character and added to a set of other values all of these would be coerced to character as well.\n\n---\n\n5. Precisely what do `is.atomic()`, `is.numeric()`, and `is.vector()` test for?\n\nAnswers:\n\n- `is.atomic(x)`: tests if x is an atomic vector (logical, integer, numeric, complex, character,\n  and raw) - is `FALSE` for lists\n- `is.numeric(x)`: tests if x is an atomic numeric vector\n- `is.vector(x, mode = \"any\")`: tests if x is an atomic vector OR a list or expression\n\nAR Solutions: The documentation states that:\n\n- `is.atomic()` tests if an object is an atomic vector (as defined in *Advanced R*) or is `NULL` (!).\n- `is.numeric()` tests if an object has type integer or double and is not of class `factor`, `Date`, `POSIXt` or `difftime`.\n- `is.vector()` tests if an object is a vector (as defined in *Advanced R*) or an expression and has no attributes, apart from names.\n\nAtomic vectors are defined in *Advanced R* as objects of type logical, integer, double, complex, character or raw. Vectors are defined as atomic vectors or lists.\n\n---\n\n## 3.3.4 Exercises\n\n1.  How is `setNames()` implemented? How is `unname()` implemented?\n    Read the source code.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetNames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (object = nm, nm) \n#> {\n#>     names(object) <- nm\n#>     object\n#> }\n#> <bytecode: 0x12d6190d0>\n#> <environment: namespace:stats>\n```\n\n\n:::\n\n```{.r .cell-code}\nunname\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (obj, force = FALSE) \n#> {\n#>     if (!is.null(names(obj))) \n#>         names(obj) <- NULL\n#>     if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n#>         dimnames(obj) <- NULL\n#>     obj\n#> }\n#> <bytecode: 0x105c5dd40>\n#> <environment: namespace:base>\n```\n\n\n:::\n:::\n\n\nAnswer: using `names()`, and `dimnames()` for `unname()`.\n\nAR Solutions:\n\nBecause the data argument comes first, `setNames()` also works well with the magrittr-pipe operator. When no first argument is given, the result is a named vector (this is rather untypical as required arguments usually come first):\n\n`unname()` removes existing names (or dimnames) by setting them to `NULL`.\n\n---\n\n2.  What does `dim()` return when applied to a 1-dimensional vector?\n    When might you use `NROW()` or `NCOL()`?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndim(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(1:12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nNROW(1:12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 12\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(1:12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nNCOL(1:12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n:::\n\n\nAnswers: `NULL`. `NROW` and `NCOL` are useful when comparing `NULL` dimensional vectors with matrices and arrays.\n\nAR Solutions: From `?nrow`:\n\n> `dim()` will return `NULL` when applied to a 1d vector.\n\nOne may want to use `NROW()` or `NCOL()` to handle atomic vectors, lists and NULL values in the same way as one column matrices or data frames.\n\n---\n\n3.  How would you describe the following three objects? What makes them\n    different from `1:5`?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))\n\nx1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> , , 1\n#> \n#>      [,1]\n#> [1,]    1\n#> \n#> , , 2\n#> \n#>      [,1]\n#> [1,]    2\n#> \n#> , , 3\n#> \n#>      [,1]\n#> [1,]    3\n#> \n#> , , 4\n#> \n#>      [,1]\n#> [1,]    4\n#> \n#> , , 5\n#> \n#>      [,1]\n#> [1,]    5\n```\n\n\n:::\n\n```{.r .cell-code}\nx2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> , , 1\n#> \n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n```\n\n\n:::\n\n```{.r .cell-code}\nx3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> , , 1\n#> \n#>      [,1]\n#> [1,]    1\n#> [2,]    2\n#> [3,]    3\n#> [4,]    4\n#> [5,]    5\n```\n\n\n:::\n:::\n\n\nAnswer: They have a 3-dimensional structure, arranged in different ways, along the z, x, and y axis.\n\nAR Solutions: These are all \"one dimensional\". If you imagine a 3d cube, `x1` is in the x-dimension, `x2` is in the y-dimension, and `x3` is in the z-dimension. In contrast to `1:5`, `x1`, `x2` and `x3` have a `dim` attribute.\n\n---\n\n4.  An early draft used this code to illustrate `structure()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstructure(1:5, comment = \"my attribute\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n    But when you print that object you don't see the comment attribute.\n    Why? Is the attribute missing, or is there something else special about\n    it? (Hint: try using help.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfactor(\"green\", levels = c(\"red\", \"amber\", \"green\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] green\n#> Levels: red amber green\n```\n\n\n:::\n\n```{.r .cell-code}\ndput(factor(\"green\", levels = c(\"red\", \"amber\", \"green\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> structure(3L, levels = c(\"red\", \"amber\", \"green\"), class = \"factor\")\n```\n\n\n:::\n:::\n\n\nAnswer: print doesn't display the attributes for arbitrary structures, only defined classes, like factors (for example, above).\n\nAR Solutions: The documentation states (see `?comment`):\n\n> Contrary to other attributes, the comment is not printed (by print or print.default).\n\nAlso, from `?attributes`:\n\n> Note that some attributes (namely class, comment, dim, dimnames, names, row.names and tsp) are treated specially and have restrictions on the values which can be set.\n\n---\n\n## 3.4.5 Exercises\n\n1.  What sort of object does `table()` return? What is its type? What \n    attributes does it have? How does the dimensionality change as you\n    tabulate more variables?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\na <- letters[1:3]\na_table <- table(a, sample(a))\na_table\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    \n#> a   a b c\n#>   a 0 1 0\n#>   b 0 0 1\n#>   c 1 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(a_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(a_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $dim\n#> [1] 3 3\n#> \n#> $dimnames\n#> $dimnames$a\n#> [1] \"a\" \"b\" \"c\"\n#> \n#> $dimnames[[2]]\n#> [1] \"a\" \"b\" \"c\"\n#> \n#> \n#> $class\n#> [1] \"table\"\n```\n\n\n:::\n\n```{.r .cell-code}\nb <- letters[1:4]\nb_table <- table(b, sample(b))\nb_table\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    \n#> b   a b c d\n#>   a 0 1 0 0\n#>   b 0 0 0 1\n#>   c 1 0 0 0\n#>   d 0 0 1 0\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(b_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $dim\n#> [1] 4 4\n#> \n#> $dimnames\n#> $dimnames$b\n#> [1] \"a\" \"b\" \"c\" \"d\"\n#> \n#> $dimnames[[2]]\n#> [1] \"a\" \"b\" \"c\" \"d\"\n#> \n#> \n#> $class\n#> [1] \"table\"\n```\n\n\n:::\n:::\n\n\nAnswer: an object of class \"table\", an array of integer values, with type \"integer\". Attributes listed above, the dimensionality is always n by n, where n is the number of variables tabulated.\n\nAR Solutions: `table()` returns a contingency table of its input variables. It is implemented as an integer vector with class `table` and dimensions (which makes it act like an array). Its attributes are `dim` (dimensions) and `dimnames` (one name for each input column). The dimensions correspond to the number of unique values (factor levels) in each input variable.\n\n---\n\n2.  What happens to a factor when you modify its levels? \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf1 <- factor(letters)\nf1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(f1) <- rev(levels(f1))\nf1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n```\n\n\n:::\n:::\n\n\nAnswer: ~~the factor will remain the same, but the attributes will change.~~ the factor and its levels are reversed.\n\nAR Solutions: The underlying integer values stay the same, but the levels are changed, making it look like the data has changed.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf1 <- factor(letters)\nf1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(f1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#> [26] 26\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(f1) <- rev(levels(f1))\nf1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n```\n\n\n:::\n:::\n\n\n---\n\n3.  What does this code do? How do `f2` and `f3` differ from `f1`?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf2 <- rev(factor(letters))\nf2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n\n```{.r .cell-code}\nf3 <- factor(letters, levels = rev(letters))\nf3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#> Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n```\n\n\n:::\n:::\n\n\nAnswer: both create a reversed list of letters. f3 also has reversed levels but f2 does not. (correct!)\n\nAR Solutions: For `f2` and `f3` either the order of the factor elements *or* its levels are being reversed. For `f1` both transformations are occurring.\n\n---\n\n## 3.5.4 Exercises\n\n1.  List all the ways that a list differs from an atomic vector.\n\nAnswers:\n\n- Each element can be a different type\n- Each element is a reference to an object\n- List size can be smaller since elements are references\n- Lists can contain other lists\n\nAR Solutions: To summarise:\n\n- Atomic vectors are always homogeneous (all elements must be of the same type). Lists may be heterogeneous (the elements can be of different types) as described in the [introduction of the vectors chapter](https://adv-r.hadley.nz/vectors-chap.html#introduction).\n- Atomic vectors point to one address in memory, while lists contain a separate reference for each element. (This was described in the list sections of the [vectors](https://adv-r.hadley.nz/vectors-chap.html#lists) and the [names and values](https://adv-r.hadley.nz/names-values.html#list-references) chapters.)\n- Subsetting with out-of-bounds and `NA` values leads to different output. For example, `[` returns `NA` for atomics and `NULL` for lists. (This is described in more detail within the [subsetting chapter](https://adv-r.hadley.nz/subsetting.html).)\n\n---\n\n2.  Why do you need to use `unlist()` to convert a list to an \n    atomic vector? Why doesn't `as.vector()` work? \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nis.vector(list(1:4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ndput(as.vector(list(1:4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> list(1:4)\n```\n\n\n:::\n:::\n\n\nAnswer: a list is considered a vector by `as.vector()`.\n\nAR Solutions: A list is already a vector, though not an atomic one!\n\n---\n\n3.  Compare and contrast `c()` and `unlist()` when combining a \n    date and date-time into a single vector.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nd <- list(date = as.Date(\"2022-06-25\"), datetime = as.POSIXct(\"2022-06-25 09:59:40 CDT\"))\ndput(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> list(date = structure(19168, class = \"Date\"), datetime = structure(1656169180, class = c(\"POSIXct\", \n#> \"POSIXt\"), tzone = \"\"))\n```\n\n\n:::\n\n```{.r .cell-code}\ndput(c(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> list(date = structure(19168, class = \"Date\"), datetime = structure(1656169180, class = c(\"POSIXct\", \n#> \"POSIXt\"), tzone = \"\"))\n```\n\n\n:::\n\n```{.r .cell-code}\ndput(unlist(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> c(date = 19168, datetime = 1656169180)\n```\n\n\n:::\n:::\n\n\nAnswer: `c()` preserves the list structure. `unlist()` converts both to `double`.\n\nAR Solutions: Date and date-time objects are both built upon doubles. While dates store the number of days since the reference date 1970-01-01 (also known as “the Epoch”) in days, date-time-objects (POSIXct) store the time difference to this date in seconds.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndate <- as.Date(\"1970-01-02\")\ndttm_ct <- as.POSIXct(\"1970-01-01 01:00\", tz = \"UTC\")\n# Internal representations\nunclass(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nunclass(dttm_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3600\n#> attr(,\"tzone\")\n#> [1] \"UTC\"\n```\n\n\n:::\n:::\n\n\nAs the `c()` generic only dispatches on its first argument, combining date and date-time objects via `c()` could lead to surprising results in older R versions (pre R 4.0.0):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Output in R version 3.6.2\nc(date, dttm_ct) # equal to c.Date(date, dttm_ct)\n#> [1] \"1970-01-02\" \"1979-11-10\"\nc(dttm_ct, date) # equal to c.POSIXct(date, dttm_ct)\n#> [1] \"1970-01-01 02:00:00 CET\" \"1970-01-01 01:00:01 CET\"\n```\n:::\n\n\nIn the first statement above `c.Date()` is executed, which incorrectly treats the underlying double of `dttm_ct` (3600) as days instead of seconds. Conversely, when `c.POSIXct()` is called on a date, one day is counted as one second only.\n\nWe can highlight these mechanics by the following code:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Output in R version 3.6.2\nunclass(c(date, dttm_ct)) # internal representation\n#> [1] 1 3600\ndate + 3599\n#> \"1979-11-10\"\n```\n:::\n\n\nAs of R 4.0.0 these issues have been resolved and both methods now convert their input first into `POSIXct` and `Date`, respectively.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(dttm_ct, date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"1970-01-01 01:00:00 UTC\" \"1970-01-02 00:00:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nunclass(c(dttm_ct, date))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  3600 86400\n#> attr(,\"tzone\")\n#> [1] \"UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(date, dttm_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"1970-01-02\" \"1970-01-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\nunclass(c(date, dttm_ct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 0\n```\n\n\n:::\n:::\n\n\nHowever, as `c()` strips the time zone (and other attributes) of `POSIXct` objects, some caution is still recommended.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(dttm_ct <- as.POSIXct(\"1970-01-01 01:00\", tz = \"HST\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"1970-01-01 01:00:00 HST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(c(dttm_ct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"HST\"\n```\n\n\n:::\n:::\n\n\nA package that deals with these kinds of problems in more depth and provides a structural solution for them is the [`vctrs` package](https://github.com/r-lib/vctrs) which is also used throughout the tidyverse.\n\nLet's look at `unlist()`, which operates on list input.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Attributes are stripped\nunlist(list(date, dttm_ct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]     1 39600\n```\n\n\n:::\n:::\n\n\nWe see again that dates and date-times are internally stored as doubles. Unfortunately, this is all we are left with, when unlist strips the attributes of the list.\n\nTo summarise: `c()` coerces types and strips time zones. Errors may have occurred in older R versions because of inappropriate method dispatch/immature methods. `unlist()` strips attributes.\n\n---\n\n## 3.6.8 Exercises\n\n1.  Can you have a data frame with zero rows? What about zero columns?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# from data.frame() examples:\ndf <- data.frame(x = 1:3, y = 4:6, z = 7:9)\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y z\n#> 1 1 4 7\n#> 2 2 5 8\n#> 3 3 6 9\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[, FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> data frame with 0 columns and 3 rows\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[FALSE, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] x y z\n#> <0 rows> (or 0-length row.names)\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[FALSE, FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> data frame with 0 columns and 0 rows\n```\n\n\n:::\n:::\n\n\nAnswer: yes!\n\nAR Solutions: Yes, you can create these data frames easily; either during creation or via subsetting. Even both dimensions can be zero.\n\n---\n\n2.  What happens if you attempt to set rownames that are not unique?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrownames(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"1\" \"2\" \"3\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(rownames(df) <- c(\"a\", \"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: non-unique value when setting 'row.names': 'a'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in `.rowNamesDF<-`(x, value = value) : \n#>   duplicate 'row.names' are not allowed\n```\n\n\n:::\n:::\n\n\nAnswer: error, duplicates not allowed.\n\nAR Solutions: Matrices can have duplicated row names, so this does not cause problems.\n\nData frames, however, require unique rownames and you get different results depending on how you attempt to set them. If you set them directly or via `row.names()`, you get an error.  If you use subsetting, `[` automatically deduplicates.\n\n---\n\n3.  If `df` is a data frame, what can you say about `t(df)`, and `t(t(df))`? \n    Perform some experiments, making sure to try different column types.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   [,1] [,2] [,3]\n#> x    1    2    3\n#> y    4    5    6\n#> z    7    8    9\n```\n\n\n:::\n\n```{.r .cell-code}\nt(t(df))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      x y z\n#> [1,] 1 4 7\n#> [2,] 2 5 8\n#> [3,] 3 6 9\n```\n\n\n:::\n\n```{.r .cell-code}\ndf2 <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"), z = 4L:6L, stringsAsFactors = FALSE)\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y z\n#> 1 1 a 4\n#> 2 2 b 5\n#> 3 3 c 6\n```\n\n\n:::\n\n```{.r .cell-code}\nt(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   [,1] [,2] [,3]\n#> x \"1\"  \"2\"  \"3\" \n#> y \"a\"  \"b\"  \"c\" \n#> z \"4\"  \"5\"  \"6\"\n```\n\n\n:::\n\n```{.r .cell-code}\nt(t(df2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      x   y   z  \n#> [1,] \"1\" \"a\" \"4\"\n#> [2,] \"2\" \"b\" \"5\"\n#> [3,] \"3\" \"c\" \"6\"\n```\n\n\n:::\n:::\n\n\nAnswer: `t()` coerces the vector types, so `t(t(df))` is the same as `df` only when all columns are\nthe same type.\n\nAR Solutions: Both of `t(df)` and `t(t(df))` will return matrices:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3, y = letters[1:3])\nis.matrix(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(t(df))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(t(t(df)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\nThe dimensions will respect the typical transposition rules:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndim(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3 2\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(t(df))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(t(t(df)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3 2\n```\n\n\n:::\n:::\n\n\nBecause the output is a matrix, every column is coerced to the same type. (It is implemented within `t.data.frame()` via `as.matrix()` which is described below).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y\n#> 1 1 a\n#> 2 2 b\n#> 3 3 c\n```\n\n\n:::\n\n```{.r .cell-code}\nt(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   [,1] [,2] [,3]\n#> x \"1\"  \"2\"  \"3\" \n#> y \"a\"  \"b\"  \"c\"\n```\n\n\n:::\n:::\n\n\n---\n\n4.  What does `as.matrix()` do when applied to a data frame with \n    columns of different types? How does it differ from `data.matrix()`?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nas.matrix(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      x   y  \n#> [1,] \"1\" \"a\"\n#> [2,] \"2\" \"b\"\n#> [3,] \"3\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.matrix(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      x   y   z  \n#> [1,] \"1\" \"a\" \"4\"\n#> [2,] \"2\" \"b\" \"5\"\n#> [3,] \"3\" \"c\" \"6\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndata.matrix(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      x y z\n#> [1,] 1 1 4\n#> [2,] 2 2 5\n#> [3,] 3 3 6\n```\n\n\n:::\n\n```{.r .cell-code}\nas.data.frame(data.matrix(df2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y z\n#> 1 1 1 4\n#> 2 2 2 5\n#> 3 3 3 6\n```\n\n\n:::\n\n```{.r .cell-code}\nas.data.frame(data.matrix(data.frame(x = 1:3, y = c(0, 0.5, 1), z = 4:6)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x   y z\n#> 1 1 0.0 4\n#> 2 2 0.5 5\n#> 3 3 1.0 6\n```\n\n\n:::\n:::\n\n\nAnswer: `as.matrix()` coerces all elements to the same type. `data.matrix()` coerces elements to either integer (when possible) or double (when not).\n\nAR Solutions: The type of the result of `as.matrix` depends on the types of the input columns (see `?as.matrix`):\n\n> The method for data frames will return a character matrix if there is only atomic columns and any non-(numeric/logical/complex) column, applying as.vector to factors and format to other non-character columns. Otherwise the usual coercion hierarchy (logical < integer < double < complex) will be used, e.g. all-logical data frames will be coerced to a logical matrix, mixed logical-integer will give an integer matrix, etc.\n\nOn the other hand, `data.matrix` will always return a numeric matrix (see `?data.matrix()`).\n\n> Return the matrix obtained by converting all the variables in a data frame to numeric mode and then binding them together as the columns of a matrix. Factors and ordered factors are replaced by their internal codes. [...] Character columns are first converted to factors and then to integers.\n\nWe can illustrate and compare the mechanics of these functions using a concrete example. `as.matrix()` makes it possible to retrieve most of the original information from the data frame but leaves us with characters. To retrieve all information from `data.matrix()`'s output, we would need a lookup table for each column.\n\n---\n\n# 4 Subsetting\n\nR's subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:\n\n* There are six ways to subset atomic vectors.\n\n* There are three subsetting operators, `[[`, `[`, and `$`.\n\n* Subsetting operators interact differently with different vector \n  types (e.g., atomic vectors, lists, factors, matrices, and data frames).\n\n* Subsetting can be combined with assignment.\n\nSubsetting is a natural complement to `str()`. While `str()` shows you all the pieces of any object (its structure), subsetting allows you to pull out the pieces that you're interested in. For large, complex objects, I highly recommend using the interactive RStudio Viewer, which you can activate with `View(my_object)`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n## 4.2.6 Exercises\n\n1.  Fix each of the following common data frame subsetting errors:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# mtcars[mtcars$cyl = 4, ]\nmtcars[mtcars$cyl == 4, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#> Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#> Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#> Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#> Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#> Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#> Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#> Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\n# use `==`              (instead of `=`)\n\n# mtcars[-1:4, ]\nmtcars[-(1:4), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#> Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#> Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#> Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#> Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#> Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#> Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#> Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#> Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#> Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#> Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#> Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#> Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#> Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#> Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#> Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#> AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#> Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#> Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#> Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#> Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#> Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#> Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#> Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#> Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#> Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\n# use `-(1:4)`          (instead of `-1:4`)\n\n# mtcars[mtcars$cyl <= 5]\nmtcars[mtcars$cyl <= 5, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#> Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#> Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#> Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#> Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#> Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#> Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#> Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\n# `,` is missing\n\n# mtcars[mtcars$cyl == 4 | 6, ]\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Mazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#> Mazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#> Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#> Valiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#> Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> Merc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#> Merc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#> Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#> Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#> Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#> Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#> Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#> Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#> Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#> Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#> Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\n# use `mtcars$cyl == 6` (instead of `6`)\n#  or `%in% c(4, 6)`    (instead of `== 4 | 6`)\n```\n:::\n\n\nAnswer: fixed!\n\nAR solutions: see the comments below the fixed code.\n\n---\n\n2.  Why does the following code yield five missing values? (Hint: why is \n    it different from `x[NA_real_]`?)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:5\nx[NA]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] NA NA NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nx[NA_real_]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nx[TRUE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\nAnswer: NA is a logical constant of length 1.\n\nAR Solutions: In contrast to `NA_real`, `NA` has logical type and logical vectors are recycled to the same length as the vector being subset, i.e. `x[NA]` is recycled to `x[c(NA, NA, NA, NA, NA)]`.\n\n---\n\n3.  What does `upper.tri()` return? How does subsetting a matrix with it \n    work? Do we need any additional subsetting rules to describe its behaviour?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- outer(1:5, 1:5, FUN = \"*\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#> [2,]    2    4    6    8   10\n#> [3,]    3    6    9   12   15\n#> [4,]    4    8   12   16   20\n#> [5,]    5   10   15   20   25\n```\n\n\n:::\n\n```{.r .cell-code}\nx[upper.tri(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  2  3  6  4  8 12  5 10 15 20\n```\n\n\n:::\n:::\n\n\nAnswer: `upper.tri()` returns a matrix of logicals, which can be used to subset the upper triangle. This is subsetting by matrix, which is new.\n\nAR Solutions: `upper.tri(x)` returns a logical matrix, which contains `TRUE` values above the diagonal and `FALSE` values everywhere else. In `upper.tri()` the positions for `TRUE` and `FALSE` values are determined by comparing `x`'s row and column indices via `.row(dim(x)) < .col(dim(x))`.\n\nWhen subsetting with logical matrices, all elements that correspond to `TRUE` will be selected. Matrices extend vectors with a dimension attribute, so the vector forms of subsetting can be used (including logical subsetting). We should take care, that the dimensions of the subsetting matrix match the object of interest — otherwise unintended selections due to vector recycling may occur. Please also note, that this form of subsetting returns a vector instead of a matrix, as the subsetting alters the dimensions of the object.\n\n---\n\n4.  Why does `mtcars[1:20]` return an error? How does it differ from the \n    similar `mtcars[1:20, ]`?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntry(mtcars[1:20])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in `[.data.frame`(mtcars, 1:20) : undefined columns selected\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[1:20, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#> Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#> Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#> Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#> Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#> Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#> Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#> Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#> Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#> Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#> Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#> Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#> Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#> Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#> Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#> Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#> Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n```\n\n\n:::\n:::\n\n\nAnswer: `mtcars[1:20]` selects the first 20 columns, but there are only 11. `mtcars[1:20, ]` selects the first 20 rows of 32.\n\nAR Solutions: When subsetting a data frame with a single vector, it behaves the same way as subsetting a list of columns. So, `mtcars[1:20]` would return a data frame containing the first 20 columns of the dataset. However, as `mtcars` has only 11 columns, the index will be out of bounds and an error is thrown. `mtcars[1:20, ]` is subsetted with two vectors, so 2d subsetting kicks in, and the first index refers to rows.\n\n---\n\n5.  Implement your own function that extracts the diagonal entries from a\n    matrix (it should behave like `diag(x)` where `x` is a matrix).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nm <- matrix(ncol = 3, byrow = TRUE, c(\n  1, 4, 7,\n  2, 5, 8,\n  3, 6, 9\n))\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n```\n\n\n:::\n\n```{.r .cell-code}\ndiag(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 5 9\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_diag <- function(x) {\n  diag_element <- function(n, x) {\n    x[n, n]\n  }\n  vapply(seq_len(nrow(m)), diag_element, 1, x)\n}\nmy_diag(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 5 9\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: The elements in the diagonal of a matrix have the same row- and column indices. This characteristic can be used to create a suitable numeric matrix used for subsetting.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndiag2 <- function(x) {\n  n <- min(nrow(x), ncol(x))\n  idx <- cbind(seq_len(n), seq_len(n))\n  x[idx]\n}\n# Let's check if it works\n(x <- matrix(1:30, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      [,1] [,2] [,3] [,4] [,5] [,6]\n#> [1,]    1    6   11   16   21   26\n#> [2,]    2    7   12   17   22   27\n#> [3,]    3    8   13   18   23   28\n#> [4,]    4    9   14   19   24   29\n#> [5,]    5   10   15   20   25   30\n```\n\n\n:::\n\n```{.r .cell-code}\ndiag(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  1  7 13 19 25\n```\n\n\n:::\n\n```{.r .cell-code}\ndiag2(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  1  7 13 19 25\n```\n\n\n:::\n:::\n\n\n---\n\n5.  What does `df[is.na(df)] <- 0` do? How does it work?\n\nAnswer: sets the `NA` values in `df` to `0`, by first selecting `NA` values then assigning `0`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- data.frame(x = c(1, 2, NA), y = c(4, NA, 6), z = c(NA, 8, 9))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    x  y  z\n#> 1  1  4 NA\n#> 2  2 NA  8\n#> 3 NA  6  9\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[is.na(df)] <- 0\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y z\n#> 1 1 4 0\n#> 2 2 0 8\n#> 3 0 6 9\n```\n\n\n:::\n:::\n\n\nCorrect!\n\nAR Solutions: This expression replaces the `NA`s in `df` with `0`. Here `is.na(df)` returns a logical matrix that encodes the position of the missing values in `df`. Subsetting and assignment are then combined to replace only the missing values.\n\n---\n\n## 4.3.5 Exercises\n\n1.  Brainstorm as many ways as possible to extract the third value from the\n    `cyl` variable in the `mtcars` dataset.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars$cyl[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars$cyl[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[[\"cyl\"]][[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[3, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[[3, 2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[[\"Datsun 710\", \"cyl\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[-c(1:2, 4:32), -c(1, 3:11)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n:::\n\n\nAnswer: code above (some variations omitted). There are many more.\n\nAR Solutions: Base R already provides an abundance of possibilities:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Select column first\nmtcars$cyl[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[, \"cyl\"][[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[[\"cyl\"]][[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nwith(mtcars, cyl[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Select row first\nmtcars[3, ]$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[3, \"cyl\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[3, ][, \"cyl\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[3, ][[\"cyl\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Select simultaneously\nmtcars[3, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[[c(2, 3)]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n:::\n\n\n---\n\n2.  Given a linear model, e.g., `mod <- lm(mpg ~ wt, data = mtcars)`, extract\n    the residual degrees of freedom. Then extract the R squared from the model\n    summary (`summary(mod)`)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmod <- lm(mpg ~ wt, data = mtcars)\nmod$df.residual\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 30\n```\n\n\n:::\n\n```{.r .cell-code}\nmod_sum <- summary(mod)\nmod_sum$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.7528328\n```\n\n\n:::\n\n```{.r .cell-code}\nmod_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> lm(formula = mpg ~ wt, data = mtcars)\n#> \n#> Residuals:\n#>     Min      1Q  Median      3Q     Max \n#> -4.5432 -2.3647 -0.1252  1.4096  6.8727 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)  37.2851     1.8776  19.858  < 2e-16 ***\n#> wt           -5.3445     0.5591  -9.559 1.29e-10 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 3.046 on 30 degrees of freedom\n#> Multiple R-squared:  0.7528,\tAdjusted R-squared:  0.7446 \n#> F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: `mod` is of type list, which opens up several possibilities. We use `$` or `[[` to extract a single element:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmod <- lm(mpg ~ wt, data = mtcars)\n\nmod$df.residual\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 30\n```\n\n\n:::\n\n```{.r .cell-code}\nmod[[\"df.residual\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 30\n```\n\n\n:::\n:::\n\n\nThe same also applies to `summary(mod)`, so we could use, e.g.:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(mod)$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.7528328\n```\n\n\n:::\n:::\n\n\n(Tip: The [`broom` package](https://github.com/tidymodels/broom) provides a very useful approach to work with models in a tidy way.)\n\n---\n\n## 4.5.9 Exercises\n\n1.  How would you randomly permute the columns of a data frame? (This is an\n    important technique in random forests.) Can you simultaneously permute \n    the rows and columns in one step?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:5, y = 5:1, z = letters[1:5], row.names = 1:5)\n\ndf[, sample(ncol(df))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   z x y\n#> 1 a 1 5\n#> 2 b 2 4\n#> 3 c 3 3\n#> 4 d 4 2\n#> 5 e 5 1\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[sample(nrow(df)), sample(ncol(df))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y z\n#> 1 1 5 a\n#> 2 2 4 b\n#> 5 5 1 e\n#> 4 4 2 d\n#> 3 3 3 c\n```\n\n\n:::\n:::\n\n\nAnswer: using `sample()`. Yes!\n\nAR Solutions: This can be achieved by combining `[` and `sample()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Permute columns\nmtcars[sample(ncol(mtcars))]\n\n# Permute columns and rows in one step\nmtcars[sample(nrow(mtcars)), sample(ncol(mtcars))]\n```\n:::\n\n\n---\n\n2.  How would you select a random sample of `m` rows from a data frame? \n    What if the sample had to be contiguous (i.e., with an initial row, a \n    final row, and every row in between)?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsample_rows <- function(df, m, contiguous = FALSE) {\n  if (m > nrow(df)) {\n    stop(\"sample size '\", m, \"' is larger than the number of rows, '\", nrow(df), \"'\")\n  }\n  if (contiguous) {\n    first_row <- sample(nrow(df) - m + 1, 1)\n    last_row <- first_row + m - 1\n    return(df[first_row:last_row, ])\n  }\n  df[sample(nrow(df), m), ]\n}\n\nsample_rows(df, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y z\n#> 4 4 2 d\n#> 3 3 3 c\n#> 1 1 5 a\n```\n\n\n:::\n\n```{.r .cell-code}\nsample_rows(df, 3, contiguous = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   x y z\n#> 1 1 5 a\n#> 2 2 4 b\n#> 3 3 3 c\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(sample_rows(df, 6))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in sample_rows(df, 6) : \n#>   sample size '6' is larger than the number of rows, '5'\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: Selecting `m` random rows from a data frame can be achieved through subsetting.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nm <- 10\nmtcars[sample(nrow(mtcars), m), ]\n```\n:::\n\n\nHolding successive lines together as a blocked sample requires only a certain amount of caution in order to obtain the correct start and end index.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstart <- sample(nrow(mtcars) - m + 1, 1)\nend <- start + m - 1\nmtcars[start:end, , drop = FALSE]\n```\n:::\n\n\n---\n    \n3.  How could you put the columns in a data frame in alphabetical order?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars[sort(colnames(mtcars))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                     am carb cyl  disp drat gear  hp  mpg  qsec vs    wt\n#> Mazda RX4            1    4   6 160.0 3.90    4 110 21.0 16.46  0 2.620\n#> Mazda RX4 Wag        1    4   6 160.0 3.90    4 110 21.0 17.02  0 2.875\n#> Datsun 710           1    1   4 108.0 3.85    4  93 22.8 18.61  1 2.320\n#> Hornet 4 Drive       0    1   6 258.0 3.08    3 110 21.4 19.44  1 3.215\n#> Hornet Sportabout    0    2   8 360.0 3.15    3 175 18.7 17.02  0 3.440\n#> Valiant              0    1   6 225.0 2.76    3 105 18.1 20.22  1 3.460\n#> Duster 360           0    4   8 360.0 3.21    3 245 14.3 15.84  0 3.570\n#> Merc 240D            0    2   4 146.7 3.69    4  62 24.4 20.00  1 3.190\n#> Merc 230             0    2   4 140.8 3.92    4  95 22.8 22.90  1 3.150\n#> Merc 280             0    4   6 167.6 3.92    4 123 19.2 18.30  1 3.440\n#> Merc 280C            0    4   6 167.6 3.92    4 123 17.8 18.90  1 3.440\n#> Merc 450SE           0    3   8 275.8 3.07    3 180 16.4 17.40  0 4.070\n#> Merc 450SL           0    3   8 275.8 3.07    3 180 17.3 17.60  0 3.730\n#> Merc 450SLC          0    3   8 275.8 3.07    3 180 15.2 18.00  0 3.780\n#> Cadillac Fleetwood   0    4   8 472.0 2.93    3 205 10.4 17.98  0 5.250\n#> Lincoln Continental  0    4   8 460.0 3.00    3 215 10.4 17.82  0 5.424\n#> Chrysler Imperial    0    4   8 440.0 3.23    3 230 14.7 17.42  0 5.345\n#> Fiat 128             1    1   4  78.7 4.08    4  66 32.4 19.47  1 2.200\n#> Honda Civic          1    2   4  75.7 4.93    4  52 30.4 18.52  1 1.615\n#> Toyota Corolla       1    1   4  71.1 4.22    4  65 33.9 19.90  1 1.835\n#> Toyota Corona        0    1   4 120.1 3.70    3  97 21.5 20.01  1 2.465\n#> Dodge Challenger     0    2   8 318.0 2.76    3 150 15.5 16.87  0 3.520\n#> AMC Javelin          0    2   8 304.0 3.15    3 150 15.2 17.30  0 3.435\n#> Camaro Z28           0    4   8 350.0 3.73    3 245 13.3 15.41  0 3.840\n#> Pontiac Firebird     0    2   8 400.0 3.08    3 175 19.2 17.05  0 3.845\n#> Fiat X1-9            1    1   4  79.0 4.08    4  66 27.3 18.90  1 1.935\n#> Porsche 914-2        1    2   4 120.3 4.43    5  91 26.0 16.70  0 2.140\n#> Lotus Europa         1    2   4  95.1 3.77    5 113 30.4 16.90  1 1.513\n#> Ford Pantera L       1    4   8 351.0 4.22    5 264 15.8 14.50  0 3.170\n#> Ferrari Dino         1    6   6 145.0 3.62    5 175 19.7 15.50  0 2.770\n#> Maserati Bora        1    8   8 301.0 3.54    5 335 15.0 14.60  0 3.570\n#> Volvo 142E           1    2   4 121.0 4.11    4 109 21.4 18.60  1 2.780\n```\n\n\n:::\n:::\n\n\nAnswer: using `sort(colnames)`.\n\nAR Solutions: We combine `[` with `order()` or `sort()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars[order(names(mtcars))]\nmtcars[sort(names(mtcars))]\n```\n:::\n\n\n---\n\n# 5 Control flow\n\nThere are two primary tools of control flow: choices and loops. Choices, like `if` statements and `switch()` calls, allow you to run different code depending on the input. Loops, like `for` and `while`, allow you to repeatedly run code, typically with changing options. I'd expect that you're already familiar with the basics of these functions so I'll briefly cover some technical details and then introduce some useful, but lesser known, features.\n\nThe condition system (messages, warnings, and errors), which you'll learn about in Chapter 8, also provides non-local control flow. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n## 5.2.4 Exercises\n\n1.  What type of vector does each of the following calls to `ifelse()`\n    return? Read the documentation and write down the rules in your own words.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nifelse(TRUE, 1, \"no\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(ifelse(TRUE, 1, \"no\")) # double\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nifelse(FALSE, 1, \"no\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"no\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(ifelse(FALSE, 1, \"no\")) # character\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nifelse(NA, 1, \"no\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(ifelse(NA, 1, \"no\")) # logical\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nifelse(NULL, 1, \"no\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> logical(0)\n```\n\n\n:::\n:::\n\n\nAnswer:\n\n- if `test` is true, return a vector of the same length as `test` (1) populated with \"yes\" - here 1\n  is a double, 1L would be integer\n- if `test` is false, return a vector of the same length as `test` (1) populated with \"no\" - here\n  \"no\" is a character\n- if `test` is `NA`, return `NA`, and if `test` is `NULL`, return `logical(0)`\n\nAR Solutions: The arguments of `ifelse()` are named `test`, `yes` and `no`. In general, `ifelse()` returns the entry for `yes` when `test` is `TRUE`, the entry for `no` when `test` is `FALSE` and `NA` when `test` is `NA`. Therefore, the expressions above return vectors of type `double` (`1`), `character` (`\"no\"`) and `logical` (`NA`).\n\nTo be a little more precise, we will cite the part of the documentation on the return value of `ifelse()`:\n\n> A vector of the same length and attributes (including dimensions and \"class\") as test and data values from the values of yes or no. The mode of the answer will be coerced from logical to accommodate first any values taken from yes and then any values taken from no.\n\nThis is surprising because it uses the type of `test`. In practice this means, that `test` is first converted to logical and if the result is neither `TRUE` nor `FALSE`, simply `as.logical(test)` is returned.\n\n---\n\n2.  Why does the following code work?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"not empty\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"empty\"\n```\n\n\n:::\n:::\n\n\nAnswer: in the first example, `length(x)` is nonzero, which evaluates to `TRUE`. In the second example, `numeric()` returns a vector of length 0 (the default), `length(x)` is zero, which evaluates to `FALSE`.\n\nAR Solutions: `if()` expects a logical condition, but also accepts a numeric vector where `0` is treated as `FALSE` and all other numbers are treated as `TRUE`. Numerical missing values (including `NaN`) lead to an error in the same way that a logical missing, `NA`, does.\n\n---\n\n## 5.3.3 Exercises\n\n1.  Why does this code succeed without errors or warnings? \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- numeric() # x is numeric(0)\nout <- vector(\"list\", length(x)) # out is list(0)\nfor (i in 1:length(x)) { # nolint: seq_linter. i is 1, then 0.\n  out[i] <- x[i]^2 # when i = 1 x[1] is NA, sets out[1] to NA. when i = 0 nothing happens\n}\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> [1] NA\n```\n\n\n:::\n:::\n\n\nAnswer: in addition to notes above, `out[0]` and `x[0]` return a zero-length vector.\n\nAR Solutions: This loop is a delicate issue, and we have to consider a few points to explain why it is evaluated without raising any errors or warnings.\n\nThe beginning of this code smell is the statement `1:length(x)` which creates the index of the for loop. As `x` has length 0 `1:length(x)` counts down from 1 to 0. This issue is typically avoided via usage of `seq_along(x)` or similar helpers which would just generate `integer(0)` in this case.\n\nAs we use `[<-` and `[` for indexing 0-length vectors at their first and zeroth position, we need to be aware of their subsetting behaviour for out-of-bounds and zero indices.\n\nDuring the first iteration `x[1]` will generate an `NA` (out-of-bounds indexing for atomics). The resulting `NA` (from squaring) will be assigned to the empty length-1 list `out[1]` (out-of-bounds indexing for lists).\n\nIn the next iteration, `x[0]` will return `numeric(0)` (zero indexing for atomics). Again, squaring doesn't change the value and `numeric(0)` is assigned to `out[0]` (zero indexing for lists). Assigning a 0-length vector to a 0-length subset works but doesn't change the object.\n\nOverall, the code works, because each step includes valid R operations (even though the result may not be what the user intended).\n\n---\n\n2.  When the following code is evaluated, what can you say about the \n    vector being iterated?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nxs <- c(1, 2, 3)\nfor (x in xs) {\n  xs <- c(xs, x * 2)\n}\nxs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 2 3 2 4 6\n```\n\n\n:::\n:::\n\n\nAnswer: `x` iterates from 1 to 3, and is not affected by changes to `xs` during the loop, while `xs` is updated.\n\nAR Solution: In this loop `x` takes on the values of the initial `xs` (`1`, `2` and `3`), indicating that it is evaluated just once in the beginning of the loop, not after each iteration. (Otherwise, we would run into an infinite loop.)\n\n---\n\n3.  What does the following code tell you about when the index is updated?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfor (i in 1:3) {\n  i <- i * 2\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n#> [1] 4\n#> [1] 6\n```\n\n\n:::\n:::\n\n\nAnswer: the index is updated at the beginning of each loop.\n\nAR Solutions: In a for loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn't affect the following iterations. (Again, we would otherwise run into an infinite loop.)\n\n---\n\n# 6 Functions\n\nIf you're reading this book, you've probably already created many R functions and know how to use them to reduce duplication in your code. In this chapter, you'll learn how to turn that informal, working knowledge into more rigorous, theoretical understanding. And while you'll see some interesting tricks and techniques along the way, keep in mind that what you'll learn here will be important for understanding the more advanced topics discussed later in the book.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n## 6 Quiz\n\nAnswer the following questions to see if you can safely skip this chapter.\n\n1.  What are the three components of a function? a: arguments, code, return value [body, arguments,\n    environment]\n\n2.  What does the following code return? a: 11 [correct!]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 10\nf1 <- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 11\n```\n\n\n:::\n:::\n\n\n3.  How would you usually write this code? a: `1 + 2 * 3` [correct! ... `1 + (2 * 3)`]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`+`(1, `*`(2, 3))\n```\n:::\n\n\n4.  How could you make this call easier to read? `mean(c(1:10, NA), na.rm = TRUE)` [correct!]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(, TRUE, x = c(1:10, NA))\n```\n:::\n\n\n5.  Does the following code throw an error when executed? Why or why not? a: no, due to lazy\n    evaluation, the `stop()` is never run [correct! ... second argument is never used]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf2 <- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 100\n```\n\n\n:::\n:::\n\n\n6.  What is an infix function? How do you write it? What's a replacement \n    function? How do you write it? a: `function(x) x`. ??? [see 6.8.3 and 6.8.4]\n\n7.  How do you ensure that cleanup action occurs regardless of how a function \n    exits? a: ??? [`on.exit()`]\n\n## 6.2.5 Exercises\n\n1. Given a name, like `\"mean\"`, `match.fun()` lets you find a function. \n   Given a function, can you find its name? Why doesn't that make sense in R?\n\nAnswer: a function is an object and could have multiple names pointing to it.\n\nAR Solutions: In R there is no one-to-one mapping between functions and names. A name always points to a single object, but an object may have zero, one or many names.\n\n---\n\n2.  It's possible (although typically not useful) to call an anonymous function.\n    Which of the two approaches below is correct? Why?\n\n\n::: {.cell layout-align=\"center\" result='hide'}\n\n```{.r .cell-code}\nfunction(x) 3()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function(x) 3()\n```\n\n\n:::\n\n```{.r .cell-code}\n(function(x) 3)()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3\n```\n\n\n:::\n:::\n\n\nAnswer: The second is correct, as the first is the form of defining a function.\n\nAR Solutions: The second approach is correct.\n\nThe anonymous function `function(x) 3` is surrounded by a pair of parentheses before it is called by `()`. These extra parentheses separate the function call from the anonymous function's body. Without them a function with the invalid body `3()` is returned, which throws an error when we call it.\n\n---\n\n3. A good rule of thumb is that an anonymous function should fit on one line \n   and shouldn't need to use `{}`. Review your code. Where could you have \n   used an anonymous function instead of a named function? Where should you \n   have used a named function instead of an anonymous function?\n\nAnswer: in `rdev::build_analysis_site()`, `analysis_menu_item()` is properly written as a named function, where `get_component()` could be written as an anonymous function, with `dir_check_copy()` and `dir_check_delete()` potentially either.\n\nAR Solutions: The use of anonymous functions allows concise and elegant code in certain situations. However, they miss a descriptive name and when re-reading the code, it can take a while to figure out what they do. That's why it's helpful to give long and complex functions a descriptive name. It may be worthwhile to take a look at your own projects or other people's code to reflect on this part of your coding style.\n\n---\n\n4.  What function allows you to tell if an object is a function? What function\n    allows you to tell if a function is a primitive function?\n\nAnswer: `is.function()` and `is.primitive()`.\n\nAR Solutions: Use `is.function()` to test if an object is a function. Consider using `is.primitive()` to test specifically for primitive functions.\n\n---\n\n5.  This code makes a list of all functions in the base package. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning in ls(\"package:base\", all = TRUE): partial argument match of 'all' to\n#> 'all.names'\n```\n\n\n:::\n\n```{.r .cell-code}\nfuns <- Filter(is.function, objs)\n```\n:::\n\n\nUse it to answer the following questions:\n\na. Which base function has the most arguments?\na. How many base functions have no arguments? What's special about those\n   functions?\na. How could you adapt the code to find all primitive functions?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfun_args <- data.frame(\n  name = names(funs),\n  args = unname(vapply(funs, function(x) length(formals(x)), 1L))\n)\nhead(fun_args[order(fun_args$args, decreasing = TRUE), ], 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                   name args\n#> 1076              scan   22\n#> 1132            source   17\n#> 574     format.default   16\n#> 587            formatC   15\n#> 768            library   13\n#> 825   merge.data.frame   13\n#> 924          prettyNum   13\n#> 1242           system2   12\n#> 1239            system   11\n#> 198  all.equal.numeric   10\n```\n\n\n:::\n\n```{.r .cell-code}\nfun_args[fun_args$args == 0, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                          name args\n#> 1                           -    0\n#> 4                           :    0\n#> 5                          ::    0\n#> 6                         :::    0\n#> 7                           !    0\n#> 10                         !=    0\n#> 13                     ...elt    0\n#> 14                  ...length    0\n#> 15                   ...names    0\n#> 20                         .C    0\n#> 21               .cache_class    0\n#> 22                      .Call    0\n#> 23             .Call.graphics    0\n#> 25                    .class2    0\n#> 42                  .External    0\n#> 43         .External.graphics    0\n#> 44                 .External2    0\n#> 45                 .First.sys    0\n#> 48                   .Fortran    0\n#> 56                  .Internal    0\n#> 57       .isMethodsDispatchOn    0\n#> 68         .NotYetImplemented    0\n#> 70         .OptRequireMethods    0\n#> 76                 .Primitive    0\n#> 77                 .primTrace    0\n#> 78               .primUntrace    0\n#> 90          .standard_regexps    0\n#> 91                    .subset    0\n#> 92                   .subset2    0\n#> 95        .tryResumeInterrupt    0\n#> 97                          (    0\n#> 98                          [    0\n#> 116                        [[    0\n#> 123                      [[<-    0\n#> 128                       [<-    0\n#> 136                         {    0\n#> 137                         @    0\n#> 138                       @<-    0\n#> 139                         *    0\n#> 141                         /    0\n#> 143                         &    0\n#> 146                        &&    0\n#> 147                       %*%    0\n#> 148                       %/%    0\n#> 149                        %%    0\n#> 154                         ^    0\n#> 155                         +    0\n#> 158                         <    0\n#> 159                        <-    0\n#> 160                       <<-    0\n#> 161                        <=    0\n#> 162                         =    0\n#> 163                        ==    0\n#> 164                         >    0\n#> 165                        >=    0\n#> 166                         |    0\n#> 169                        ||    0\n#> 170                         ~    0\n#> 171                         $    0\n#> 174                       $<-    0\n#> 178                       abs    0\n#> 179                      acos    0\n#> 180                     acosh    0\n#> 187                       all    0\n#> 204                       any    0\n#> 210                     anyNA    0\n#> 219                       Arg    0\n#> 226                   as.call    0\n#> 227              as.character    0\n#> 238                as.complex    0\n#> 272                 as.double    0\n#> 275            as.environment    0\n#> 282                as.integer    0\n#> 294                as.logical    0\n#> 304                as.numeric    0\n#> 323                    as.raw    0\n#> 333                      asin    0\n#> 334                     asinh    0\n#> 340                      atan    0\n#> 342                     atanh    0\n#> 345                      attr    0\n#> 347                    attr<-    0\n#> 348                attributes    0\n#> 349              attributes<-    0\n#> 354                   baseenv    0\n#> 373                     break    0\n#> 374                   browser    0\n#> 383                         c    0\n#> 392                      call    0\n#> 399                   ceiling    0\n#> 412                     class    0\n#> 413                   class<-    0\n#> 419       closeAllConnections    0\n#> 436                      Conj    0\n#> 437              contributors    0\n#> 438                       cos    0\n#> 439                      cosh    0\n#> 440                     cospi    0\n#> 441                 crossprod    0\n#> 442               Cstack_info    0\n#> 443                    cummax    0\n#> 444                    cummin    0\n#> 445                   cumprod    0\n#> 446                    cumsum    0\n#> 455                      date    0\n#> 459                   declare    0\n#> 460  default.stringsAsFactors    0\n#> 477                   digamma    0\n#> 478                       dim    0\n#> 480                     dim<-    0\n#> 481                  dimnames    0\n#> 483                dimnames<-    0\n#> 512                  emptyenv    0\n#> 513                enc2native    0\n#> 514                  enc2utf8    0\n#> 522             environment<-    0\n#> 529                      Exec    0\n#> 531                       exp    0\n#> 533                     expm1    0\n#> 534                expression    0\n#> 535            extSoftVersion    0\n#> 562                     floor    0\n#> 565                       for    0\n#> 567              forceAndCall    0\n#> 590                  function    0\n#> 591                     gamma    0\n#> 593                   gc.time    0\n#> 599         getAllConnections    0\n#> 607             geterrmessage    0\n#> 610             getLoadedDLLs    0\n#> 620               getRversion    0\n#> 622      getTaskCallbackNames    0\n#> 625                     getwd    0\n#> 628                 globalenv    0\n#> 640                 iconvlist    0\n#> 645                        if    0\n#> 647                        Im    0\n#> 653               interactive    0\n#> 658                 invisible    0\n#> 661                  is.array    0\n#> 662                 is.atomic    0\n#> 663                   is.call    0\n#> 664              is.character    0\n#> 665                is.complex    0\n#> 667                 is.double    0\n#> 669            is.environment    0\n#> 670             is.expression    0\n#> 672                 is.finite    0\n#> 674               is.function    0\n#> 675               is.infinite    0\n#> 677                is.integer    0\n#> 678               is.language    0\n#> 679                   is.list    0\n#> 681                is.logical    0\n#> 682                 is.matrix    0\n#> 683                     is.na    0\n#> 691                   is.name    0\n#> 692                    is.nan    0\n#> 694                   is.null    0\n#> 695                is.numeric    0\n#> 700                 is.object    0\n#> 703               is.pairlist    0\n#> 706                      is.R    0\n#> 707                    is.raw    0\n#> 708              is.recursive    0\n#> 709                 is.single    0\n#> 710                 is.symbol    0\n#> 726                      isS4    0\n#> 740                 l10n_info    0\n#> 741                La_library    0\n#> 742                La_version    0\n#> 749           lazyLoadDBfetch    0\n#> 752                    length    0\n#> 754                  length<-    0\n#> 763                  levels<-    0\n#> 766                    lgamma    0\n#> 767            libcurlVersion    0\n#> 771                   licence    0\n#> 772                   license    0\n#> 773                      list    0\n#> 779          loadedNamespaces    0\n#> 780      loadingNamespaceInfo    0\n#> 785                       log    0\n#> 786                     log10    0\n#> 787                     log1p    0\n#> 788                      log2    0\n#> 811                       max    0\n#> 823            memory.profile    0\n#> 829                       min    0\n#> 830                   missing    0\n#> 831                       Mod    0\n#> 844                     names    0\n#> 846                   names<-    0\n#> 853                     nargs    0\n#> 859                      next    0\n#> 868                  nullfile    0\n#> 873                    nzchar    0\n#> 875                  oldClass    0\n#> 876                oldClass<-    0\n#> 878                   on.exit    0\n#> 911               pcre_config    0\n#> 920                pos.to.env    0\n#> 963                 proc.time    0\n#> 964                      prod    0\n#> 987                     quote    0\n#> 988             R_compiled_by    0\n#> 991                 R.Version    0\n#> 992                     range    0\n#> 1007                       Re    0\n#> 1026                      rep    0\n#> 1035                   repeat    0\n#> 1042               retracemem    0\n#> 1043                   return    0\n#> 1051                    round    0\n#> 1077                   search    0\n#> 1078              searchpaths    0\n#> 1082                seq_along    0\n#> 1083                  seq_len    0\n#> 1086                  seq.int    0\n#> 1102                     sign    0\n#> 1104                   signif    0\n#> 1110                      sin    0\n#> 1112                     sinh    0\n#> 1115                    sinpi    0\n#> 1142                     sqrt    0\n#> 1148          standardGeneric    0\n#> 1150                   stderr    0\n#> 1151                    stdin    0\n#> 1152                   stdout    0\n#> 1156           storage.mode<-    0\n#> 1172               substitute    0\n#> 1177                      sum    0\n#> 1206                   switch    0\n#> 1208                sys.calls    0\n#> 1210                 Sys.Date    0\n#> 1212               sys.frames    0\n#> 1216               Sys.getpid    0\n#> 1218                 Sys.info    0\n#> 1220           Sys.localeconv    0\n#> 1221               sys.nframe    0\n#> 1222              sys.on.exit    0\n#> 1224              sys.parents    0\n#> 1233               sys.status    0\n#> 1234                 Sys.time    0\n#> 1248                 Tailcall    0\n#> 1249                      tan    0\n#> 1250                     tanh    0\n#> 1251                    tanpi    0\n#> 1254               tcrossprod    0\n#> 1266                 tracemem    0\n#> 1271                 trigamma    0\n#> 1273                    trunc    0\n#> 1282           unCfillPOSIXlt    0\n#> 1283                  unclass    0\n#> 1307               untracemem    0\n#> 1312                UseMethod    0\n#> 1328                    while    0\n#> 1345                    xtfrm    0\n```\n\n\n:::\n\n```{.r .cell-code}\n# check if all functions with 0 arguments are primitive\nfun_args2 <- data.frame(\n  name = names(funs),\n  args = unname(vapply(funs, function(x) length(formals(x)), 1L)),\n  prim = unname(vapply(funs, is.primitive, TRUE))\n)\nfun_args2[fun_args2$args == 0, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                          name args  prim\n#> 1                           -    0  TRUE\n#> 4                           :    0  TRUE\n#> 5                          ::    0  TRUE\n#> 6                         :::    0  TRUE\n#> 7                           !    0  TRUE\n#> 10                         !=    0  TRUE\n#> 13                     ...elt    0  TRUE\n#> 14                  ...length    0  TRUE\n#> 15                   ...names    0  TRUE\n#> 20                         .C    0  TRUE\n#> 21               .cache_class    0  TRUE\n#> 22                      .Call    0  TRUE\n#> 23             .Call.graphics    0  TRUE\n#> 25                    .class2    0  TRUE\n#> 42                  .External    0  TRUE\n#> 43         .External.graphics    0  TRUE\n#> 44                 .External2    0  TRUE\n#> 45                 .First.sys    0 FALSE\n#> 48                   .Fortran    0  TRUE\n#> 56                  .Internal    0  TRUE\n#> 57       .isMethodsDispatchOn    0  TRUE\n#> 68         .NotYetImplemented    0 FALSE\n#> 70         .OptRequireMethods    0 FALSE\n#> 76                 .Primitive    0  TRUE\n#> 77                 .primTrace    0  TRUE\n#> 78               .primUntrace    0  TRUE\n#> 90          .standard_regexps    0 FALSE\n#> 91                    .subset    0  TRUE\n#> 92                   .subset2    0  TRUE\n#> 95        .tryResumeInterrupt    0 FALSE\n#> 97                          (    0  TRUE\n#> 98                          [    0  TRUE\n#> 116                        [[    0  TRUE\n#> 123                      [[<-    0  TRUE\n#> 128                       [<-    0  TRUE\n#> 136                         {    0  TRUE\n#> 137                         @    0  TRUE\n#> 138                       @<-    0  TRUE\n#> 139                         *    0  TRUE\n#> 141                         /    0  TRUE\n#> 143                         &    0  TRUE\n#> 146                        &&    0  TRUE\n#> 147                       %*%    0  TRUE\n#> 148                       %/%    0  TRUE\n#> 149                        %%    0  TRUE\n#> 154                         ^    0  TRUE\n#> 155                         +    0  TRUE\n#> 158                         <    0  TRUE\n#> 159                        <-    0  TRUE\n#> 160                       <<-    0  TRUE\n#> 161                        <=    0  TRUE\n#> 162                         =    0  TRUE\n#> 163                        ==    0  TRUE\n#> 164                         >    0  TRUE\n#> 165                        >=    0  TRUE\n#> 166                         |    0  TRUE\n#> 169                        ||    0  TRUE\n#> 170                         ~    0  TRUE\n#> 171                         $    0  TRUE\n#> 174                       $<-    0  TRUE\n#> 178                       abs    0  TRUE\n#> 179                      acos    0  TRUE\n#> 180                     acosh    0  TRUE\n#> 187                       all    0  TRUE\n#> 204                       any    0  TRUE\n#> 210                     anyNA    0  TRUE\n#> 219                       Arg    0  TRUE\n#> 226                   as.call    0  TRUE\n#> 227              as.character    0  TRUE\n#> 238                as.complex    0  TRUE\n#> 272                 as.double    0  TRUE\n#> 275            as.environment    0  TRUE\n#> 282                as.integer    0  TRUE\n#> 294                as.logical    0  TRUE\n#> 304                as.numeric    0  TRUE\n#> 323                    as.raw    0  TRUE\n#> 333                      asin    0  TRUE\n#> 334                     asinh    0  TRUE\n#> 340                      atan    0  TRUE\n#> 342                     atanh    0  TRUE\n#> 345                      attr    0  TRUE\n#> 347                    attr<-    0  TRUE\n#> 348                attributes    0  TRUE\n#> 349              attributes<-    0  TRUE\n#> 354                   baseenv    0  TRUE\n#> 373                     break    0  TRUE\n#> 374                   browser    0  TRUE\n#> 383                         c    0  TRUE\n#> 392                      call    0  TRUE\n#> 399                   ceiling    0  TRUE\n#> 412                     class    0  TRUE\n#> 413                   class<-    0  TRUE\n#> 419       closeAllConnections    0 FALSE\n#> 436                      Conj    0  TRUE\n#> 437              contributors    0 FALSE\n#> 438                       cos    0  TRUE\n#> 439                      cosh    0  TRUE\n#> 440                     cospi    0  TRUE\n#> 441                 crossprod    0  TRUE\n#> 442               Cstack_info    0 FALSE\n#> 443                    cummax    0  TRUE\n#> 444                    cummin    0  TRUE\n#> 445                   cumprod    0  TRUE\n#> 446                    cumsum    0  TRUE\n#> 455                      date    0 FALSE\n#> 459                   declare    0  TRUE\n#> 460  default.stringsAsFactors    0 FALSE\n#> 477                   digamma    0  TRUE\n#> 478                       dim    0  TRUE\n#> 480                     dim<-    0  TRUE\n#> 481                  dimnames    0  TRUE\n#> 483                dimnames<-    0  TRUE\n#> 512                  emptyenv    0  TRUE\n#> 513                enc2native    0  TRUE\n#> 514                  enc2utf8    0  TRUE\n#> 522             environment<-    0  TRUE\n#> 529                      Exec    0  TRUE\n#> 531                       exp    0  TRUE\n#> 533                     expm1    0  TRUE\n#> 534                expression    0  TRUE\n#> 535            extSoftVersion    0 FALSE\n#> 562                     floor    0  TRUE\n#> 565                       for    0  TRUE\n#> 567              forceAndCall    0  TRUE\n#> 590                  function    0  TRUE\n#> 591                     gamma    0  TRUE\n#> 593                   gc.time    0  TRUE\n#> 599         getAllConnections    0 FALSE\n#> 607             geterrmessage    0 FALSE\n#> 610             getLoadedDLLs    0 FALSE\n#> 620               getRversion    0 FALSE\n#> 622      getTaskCallbackNames    0 FALSE\n#> 625                     getwd    0 FALSE\n#> 628                 globalenv    0  TRUE\n#> 640                 iconvlist    0 FALSE\n#> 645                        if    0  TRUE\n#> 647                        Im    0  TRUE\n#> 653               interactive    0  TRUE\n#> 658                 invisible    0  TRUE\n#> 661                  is.array    0  TRUE\n#> 662                 is.atomic    0  TRUE\n#> 663                   is.call    0  TRUE\n#> 664              is.character    0  TRUE\n#> 665                is.complex    0  TRUE\n#> 667                 is.double    0  TRUE\n#> 669            is.environment    0  TRUE\n#> 670             is.expression    0  TRUE\n#> 672                 is.finite    0  TRUE\n#> 674               is.function    0  TRUE\n#> 675               is.infinite    0  TRUE\n#> 677                is.integer    0  TRUE\n#> 678               is.language    0  TRUE\n#> 679                   is.list    0  TRUE\n#> 681                is.logical    0  TRUE\n#> 682                 is.matrix    0  TRUE\n#> 683                     is.na    0  TRUE\n#> 691                   is.name    0  TRUE\n#> 692                    is.nan    0  TRUE\n#> 694                   is.null    0  TRUE\n#> 695                is.numeric    0  TRUE\n#> 700                 is.object    0  TRUE\n#> 703               is.pairlist    0  TRUE\n#> 706                      is.R    0 FALSE\n#> 707                    is.raw    0  TRUE\n#> 708              is.recursive    0  TRUE\n#> 709                 is.single    0  TRUE\n#> 710                 is.symbol    0  TRUE\n#> 726                      isS4    0  TRUE\n#> 740                 l10n_info    0 FALSE\n#> 741                La_library    0 FALSE\n#> 742                La_version    0 FALSE\n#> 749           lazyLoadDBfetch    0  TRUE\n#> 752                    length    0  TRUE\n#> 754                  length<-    0  TRUE\n#> 763                  levels<-    0  TRUE\n#> 766                    lgamma    0  TRUE\n#> 767            libcurlVersion    0 FALSE\n#> 771                   licence    0 FALSE\n#> 772                   license    0 FALSE\n#> 773                      list    0  TRUE\n#> 779          loadedNamespaces    0 FALSE\n#> 780      loadingNamespaceInfo    0 FALSE\n#> 785                       log    0  TRUE\n#> 786                     log10    0  TRUE\n#> 787                     log1p    0  TRUE\n#> 788                      log2    0  TRUE\n#> 811                       max    0  TRUE\n#> 823            memory.profile    0 FALSE\n#> 829                       min    0  TRUE\n#> 830                   missing    0  TRUE\n#> 831                       Mod    0  TRUE\n#> 844                     names    0  TRUE\n#> 846                   names<-    0  TRUE\n#> 853                     nargs    0  TRUE\n#> 859                      next    0  TRUE\n#> 868                  nullfile    0 FALSE\n#> 873                    nzchar    0  TRUE\n#> 875                  oldClass    0  TRUE\n#> 876                oldClass<-    0  TRUE\n#> 878                   on.exit    0  TRUE\n#> 911               pcre_config    0 FALSE\n#> 920                pos.to.env    0  TRUE\n#> 963                 proc.time    0  TRUE\n#> 964                      prod    0  TRUE\n#> 987                     quote    0  TRUE\n#> 988             R_compiled_by    0 FALSE\n#> 991                 R.Version    0 FALSE\n#> 992                     range    0  TRUE\n#> 1007                       Re    0  TRUE\n#> 1026                      rep    0  TRUE\n#> 1035                   repeat    0  TRUE\n#> 1042               retracemem    0  TRUE\n#> 1043                   return    0  TRUE\n#> 1051                    round    0  TRUE\n#> 1077                   search    0 FALSE\n#> 1078              searchpaths    0 FALSE\n#> 1082                seq_along    0  TRUE\n#> 1083                  seq_len    0  TRUE\n#> 1086                  seq.int    0  TRUE\n#> 1102                     sign    0  TRUE\n#> 1104                   signif    0  TRUE\n#> 1110                      sin    0  TRUE\n#> 1112                     sinh    0  TRUE\n#> 1115                    sinpi    0  TRUE\n#> 1142                     sqrt    0  TRUE\n#> 1148          standardGeneric    0  TRUE\n#> 1150                   stderr    0 FALSE\n#> 1151                    stdin    0 FALSE\n#> 1152                   stdout    0 FALSE\n#> 1156           storage.mode<-    0  TRUE\n#> 1172               substitute    0  TRUE\n#> 1177                      sum    0  TRUE\n#> 1206                   switch    0  TRUE\n#> 1208                sys.calls    0 FALSE\n#> 1210                 Sys.Date    0 FALSE\n#> 1212               sys.frames    0 FALSE\n#> 1216               Sys.getpid    0 FALSE\n#> 1218                 Sys.info    0 FALSE\n#> 1220           Sys.localeconv    0 FALSE\n#> 1221               sys.nframe    0 FALSE\n#> 1222              sys.on.exit    0 FALSE\n#> 1224              sys.parents    0 FALSE\n#> 1233               sys.status    0 FALSE\n#> 1234                 Sys.time    0 FALSE\n#> 1248                 Tailcall    0  TRUE\n#> 1249                      tan    0  TRUE\n#> 1250                     tanh    0  TRUE\n#> 1251                    tanpi    0  TRUE\n#> 1254               tcrossprod    0  TRUE\n#> 1266                 tracemem    0  TRUE\n#> 1271                 trigamma    0  TRUE\n#> 1273                    trunc    0  TRUE\n#> 1282           unCfillPOSIXlt    0  TRUE\n#> 1283                  unclass    0  TRUE\n#> 1307               untracemem    0  TRUE\n#> 1312                UseMethod    0  TRUE\n#> 1328                    while    0  TRUE\n#> 1345                    xtfrm    0  TRUE\n```\n\n\n:::\n:::\n\n\nAnswers:\n\na. `scan()` has the most arguments, 22\na. most (but not all) are primitive functions (204 of 254)\na. the `ls()` in the original code could be expanded to search all packages\n\nAR Solutions: Let's look at each sub-question separately:\n\na. To find the function with the most arguments, we first compute the length of `formals()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(purrr)\n\nn_args <- funs %>%\n  map(formals) %>%\n  map_int(length)\n```\n:::\n\n\nThen we sort `n_args` in decreasing order and look at its first entries.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn_args %>%\n  sort(decreasing = TRUE) %>%\n  head()\n#> scan format.default source\n#> 22 16 16\n#> formatC library merge.data.frame\n#> 15 13 13\n```\n:::\n\n\nb. We can further use `n_args` to find the number of functions with no arguments:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsum(n_args == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 258\n```\n\n\n:::\n:::\n\n\nHowever, this over counts because `formals()` returns `NULL` for primitive functions, and `length(NULL)` is 0. To fix this, we can first remove the primitive functions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn_args2 <- funs %>%\n  discard(is.primitive) %>%\n  map(formals) %>%\n  map_int(length)\n\nsum(n_args2 == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 48\n```\n\n\n:::\n:::\n\n\nIndeed, most of the functions with no arguments are actually primitive functions.\n\nc. To find all primitive functions, we can change the predicate in `Filter()` from `is.function()` to `is.primitive()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfuns <- Filter(is.primitive, objs)\nlength(funs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 210\n```\n\n\n:::\n:::\n\n\n---\n\n6. What are the three important components of a function?\n\nAnswer: the `formals()`, `body()` and `environment()`.\n\nAR Solutions: These components are the function's `body()`, `formals()` and `environment()`. However, as mentioned in *Advanced R*:\n\n> There is one exception to the rule that functions have three components. Primitive functions, like `sum()`, call C code directly with `.Primitive()` and contain no R code. Therefore, their `formals()`, `body()`, and `environment()` are all `NULL`.\n\n---\n\n7. When does printing a function not show the environment it was created in?\n\nAnswer: when it is created in the global environment.\n\nAR Solutions: Primitive functions and functions created in the global environment do not print their environment.\n\n---\n\n## 6.4.5 Exercises\n\n1. What does the following code return? Why? Describe how each of the three\n   `c`'s is interpreted.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc <- 10\nc(c = c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  c \n#> 10\n```\n\n\n:::\n:::\n\n\nAnswer: a named vector, `c 10`. The first and final c is a variable. The second c is a function name. the third c is a name.\n\nAR Solutions: This code returns a named numeric vector of length one — with one element of the value `10` and the name `\"c\"`. The first `c` represents the `c()` function, the second `c` is interpreted as a (quoted) name and the third `c` as a value.\n\n---\n\n2. What are the four principles that govern how R looks for values?\n\nAnswer: name masking, functions versus variables, a fresh start, dynamic lookup.\n\nAR Solutions: R's [lexical scoping](https://adv-r.hadley.nz/functions.html#lexical-scoping) rules are based on these four principles:\n- [Name masking](https://adv-r.hadley.nz/functions.html#name-masking)\n- [Functions vs. variables](https://adv-r.hadley.nz/functions.html#functions-versus-variables)\n- [A fresh start](https://adv-r.hadley.nz/functions.html#fresh-start)\n- [Dynamic lookup](https://adv-r.hadley.nz/functions.html#dynamic-lookup)\n\n---\n\n3. What does the following function return? Make a prediction before \n   running the code yourself.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- function(x) {\n  f <- function(x) { # return value of this is 101\n    f <- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 202\n```\n\n\n:::\n:::\n\n\nAnswer: 202. Correct!\n\nAR Solutions: Within this nested function two more functions also named `f` are defined and called. Because the functions are each executed in their own environment R will look up and use the functions defined last in these environments. The innermost `f()` is called last, though it is the first function to return a value. Therefore, the order of the calculation passes \"from the inside to the outside\" and the function returns `((10 ^ 2) + 1) * 2`, i.e. 202.\n\n---\n\n## 6.5.4 Exercises\n\n1.  What important property of `&&` makes `x_ok()` work?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nx_ok(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nx_ok(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n:::\n\n\nAnswer: From the `&&` docs, \"The longer forms evaluates left to right, proceeding only until the result is determined.\"\n\nWhat is different with this code? Why is this behaviour undesirable here?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> logical(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nx_ok(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nx_ok(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nAnswer: \"The shorter forms performs elementwise comparisons in much the same way as arithmetic operators.\" This is undesirable because the intent of the function is to return `TRUE` or `FALSE`.\n\nAR Solutions: In summary: `&&` short-circuits which means that if the left-hand side is `FALSE` it doesn't evaluate the right-hand side (because it doesn't matter). Similarly, if the left-hand side of `||` is `TRUE` it doesn't evaluate the right-hand side.\n\nWe expect `x_ok()` to validate its input via certain criteria: it must not be `NULL`, have length `1` and be greater than `0`. Meaningful outcomes for this assertion will be `TRUE`, `FALSE` or `NA`. The desired behaviour is reached by combining the assertions through `&&` instead of `&`.\n\n`&&` does not perform elementwise comparisons; instead it uses the first element of each value only. It also uses lazy evaluation, in the sense that evaluation \"proceeds only until the result is determined\" (from `?Logic`). This means that the RHS of `&&` won't be evaluated if the LHS already determines the outcome of the comparison (e.g. evaluate to `FALSE`). This behaviour is also known as \"short-circuiting\". For some situations (`x = 1`) both operators will lead to the same result. But this is not always the case. For `x = NULL`, the `&&`-operator will stop after the `!is.null` statement and return the result. The following conditions won't even be evaluated! (If the other conditions are also evaluated (by the use of `&`), the outcome would change. `NULL > 0` returns `logical(0)`, which is not helpful in this case.)\n\nWe can also see the difference in behaviour, when we set `x = 1:3`. The `&&`-operator returns the result from `length(x) == 1`, which is `FALSE`. Using `&` as the logical operator leads to the (vectorised) `x > 0` condition being evaluated and also returned.\n\n---\n\n2.  What does this function return? Why? Which principle does it illustrate?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 100\n```\n\n\n:::\n:::\n\n\nAnswer: 100, lazy evaluation. `x = z` isn't evaluated until `x`.\n\nAR Solutions: The function returns 100. The default argument (`x = z`) gets lazily evaluated within the function environment when `x` gets accessed. At this time `z` has already been bound to the value `100`. The illustrated principle here is *lazy evaluation*.\n\n---\n\n3.  What does this function return? Why? Which principle does it illustrate?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny <- 10\n# styler: off\nf1 <- function(x = {y <- 1; 2}, y = 0) { # nolint: semicolon_linter.\n  # styler: on\n  c(x, y)\n}\nf1()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2 1\n```\n\n\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 10\n```\n\n\n:::\n:::\n\n\nAnswer: `c(2, 1)`. default arguments.\n\nAR Solutions: The function returns `c(2, 1)` which is due to *name masking*. When `x` is accessed within `c()`, the promise `x = {y <- 1; 2}` is evaluated inside `f1()`'s environment. `y` gets bound to the value `1` and the return value of `{()` (`2`) gets assigned to `x`. When `y` gets accessed next within `c()`, it has already the value `1` and R doesn't need to look it up any further. Therefore, the promise `y = 0` won't be evaluated. Also, as `y` is assigned within `f1()`'s environment, the value of the global variable `y` is left untouched.\n\n---\n\n4.  In `hist()`, the default value of `xlim` is `range(breaks)`, the default \n    value for `breaks` is `\"Sturges\"`, and\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrange(\"Sturges\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Sturges\" \"Sturges\"\n```\n\n\n:::\n:::\n\n\nExplain how `hist()` works to get a correct `xlim` value.\n\nAnswer: from the docs, \"Note that `xlim` is *not* used to define the histogram (breaks), but only for plotting (when `plot = TRUE`).\" So, the breakpoints are calculated when the object is created, and `xlim` is calculated when the histogram is plotted, in the second step.\n\nAR Solutions: The `xlim` argument of `hist()` defines the range of the histogram's x-axis. In order to provide a valid axis `xlim` must contain a numeric vector of exactly two unique values. Consequently, for the default `xlim = range(breaks)`), `breaks` must evaluate to a vector with at least two unique values.\n\nDuring execution `hist()` overwrites the `breaks` argument. The `breaks` argument is quite flexible and allows the users to provide the breakpoints directly or compute them in several ways. Therefore, the specific behaviour depends highly on the input. But `hist` ensures that `breaks` evaluates to a numeric vector containing at least two unique elements before `xlim` is computed.\n\n---\n    \n5.  Explain why this function works. Why is it confusing?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2024-04-27 09:20:31 CDT\"\n```\n\n\n:::\n:::\n\n\nAnswer: `stop` is redefined before `x` is evaluated. This is a confusing use of lazy evaluation.\n\nAR Solutions: Before `show_time()` accesses `x` (default `stop(\"Error\")`), the `stop()` function is masked by `function(...) Sys.time()`. As default arguments are evaluated in the function environment, `print(x)` will be evaluated as `print(Sys.time())`.\n\nThis function is confusing because its behaviour changes when `x`'s value is supplied directly. Now the value from the calling environment will be used and the overwriting of `stop()` won't affect `x` anymore.\n\n---\n\n6.  How many arguments are required when calling `library()`?\n\nAnswer: zero. `library()` uses `missing()` to return the list of available packages if there are no arguments.\n\nAR Solutions: `library()` doesn't require any arguments. When called without arguments `library()` invisibly returns a list of class `libraryIQR`, which contains a results matrix with one row and three columns per installed package. These columns contain entries for the name of the package (\"Package\"), the path to the package (\"LibPath\") and the title of the package (\"Title\"). `library()` also has its own print method (`print.libraryIQR()`), which displays this information conveniently in its own window.\n\nThis behaviour is also documented under the details section of `library()`'s help page (`?library`):\n\n> If library is called with no package or help argument, it lists all available packages in the libraries specified by lib.loc, and returns the corresponding information in an object of class “libraryIQR”. (The structure of this class may change in future versions.) Use .packages(all = TRUE) to obtain just the names of all available packages, and installed.packages() for even more information.\n\nBecause the `package` and `help` argument from `library()` do not show a default value, it's easy to overlook the possibility to call `library()` without these arguments. (Instead of providing `NULL`s as default values `library()` uses `missing()` to check if these arguments were provided.)\n\n---\n\n## 6.6.1 Exercises\n\n1.  Explain the following results:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsum(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(1, 2, 3, na.omit = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(1, 2, 3, na.omit = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n:::\n\n\nAnswer:\n\n- \"`sum()` returns the sum of all the values present in its arguments.\" The first example is\n  straightforward. In the second sum example, `na.omit` isn't a valid argument (`na.rm` is), so the\n  `TRUE` value is passed to `...`, coerced to 1, and included in the sum.\n- `mean()` takes a single parameter, and passes on remaining arguments to `...`. In both cases, the\n  arguments after the `1` are silently dropped. The correct form would be `mean(c(1, 2, 3))`.\n\nAR Solutions: Let's inspect the arguments and their order for both functions. For `sum()` these are `...` and `na.rm`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (..., na.rm = FALSE)\n```\n\n\n:::\n:::\n\nFor the `...` argument `sum()` expects numeric, complex, or logical vector input (see `?sum`). Unfortunately, when `...` is used, misspelled arguments (!) like `na.omit` won't raise an error (in case of no further input checks). So instead, `na.omit` is treated as a logical and becomes part of the `...` argument. It will be coerced to `1` and be part of the sum. All other arguments are left unchanged. Therefore `sum(1, 2, 3)` returns `6` and `sum(1, 2, 3, na.omit = TRUE)` returns `7`.\n\nIn contrast, the generic function `mean()` expects `x`, `trim`, `na.rm` and `...` for its default method.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr(mean.default)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, trim = 0, na.rm = FALSE, ...)\n```\n\n\n:::\n:::\n\n\nAs `na.omit` is not one of `mean()`'s named arguments (`x`; and no candidate for partial matching), `na.omit` again becomes part of the `...` argument. However, in contrast to `sum()` the elements of `...` are not \"part\" of the mean. The other supplied arguments are matched by their order, i.e. `x = 1`, `trim = 2` and `na.rm = 3`. As `x` is of length 1 and not `NA`, the settings of `trim` and `na.rm` do not affect the calculation of the mean. Both calls (`mean(1, 2, 3)` and `mean(1, 2, 3, na.omit = TRUE)`) return `1`.\n\n---\n\n2.  Explain how to find the documentation for the named arguments in the \n    following function call:\n\n<!-- TODO: bugfix: the figure below renders incorrectly,\n     possibly due to https://github.com/rstudio/rstudio/issues/4521\n     see also: https://github.com/hadley/adv-r/blob/master/common.R\n     and: https://yihui.org/knitr/options/#plots\n     workaround: use {r, fig.asp = 1}.\n     {r, fig.asp = 1, fig.width = 3} looks correct in RStudio, but doesn't render properly for\n     build_analysis_site(). {r, fig.asp = 1} works with build_analysis_site() but is not sized\n     properly in RStudio. {r, fig.asp = 1} is the best option for now.\n  -->\n\n\n::: {.cell layout-align=\"center\" small_mar='true'}\n\n```{.r .cell-code}\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\n```\n\n::: {.cell-output-display}\n![](advanced-r-1_files/figure-html/unnamed-chunk-102-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nAnswer: in other functions, specifically `par()` and `plot.default()`.\n\nAR Solutions: First we type `?plot` in the console and check the \"Usage\" section which contains:\n\n```r\nplot(x, y, ...)\n```\n\nThe arguments we want to learn more about (`col`, `pch`, `xlab`, `col.lab`) are part of the `...` argument. There we can find information for the `xlab` argument and a recommendation to visit `?par` for the other arguments. Under `?par` we type \"col\" into the search bar, which leads us to the section \"Color Specification\". We also search for the `pch` argument, which leads to the recommendation to check `?points`. Finally, `col.lab` is also directly documented within `?par`.\n\n---\n\n3.  Why does `plot(1:10, col = \"red\")` only colour the points, not the axes \n    or labels? Read the source code of `plot.default()` to find out.\n\n```r\nlocalAxis <- function(..., col, bg, pch, cex, lty, lwd) Axis(...)\nlocalBox <- function(..., col, bg, pch, cex, lty, lwd) box(...)\nlocalWindow <- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)\nlocalTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)\n```\n\nAnswer: `plot.default()` discards `col` and several other arguments when calling `Axis()`, `box()`, `plot.window()`, and `title()`.\n\nAR Solutions: To learn about the internals of `plot.default()` we add `browser()` to the first line of the code and interactively run `plot(1:10, col = \"red\")`. This way we can see how the plot is built and learn where the axes are added.\nThis leads us to the function call\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlocalTitle(main = main, sub = sub, xlab = xlab, ylab = ylab, ...)\n```\n:::\n\n\nThe `localTitle()` function was defined in the first lines of `plot.default()` as:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlocalTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)\n```\n:::\n\n\nThe call to `localTitle()` passes the `col` parameter as part of the `...` argument to `title()`. `?title` tells us that the `title()` function specifies four parts of the plot: Main (title of the plot), sub (sub-title of the plot) and both axis labels. Therefore, it would introduce ambiguity inside `title()` to use `col` directly. Instead, one has the option to supply `col` via the `...` argument, via `col.lab` or as part of `xlab` in the form `xlab = list(c(\"index\"), col = \"red\")` (similar for `ylab`).\n\n---\n\n## 6.7.5 Exercises\n\n1.  What does `load()` return? Why don't you normally see these values?\n\nAnswer: from the docs, `load()` returns \"A character vector of the names of objects created, invisibly.\"\n\nAR Solutions: `load()` loads objects saved to disk in `.Rdata` files by `save()`. When run successfully, `load()` invisibly returns a character vector containing the names of the newly loaded objects. To print these names to the console, one can set the argument `verbose` to `TRUE` or surround the call in parentheses to trigger R's auto-printing mechanism.\n\n---\n\n2.  What does `write.table()` return? What would be more useful?\n\nAnswer: it returns `invisible(NULL)`. Returning the written table or the argument `x` would be more useful.\n\nAR Solutions: `write.table()` writes an object, usually a data frame or a matrix, to disk. The function invisibly returns `NULL`. It would be more useful if `write.table()` would (invisibly) return the input data, `x`. This would allow to save intermediate results and directly take on further processing steps without breaking the flow of the code (i.e. breaking it into different lines). One package which uses this pattern is the `{readr}` package, which is part of the [tidyverse-ecosystem](https://www.tidyverse.org/).\n\n---\n\n3.  How does the `chdir` parameter of `source()` compare to `with_dir()`? Why \n    might you prefer one to the other?\n\nAnswer: both temporarily change the working directory. `chdir` is preferable since this is expected behavior for the function, unless you need to set a working directory other than the directory containing `file`.\n\nAR Solutions: `with_dir()` takes a path for a working directory (`dir`) as its first argument. This is the directory where the provided code (`code`) should be executed. Therefore, the current working directory is changed in `with_dir()` via `setwd()`. Then, `on.exit()` ensures that the modification of the working directory is reset to the initial value when the function exits. By passing the path explicitly, the user has full control over the directory to execute the code in.\n\nIn `source()` the code is passed via the `file` argument (a path to a file). The `chdir` argument specifies if the working directory should be changed to the directory containing the file. The default for `chdir` is `FALSE`, so you don't have to provide a value. However, as you can only provide `TRUE` or `FALSE`, you are also less flexible in choosing the working directory for the code execution.\n\n---\n\n4.  Write a function that opens a graphics device, runs the supplied code, and \n    closes the graphics device (always, regardless of whether or not the \n    plotting code works).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwith_png <- function(code, ...) {\n  png(...)\n  on.exit(dev.off(), add = TRUE, after = TRUE)\n  force(code)\n}\n\nwith_png(\n  plot(1:10),\n  filename = \"rendered/withpng-example.png\",\n  # use 3 times default resolution which is close to retina display ppi (218-254 depending on model)\n  # https://support.apple.com/en-us/HT202471\n  width = 480 * 3, height = 480 * 3, res = 72 * 3\n)\n```\n:::\n\n\n![with_png output](rendered/withpng-example.png)\n\nAnswer: code example above.\n\nAR Solutions: To control the graphics device we use `pdf()` and `dev.off()`. To ensure a clean termination `on.exit()` is used.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_pdf <- function(code) {\n  pdf(\"test.pdf\")\n  on.exit(dev.off(), add = TRUE)\n  code\n}\n```\n:::\n\n\n---\n\n5.  We can use `on.exit()` to implement a simple version of `capture.output()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncapture.output2 <- function(code) {\n  temp <- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n  force(code)\n  readLines(temp)\n}\n\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\nCompare `capture.output()` to `capture.output2()`. How do the functions  differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas so they're easier to understand?\n\nAnswer: `capture.output2()` has fewer features and uses two separate calls to `on.exit()`. It simply returns the output (by line) from the executed code, and highlights the key idea, using `sink()` to capture output to a temporary file.\n\nAR Solutions: Using `body(capture.output)` we inspect the source code of the original `capture.output()` function: The implementation for `capture.output()` is quite a bit longer (39 lines vs. 7 lines).\n\nIn `capture_output2()` the code is simply forced, and the output is caught via `sink()` in a temporary file. An additional feature of `capture_output()` is that one can also capture messages by setting `type = \"message\"`. As this is internally forwarded to `sink()`, this behaviour (and also `sink()`'s `split` argument) could be easily introduced within `capture_output2()` as well.\n\nThe main difference is that `capture.output()` calls print.\n\n---\n\n## 6.8.6 Exercises\n\n1. Rewrite the following code snippets into prefix form:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1 + 2 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n`+`(`+`(1, 2), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n1 + (2 + 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n`+`(1, `+`(2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nfxn <- function(x, n) if (length(x) <= 5) x[[5]] else x[[n]]\nfxn(1:5, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nfxn(1:10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nfxn2 <- function(x, n) `if`(`<=`(length(x), 5), `[[`(x, 5), `[[`(x, n))\nfxn2(1:5, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nfxn2(1:10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n\nAnswer: inline above.\n\nAR Solutions: Let's rewrite the expressions to match the exact syntax from the code above. Because prefix functions already define the execution order, we may omit the parentheses in the second expression.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`+`(`+`(1, 2), 3)\n`+`(1, `(`(`+`(2, 3)))\n`+`(1, `+`(2, 3))\n`if`(`<=`(length(x), 5), `[[`(x, 5), `[[`(x, n))\n```\n:::\n\n\n---\n\n2.  Clarify the following list of odd function calls:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- sample(replace = TRUE, 20, x = c(1:10, NA))\ny <- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\n```\n:::\n\n\nAnswers: improved code below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- sample(c(1:10, NA), 20, replace = TRUE)\ny <- runif(20)\ncor(x, y, use = \"pairwise.complete.obs\", method = \"kendall\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1492563\n```\n\n\n:::\n:::\n\n\nAR Solutions: None of these functions provides a `...` argument. Therefore, the function arguments are first matched exactly, then via partial matching and finally by position. This leads us to the following explicit function calls:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- sample(c(1:10, NA), size = 20, replace = TRUE)\ny <- runif(20, min = 0, max = 1)\ncor(x, y, use = \"pairwise.complete.obs\", method = \"kendall\")\n```\n:::\n\n\n---\n\n3. Explain why the following code fails:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`modify<-` <- function(x, position, value) {\n  x[position] <- value\n  x\n}\n\ntry(modify(get(\"x\"), 1) <- 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in modify(get(\"x\"), 1) <- 10 : \n#>   target of assignment expands to non-language object\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Error: target of assignment expands to non-language object\n```\n:::\n\n\nAnswer: as explained on [stack overflow](https://stackoverflow.com/questions/27662162/error-in-my-code-target-of-assignment-expands-to-non-language-object), the error is caused when assigning to an object directly, instead of a name that refers to the object (like `x`).\n\nAR Solutions: First, let's define `x` and recall the definition of `modify()` from *Advanced R*:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:3\n\n`modify<-` <- function(x, position, value) {\n  x[position] <- value\n  x\n}\n```\n:::\n\n\nR internally transforms the code, and the transformed code reproduces the error above:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget(\"x\") <- `modify<-`(get(\"x\"), 1, 10)\n#> Error in get(\"x\") <- `modify<-`(get(\"x\"), 1, 10) :\n#>   target of assignment expands to non-language object\n```\n:::\n\n\nThe error occurs during the assignment because no corresponding replacement function, i.e. `get<-`, exists for `get()`. To confirm this, we reproduce the error via the following simplified example.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget(\"x\") <- 2\n#> Error in get(\"x\") <- 2 :\n#>   target of assignment expands to non-language object\n```\n:::\n\n\n---\n\n4. Create a replacement function that modifies a random location in a vector.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`modrand<-` <- function(x, value) {\n  x[sample(length(x), 1)] <- value\n  x\n}\n\nv <- 1:20\nmodrand(v) <- NA\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 NA 18 19 20\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: Let's define `random<-` like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`random<-` <- function(x, value) {\n  idx <- sample(length(x), 1)\n  x[idx] <- value\n  x\n}\n```\n:::\n\n\n---\n\n5. Write your own version of `+` that pastes its inputs together if they are \n   character vectors but behaves as usual otherwise. In other words, make this \n   code work:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`+` <- function(x, y) {\n  if (is.character(x) && is.character(y)) {\n    return(paste0(x, y))\n  }\n  base::`+`(x, y)\n}\n\n1 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3\n\n\"a\" + \"b\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"ab\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"ab\"\n\nrm(`+`)\n```\n:::\n\n\nAnswer: code above.\n\nAR Solutions: To achieve this behaviour, we need to override the `+` operator. We need to take care to not use the `+` operator itself inside of the function definition, as this would lead to an undesired infinite recursion. We also add `b = 0L` as a default value to keep the behaviour of `+` as a unary operator, i.e. to keep `+ 1` working and not throwing an error.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`+` <- function(a, b = 0L) {\n  if (is.character(a) && is.character(b)) {\n    paste0(a, b)\n  } else {\n    base::`+`(a, b)\n  }\n}\n# Test\n+1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n\"a\" + \"b\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"ab\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Return back to the original `+` operator\nrm(`+`)\n```\n:::\n\n\n---\n\n6. Create a list of all the replacement functions found in the base package. \n   Which ones are primitive functions? (Hint: use `apropos()`.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# all replacement functions in base\nfun_args2[endsWith(fun_args2$name, \"<-\"), ]$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \".rowNamesDF<-\"    \"[[<-\"             \"[<-\"              \"@<-\"             \n#>  [5] \"<-\"               \"<<-\"              \"$<-\"              \"attr<-\"          \n#>  [9] \"attributes<-\"     \"body<-\"           \"class<-\"          \"colnames<-\"      \n#> [13] \"comment<-\"        \"diag<-\"           \"dim<-\"            \"dimnames<-\"      \n#> [17] \"Encoding<-\"       \"environment<-\"    \"formals<-\"        \"is.na<-\"         \n#> [21] \"length<-\"         \"levels<-\"         \"mode<-\"           \"mostattributes<-\"\n#> [25] \"names<-\"          \"oldClass<-\"       \"parent.env<-\"     \"regmatches<-\"    \n#> [29] \"row.names<-\"      \"rownames<-\"       \"split<-\"          \"storage.mode<-\"  \n#> [33] \"substr<-\"         \"substring<-\"      \"units<-\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# all replacement primitive functions in base\nfun_args2[endsWith(fun_args2$name, \"<-\") & fun_args2$prim, ]$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"[[<-\"           \"[<-\"            \"@<-\"            \"<-\"            \n#>  [5] \"<<-\"            \"$<-\"            \"attr<-\"         \"attributes<-\"  \n#>  [9] \"class<-\"        \"dim<-\"          \"dimnames<-\"     \"environment<-\" \n#> [13] \"length<-\"       \"levels<-\"       \"names<-\"        \"oldClass<-\"    \n#> [17] \"storage.mode<-\"\n```\n\n\n:::\n:::\n\n\nAnswer: while you could use `apropos(\"<-\")`, I leveraged the existing code from 6.2.5 #5.\n\nAR Solutions: The hint suggests to look for functions with a specific naming pattern: Replacement functions conventionally end on \"<-\". We can search for these objects by supplying the regular expression `\"<-$\"` to `apropos()`. `apropos()` also allows to return the position on the search path (`search()`) for each of its matches via setting `where = TRUE`. Finally, we can set `mode = function` to narrow down our search to relevant objects only. This gives us the following statement to begin with:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrepls <- apropos(\"<-\", where = TRUE, mode = \"function\")\nhead(repls, 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                     14                     14                     14 \n#>        \".rowNamesDF<-\"                 \"[[<-\"      \"[[<-.data.frame\" \n#>                     14                     14                     14 \n#>          \"[[<-.factor\" \"[[<-.numeric_version\"         \"[[<-.POSIXlt\" \n#>                     14                     14                     14 \n#>                  \"[<-\"       \"[<-.data.frame\"             \"[<-.Date\" \n#>                     14                     14                     14 \n#>         \"[<-.difftime\"           \"[<-.factor\"  \"[<-.numeric_version\" \n#>                     14                     14                     14 \n#>          \"[<-.POSIXct\"          \"[<-.POSIXlt\"                  \"@<-\" \n#>                      3                     14                     14 \n#>                \"%@%<-\"                   \"<-\"                  \"<<-\" \n#>                     14                     14                     14 \n#>                  \"$<-\"       \"$<-.data.frame\"          \"$<-.POSIXlt\" \n#>                     12                     14                     14 \n#>                 \"as<-\"               \"attr<-\"         \"attributes<-\" \n#>                     12                     14                     14 \n#>               \"body<-\"               \"body<-\"              \"class<-\" \n#>                     12                     14                     14 \n#>             \"coerce<-\"           \"colnames<-\"            \"comment<-\"\n```\n\n\n:::\n:::\n\n\nTo restrict `repl` to names of replacement functions from the `{base}` package, we select only matches containing the relevant position on the search path.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrepls_base <- repls[names(repls) == length(search())]\nrepls_base\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                        14                        14                        14 \n#>           \".rowNamesDF<-\"                    \"[[<-\"         \"[[<-.data.frame\" \n#>                        14                        14                        14 \n#>             \"[[<-.factor\"    \"[[<-.numeric_version\"            \"[[<-.POSIXlt\" \n#>                        14                        14                        14 \n#>                     \"[<-\"          \"[<-.data.frame\"                \"[<-.Date\" \n#>                        14                        14                        14 \n#>            \"[<-.difftime\"              \"[<-.factor\"     \"[<-.numeric_version\" \n#>                        14                        14                        14 \n#>             \"[<-.POSIXct\"             \"[<-.POSIXlt\"                     \"@<-\" \n#>                        14                        14                        14 \n#>                      \"<-\"                     \"<<-\"                     \"$<-\" \n#>                        14                        14                        14 \n#>          \"$<-.data.frame\"             \"$<-.POSIXlt\"                  \"attr<-\" \n#>                        14                        14                        14 \n#>            \"attributes<-\"                  \"body<-\"                 \"class<-\" \n#>                        14                        14                        14 \n#>              \"colnames<-\"               \"comment<-\"                  \"diag<-\" \n#>                        14                        14                        14 \n#>                   \"dim<-\"              \"dimnames<-\"   \"dimnames<-.data.frame\" \n#>                        14                        14                        14 \n#>              \"Encoding<-\"           \"environment<-\"               \"formals<-\" \n#>                        14                        14                        14 \n#>                 \"is.na<-\"         \"is.na<-.default\"          \"is.na<-.factor\" \n#>                        14                        14                        14 \n#> \"is.na<-.numeric_version\"                \"length<-\"           \"length<-.Date\" \n#>                        14                        14                        14 \n#>       \"length<-.difftime\"         \"length<-.factor\"        \"length<-.POSIXct\" \n#>                        14                        14                        14 \n#>        \"length<-.POSIXlt\"                \"levels<-\"         \"levels<-.factor\" \n#>                        14                        14                        14 \n#>                  \"mode<-\"        \"mostattributes<-\"                 \"names<-\" \n#>                        14                        14                        14 \n#>         \"names<-.POSIXlt\"              \"oldClass<-\"            \"parent.env<-\" \n#>                        14                        14                        14 \n#>            \"regmatches<-\"             \"row.names<-\"  \"row.names<-.data.frame\" \n#>                        14                        14                        14 \n#>     \"row.names<-.default\"              \"rownames<-\"                 \"split<-\" \n#>                        14                        14                        14 \n#>      \"split<-.data.frame\"         \"split<-.default\"          \"storage.mode<-\" \n#>                        14                        14                        14 \n#>                \"substr<-\"             \"substring<-\"                 \"units<-\" \n#>                        14 \n#>        \"units<-.difftime\"\n```\n\n\n:::\n:::\n\n\nTo find out which of these functions are primitives, we first search for these functions via `mget()` and then subset the result using `Filter()` and `is.primitive()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrepls_base_prim <- mget(repls_base, envir = baseenv()) %>%\n  Filter(is.primitive, .) %>%\n  names()\nrepls_base_prim\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"[[<-\"           \"[<-\"            \"@<-\"            \"<-\"            \n#>  [5] \"<<-\"            \"$<-\"            \"attr<-\"         \"attributes<-\"  \n#>  [9] \"class<-\"        \"dim<-\"          \"dimnames<-\"     \"environment<-\" \n#> [13] \"length<-\"       \"levels<-\"       \"names<-\"        \"oldClass<-\"    \n#> [17] \"storage.mode<-\"\n```\n\n\n:::\n:::\n\n\nOverall the `base` package contains 63 replacement functions of which 17 are primitive functions.\n\n---\n\n7. What are valid names for user-created infix functions?\n\nAnswer: they must begin and end with `%`, and can contain any sequence of characters except `%`.\n\n---\n\n8. Create an infix `xor()` operator.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`%xor%` <- function(x, y) xor(x, y)\n\nxor(0, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(1, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(1, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n0 %xor% 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 %xor% 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 %xor% 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: We could create an infix `%xor%` like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`%xor%` <- function(a, b) {\n  xor(a, b)\n}\nTRUE %xor% TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE %xor% TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n---\n\n9. Create infix versions of the set functions `intersect()`, `union()`, and\n   `setdiff()`. You might call them `%n%`, `%u%`, and `%/%` to match \n   conventions from mathematics.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`%n%` <- function(x, y) intersect(x, y)\n`%u%` <- function(x, y) union(x, y)\n`%s%` <- function(x, y) setdiff(x, y)\n\n# taken from docs examples\n(x <- c(sort(sample(1:20, 9)), NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  2  3  4  9 11 12 14 17 20 NA\n```\n\n\n:::\n\n```{.r .cell-code}\n(y <- c(sort(sample(3:23, 7)), NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  4  5  8 12 17 18 21 NA\n```\n\n\n:::\n\n```{.r .cell-code}\nx %u% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  2  3  4  9 11 12 14 17 20 NA  5  8 18 21\n```\n\n\n:::\n\n```{.r .cell-code}\nx %n% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  4 12 17 NA\n```\n\n\n:::\n\n```{.r .cell-code}\nx %s% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  2  3  9 11 14 20\n```\n\n\n:::\n\n```{.r .cell-code}\ny %s% x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  5  8 18 21\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: These infix operators could be defined in the following way. (`%/%` is chosen instead of `%\\%`, because `\\` serves as an escape character.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`%n%` <- function(a, b) {\n  intersect(a, b)\n}\n\n`%u%` <- function(a, b) {\n  union(a, b)\n}\n\n`%/%` <- function(a, b) {\n  setdiff(a, b)\n}\n\nx <- c(\"a\", \"b\", \"d\")\ny <- c(\"a\", \"c\", \"d\")\n\nx %u% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\" \"b\" \"d\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx %n% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\" \"d\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx %/% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"b\"\n```\n\n\n:::\n:::\n\n\n---\n\n# 7 Environments\n\nThe environment is the data structure that powers scoping. This chapter dives deep into environments, describing their structure in depth, and using them to improve your understanding of the four scoping rules described in Section 6.4. Understanding environments is not necessary for day-to-day use of R. But they are important to understand because they power many important R features like lexical scoping, namespaces, and R6 classes, and interact with evaluation to give you powerful tools for making domain specific languages, like dplyr and ggplot2.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n## 7.2.7 Exercises\n\n1.  List three ways in which an environment differs from a list.\n\nAnswer:\n\n- Every name in an environment must be unique\n- Environment names are not ordered\n- Environments have parents (except the empty environment)\n- Environments are not copied when modified\n\nAR Solutions: The most important differences between environments and lists are:\n\n- environments have reference semantics (i.e. they don't copy-on-modify)\n- environments have parents\n- the contents of an environment must have unique names\n- the contents of an environment are not ordered\n- (environments can only be compared via `identical()`; not with `==`)\n- (environments can contain themselves)\n\n---\n\n2.  Create an environment as illustrated by this picture.\n\n![](assets/recursive-1.png)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ne1 <- env()\ne1$loop <- e1\n```\n:::\n\n\nAnswer: code above.\n\nAR Solutions: Let's create an environment that contains itself.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ne1 <- env()\ne1$loop <- e1\n\n# Print the environment\nenv_print(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x13ca42770>\n#> Parent: <environment: global>\n#> Bindings:\n#> • loop: <env>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Verify that it contains itself\nlobstr::ref(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █ [1:0x13ca42770] <env> \n#> └─loop = [1:0x13ca42770]\n```\n\n\n:::\n:::\n\n\n---\n\n3.  Create a pair of environments as illustrated by this picture.\n\n![](assets/recursive-2.png)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ne2 <- env()\ne3 <- env()\n\ne2$loop <- e3\ne3$dedoop <- e2\n```\n:::\n\n\nAnswer: code above.\n\nAR Solutions: These two environments contain each other:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ne1 <- env()\ne2 <- env()\n\ne1$loop <- e2\ne2$dedoop <- e1\n\nlobstr::ref(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █ [1:0x107ee7888] <env> \n#> └─loop = █ [2:0x107e607b0] <env> \n#>          └─dedoop = [1:0x107ee7888]\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::ref(e2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> █ [1:0x107e607b0] <env> \n#> └─dedoop = █ [2:0x107ee7888] <env> \n#>            └─loop = [1:0x107e607b0]\n```\n\n\n:::\n:::\n\n\n---\n\n4.  Explain why `e[[1]]` and `e[c(\"a\", \"b\")]` don't make sense when `e` is\n    an environment.\n\nAnswer: environment names are not ordered, and aren't copied when modified, so they aren't subsettable.\n\nAR Solutions: The first option doesn't make sense, because elements of an environment are not ordered. The second option would return two objects at the same time. What data structure would they be contained inside?\n\n---\n\n5.  Create a version of `env_poke()` that will only bind new names, never \n    re-bind old names. Some programming languages only do this, and are known \n    as [single assignment languages](https://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nenv_poke_new <- function(env, nm, value) {\n  if (!is.environment(env)) stop(\"env is not an enviornment\")\n  if (nm %in% names(env)) stop(\"nm '\", nm, \"' already bound\")\n  env[[nm]] <- value\n}\n\ne_test <- env(a = NULL, b = 2, c = \"three\")\n\nenv_poke_new(e_test, \"d\", \"success\")\ntry(env_poke_new(e_test, \"a\", \"fail\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in env_poke_new(e_test, \"a\", \"fail\") : nm 'a' already bound\n```\n\n\n:::\n\n```{.r .cell-code}\nenv_print(e_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: 0x106c5dd18>\n#> Parent: <environment: global>\n#> Bindings:\n#> • a: <NULL>\n#> • b: <dbl>\n#> • c: <chr>\n#> • d: <chr>\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: As described in *Advanced R* `rlang::env_poke()` takes a name (as string) and a value to assign (or reassign) a binding in an environment.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ne3 <- new.env()\n\nenv_poke(e3, \"a\", 100)\ne3$a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\nenv_poke(e3, \"a\", 200)\ne3$a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 200\n```\n\n\n:::\n:::\n\n\nSo, we want `env_poke2()` to test, if the supplied name is already present in the given environment. This can be checked via `env_has()`. If this is the case, an (informative) error is thrown.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nenv_poke2 <- function(env, name, value) {\n  if (env_has(env, name)) {\n    abort(paste0(\"\\\"\", name, \"\\\" is already assigned to a value.\"))\n  }\n\n  env_poke(env, name, value)\n  invisible(env)\n}\n\n# Test\nenv_poke2(e3, \"b\", 100)\ne3$b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(env_poke2(e3, \"b\", 200))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in env_poke2(e3, \"b\", 200) : \"b\" is already assigned to a value.\n```\n\n\n:::\n:::\n\n\n---\n\n6.  What does this function do? How does it differ from `<<-` and why\n    might you prefer it?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(a)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning in rm(a): object 'a' not found\n```\n\n\n:::\n\n```{.r .cell-code}\nrebind <- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\ntry(rebind(\"a\", 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : Can't find `a`\n```\n\n\n:::\n\n```{.r .cell-code}\n(a <- 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nrebind(\"a\", 10)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 10\n```\n\n\n:::\n:::\n\n\nAnswer: `<<-` will assign a value to the name in the global environment if the name is not found, `rebind()` does not.\n\nAR Solutions: The primary difference between `rebind()` and `<<-` is that `rebind()` will only carry out an assignment when it finds an existing binding; unlike `<<-` it will never create a new one in the global environment. This behaviour of `<<-` is usually undesirable because global variables introduce non-obvious dependencies between functions.\n\n---\n\n## 7.3.1 Exercises\n\n1.  Modify `where()` to return _all_ environments that contain a binding for\n    `name`. Carefully think through what type of object the function will\n    need to return.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwhere <- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n\nx <- 5\ntry(where(\"yyy\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : Can't find yyy\n```\n\n\n:::\n\n```{.r .cell-code}\nwhere(\"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\nwhere(\"mean\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: base>\n```\n\n\n:::\n\n```{.r .cell-code}\nall_where <- function(name, env = caller_env(), found = list()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    found\n  } else if (env_has(env, name)) {\n    # Success case\n    all_where(name, env_parent(env), append(env, found, after = 0))\n  } else {\n    # Recursive case\n    all_where(name, env_parent(env), found)\n  }\n}\n\nall_where(\"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n\n```{.r .cell-code}\nlocal({\n  x <- 10\n  all_where(\"x\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> <environment: 0x1068152e0>\n#> \n#> [[2]]\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: `where()` searches (recursively) for a given name within a given environment and its ancestors. If `where()` finds the name in one of these environments, it returns the environment's name. Otherwise, it throws an error.\n\nOur modified version of `where()` will always recurse until it reaches the empty environment. No matter if it has already found the name or not. Along the way, it will check each environment for the given `name`. Finally, it will return a list of environments where the binding was found; if no binding was found, the list will be empty.\n\nPlease also note how the list is initialised via the default argument, when the function is called for the first time. This is a bit confusing, which is why it's common to wrap a recursive function inside another, more user friendly, function.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwhere2 <- function(name, env = caller_env(), results = list()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    results\n  } else {\n    # Recursive case\n    if (env_has(env, name)) {\n      results <- c(results, env)\n    }\n    where2(name, env_parent(env), results)\n  }\n}\n# Test\ne1a <- env(empty_env(), a = 1, b = 2)\ne1b <- env(e1a, b = 10, c = 11)\ne1c <- env(e1b, a = 12, d = 13)\nwhere2(\"a\", e1c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> <environment: 0x108dee0e8>\n#> \n#> [[2]]\n#> <environment: 0x1280e57e8>\n```\n\n\n:::\n:::\n\n\n---\n\n2.  Write a function called `fget()` that finds only function objects. It \n    should have two arguments, `name` and `env`, and should obey the regular \n    scoping rules for functions: if there's an object with a matching name \n    that's not a function, look in the parent. For an added challenge, also \n    add an `inherits` argument which controls whether the function recurses up \n    the parents or only looks in one environment.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfget <- function(name, env = caller_env(), inherits = TRUE) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name) && is.function(env[[name]])) {\n    # Success case\n    env\n  } else if (inherits) {\n    # Recursive case\n    fget(name, env_parent(env))\n  } else {\n    stop(\"Can't find \", name, call. = FALSE)\n  }\n}\n\ntry(fget(\"x\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : Can't find x\n```\n\n\n:::\n\n```{.r .cell-code}\nfget(\"print\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: base>\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(fget(\"print\", inherits = FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : Can't find print\n```\n\n\n:::\n\n```{.r .cell-code}\nfget(\"all_where\", inherits = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: We follow a similar approach to the previous exercise. This time we additionally check if the found object is a function and implement an argument to turn off the recursion, if desired.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfget <- function(name, env = caller_env(), inherits = TRUE) {\n  # Base case\n  if (env_has(env, name)) {\n    obj <- env_get(env, name)\n    if (is.function(obj)) {\n      return(obj)\n    }\n  }\n  if (identical(env, emptyenv()) || !inherits) {\n    stop(\"Could not find a function called \\\"\", name, \"\\\".\",\n      call. = FALSE\n    )\n  }\n\n  # Recursive Case\n  fget(name, env_parent(env))\n}\n\n# Test\nmean <- 10\nfget(\"mean\", inherits = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x1058a2210>\n#> <environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n---\n\n## 7.4.5 Exercises\n\n1.  How is `search_envs()` different from `env_parents(global_env())`?\n\nAnswer: `search_envs()` includes the global environment. `env_parents(global_env())` doesn't include the global environment and also returns the empty environment (the top parent).\n\nAR Solutions: `search_envs()` returns all the environments on the search path, which is \"a chain of environments containing exported functions of attached packages\" (from `?search_envs`). Every time you attach a new package, this search path will grow. The search path ends with the base-environment. The global environment is included, because functions present in the global environment will always be part of the search path.\n\n`env_parents(global_env())` will list all the ancestors of the global environment, therefore the global environment itself is not included. This also includes the \"ultimate ancestor\", the empty environment. This environment is not considered part of the search path because it contains no objects.\n\n---\n\n2.  Draw a diagram that shows the enclosing environments of this function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)\n```\n:::\n\n\nAnswer: No.\n\n---\n\n3.  Write an enhanced version of `str()` that provides more information \n    about functions. Show where the function was found and what environment \n    it was defined in.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ne_str <- function(object, ...) {\n  str(object, ...)\n  if (is.function(object)) {\n    message(\"fn_env():\")\n    print(fn_env(object))\n    message(\"environment():\")\n    print(environment(object))\n  }\n}\n\ne_str(print)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> fn_env():\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: namespace:base>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> environment():\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\ne_str(fget)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (name, env = caller_env(), inherits = TRUE)  \n#>  - attr(*, \"srcref\")= 'srcref' int [1:8] 1 9 17 1 9 1 1 17\n#>   ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' <environment: 0x128fd90f0>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> fn_env():\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> environment():\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: To solve this problem, we need to write a function that takes the name of a function and looks for that function returning both the function and the environment that it was found in.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfget2 <- function(name, env = caller_env()) {\n  # Base case\n  if (env_has(env, name)) {\n    obj <- env_get(env, name)\n    if (is.function(obj)) {\n      return(list(fun = obj, env = env))\n    }\n  }\n  if (identical(env, emptyenv())) {\n    stop(\"Could not find a function called \\\"\", name, \"\\\"\",\n      call. = FALSE\n    )\n  }\n  # Recursive Case\n  fget2(name, env_parent(env))\n}\n\nfstr <- function(fun_name, env = caller_env()) {\n  if (!is.character(fun_name) && length(fun_name) == 1) {\n    stop(\"`fun_name` must be a string.\", call. = FALSE)\n  }\n  fun_env <- fget2(fun_name, env)\n  list(\n    where = fun_env$env,\n    enclosing = fn_env(fun_env$fun)\n  )\n}\n\n# Test\nfstr(\"mean\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $where\n#> <environment: base>\n#> \n#> $enclosing\n#> <environment: namespace:base>\n```\n\n\n:::\n:::\n\n\nOnce you have learned about tidy evaluation, you could rewrite `fstr()` to use `enquo()` so that you'd call it more like `str()`, i.e. `fstr(sum)`.\n\n---\n\n## 7.5.5 Exercises\n\n1.  Write a function that lists all the variables defined in the environment\n    in which it was called. It should return the same results as `ls()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_ls <- function() {\n  vars <- sort(names(parent.frame()))\n  vars[!startsWith(vars, \".\")]\n}\n\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"a\"            \"all_where\"    \"e_str\"        \"e_test\"       \"e1\"          \n#>  [6] \"e1a\"          \"e1b\"          \"e1c\"          \"e2\"           \"e3\"          \n#> [11] \"env_poke_new\" \"env_poke2\"    \"fget\"         \"fget2\"        \"fstr\"        \n#> [16] \"mean\"         \"my_ls\"        \"rebind\"       \"where\"        \"where2\"      \n#> [21] \"x\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_ls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"a\"            \"all_where\"    \"e_str\"        \"e_test\"       \"e1\"          \n#>  [6] \"e1a\"          \"e1b\"          \"e1c\"          \"e2\"           \"e3\"          \n#> [11] \"env_poke_new\" \"env_poke2\"    \"fget\"         \"fget2\"        \"fstr\"        \n#> [16] \"mean\"         \"my_ls\"        \"rebind\"       \"where\"        \"where2\"      \n#> [21] \"x\"\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: We can implement this dynamic scoping behaviour by explicitly referencing the caller environment. Please note that this approach returns also variables starting with a dot, an option that `ls()` usually requires.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nls2 <- function(env = caller_env()) {\n  sort(env_names(env))\n}\n\n# Test in global environment\nls(all.names = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \".main\"               \".QuartoInlineRender\" \".Random.seed\"       \n#>  [4] \"a\"                   \"all_where\"           \"e_str\"              \n#>  [7] \"e_test\"              \"e1\"                  \"e1a\"                \n#> [10] \"e1b\"                 \"e1c\"                 \"e2\"                 \n#> [13] \"e3\"                  \"env_poke_new\"        \"env_poke2\"          \n#> [16] \"fget\"                \"fget2\"               \"fstr\"               \n#> [19] \"ls2\"                 \"mean\"                \"my_ls\"              \n#> [22] \"rebind\"              \"where\"               \"where2\"             \n#> [25] \"x\"\n```\n\n\n:::\n\n```{.r .cell-code}\nls2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \".main\"               \".QuartoInlineRender\" \".Random.seed\"       \n#>  [4] \"a\"                   \"all_where\"           \"e_str\"              \n#>  [7] \"e_test\"              \"e1\"                  \"e1a\"                \n#> [10] \"e1b\"                 \"e1c\"                 \"e2\"                 \n#> [13] \"e3\"                  \"env_poke_new\"        \"env_poke2\"          \n#> [16] \"fget\"                \"fget2\"               \"fstr\"               \n#> [19] \"ls2\"                 \"mean\"                \"my_ls\"              \n#> [22] \"rebind\"              \"where\"               \"where2\"             \n#> [25] \"x\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Test in \"sandbox\" environment\ne1 <- env(a = 1, b = 2)\nls(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\" \"b\"\n```\n\n\n:::\n\n```{.r .cell-code}\nls2(e1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\" \"b\"\n```\n\n\n:::\n:::\n\n\n---\n\n# 8 Conditions\n\nThe __condition__ system provides a paired set of tools that allow the author of a function to indicate that something unusual is happening, and the user of that function to deal with it. The function author __signals__ conditions with functions like `stop()` (for errors), `warning()` (for warnings), and `message()` (for messages), then the function user can handle them with functions like `tryCatch()` and `withCallingHandlers()`. Understanding the condition system is important because you'll often need to play both roles: signalling conditions from the functions you create, and handle conditions signalled by the functions you call.\n\nR offers a very powerful condition system based on ideas from Common Lisp. Like R's approach to object-oriented programming, it is rather different to currently popular programming languages so it is easy to misunderstand, and there has been relatively little written about how to use it effectively. Historically, this has meant that few people (myself included) have taken full advantage of its power. The goal of this chapter is to remedy that situation. Here you will learn about the big ideas of R's condition system, as well as learning a bunch of practical tools that will make your code stronger.\n\nI found two resources particularly useful when writing this chapter. You may also want to read them if you want to learn more about the inspirations and motivations for the system:\n\n* [_A prototype of a condition system for R_](https://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html) by Robert Gentleman \n  and Luke Tierney. This describes an early version of R's condition system. \n  While the implementation has changed somewhat since this document was \n  written, it provides a good overview of how the pieces fit together, and \n  some motivation for its design.\n\n* [_Beyond exception handling: conditions and restarts_](https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html)\n  by Peter Seibel. This describes exception handling in Lisp, which happens \n  to be very similar to R's approach. It provides useful motivation and \n  more sophisticated examples. I have provided an R translation of the \n  chapter at <http://adv-r.had.co.nz/beyond-exception-handling.html>.\n\nI also found it helpful to work through the underlying C code that implements these ideas. If you're interested in understanding how it all works, you might find [my notes](https://gist.github.com/hadley/4278d0a6d3a10e42533d59905fbed0ac) to be useful.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n## 8.2.4 Exercises\n\n1.  Write a wrapper around `file.remove()` that throws an error if the file\n    to be deleted does not exist.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsafe_file_remove <- function(...) {\n  if (!file.exists(...)) stop(\"file '\", ..., \"' does not exist\")\n  file.remove(...)\n}\n\ntmp <- tempfile()\n\nfile.create(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nsafe_file_remove(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nfile.remove(tmp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning in file.remove(tmp): cannot remove file\n#> '/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//RtmpQlaAMH/file1716173023728',\n#> reason 'No such file or directory'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(safe_file_remove(tmp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in safe_file_remove(tmp) : \n#>   file '/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//RtmpQlaAMH/file1716173023728' does not exist\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: We prefer the following solution for its clarity and simplicity:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfile_remove_strict <- function(path) {\n  if (!file.exists(path)) {\n    stop(\"Can't delete the file \\\"\", path,\n      \"\\\" because it doesn't exist.\",\n      call. = FALSE\n    )\n  }\n  file.remove(path)\n}\n\n# Test\nsaveRDS(mtcars, \"mtcars.rds\")\nfile_remove_strict(\"mtcars.rds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(file_remove_strict(\"mtcars.rds\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : Can't delete the file \"mtcars.rds\" because it doesn't exist.\n```\n\n\n:::\n:::\n\n\n---\n\n2.  What does the `appendLF` argument to `message()` do? How is it related to\n    `cat()`?\n\nAnswer: `appendLF` controls whether or not a newline is added to the message; by default, `cat()` does not add a newline.\n\nAR Solutions: The `appendLF` argument automatically appends a new line to the message.\n\nComparable behaviour regarding line breaks for `cat()` can be achieved via setting its `sep` argument to `\"\\n\"`.\n\n---\n\n## 8.4.5 Exercises\n\n1.  What extra information does the condition generated by `abort()` contain\n    compared to the condition generated by `stop()` i.e. what's the difference\n    between these two objects? Read the help for `?abort` to learn more.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncatch_cnd(stop(\"An error\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <simpleError in force(expr): An error>\n```\n\n\n:::\n\n```{.r .cell-code}\ncatch_cnd(abort(\"An error\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <error/rlang_error>\n#> Error:\n#> ! An error\n#> ---\n#> Backtrace:\n#> ▆\n```\n\n\n:::\n:::\n\n\nAnswer: `abort()` includes the error message and backtrace in the condition object. `abort()` uses the custom class `rlang_error`.\n\nAR Solutions: In contrast to `stop()`, which contains the call, `abort()` stores the whole backtrace generated by `rlang::trace_back()`. This is a lot of extra data!\n\n---\n\n2.  Predict the results of evaluating the following code\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_condition <- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\")) #> \"error\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"error\"\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition(10) #> 10 [NULL]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition(warning(\"?!\")) #> \"warning\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"warning\"\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"message\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> 10\n#> \"message\"\n#> \"warning\"\n```\n:::\n\n\nAnswer: predictions in comments. The prediction for `show_condition(10)` was incorrect; the correct answer is `NULL` as that's what's returned when there is no condition. The final prediction was also incorrect; the `tryCatch()` call stops further execution when the `message()` is caught.\n\nAR Solutions: The first three examples are straightforward:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_condition(stop(\"!\")) # stop raises an error\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"error\"\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition(10) # no condition is signalled\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition(warning(\"?!\")) # warning raises a warning\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"warning\"\n```\n\n\n:::\n:::\n\n\nThe last example is the most interesting and makes us aware of the exiting qualities of `tryCatch()`; it will terminate the evaluation of the code as soon as it is called.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"message\"\n```\n\n\n:::\n:::\n\n\n---\n\n3.  Explain the results of running this code:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithCallingHandlers(\n  message = function(cnd) message(\"b\"), # handler 1\n  withCallingHandlers(\n    message = function(cnd) message(\"a\"), # handler 2\n    message(\"c\")\n  )\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> b\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> a\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> b\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> c\n```\n\n\n:::\n:::\n\n\nAnswer:\n\n1. `message(\"c\")` is caught, handler 2 is called\n1. in handler 2, `message(\"a\")` is caught and handler 1 is called\n1. handler 1 writes message `b`\n1. code resumes and handler 2 writes message `a`\n1. `message(\"c\")` propagates to the parent, is caught, and handler 1 is called\n1. handler 1 writes message `b`\n1. code resumes and the code writes message `c`\n\n\nAR Solutions: It's a little tricky to untangle the flow here:\nFirst, `message(\"c\")` is run, and it's caught by (1). It then calls `message(\"a\")`, which is caught by (2), which calls `message(\"b\")`. `message(\"b\")` isn't caught by anything, so we see a `b` on the console, followed by `a`. But why do we get another `b` before we see `c`? That's because we haven't handled the message, so it bubbles up to the outer calling handler.\n\n---\n\n4.  Read the source code for `catch_cnd()` and explain how it works.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncatch_cnd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (expr, classes = \"condition\") \n#> {\n#>     stopifnot(is_character(classes))\n#>     handlers <- rep_named(classes, list(identity))\n#>     eval_bare(rlang::expr(tryCatch(!!!handlers, {\n#>         force(expr)\n#>         return(NULL)\n#>     })))\n#> }\n#> <bytecode: 0x128e84120>\n#> <environment: namespace:rlang>\n```\n\n\n:::\n\n```{.r .cell-code}\ncatch_cnd(stop(\"error\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <simpleError in force(expr): error>\n```\n\n\n:::\n\n```{.r .cell-code}\n# replicate the core functionality\ntryCatch(condition = function(x) x, force(stop(\"error\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <simpleError in force(stop(\"error\")): error>\n```\n\n\n:::\n:::\n\n\nAnswer: `catch_cnd()` uses `tryCatch()` to catch any condition and return itself using `identity()`.\n\nAR Solutions: At the time *Advanced R* was written, the source for `catch_cnd()` was a little simpler:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncatch_cnd <- function(expr) {\n  tryCatch(\n    condition = function(cnd) cnd,\n    {\n      force(expr)\n      return(NULL)\n    }\n  )\n}\n```\n:::\n\n\n`catch_cnd()` is a simple wrapper around `tryCatch()`. If a condition is signalled, it's caught and returned. If no condition is signalled, execution proceeds sequentially and the function returns `NULL`.\n\nThe current version of `catch_cnd()` is a little more complex because it allows you to specify which classes of condition you want to capture. This requires some manual code generation because the interface of `tryCatch()` provides condition classes as argument names.\n\n---\n\n5.  How could you rewrite `show_condition()` to use a single handler?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_condition2 <- function(code) {\n  tryCatch(\n    condition = function(cnd) {\n      if (is_error(cnd)) {\n        return(\"error\")\n      }\n      if (is_warning(cnd)) {\n        return(\"warning\")\n      }\n      if (is_message(cnd)) {\n        return(\"message\")\n      }\n    },\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition2(stop(\"!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"error\"\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition2(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition2(warning(\"?!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"warning\"\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition2({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"message\"\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: `show_condition()` was defined in one of the previous questions. Let's use the `condition` argument of `tryCatch()` as shown in `rlang::catch_cond()` above for our re-implementation:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshow_condition2 <- function(code) {\n  tryCatch(\n    condition = function(cnd) {\n      if (inherits(cnd, \"error\")) {\n        return(\"error\")\n      }\n      if (inherits(cnd, \"warning\")) {\n        return(\"warning\")\n      }\n      if (inherits(cnd, \"message\")) {\n        return(\"message\")\n      }\n    },\n    {\n      code\n      NULL\n    }\n  )\n}\n\n# Test\nshow_condition2(stop(\"!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"error\"\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition2(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition2(warning(\"?!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"warning\"\n```\n\n\n:::\n\n```{.r .cell-code}\nshow_condition2({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"message\"\n```\n\n\n:::\n:::\n\n\n`tryCatch()` executes the code and captures any condition raised. The function provided as the `condition` handles this condition. In this case it dispatches on the class of the condition.\n\n---\n\n## 8.5.4 Exercises\n\n1.  Inside a package, it's occasionally useful to check that a package is \n    installed before using it. Write a function that checks if a package is \n    installed (with `requireNamespace(\"pkg\", quietly = FALSE))` and if not,\n    throws a custom condition that includes the package name in the metadata.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_check_installed <- function(pkg) {\n  if (!requireNamespace(pkg, quietly = TRUE)) {\n    abort(\n      \"error_not_found\",\n      message = paste0(\"package '\", pkg, \"' not found\"),\n      pkg = pkg\n    )\n  }\n}\n\nmy_check_installed(\"rlang\")\n# NOTE: this code causes renv::dependencies() to mistakenly report package 'pkg' as a dependency\n# requireNamespace(\"pkg\", quietly = FALSE)\n# err <- catch_cnd(my_check_installed(\"pkg\"))\n# err\n# err$pkg\ntry(my_check_installed(\"pkg\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in my_check_installed(\"pkg\") : package 'pkg' not found\n```\n\n\n:::\n:::\n\n\nAnswer: code above. The question specifies to use `quietly = FALSE`, but this approach makes more sense (to me). The alternative is to catch the 'Failed with error:' message which seems less reliable.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_check_installed2 <- function(pkg) {\n  tryCatch(\n    condition = function(cnd) {\n      abort(\n        \"error_not_found\",\n        message = paste0(\"package '\", pkg, \"' not found\"),\n        pkg = pkg\n      )\n    },\n    requireNamespace(pkg, quietly = FALSE)\n  )\n}\n\nmy_check_installed2(\"rlang\")\ntry(my_check_installed2(\"pkg\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in value[[3L]](cond) : package 'pkg' not found\n```\n\n\n:::\n:::\n\n\nThe alternative version, `my_check_installed2()` works but its Backtrace is harder to read.\n\nAR Solutions: We use `rlang::abort()` to supply error metadata:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncheck_installed <- function(package) {\n  if (!requireNamespace(package, quietly = FALSE)) {\n    abort(\n      \"error_pkg_not_found\",\n      message = paste0(\"package '\", package, \"' not installed.\"),\n      package = package\n    )\n  }\n  TRUE\n}\ncheck_installed(\"rlang\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(check_installed(\"ggplot3\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Loading required namespace: ggplot3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in check_installed(\"ggplot3\") : package 'ggplot3' not installed.\n```\n\n\n:::\n:::\n\n\n---\n\n2.  Inside a package you often need to stop with an error when something\n    is not right. Other packages that depend on your package might be\n    tempted to check these errors in their unit tests. How could you help\n    these packages to avoid relying on the error message which is part of\n    the user interface rather than the API and might change without notice?\n\nAnswer: return custom error objects that aren't dependent on the error text (like in 8.5.3)\n\nAR Solutions: Instead of returning an error it might be preferable to throw a customised condition and place a standardised error message inside the metadata. Then the downstream package could check for the class of the condition, rather than inspecting the message.\n\n---\n\n## 8.6.6 Exercises\n\n1.  Create `suppressConditions()` that works like `suppressMessages()` and \n    `suppressWarnings()` but suppresses everything. Think carefully about how you\n    should handle errors.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsuppressConditions <- function(expr) {\n  tryCatch(\n    error = function(cnd) invisible(cnd),\n    withCallingHandlers(\n      condition = function(cnd) {\n        cnd_muffle(cnd)\n      },\n      expr\n    )\n  )\n}\n\nsup <- suppressConditions({\n  message(\"processing...\")\n  warning(\"something went wrong\")\n  print(\"still running\")\n  stop(\"error\")\n  print(\"this shouldn't run\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"still running\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(sup)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> List of 2\n#>  $ message: chr \"error\"\n#>  $ call   : language withCallingHandlers(condition = function(cnd) {     cnd_muffle(cnd) ...\n#>  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n```\n\n\n:::\n:::\n\n\nAnswer: code above. Errors are not printed, but are returned, invisibly.\n\nAR Solutions: In general, we would like to catch errors, since they contain important information for debugging. To suppress the error message and hide the returned error object from the console, we handle errors within a `tryCatch()` and return the error object invisibly:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsuppressErrors <- function(expr) {\n  tryCatch(\n    error = function(cnd) invisible(cnd),\n    interrupt = function(cnd) {\n      stop(\"Terminated by the user.\",\n        call. = FALSE\n      )\n    },\n    expr\n  )\n}\n```\n:::\n\n\nAfter we defined the error handling, we can just combine it with the other handlers to create `suppressConditions()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsuppressConditions <- function(expr) {\n  suppressErrors(suppressWarnings(suppressMessages(expr)))\n}\n```\n:::\n\n\nTo test the new function, we apply it to a set of conditions and inspect the returned error object.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# The messages/warnings/conditions are suppressed successfully\nerror_obj <- suppressConditions({\n  message(\"message\")\n  warning(\"warning\")\n  abort(\"error\")\n})\nerror_obj\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <error/rlang_error>\n#> Error:\n#> ! error\n#> ---\n#> Backtrace:\n#> ▆\n```\n\n\n:::\n:::\n\n\n---\n\n2.  Compare the following two implementations of `message2error()`. What is the\n    main advantage of `withCallingHandlers()` in this scenario? (Hint: look\n    carefully at the traceback.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmessage2error <- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\n\nmessage2error2 <- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\n```\n:::\n\n\nAnswer: `message2error()` shows the invocation of `message()` in the traceback, but\n`message2error2()` does not.\n\nAR Solutions: Both functions differ in the way conditions are handled. `withCallingHandlers()` creates a *calling handler*, which is executed from within the signalling function. This makes it possible to record a detailed call stack, which helps us identify the signalling condition.\n\n`tryCatch()` defines an *exiting handler*, which means that the signalling function is terminated as soon as a condition is raised. It also returns control to the context where `tryCatch()` was called.\n\nIn this example the use of `withCallingHandlers()` returns more information than the use of `tryCatch()`. This allows us to determine the exact call that raised the condition.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmessage2error1 <- function(code) {\n  withCallingHandlers(code, message = function(e) stop(\"error\"))\n}\n\nmessage2error1({\n  1\n  message(\"hidden error\")\n  NULL\n})\n#> Error in (function (e) : error\ntraceback()\n#> 9: stop(\"error\") at #2\n#> 8: (function (e)\n#>    stop(\"error\"))(list(message = \"hidden error\\n\",\n#>      call = message(\"hidden error\")))\n#> 7: signalCondition(cond)\n#> 6: doWithOneRestart(return(expr), restart)\n#> 5: withOneRestart(expr, restarts[[1L]])\n#> 4: withRestarts({\n#>        signalCondition(cond)\n#>        defaultHandler(cond)\n#>    }, muffleMessage = function() NULL)\n#> 3: message(\"hidden error\") at #1\n#> 2: withCallingHandlers(code,\n#>      message = function(e) stop(\"error\")) at #2\n#> 1: message2error1({\n#>        1\n#>        message(\"hidden error\")\n#>        NULL\n#>    })\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmessage2error2 <- function(code) {\n  tryCatch(code, message = function(e) (stop(\"error\")))\n}\n\nmessage2error2({\n  1\n  stop(\"hidden error\")\n  NULL\n})\n#> Error in value[[3L]](cond) : error\ntraceback()\n#> 6: stop(\"error\") at #2\n#> 5: value[[3L]](cond)\n#> 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#> 3: tryCatchList(expr, classes, parentenv, handlers)\n#> 2: tryCatch(code, message = function(e) (stop(\"error\"))) at #2\n#> 1: message2error2({\n#>        1\n#>        message(\"hidden error\")\n#>        NULL\n#>    })\n```\n:::\n\n\n---\n\n3.  How would you modify the `catch_cnds()` definition if you wanted to recreate\n    the original intermingling of warnings and messages?\n\nAnswer: as noted in\n[Advanced R Solutions](https://advanced-r-solutions.rbind.io/conditions.html#applications-1),\n\"It looks like Hadley wrote a part of the chapter after the exercises, as the `catch_cnds()`\nfunction defined in the chapter already solves this problem by storing all messages and warnings in\ntheir original order within a list.\"\n\n---\n\n4.  Why is catching interrupts dangerous? Run this code to find out.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbottles_of_beer <- function(i = 99) {\n  message(\n    \"There are \", i, \" bottles of beer on the wall, \",\n    i, \" bottles of beer.\"\n  )\n  while (i > 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i <<- i - 1\n        if (i > 0) {\n          message(\n            \"Take one down, pass it around, \", i,\n            \" bottle\", if (i > 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \",\n    \"no more bottles of beer.\"\n  )\n}\n```\n:::\n\n\nAnswer: this prevents user interrupts (control-c) from halting the code, which in this case can be\npretty annoying if run with the defaults, requiring 99 interrupts (or just \"Restart R\").\n\nAR Solutions: When running the `bottles_of_beer()` function in your console, the output should look somehow like the following:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbottles_of_beer()\n#> There are 99 bottles of beer on the wall, 99 bottles of beer.\n#> Take one down, pass it around, 98 bottles of beer on the wall.\n#> Take one down, pass it around, 97 bottles of beer on the wall.\n#> Take one down, pass it around, 96 bottles of beer on the wall.\n#> Take one down, pass it around, 95 bottles of beer on the wall.\n#>\n```\n:::\n\n\nAt this point you'll probably recognise how hard it is to get the number of bottles down from `99` to `0`. There's no way to break out of the function because we're capturing the interrupt that you'd usually use!\n\n---\n",
    "supporting": [
      "advanced-r-1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}