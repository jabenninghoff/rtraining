{
  "hash": "3ae0b22a605f3dc1692575b51eac25ca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advanced R (Object-oriented programming)\"\nauthor: \"John Benninghoff\"\ndate: '2022-08-15'\ndate-modified: '2023-11-11'\ncategories: [exercises, advanced-r]\norder: 203\noutput:\n  html_notebook:\n    theme:\n      version: 5\n      preset: bootstrap\n    css: assets/extra.css\n    pandoc_args: --shift-heading-level-by=1\n    toc: yes\n    toc_float:\n      collapsed: yes\n      smooth_scroll: no\n---\n\n\n\n\nWorkbook for completing quizzes and exercises from the \"Object-oriented programming\" chapters of [Advanced R](https://adv-r.hadley.nz/index.html), second edition, with comparisons to solutions from [Advanced R Solutions](https://advanced-r-solutions.rbind.io).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sloop)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(R6)\nlibrary(methods)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)\n```\n:::\n\n\n\n\n# Introduction\n\nThis workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html) and [Advanced R Solutions](https://advanced-r-solutions.rbind.io), organized by chapter. It includes excerpts from both books, copied here.\n\n**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and exercises, don't read this notebook. It contains my (potentially wrong) answers to both.\n\n# 12 Base types\n\nTo talk about objects and OOP in R we first need to clear up a fundamental confusion about two uses of the word \"object\". So far in this book, we've used the word in the general sense captured by John Chambers' pithy quote: \"Everything that exists in R is an object\". However, while everything _is_ an object, not everything is object-oriented. This confusion arises because the base objects come from S, and were developed before anyone thought that S might need an OOP system. The tools and nomenclature evolved organically over many years without a single guiding principle.\n\nMost of the time, the distinction between objects and object-oriented objects is not important. But here we need to get into the nitty gritty details so we'll use the terms __base objects__ and __OO objects__ to distinguish them.\n\n# 13 S3\n\nS3 is R's first and simplest OO system. S3 is informal and ad hoc, but there is a certain elegance in its minimalism: you can't take away any part of it and still have a useful OO system. For these reasons, you should use it, unless you have a compelling reason to do otherwise. S3 is the only OO system used in the base and stats packages, and it's the most commonly used system in CRAN packages.\n\nS3 is very flexible, which means it allows you to do things that are quite ill-advised. If you're coming from a strict environment like Java this will seem pretty frightening, but it gives R programmers a tremendous amount of freedom.  It may be very difficult to prevent people from doing something you don't want them to do, but your users will never be held back because there is something you haven't implemented yet. Since S3 has few built-in constraints, the key to its successful use is applying the constraints yourself. This chapter will therefore teach you the conventions you should (almost) always follow.\n\nThe goal of this chapter is to show you how the S3 system works, not how to use it effectively to create new classes and generics. I'd recommend coupling the theoretical knowledge from this chapter with the practical knowledge encoded in the [vctrs package](https://vctrs.r-lib.org).\n\n## 13.2.1 Exercises\n\n1.  Describe the difference between `t.test()` and `t.data.frame()`.\n    When is each function called?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nftype(t.test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"S3\"      \"generic\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(t.data.frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"S3\"     \"method\"\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_dispatch(t.test(formula()))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> => t.test.formula\n#>  * t.test.default\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_dispatch(t(data.frame()))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> => t.data.frame\n#> -> t.default\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: As noted by `sloop::ftype()` and the docs, `t.test()` is a S3 generic, and `t.data.frame()` is an S3 method for `t()` (transpose). `t.data.frame()` is called as a method when calling `t(x)` when `x` is a `data.frame`. `t.test()` calls either `t.test.default` or `t.test.formula`.\n\nAR Solutions: Because of S3's `generic.class()` naming scheme, both functions may initially look similar, while they are in fact unrelated.\n\n- `t.test()` is a *generic* function that performs a t-test. \n- `t.data.frame()` is a *method* that gets called by the generic `t()` to transpose data frame input.\n\nDue to R's S3 dispatch rules, `t.test()` would also get called when `t()` is applied to an object of class `test`\n\n---\n\n2.  Make a list of commonly used base R functions that contain `.` in their\n    name but are not S3 methods.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nftype(as.character)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"primitive\" \"generic\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(as.data.frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"S3\"      \"generic\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(data.frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(eval.parent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(file.path)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"internal\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(file.copy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"internal\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(is.null)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"primitive\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(is.data.frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(Sys.localeconv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"internal\"\n```\n\n\n:::\n\n```{.r .cell-code}\nftype(Sys.time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"internal\"\n```\n\n\n:::\n:::\n\n\n\n\nAnswer:\n\n- All of the `as.` functions\n- `data.frame`\n- All of the `file.` functions\n- All of the `is.` functions\n- All of the `Sys.` functions\n\nAR Solutions: In recent years \"snake_case\"-style has become increasingly common when naming functions and variables in R. But many functions in base R will continue to be \"point.separated\", which is why some inconsistency in your R code most likely cannot be avoided. (`install.packages(), read.csv(), list.files(), download.file(), data.frame(), as.character(), Sys.Date(), all.equal(), do.call(), on.exit()`)\n\n---\n\n3.  What does the `as.data.frame.data.frame()` method do? Why is\n    it confusing? How could you avoid this confusion in your own\n    code?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(as.data.frame(data.frame()))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> => as.data.frame.data.frame\n#>  * as.data.frame.default\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: `as.data.frame.data.frame()` is the method used to coerce a `data.frame` to a `data.frame`. This is confusing because the class contains a period (as does the function call); avoiding periods improves readability: `as_dataframe.dataframe` makes the generic and method clear.\n\nAR Solutions: The function `as.data.frame.data.frame()` implements the `data.frame()` *method* for the `as.data.frame()` *generic*, which coerces objects to data frames.\n\nThe name is confusing, because it does not clearly communicate the type of the function, which could be a regular function, a generic or a method. Even if we assume a method, the amount of `.`'s makes it difficult to separate the generic- and the class-part of the name. Is it the `data.frame.data.frame()` method for the `as()` generic? Is it the `frame.data.frame()` method for the `as.data()` generic?\n\nWe could avoid this confusion by applying a different naming convention (e.g. \"snake_case\") for our class and function names.\n\n---\n\n4.  Describe the difference in behaviour in these two calls.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1014)\nsome_days <- as.Date(\"2017-01-31\") + sample(10, 5)\nmean(some_days)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2017-02-06\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(unclass(some_days))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 17203.4\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_dispatch(mean(some_days))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> => mean.Date\n#>  * mean.default\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_dispatch(mean(unclass(some_days)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    mean.double\n#>    mean.numeric\n#> => mean.default\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: the first call calculates the mean using `mean.Date()`, and so returns a date. using `unclass()` changes the date to its underlying value (double) which calculates the mean using `mean.default()`.\n\nAR Solutions: `mean()` is a generic function, which will select the appropriate method based on the class of the input. `some_days` has the class `Date` and `mean.Date(some_days)` will be used to calculate the mean date of `some_days`.\n\nAfter `unclass()` has removed the class attribute from `some_date`, the default method is chosen. `mean.default(unclass(some_days))` then calculates the mean of the underlying double.\n\n---\n\n5.  What class of object does the following code return? What base type is it \n    built on? What attributes does it use?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- ecdf(rpois(100, 10))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Empirical CDF \n#> Call: ecdf(rpois(100, 10))\n#>  x[1:18] =      2,      3,      4,  ...,     18,     19\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (v)  \n#>  - attr(*, \"class\")= chr [1:3] \"ecdf\" \"stepfun\" \"function\"\n#>  - attr(*, \"call\")= language ecdf(rpois(100, 10))\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: the code returns an object of class `ecdf`, which is build on the `stepfun` object, and the `function` base type. It additionally includes the `call` attribute.\n\nAR Solutions: It returns an object of the class `ecdf` (empirical cumulative distribution function) with the superclasses `stepfun` and `function`. The `ecdf` object is built on the base type `closure` (a function). The expression, which was used to create it (`rpois(100, 10)`), is stored in the `call` attribute.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"closure\"\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n6.  What class of object does the following code return? What base type is it \n    built on? What attributes does it use?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- table(rpois(100, 5))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#>  1  2  3  4  5  6  7  8  9 10 \n#>  7  5 18 14 15 15 14  4  5  3\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  'table' int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3\n#>  - attr(*, \"dimnames\")=List of 1\n#>   ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(unclass(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3\n#>  - attr(*, \"dimnames\")=List of 1\n#>   ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: per the docs, the code returns an object of class `table`, which is built on `array`, which uses the `dimnames` attribute in combination with a vector.\n\nAR Solutions: This code returns a `table` object, which is built upon the `integer` type. The attribute `dimnames` is used to name the elements of the integer vector.\n\n---\n\n## 13.3.4 Exercises\n\n1.  Write a constructor for `data.frame` objects. What base type is a data\n    frame built on? What attributes does it use? What are the restrictions\n    placed on the individual elements? What about the names?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndput(data.frame())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> structure(list(), names = character(0), row.names = integer(0), class = \"data.frame\")\n```\n\n\n:::\n\n```{.r .cell-code}\ndput(data.frame(a = 1:2, b = 3:4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> structure(list(a = 1:2, b = 3:4), class = \"data.frame\", row.names = c(NA, \n#> -2L))\n```\n\n\n:::\n\n```{.r .cell-code}\nunclass(data.frame(a = 1:2, b = 3:4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $a\n#> [1] 1 2\n#> \n#> $b\n#> [1] 3 4\n#> \n#> attr(,\"row.names\")\n#> [1] 1 2\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: code below. The data frame is built on the list base type, and includes the names, row.names, and class attributes. This implementation requires values to be a list, names to be a character, and row.names to be an integer.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_data.frame <- function(values = list(),\n                           names = character(length(values)),\n                           row.names = integer(length(values))) {\n  stopifnot(\n    is.list(values),\n    is.character(names),\n    is.integer(row.names)\n  )\n  structure(values, names = names, row.names = row.names, class = \"data.frame\")\n}\n\nnew_data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> data frame with 0 columns and 0 rows\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_data.frame(list(1:3, 4:6, 7:9))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>        \n#> 0 1 4 7\n#> 0 2 5 8\n#> 0 3 6 9\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_data.frame(list(1:3, 4:6, 7:9), names = c(\"a\", \"b\", \"c\"), row.names = 1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   a b c\n#> 1 1 4 7\n#> 2 2 5 8\n#> 3 3 6 9\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: Data frames are built on named lists of vectors, which all have the same length. Besides the `class` and the column names (`names`), the `row.names` are their only further attribute. This must be a character vector with the same length as the other vectors.\n\nWe need to provide the number of rows as an input to make it possible to create data frames with 0 columns but multiple rows.\n\nThis leads to the following constructor:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_data.frame <- function(x, n, row.names = NULL) {\n  # Check if the underlying object is a list\n  stopifnot(is.list(x))\n\n  # Check all inputs are the same length\n  # (This check also allows that x has length 0)\n  stopifnot(all(lengths(x) == n)) # nolint: stopifnot_all_linter.\n\n  if (is.null(row.names)) {\n    # Use special row names helper from base R\n    row.names <- .set_row_names(n)\n  } else {\n    # Otherwise check that they're a character vector with the\n    # correct length\n    stopifnot(is.character(row.names), length(row.names) == n)\n  }\n\n  structure(\n    x,\n    class = \"data.frame\",\n    row.names = row.names\n  )\n}\n\n# Test\nx <- list(a = 1, b = 2)\nnew_data.frame(x, n = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   a b\n#> 1 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_data.frame(x, n = 1, row.names = \"l1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    a b\n#> l1 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a data frame with 0 columns and 2 rows\nnew_data.frame(list(), n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> data frame with 0 columns and 2 rows\n```\n\n\n:::\n:::\n\n\n\n\nNote: AR Solutions approach also validates that all inputs are same length, and supports creation of dataframes with 0 columns but multiple rows.\n\n---\n\n2.  Enhance my `factor()` helper to have better behaviour when one or\n    more `values` is not found in `levels`. What does `base::factor()` do\n    in this situation?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_factor <- function(x = integer(), levels = character()) {\n  stopifnot(\n    is.integer(x),\n    is.character(levels)\n  )\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n```\n:::\n\n\n\n\nAnswer: the fix is to update `validate_factor()` to allow `NA` values, since the helper already fills in `NA` when `values` is not found in `levels`. This matches the behavior of `base::factor()`. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvalidate_factor <- function(x) {\n  values <- unclass(x)\n  levels <- attr(x, \"levels\")\n\n  if (!all(is.na(values) | values > 0)) {\n    stop(\n      \"All non-missing `x` values must be greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) < max(values, na.rm = TRUE)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nmy_factor <- function(x = character(), levels = unique(x)) {\n  ind <- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nfactor(c(\"a\", \"a\", \"b\"), levels = \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] a    a    <NA>\n#> Levels: a\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_factor(c(\"a\", \"a\", \"b\"), levels = \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] a    a    <NA>\n#> Levels: a\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: `base::factor()` converts these values (silently) into `NA`s.\n\nThe `factor()` helper including the constructor (`new_factor()`) and its validator (`validate_factor()`) were given in *Advanced R*. However, as the goal of this question is to throw an early error within the helper, we only repeat the code for the helper:\n\nTo improve the `factor()` helper we choose to return an informative error message instead.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfactor2 <- function(x, levels = unique(x)) {\n  new_levels <- match(x, levels)\n\n  # Error if levels don't include all values\n  missing <- unique(setdiff(x, levels))\n  if (length(missing) > 0) {\n    stop(\n      \"The following values do not occur in the levels of x: \",\n      paste0(\"'\", missing, \"'\", collapse = \", \"), \".\",\n      call. = FALSE\n    )\n  }\n\n  validate_factor(new_factor(new_levels, levels))\n}\n\n# Test\ntry(factor2(c(\"a\", \"b\", \"c\"), levels = c(\"a\", \"b\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : The following values do not occur in the levels of x: 'c'.\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n3.  Carefully read the source code of `factor()`. What does it do that\n    my constructor does not?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfactor(c(\"a\", \"a\", \"b\", \"c\"), labels = c(\"alpha\", \"beta\", \"beta\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] alpha alpha beta  beta \n#> Levels: alpha beta\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(factor(1:10, ordered = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"ordered\" \"factor\"\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: the base implementation:\n\n- sets the value to `character(0)` if the value is null\n- retains value names\n- allows an upper bound on the number of levels, `nmax`\n- coerces the value to character\n- provides a method for excluding values from levels, `exclude`\n- provides `labels` for remapping factors\n- adds an \"ordered\" class if the value is ordered (`ordered = TRUE`)\n\nNote: labels are an interesting and unexpected feature of `factor()`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfactor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x = character(), levels, labels = levels, exclude = NA, \n#>     ordered = is.ordered(x), nmax = NA) \n#> {\n#>     if (is.null(x)) \n#>         x <- character()\n#>     nx <- names(x)\n#>     matchAsChar <- is.object(x) || !(is.character(x) || is.integer(x) || \n#>         is.logical(x))\n#>     if (missing(levels)) {\n#>         y <- unique(x, nmax = nmax)\n#>         ind <- order(y)\n#>         if (matchAsChar) \n#>             y <- as.character(y)\n#>         levels <- unique(y[ind])\n#>     }\n#>     force(ordered)\n#>     if (matchAsChar) \n#>         x <- as.character(x)\n#>     levels <- levels[is.na(match(levels, exclude))]\n#>     f <- match(x, levels)\n#>     if (!is.null(nx)) \n#>         names(f) <- nx\n#>     if (missing(labels)) {\n#>         levels(f) <- as.character(levels)\n#>     }\n#>     else {\n#>         nlab <- length(labels)\n#>         if (nlab == length(levels)) {\n#>             nlevs <- unique(xlevs <- as.character(labels))\n#>             at <- attributes(f)\n#>             at$levels <- nlevs\n#>             f <- match(xlevs, nlevs)[f]\n#>             attributes(f) <- at\n#>         }\n#>         else if (nlab == 1L) \n#>             levels(f) <- paste0(labels, seq_along(levels))\n#>         else stop(gettextf(\"invalid 'labels'; length %d should be 1 or %d\", \n#>             nlab, length(levels)), domain = NA)\n#>     }\n#>     class(f) <- c(if (ordered) \"ordered\", \"factor\")\n#>     f\n#> }\n#> <bytecode: 0x1460faa08>\n#> <environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: The original implementation (`base::factor()`) allows more flexible input for `x`. It coerces `x` to character or replaces it with `character(0)` (in case of `NULL`). It also ensures that the `levels` are unique. This is achieved by setting them via `base::levels<-`, which fails when duplicate values are supplied.\n\nNote: I missed the fact that `base::levels<-` fails when duplicate values are supplied.\n\n---\n    \n4.  Factors have an optional \"contrasts\" attribute. Read the help for `C()`, \n    and briefly describe the purpose of the attribute. What type should it \n    have? Rewrite the `new_factor()` constructor to include this attribute.\n\nAnswer: per the \"contrast {stats}\" documentation, contrast matrices are used in fitting analysis of variance and regression models, so the attribute should be a matrix.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_factor <- function(x = integer(), levels = character(), contr = matrix()) {\n  stopifnot(is.integer(x), is.character(levels), is.matrix(contr))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contr\n  )\n}\n```\n:::\n\n\n\n\nAR Solutions: When factor variables (representing nominal or ordinal information) are used in statistical models, they are typically encoded as dummy variables and by default each level is compared with the first factor level. However, many different encodings (\"contrasts\") are possible, see [Contrast](https://en.wikipedia.org/wiki/Contrast_(statistics)).\n\nWithin R's formula interface you can wrap a factor in `stats::C()` and specify the contrast of your choice. Alternatively, you can set the `contrasts` attribute of your factor variable, which accepts matrix input. (See `?contr.helmert` or similar for details.)\n\nOur updated `new_factor()` constructor gets a `contrasts` argument, which accepts a numeric matrix or `NULL` (default).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Updated new_factor() constructor\nnew_factor <- function(x = integer(),\n                       levels = character(),\n                       contrasts = NULL) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  if (!is.null(constrasts)) {\n    stopifnot(is.matrix(contrasts) && is.numeric(contrasts)) # nolint: conjunct_test_linter.\n  }\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contrasts\n  )\n}\n```\n:::\n\n\n\n\n---\n\n5.  Read the documentation for `utils::as.roman()`. How would you write a\n    constructor for this class? Does it need a validator? What might a helper \n    do?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndput(as.roman(3899))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> structure(3899L, class = \"roman\")\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_roman <- function(x = integer()) {\n  stopifnot(is.integer(x))\n\n  structure(\n    x,\n    class = \"roman\"\n  )\n}\n\nnew_roman(2022L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] MMXXII\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: the structure of the class \"roman\" is simple, an integer with a defined class. A simple constructor would take an integer and return an object of class \"roman\" as above. A validator is probably not needed, but could validate that the integer is within the supported range of integers (1-3899). A helper might coerce the number to be an integer using `as.integer()`.\n\nAR Solutions: This function transforms numeric input into Roman numbers. It is built on the integer type, which results in the following constructor.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_roman <- function(x = integer()) {\n  stopifnot(is.integer(x))\n  structure(x, class = \"roman\")\n}\n```\n:::\n\n\n\n\nThe documentation tells us, that only values between 1 and 3899 are uniquely represented, which we then include in our validation function.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvalidate_roman <- function(x) {\n  values <- unclass(x)\n\n  if (any(values < 1 | values > 3899)) {\n    stop(\n      \"Roman numbers must fall between 1 and 3899.\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n```\n:::\n\n\n\n\nFor convenience, we allow the user to also pass real values to a helper function.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nroman <- function(x = integer()) {\n  x <- as.integer(x)\n\n  validate_roman(new_roman(x))\n}\n\n# Test\nroman(c(1, 753, 2019))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] I       DCCLIII MMXIX\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(roman(0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : Roman numbers must fall between 1 and 3899.\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n## 13.4.4 Exercises\n\n1.  Read the source code for `t()` and `t.test()` and confirm that\n    `t.test()` is an S3 generic and not an S3 method. What happens if\n    you create an object with class `test` and call `t()` with it? Why?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- structure(1:10, class = \"test\")\nt(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]    1    2    3    4    5    6    7    8    9    10\n#> attr(,\"class\")\n#> [1] \"test\"\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: both `t()` and `t.test()` simply call `UseMethod()`, and are S3 generics.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x) \n#> UseMethod(\"t\")\n#> <bytecode: 0x125fd7608>\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\nt.test\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> UseMethod(\"t.test\")\n#> <bytecode: 0x1103511a0>\n#> <environment: namespace:stats>\n```\n\n\n:::\n:::\n\n\n\n\nCreating an object with class `test` and calling `t()` uses the default method since `t.test()` is not a registered method for `t()`, as this code shows:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmethods(\"t\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] t.data.frame  t.default     t.ts*         t.vctrs_sclr* t.vctrs_vctr*\n#> see '?methods' for accessing help and source code\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_dispatch(t(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    t.test\n#> => t.default\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: We can see that `t.test()` is a generic because it calls `UseMethod()`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# or simply call\nftype(t.test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"S3\"      \"generic\"\n```\n\n\n:::\n:::\n\n\n\n\nInterestingly, R also provides helpers, which list functions that look like methods, but in fact are not:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntools::nonS3methods(\"stats\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"anova.lmlist\"        \"expand.model.frame\"  \"fitted.values\"      \n#> [4] \"influence.measures\"  \"lag.plot\"            \"qr.influence\"       \n#> [7] \"t.test\"              \"plot.spec.phase\"     \"plot.spec.coherency\"\n```\n\n\n:::\n:::\n\n\n\n\nWhen we create an object with class `test`, `t()` dispatches to the `t.default()` method. This happens, because `UseMethod()` simply searches for functions named `paste0(\"generic\", \".\", c(class(x), \"default\"))`.\n\nHowever, in older versions of R (pre R 4.0.0; when *Advanced R* was written) this behaviour was slightly different. Instead of dispatching to the `t.default()` method, the `t.test()` generic was erroneously treated as a method of `t()` which then dispatched to `t.test.default()` or (when defined) to `t.test.test()`.\n\n---\n\n2.  What generics does the `table` class have methods for?\n\nAnswer: `s3_methods_class()` answers this question:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_methods_class(\"table\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 11 × 4\n#>    generic       class visible source             \n#>    <chr>         <chr> <lgl>   <chr>              \n#>  1 [             table TRUE    base               \n#>  2 aperm         table TRUE    base               \n#>  3 as_tibble     table FALSE   registered S3method\n#>  4 as.data.frame table TRUE    base               \n#>  5 Axis          table FALSE   registered S3method\n#>  6 lines         table FALSE   registered S3method\n#>  7 plot          table FALSE   registered S3method\n#>  8 points        table FALSE   registered S3method\n#>  9 print         table TRUE    base               \n#> 10 summary       table TRUE    base               \n#> 11 tail          table FALSE   registered S3method\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: This is a simple application of `sloop::s3_methods_class()`.\n\nInterestingly, the `table` class has a number of methods designed to help plotting with base graphics.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- rpois(100, 5)\nplot(table(x))\n```\n\n::: {.cell-output-display}\n![](advanced-r-3_files/figure-html/unnamed-chunk-28-1.png){fig-align='center' width=816}\n:::\n:::\n\n\n\n\n---\n\n3.  What generics does the `ecdf` class have methods for?\n\nAnswer:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_methods_class(\"ecdf\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 4 × 4\n#>   generic  class visible source             \n#>   <chr>    <chr> <lgl>   <chr>              \n#> 1 plot     ecdf  TRUE    stats              \n#> 2 print    ecdf  FALSE   registered S3method\n#> 3 quantile ecdf  FALSE   registered S3method\n#> 4 summary  ecdf  FALSE   registered S3method\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: We use the same approach as above.\n\nThe methods are primarily designed for display (`plot()`, `print()`, `summary()`), but you can also extract quantiles with `quantile()`.\n\n---\n\n4.  Which base generic has the greatest number of defined methods?\n\nAnswer: using code from 6.2.5, identify generics and count defined methods:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# from 6.2.5 exercises, this code makes a list of all functions in the base package\nfuns <- Filter(is.function, mget(ls(\"package:base\", all.names = TRUE), inherits = TRUE))\n\nget_method_count <- function(fname) {\n  data.frame(\n    name = fname,\n    # this code should work but doesn't:\n    # method_count = nrow(s3_methods_generic(fname))\n    method_count = length(methods(fname))\n  )\n}\n\nmap_dfr(names(funs), get_method_count) |>\n  arrange(desc(method_count))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                                    name method_count\n#> 1                                 print          280\n#> 2                                format          126\n#> 3                                     [           50\n#> 4                               summary           40\n#> 5                         as.data.frame           33\n#> 6                          as.character           32\n#> 7                                  plot           31\n#> 8                                    [[           22\n#> 9                                   [<-           20\n#> 10                                  $<-           18\n#> 11                                 [[<-           17\n#> 12                                    $           17\n#> 13                                 file           17\n#> 14                              as.list           15\n#> 15                                    c           15\n#> 16                            all.equal           12\n#> 17                                  rep           11\n#> 18                               unique           11\n#> 19                                xtfrm           11\n#> 20                           duplicated            9\n#> 21                              as.Date            8\n#> 22                            as.matrix            8\n#> 23                           as.POSIXlt            7\n#> 24                             length<-            7\n#> 25                                 mean            7\n#> 26                              names<-            7\n#> 27                                  row            7\n#> 28                        anyDuplicated            6\n#> 29                           as.POSIXct            6\n#> 30                                 diff            6\n#> 31                               length            6\n#> 32                                write            6\n#> 33                                anyNA            5\n#> 34                     conditionMessage            5\n#> 35                                is.na            5\n#> 36                              is.na<-            5\n#> 37                               labels            5\n#> 38                                names            5\n#> 39                                    t            5\n#> 40                                    -            4\n#> 41                                    +            4\n#> 42                            as.double            4\n#> 43                            as.vector            4\n#> 44                                close            4\n#> 45                                  cut            4\n#> 46                                 open            4\n#> 47                                range            4\n#> 48                                split            4\n#> 49                               subset            4\n#> 50                                    !            3\n#> 51                                    &            3\n#> 52                                    |            3\n#> 53                           as.logical            3\n#> 54                                cbind            3\n#> 55                           dimnames<-            3\n#> 56                           is.numeric            3\n#> 57                                kappa            3\n#> 58                               levels            3\n#> 59                             levels<-            3\n#> 60                                   ls            3\n#> 61                                match            3\n#> 62                                merge            3\n#> 63                                mtfrm            3\n#> 64                               pretty            3\n#> 65                          row.names<-            3\n#> 66                                  seq            3\n#> 67                                 sort            3\n#> 68                            transform            3\n#> 69                                    *            2\n#> 70                                    /            2\n#> 71                                aperm            2\n#> 72                           as.integer            2\n#> 73                             as.table            2\n#> 74                               body<-            2\n#> 75                                   by            2\n#> 76                                dim<-            2\n#> 77                             dimnames            2\n#> 78                                  dir            2\n#> 79                                 drop            2\n#> 80                           droplevels            2\n#> 81             getDLLRegisteredRoutines            2\n#> 82                            intersect            2\n#> 83                            is.finite            2\n#> 84                          is.infinite            2\n#> 85                               is.nan            2\n#> 86                               julian            2\n#> 87                              library            2\n#> 88                                 list            2\n#> 89                                  max            2\n#> 90                                  min            2\n#> 91                               months            2\n#> 92                                   qr            2\n#> 93                             quarters            2\n#> 94                                rbind            2\n#> 95                                  rev            2\n#> 96                                round            2\n#> 97                            row.names            2\n#> 98                               rowsum            2\n#> 99                              setdiff            2\n#> 100                            setequal            2\n#> 101                               solve            2\n#> 102                             sort_by            2\n#> 103                             split<-            2\n#> 104                              system            2\n#> 105                               trunc            2\n#> 106                               union            2\n#> 107                              unlist            2\n#> 108                            weekdays            2\n#> 109                               which            2\n#> 110                              within            2\n#> 111                                  !=            1\n#> 112                                 %/%            1\n#> 113                                  %%            1\n#> 114                                   ^            1\n#> 115                                   <            1\n#> 116                                  <=            1\n#> 117                                  ==            1\n#> 118                                   >            1\n#> 119                                  >=            1\n#> 120                            as.array            1\n#> 121                      as.environment            1\n#> 122                       as.expression            1\n#> 123                         as.function            1\n#> 124                             as.null            1\n#> 125                           as.single            1\n#> 126                                attr            1\n#> 127                                chol            1\n#> 128                     chooseOpsMethod            1\n#> 129                       conditionCall            1\n#> 130                         determinant            1\n#> 131                                 dim            1\n#> 132                                dump            1\n#> 133                                eval            1\n#> 134                              factor            1\n#> 135                               flush            1\n#> 136                                  gc            1\n#> 137                         interaction            1\n#> 138                         isSymmetric            1\n#> 139                           kronecker            1\n#> 140                             lengths            1\n#> 141                       library.dynam            1\n#> 142                         nameOfClass            1\n#> 143                               order            1\n#> 144                                pmax            1\n#> 145                                pmin            1\n#> 146                              remove            1\n#> 147                              sample            1\n#> 148                                save            1\n#> 149                               scale            1\n#> 150                                seek            1\n#> 151                            sequence            1\n#> 152                                sink            1\n#> 153                                 sum            1\n#> 154                            toString            1\n#> 155                            truncate            1\n#> 156                               units            1\n#> 157                             units<-            1\n#> 158                                 url            1\n#> 159                                with            1\n#> 160                              -.Date            0\n#> 161                            -.POSIXt            0\n#> 162                                   :            0\n#> 163                                  ::            0\n#> 164                                 :::            0\n#> 165                           !.hexmode            0\n#> 166                           !.octmode            0\n#> 167                        .__H__.cbind            0\n#> 168                        .__H__.rbind            0\n#> 169                              ...elt            0\n#> 170                           ...length            0\n#> 171                            ...names            0\n#> 172                      ..getNamespace            0\n#> 173                      .amatch_bounds            0\n#> 174                       .amatch_costs            0\n#> 175                            .bincode            0\n#> 176                                  .C            0\n#> 177                        .cache_class            0\n#> 178                               .Call            0\n#> 179                      .Call.graphics            0\n#> 180                       .check_tzones            0\n#> 181                             .class2            0\n#> 182                                .col            0\n#> 183                           .colMeans            0\n#> 184                            .colSums            0\n#> 185                               .Date            0\n#> 186             .decode_numeric_version            0\n#> 187                            .Defunct            0\n#> 188                        .deparseOpts            0\n#> 189                         .Deprecated            0\n#> 190                             .detach            0\n#> 191                           .difftime            0\n#> 192                         .doSortWrap            0\n#> 193                            .doTrace            0\n#> 194                             .doWrap            0\n#> 195                            .dynLibs            0\n#> 196             .encode_numeric_version            0\n#> 197              .expand_R_libs_env_var            0\n#> 198                           .External            0\n#> 199                  .External.graphics            0\n#> 200                          .External2            0\n#> 201                          .First.sys            0\n#> 202                       .format.zeros            0\n#> 203                    .formula2varlist            0\n#> 204                            .Fortran            0\n#> 205                       .getNamespace            0\n#> 206                   .getNamespaceInfo            0\n#> 207                .getRequiredPackages            0\n#> 208               .getRequiredPackages2            0\n#> 209                                 .gt            0\n#> 210                                .gtn            0\n#> 211                  .handleSimpleError            0\n#> 212                           .Internal            0\n#> 213                .isMethodsDispatchOn            0\n#> 214                             .isOpen            0\n#> 215                          .kappa_tri            0\n#> 216                          .kronecker            0\n#> 217                           .libPaths            0\n#> 218               .make_numeric_version            0\n#> 219                        .makeMessage            0\n#> 220                             .mapply            0\n#> 221                          .maskedMsg            0\n#> 222                 .mergeExportMethods            0\n#> 223                 .mergeImportMethods            0\n#> 224                  .NotYetImplemented            0\n#> 225                         .NotYetUsed            0\n#> 226                  .OptRequireMethods            0\n#> 227                           .packages            0\n#> 228              .packageStartupMessage            0\n#> 229                            .POSIXct            0\n#> 230                            .POSIXlt            0\n#> 231                             .pretty            0\n#> 232                          .Primitive            0\n#> 233                          .primTrace            0\n#> 234                        .primUntrace            0\n#> 235                           .rangeNum            0\n#> 236                              .rmpkg            0\n#> 237                                .row            0\n#> 238                     .row_names_info            0\n#> 239                           .rowMeans            0\n#> 240                       .rowNamesDF<-            0\n#> 241                            .rowSums            0\n#> 242                           .S3method            0\n#> 243                             .Script            0\n#> 244             .set_ops_need_as_vector            0\n#> 245                      .set_row_names            0\n#> 246                .signalSimpleWarning            0\n#> 247                   .standard_regexps            0\n#> 248                             .subset            0\n#> 249                            .subset2            0\n#> 250                      .TAOCP1997init            0\n#> 251                          .traceback            0\n#> 252                 .tryResumeInterrupt            0\n#> 253                       .valid.factor            0\n#> 254                                   (            0\n#> 255                              [.AsIs            0\n#> 256                        [.data.frame            0\n#> 257                              [.Date            0\n#> 258                          [.difftime            0\n#> 259                             [.Dlist            0\n#> 260                       [.DLLInfoList            0\n#> 261                            [.factor            0\n#> 262                           [.hexmode            0\n#> 263                            [.listof            0\n#> 264                           [.noquote            0\n#> 265                   [.numeric_version            0\n#> 266                           [.octmode            0\n#> 267                           [.POSIXct            0\n#> 268                           [.POSIXlt            0\n#> 269                       [.simple.list            0\n#> 270                             [.table            0\n#> 271                          [.warnings            0\n#> 272                       [[.data.frame            0\n#> 273                             [[.Date            0\n#> 274                           [[.factor            0\n#> 275                  [[.numeric_version            0\n#> 276                          [[.POSIXct            0\n#> 277                          [[.POSIXlt            0\n#> 278                     [[<-.data.frame            0\n#> 279                         [[<-.factor            0\n#> 280                [[<-.numeric_version            0\n#> 281                        [[<-.POSIXlt            0\n#> 282                      [<-.data.frame            0\n#> 283                            [<-.Date            0\n#> 284                        [<-.difftime            0\n#> 285                          [<-.factor            0\n#> 286                 [<-.numeric_version            0\n#> 287                         [<-.POSIXct            0\n#> 288                         [<-.POSIXlt            0\n#> 289                                   {            0\n#> 290                                   @            0\n#> 291                                 @<-            0\n#> 292                          *.difftime            0\n#> 293                          /.difftime            0\n#> 294                           &.hexmode            0\n#> 295                           &.octmode            0\n#> 296                                  &&            0\n#> 297                                 %*%            0\n#> 298                                %||%            0\n#> 299                                %in%            0\n#> 300                                 %o%            0\n#> 301                                 %x%            0\n#> 302                              +.Date            0\n#> 303                            +.POSIXt            0\n#> 304                                  <-            0\n#> 305                                 <<-            0\n#> 306                                   =            0\n#> 307                           |.hexmode            0\n#> 308                           |.octmode            0\n#> 309                                  ||            0\n#> 310                                   ~            0\n#> 311                           $.DLLInfo            0\n#> 312                   $.package_version            0\n#> 313                      $<-.data.frame            0\n#> 314                         $<-.POSIXlt            0\n#> 315                          abbreviate            0\n#> 316                                 abs            0\n#> 317                                acos            0\n#> 318                               acosh            0\n#> 319               activeBindingFunction            0\n#> 320                               addNA            0\n#> 321                     addTaskCallback            0\n#> 322                               agrep            0\n#> 323                              agrepl            0\n#> 324                               alist            0\n#> 325                                 all            0\n#> 326                 all.equal.character            0\n#> 327                   all.equal.default            0\n#> 328               all.equal.environment            0\n#> 329               all.equal.envRefClass            0\n#> 330                    all.equal.factor            0\n#> 331                   all.equal.formula            0\n#> 332                  all.equal.function            0\n#> 333                  all.equal.language            0\n#> 334                      all.equal.list            0\n#> 335                   all.equal.numeric            0\n#> 336                    all.equal.POSIXt            0\n#> 337                       all.equal.raw            0\n#> 338                           all.names            0\n#> 339                            all.vars            0\n#> 340                     allowInterrupts            0\n#> 341                                 any            0\n#> 342                 anyDuplicated.array            0\n#> 343            anyDuplicated.data.frame            0\n#> 344               anyDuplicated.default            0\n#> 345                anyDuplicated.matrix            0\n#> 346                    anyNA.data.frame            0\n#> 347               anyNA.numeric_version            0\n#> 348                       anyNA.POSIXlt            0\n#> 349                       aperm.default            0\n#> 350                         aperm.table            0\n#> 351                              append            0\n#> 352                               apply            0\n#> 353                                 Arg            0\n#> 354                                args            0\n#> 355                               array            0\n#> 356                            array2DF            0\n#> 357                            arrayInd            0\n#> 358                    as.array.default            0\n#> 359                             as.call            0\n#> 360              as.character.condition            0\n#> 361                   as.character.Date            0\n#> 362                as.character.default            0\n#> 363                  as.character.error            0\n#> 364                 as.character.factor            0\n#> 365                as.character.hexmode            0\n#> 366        as.character.numeric_version            0\n#> 367                as.character.octmode            0\n#> 368                 as.character.POSIXt            0\n#> 369                 as.character.srcref            0\n#> 370                          as.complex            0\n#> 371                 as.data.frame.array            0\n#> 372                  as.data.frame.AsIs            0\n#> 373             as.data.frame.character            0\n#> 374               as.data.frame.complex            0\n#> 375            as.data.frame.data.frame            0\n#> 376                  as.data.frame.Date            0\n#> 377               as.data.frame.default            0\n#> 378              as.data.frame.difftime            0\n#> 379                as.data.frame.factor            0\n#> 380               as.data.frame.integer            0\n#> 381                  as.data.frame.list            0\n#> 382               as.data.frame.logical            0\n#> 383                as.data.frame.matrix            0\n#> 384          as.data.frame.model.matrix            0\n#> 385               as.data.frame.noquote            0\n#> 386               as.data.frame.numeric            0\n#> 387       as.data.frame.numeric_version            0\n#> 388               as.data.frame.ordered            0\n#> 389               as.data.frame.POSIXct            0\n#> 390               as.data.frame.POSIXlt            0\n#> 391                   as.data.frame.raw            0\n#> 392                 as.data.frame.table            0\n#> 393                    as.data.frame.ts            0\n#> 394                as.data.frame.vector            0\n#> 395                   as.Date.character            0\n#> 396                     as.Date.default            0\n#> 397                      as.Date.factor            0\n#> 398                     as.Date.numeric            0\n#> 399                     as.Date.POSIXct            0\n#> 400                     as.Date.POSIXlt            0\n#> 401                         as.difftime            0\n#> 402                  as.double.difftime            0\n#> 403                   as.double.POSIXlt            0\n#> 404               as.expression.default            0\n#> 405                           as.factor            0\n#> 406                 as.function.default            0\n#> 407                          as.hexmode            0\n#> 408                  as.list.data.frame            0\n#> 409                        as.list.Date            0\n#> 410                     as.list.default            0\n#> 411                    as.list.difftime            0\n#> 412                 as.list.environment            0\n#> 413                      as.list.factor            0\n#> 414                    as.list.function            0\n#> 415             as.list.numeric_version            0\n#> 416                     as.list.POSIXct            0\n#> 417                     as.list.POSIXlt            0\n#> 418                   as.logical.factor            0\n#> 419                as.matrix.data.frame            0\n#> 420                   as.matrix.default            0\n#> 421                   as.matrix.noquote            0\n#> 422                   as.matrix.POSIXlt            0\n#> 423                             as.name            0\n#> 424                     as.null.default            0\n#> 425                          as.numeric            0\n#> 426                  as.numeric_version            0\n#> 427                          as.octmode            0\n#> 428                          as.ordered            0\n#> 429                  as.package_version            0\n#> 430                         as.pairlist            0\n#> 431                     as.POSIXct.Date            0\n#> 432                  as.POSIXct.default            0\n#> 433                  as.POSIXct.numeric            0\n#> 434                  as.POSIXct.POSIXlt            0\n#> 435                as.POSIXlt.character            0\n#> 436                     as.POSIXlt.Date            0\n#> 437                  as.POSIXlt.default            0\n#> 438                   as.POSIXlt.factor            0\n#> 439                  as.POSIXlt.numeric            0\n#> 440                  as.POSIXlt.POSIXct            0\n#> 441                               as.qr            0\n#> 442                              as.raw            0\n#> 443                   as.single.default            0\n#> 444                           as.symbol            0\n#> 445                    as.table.default            0\n#> 446                as.vector.data.frame            0\n#> 447                    as.vector.factor            0\n#> 448                   as.vector.POSIXlt            0\n#> 449                                asin            0\n#> 450                               asinh            0\n#> 451                         asNamespace            0\n#> 452                              asplit            0\n#> 453                                asS3            0\n#> 454                                asS4            0\n#> 455                              assign            0\n#> 456                                atan            0\n#> 457                               atan2            0\n#> 458                               atanh            0\n#> 459                              attach            0\n#> 460                     attachNamespace            0\n#> 461                      attr.all.equal            0\n#> 462                              attr<-            0\n#> 463                          attributes            0\n#> 464                        attributes<-            0\n#> 465                            autoload            0\n#> 466                          autoloader            0\n#> 467                           backsolve            0\n#> 468                      balancePOSIXlt            0\n#> 469                             baseenv            0\n#> 470                            basename            0\n#> 471                             besselI            0\n#> 472                             besselJ            0\n#> 473                             besselK            0\n#> 474                             besselY            0\n#> 475                                beta            0\n#> 476                     bindingIsActive            0\n#> 477                     bindingIsLocked            0\n#> 478                      bindtextdomain            0\n#> 479                             bitwAnd            0\n#> 480                             bitwNot            0\n#> 481                              bitwOr            0\n#> 482                          bitwShiftL            0\n#> 483                          bitwShiftR            0\n#> 484                             bitwXor            0\n#> 485                                body            0\n#> 486                              bquote            0\n#> 487                               break            0\n#> 488                             browser            0\n#> 489                    browserCondition            0\n#> 490                     browserSetDebug            0\n#> 491                         browserText            0\n#> 492                            builtins            0\n#> 493                       by.data.frame            0\n#> 494                          by.default            0\n#> 495                              bzfile            0\n#> 496                              c.Date            0\n#> 497                          c.difftime            0\n#> 498                            c.factor            0\n#> 499                           c.noquote            0\n#> 500                   c.numeric_version            0\n#> 501                           c.POSIXct            0\n#> 502                           c.POSIXlt            0\n#> 503                          c.warnings            0\n#> 504                                call            0\n#> 505                              callCC            0\n#> 506                        capabilities            0\n#> 507                            casefold            0\n#> 508                                 cat            0\n#> 509                    cbind.data.frame            0\n#> 510                             ceiling            0\n#> 511                         char.expand            0\n#> 512                           character            0\n#> 513                           charmatch            0\n#> 514                           charToRaw            0\n#> 515                              chartr            0\n#> 516                             chkDots            0\n#> 517                        chol.default            0\n#> 518                            chol2inv            0\n#> 519                              choose            0\n#> 520             chooseOpsMethod.default            0\n#> 521                               class            0\n#> 522                             class<-            0\n#> 523                       clearPushBack            0\n#> 524                    close.connection            0\n#> 525                       close.srcfile            0\n#> 526                  close.srcfilealias            0\n#> 527                 closeAllConnections            0\n#> 528                                 col            0\n#> 529                            colMeans            0\n#> 530                            colnames            0\n#> 531                          colnames<-            0\n#> 532                             colSums            0\n#> 533                         commandArgs            0\n#> 534                             comment            0\n#> 535                           comment<-            0\n#> 536                             complex            0\n#> 537                     computeRestarts            0\n#> 538             conditionCall.condition            0\n#> 539          conditionMessage.condition            0\n#> 540                       conflictRules            0\n#> 541                           conflicts            0\n#> 542                                Conj            0\n#> 543                        contributors            0\n#> 544                                 cos            0\n#> 545                                cosh            0\n#> 546                               cospi            0\n#> 547                           crossprod            0\n#> 548                         Cstack_info            0\n#> 549                              cummax            0\n#> 550                              cummin            0\n#> 551                             cumprod            0\n#> 552                              cumsum            0\n#> 553                      curlGetHeaders            0\n#> 554                            cut.Date            0\n#> 555                         cut.default            0\n#> 556                          cut.POSIXt            0\n#> 557                          data.class            0\n#> 558                          data.frame            0\n#> 559                         data.matrix            0\n#> 560                                date            0\n#> 561                               debug            0\n#> 562                      debuggingState            0\n#> 563                           debugonce            0\n#> 564                             declare            0\n#> 565            default.stringsAsFactors            0\n#> 566                       delayedAssign            0\n#> 567                             deparse            0\n#> 568                            deparse1            0\n#> 569                                 det            0\n#> 570                              detach            0\n#> 571                  determinant.matrix            0\n#> 572                                dget            0\n#> 573                                diag            0\n#> 574                              diag<-            0\n#> 575                           diff.Date            0\n#> 576                        diff.default            0\n#> 577                       diff.difftime            0\n#> 578                         diff.POSIXt            0\n#> 579                            difftime            0\n#> 580                             digamma            0\n#> 581                      dim.data.frame            0\n#> 582                 dimnames.data.frame            0\n#> 583               dimnames<-.data.frame            0\n#> 584                          dir.create            0\n#> 585                          dir.exists            0\n#> 586                             dirname            0\n#> 587                             do.call            0\n#> 588                           dontCheck            0\n#> 589                              double            0\n#> 590                                dput            0\n#> 591                              dQuote            0\n#> 592               droplevels.data.frame            0\n#> 593                   droplevels.factor            0\n#> 594                    duplicated.array            0\n#> 595               duplicated.data.frame            0\n#> 596                  duplicated.default            0\n#> 597                   duplicated.matrix            0\n#> 598          duplicated.numeric_version            0\n#> 599                  duplicated.POSIXlt            0\n#> 600                 duplicated.warnings            0\n#> 601                            dyn.load            0\n#> 602                          dyn.unload            0\n#> 603                              dynGet            0\n#> 604                              eapply            0\n#> 605                               eigen            0\n#> 606                            emptyenv            0\n#> 607                          enc2native            0\n#> 608                            enc2utf8            0\n#> 609                        encodeString            0\n#> 610                            Encoding            0\n#> 611                          Encoding<-            0\n#> 612                            endsWith            0\n#> 613                             enquote            0\n#> 614                         env.profile            0\n#> 615                         environment            0\n#> 616                       environment<-            0\n#> 617                 environmentIsLocked            0\n#> 618                     environmentName            0\n#> 619                      errorCondition            0\n#> 620                         eval.parent            0\n#> 621                               evalq            0\n#> 622                                Exec            0\n#> 623                              exists            0\n#> 624                                 exp            0\n#> 625                         expand.grid            0\n#> 626                               expm1            0\n#> 627                          expression            0\n#> 628                      extSoftVersion            0\n#> 629                           factorial            0\n#> 630                                fifo            0\n#> 631                         file.access            0\n#> 632                         file.append            0\n#> 633                         file.choose            0\n#> 634                           file.copy            0\n#> 635                         file.create            0\n#> 636                         file.exists            0\n#> 637                           file.info            0\n#> 638                           file.link            0\n#> 639                           file.mode            0\n#> 640                          file.mtime            0\n#> 641                           file.path            0\n#> 642                         file.remove            0\n#> 643                         file.rename            0\n#> 644                           file.show            0\n#> 645                           file.size            0\n#> 646                        file.symlink            0\n#> 647                              Filter            0\n#> 648                                Find            0\n#> 649                        find.package            0\n#> 650                        findInterval            0\n#> 651                      findPackageEnv            0\n#> 652                         findRestart            0\n#> 653                               floor            0\n#> 654                    flush.connection            0\n#> 655                                 for            0\n#> 656                               force            0\n#> 657                        forceAndCall            0\n#> 658                             formals            0\n#> 659                           formals<-            0\n#> 660                         format.AsIs            0\n#> 661                   format.data.frame            0\n#> 662                         format.Date            0\n#> 663                      format.default            0\n#> 664                     format.difftime            0\n#> 665                       format.factor            0\n#> 666                      format.hexmode            0\n#> 667                         format.info            0\n#> 668                   format.libraryIQR            0\n#> 669              format.numeric_version            0\n#> 670                      format.octmode            0\n#> 671                  format.packageInfo            0\n#> 672                      format.POSIXct            0\n#> 673                      format.POSIXlt            0\n#> 674                         format.pval            0\n#> 675               format.summaryDefault            0\n#> 676                             formatC            0\n#> 677                            formatDL            0\n#> 678                        forwardsolve            0\n#> 679                            function            0\n#> 680                               gamma            0\n#> 681                             gc.time            0\n#> 682                              gcinfo            0\n#> 683                           gctorture            0\n#> 684                          gctorture2            0\n#> 685                                 get            0\n#> 686                                get0            0\n#> 687                   getAllConnections            0\n#> 688                       getCallingDLL            0\n#> 689                      getCallingDLLe            0\n#> 690                       getConnection            0\n#> 691  getDLLRegisteredRoutines.character            0\n#> 692    getDLLRegisteredRoutines.DLLInfo            0\n#> 693                          getElement            0\n#> 694                       geterrmessage            0\n#> 695                    getExportedValue            0\n#> 696                             getHook            0\n#> 697                       getLoadedDLLs            0\n#> 698                        getNamespace            0\n#> 699                 getNamespaceExports            0\n#> 700                 getNamespaceImports            0\n#> 701                    getNamespaceInfo            0\n#> 702                    getNamespaceName            0\n#> 703                   getNamespaceUsers            0\n#> 704                 getNamespaceVersion            0\n#> 705                 getNativeSymbolInfo            0\n#> 706                           getOption            0\n#> 707                         getRversion            0\n#> 708                         getSrcLines            0\n#> 709                getTaskCallbackNames            0\n#> 710                             gettext            0\n#> 711                            gettextf            0\n#> 712                               getwd            0\n#> 713                                  gl            0\n#> 714               globalCallingHandlers            0\n#> 715                           globalenv            0\n#> 716                            gregexec            0\n#> 717                            gregexpr            0\n#> 718                                grep            0\n#> 719                               grepl            0\n#> 720                             grepRaw            0\n#> 721                               grepv            0\n#> 722                            grouping            0\n#> 723                                gsub            0\n#> 724                               gzcon            0\n#> 725                              gzfile            0\n#> 726                                   I            0\n#> 727                               iconv            0\n#> 728                           iconvlist            0\n#> 729                       icuGetCollate            0\n#> 730                       icuSetCollate            0\n#> 731                           identical            0\n#> 732                            identity            0\n#> 733                                  if            0\n#> 734                              ifelse            0\n#> 735                                  Im            0\n#> 736                       importIntoEnv            0\n#> 737                             infoRDS            0\n#> 738                            inherits            0\n#> 739                             integer            0\n#> 740                         interactive            0\n#> 741                           intToBits            0\n#> 742                           intToUtf8            0\n#> 743                         inverse.rle            0\n#> 744                           invisible            0\n#> 745                       invokeRestart            0\n#> 746          invokeRestartInteractively            0\n#> 747                            is.array            0\n#> 748                           is.atomic            0\n#> 749                             is.call            0\n#> 750                        is.character            0\n#> 751                          is.complex            0\n#> 752                       is.data.frame            0\n#> 753                           is.double            0\n#> 754                          is.element            0\n#> 755                      is.environment            0\n#> 756                       is.expression            0\n#> 757                           is.factor            0\n#> 758                   is.finite.POSIXlt            0\n#> 759                         is.function            0\n#> 760                 is.infinite.POSIXlt            0\n#> 761                          is.integer            0\n#> 762                         is.language            0\n#> 763                             is.list            0\n#> 764                           is.loaded            0\n#> 765                          is.logical            0\n#> 766                           is.matrix            0\n#> 767                    is.na.data.frame            0\n#> 768               is.na.numeric_version            0\n#> 769                       is.na.POSIXlt            0\n#> 770                     is.na<-.default            0\n#> 771                      is.na<-.factor            0\n#> 772             is.na<-.numeric_version            0\n#> 773                             is.name            0\n#> 774                      is.nan.POSIXlt            0\n#> 775                             is.null            0\n#> 776                  is.numeric_version            0\n#> 777                     is.numeric.Date            0\n#> 778                 is.numeric.difftime            0\n#> 779                   is.numeric.POSIXt            0\n#> 780                           is.object            0\n#> 781                          is.ordered            0\n#> 782                  is.package_version            0\n#> 783                         is.pairlist            0\n#> 784                        is.primitive            0\n#> 785                               is.qr            0\n#> 786                                is.R            0\n#> 787                              is.raw            0\n#> 788                        is.recursive            0\n#> 789                           is.single            0\n#> 790                           is.symbol            0\n#> 791                            is.table            0\n#> 792                         is.unsorted            0\n#> 793                           is.vector            0\n#> 794                                 isa            0\n#> 795                              isatty            0\n#> 796                     isBaseNamespace            0\n#> 797                          isdebugged            0\n#> 798                             isFALSE            0\n#> 799                        isIncomplete            0\n#> 800                         isNamespace            0\n#> 801                   isNamespaceLoaded            0\n#> 802                             ISOdate            0\n#> 803                         ISOdatetime            0\n#> 804                              isOpen            0\n#> 805                           isRestart            0\n#> 806                                isS4            0\n#> 807                          isSeekable            0\n#> 808                  isSymmetric.matrix            0\n#> 809                              isTRUE            0\n#> 810                              jitter            0\n#> 811                         julian.Date            0\n#> 812                       julian.POSIXt            0\n#> 813                       kappa.default            0\n#> 814                            kappa.lm            0\n#> 815                            kappa.qr            0\n#> 816                           l10n_info            0\n#> 817                          La_library            0\n#> 818                          La_version            0\n#> 819                              La.svd            0\n#> 820                      labels.default            0\n#> 821                              lapply            0\n#> 822                            lazyLoad            0\n#> 823                      lazyLoadDBexec            0\n#> 824                     lazyLoadDBfetch            0\n#> 825                               lbeta            0\n#> 826                             lchoose            0\n#> 827                      length.POSIXlt            0\n#> 828                       length<-.Date            0\n#> 829                   length<-.difftime            0\n#> 830                     length<-.factor            0\n#> 831                    length<-.POSIXct            0\n#> 832                    length<-.POSIXlt            0\n#> 833                      levels.default            0\n#> 834                     levels<-.factor            0\n#> 835                          lfactorial            0\n#> 836                              lgamma            0\n#> 837                      libcurlVersion            0\n#> 838                library.dynam.unload            0\n#> 839                             licence            0\n#> 840                             license            0\n#> 841                           list.dirs            0\n#> 842                          list.files            0\n#> 843                             list2DF            0\n#> 844                            list2env            0\n#> 845                                load            0\n#> 846                    loadedNamespaces            0\n#> 847                loadingNamespaceInfo            0\n#> 848                       loadNamespace            0\n#> 849                               local            0\n#> 850                         lockBinding            0\n#> 851                     lockEnvironment            0\n#> 852                                 log            0\n#> 853                               log10            0\n#> 854                               log1p            0\n#> 855                                log2            0\n#> 856                                logb            0\n#> 857                             logical            0\n#> 858                           lower.tri            0\n#> 859                          make.names            0\n#> 860                         make.unique            0\n#> 861                   makeActiveBinding            0\n#> 862                                 Map            0\n#> 863                              mapply            0\n#> 864                        margin.table            0\n#> 865                          marginSums            0\n#> 866                          mat.or.vec            0\n#> 867                           match.arg            0\n#> 868                          match.call            0\n#> 869                           match.fun            0\n#> 870                     Math.data.frame            0\n#> 871                           Math.Date            0\n#> 872                       Math.difftime            0\n#> 873                         Math.factor            0\n#> 874                         Math.POSIXt            0\n#> 875                              matrix            0\n#> 876                             max.col            0\n#> 877                           mean.Date            0\n#> 878                        mean.default            0\n#> 879                       mean.difftime            0\n#> 880                        mean.POSIXct            0\n#> 881                        mean.POSIXlt            0\n#> 882                        mem.maxNSize            0\n#> 883                        mem.maxVSize            0\n#> 884                         memCompress            0\n#> 885                       memDecompress            0\n#> 886                      memory.profile            0\n#> 887                    merge.data.frame            0\n#> 888                       merge.default            0\n#> 889                             message            0\n#> 890                                mget            0\n#> 891                             missing            0\n#> 892                                 Mod            0\n#> 893                                mode            0\n#> 894                              mode<-            0\n#> 895                         months.Date            0\n#> 896                       months.POSIXt            0\n#> 897                    mostattributes<-            0\n#> 898                       mtfrm.default            0\n#> 899                       mtfrm.POSIXct            0\n#> 900                       mtfrm.POSIXlt            0\n#> 901                 nameOfClass.default            0\n#> 902                       names.POSIXlt            0\n#> 903                     names<-.POSIXlt            0\n#> 904                     namespaceExport            0\n#> 905                     namespaceImport            0\n#> 906              namespaceImportClasses            0\n#> 907                 namespaceImportFrom            0\n#> 908              namespaceImportMethods            0\n#> 909                               nargs            0\n#> 910                               nchar            0\n#> 911                                ncol            0\n#> 912                                NCOL            0\n#> 913                              Negate            0\n#> 914                             new.env            0\n#> 915                                next            0\n#> 916                          NextMethod            0\n#> 917                            ngettext            0\n#> 918                             nlevels            0\n#> 919                             noquote            0\n#> 920                                norm            0\n#> 921                       normalizePath            0\n#> 922                                nrow            0\n#> 923                                NROW            0\n#> 924                            nullfile            0\n#> 925                             numeric            0\n#> 926                     numeric_version            0\n#> 927                           numToBits            0\n#> 928                           numToInts            0\n#> 929                              nzchar            0\n#> 930                             objects            0\n#> 931                            oldClass            0\n#> 932                          oldClass<-            0\n#> 933                          OlsonNames            0\n#> 934                             on.exit            0\n#> 935                     open.connection            0\n#> 936                        open.srcfile            0\n#> 937                   open.srcfilealias            0\n#> 938                    open.srcfilecopy            0\n#> 939                      Ops.data.frame            0\n#> 940                            Ops.Date            0\n#> 941                        Ops.difftime            0\n#> 942                          Ops.factor            0\n#> 943                 Ops.numeric_version            0\n#> 944                         Ops.ordered            0\n#> 945                          Ops.POSIXt            0\n#> 946                             options            0\n#> 947                             ordered            0\n#> 948                               outer            0\n#> 949                     package_version            0\n#> 950                        packageEvent            0\n#> 951                 packageHasNamespace            0\n#> 952                packageNotFoundError            0\n#> 953               packageStartupMessage            0\n#> 954                            packBits            0\n#> 955                            pairlist            0\n#> 956                          parent.env            0\n#> 957                        parent.env<-            0\n#> 958                        parent.frame            0\n#> 959                               parse            0\n#> 960                  parseNamespaceFile            0\n#> 961                               paste            0\n#> 962                              paste0            0\n#> 963                         path.expand            0\n#> 964                        path.package            0\n#> 965                         pcre_config            0\n#> 966                                pipe            0\n#> 967                              pmatch            0\n#> 968                            pmax.int            0\n#> 969                            pmin.int            0\n#> 970                            polyroot            0\n#> 971                          pos.to.env            0\n#> 972                            Position            0\n#> 973                      pretty.default            0\n#> 974                           prettyNum            0\n#> 975                          print.AsIs            0\n#> 976                            print.by            0\n#> 977                     print.condition            0\n#> 978                    print.connection            0\n#> 979                    print.data.frame            0\n#> 980                          print.Date            0\n#> 981                       print.default            0\n#> 982                      print.difftime            0\n#> 983                         print.Dlist            0\n#> 984                       print.DLLInfo            0\n#> 985                   print.DLLInfoList            0\n#> 986         print.DLLRegisteredRoutines            0\n#> 987                         print.eigen            0\n#> 988                        print.factor            0\n#> 989                      print.function            0\n#> 990                       print.hexmode            0\n#> 991                    print.libraryIQR            0\n#> 992                        print.listof            0\n#> 993             print.NativeRoutineList            0\n#> 994                       print.noquote            0\n#> 995               print.numeric_version            0\n#> 996                       print.octmode            0\n#> 997                   print.packageInfo            0\n#> 998                       print.POSIXct            0\n#> 999                       print.POSIXlt            0\n#> 1000                    print.proc_time            0\n#> 1001                      print.restart            0\n#> 1002                          print.rle            0\n#> 1003                  print.simple.list            0\n#> 1004                      print.srcfile            0\n#> 1005                       print.srcref            0\n#> 1006                print.summary.table            0\n#> 1007             print.summary.warnings            0\n#> 1008               print.summaryDefault            0\n#> 1009                        print.table            0\n#> 1010                     print.warnings            0\n#> 1011                           prmatrix            0\n#> 1012                          proc.time            0\n#> 1013                               prod            0\n#> 1014                         prop.table            0\n#> 1015                        proportions            0\n#> 1016                    provideDimnames            0\n#> 1017                           psigamma            0\n#> 1018                           pushBack            0\n#> 1019                     pushBackLength            0\n#> 1020                                  q            0\n#> 1021                            qr.coef            0\n#> 1022                         qr.default            0\n#> 1023                          qr.fitted            0\n#> 1024                               qr.Q            0\n#> 1025                             qr.qty            0\n#> 1026                              qr.qy            0\n#> 1027                               qr.R            0\n#> 1028                           qr.resid            0\n#> 1029                           qr.solve            0\n#> 1030                               qr.X            0\n#> 1031                      quarters.Date            0\n#> 1032                    quarters.POSIXt            0\n#> 1033                               quit            0\n#> 1034                              quote            0\n#> 1035                      R_compiled_by            0\n#> 1036                   R_system_version            0\n#> 1037                             R.home            0\n#> 1038                          R.Version            0\n#> 1039                         range.Date            0\n#> 1040                      range.default            0\n#> 1041                      range.POSIXct            0\n#> 1042                               rank            0\n#> 1043                             rapply            0\n#> 1044                                raw            0\n#> 1045                      rawConnection            0\n#> 1046                 rawConnectionValue            0\n#> 1047                           rawShift            0\n#> 1048                          rawToBits            0\n#> 1049                          rawToChar            0\n#> 1050                   rbind.data.frame            0\n#> 1051                              rcond            0\n#> 1052                                 Re            0\n#> 1053                           read.dcf            0\n#> 1054                            readBin            0\n#> 1055                           readChar            0\n#> 1056                           readline            0\n#> 1057                          readLines            0\n#> 1058                            readRDS            0\n#> 1059                       readRenviron            0\n#> 1060                             Recall            0\n#> 1061                             Reduce            0\n#> 1062                      reg.finalizer            0\n#> 1063                            regexec            0\n#> 1064                            regexpr            0\n#> 1065                   registerS3method            0\n#> 1066                  registerS3methods            0\n#> 1067                         regmatches            0\n#> 1068                       regmatches<-            0\n#> 1069                 removeTaskCallback            0\n#> 1070                            rep_len            0\n#> 1071                           rep.Date            0\n#> 1072                       rep.difftime            0\n#> 1073                         rep.factor            0\n#> 1074                            rep.int            0\n#> 1075                rep.numeric_version            0\n#> 1076                        rep.POSIXct            0\n#> 1077                        rep.POSIXlt            0\n#> 1078                             repeat            0\n#> 1079                            replace            0\n#> 1080                          replicate            0\n#> 1081                            require            0\n#> 1082                   requireNamespace            0\n#> 1083                 restartDescription            0\n#> 1084                     restartFormals            0\n#> 1085                         retracemem            0\n#> 1086                             return            0\n#> 1087                        returnValue            0\n#> 1088                        rev.default            0\n#> 1089                                rle            0\n#> 1090                                 rm            0\n#> 1091                            RNGkind            0\n#> 1092                         RNGversion            0\n#> 1093                         round.Date            0\n#> 1094                       round.POSIXt            0\n#> 1095               row.names.data.frame            0\n#> 1096                  row.names.default            0\n#> 1097             row.names<-.data.frame            0\n#> 1098                row.names<-.default            0\n#> 1099                           rowMeans            0\n#> 1100                           rownames            0\n#> 1101                         rownames<-            0\n#> 1102                  rowsum.data.frame            0\n#> 1103                     rowsum.default            0\n#> 1104                            rowSums            0\n#> 1105                         sample.int            0\n#> 1106                             sapply            0\n#> 1107                         save.image            0\n#> 1108                            saveRDS            0\n#> 1109                      scale.default            0\n#> 1110                               scan            0\n#> 1111                             search            0\n#> 1112                        searchpaths            0\n#> 1113                    seek.connection            0\n#> 1114                          seq_along            0\n#> 1115                            seq_len            0\n#> 1116                           seq.Date            0\n#> 1117                        seq.default            0\n#> 1118                            seq.int            0\n#> 1119                         seq.POSIXt            0\n#> 1120                   sequence.default            0\n#> 1121                          serialize            0\n#> 1122                       serverSocket            0\n#> 1123                           set.seed            0\n#> 1124                            setHook            0\n#> 1125                   setNamespaceInfo            0\n#> 1126                setSessionTimeLimit            0\n#> 1127                       setTimeLimit            0\n#> 1128                              setwd            0\n#> 1129                    showConnections            0\n#> 1130                            shQuote            0\n#> 1131                               sign            0\n#> 1132                    signalCondition            0\n#> 1133                             signif            0\n#> 1134                    simpleCondition            0\n#> 1135                        simpleError            0\n#> 1136                      simpleMessage            0\n#> 1137                      simpleWarning            0\n#> 1138                     simplify2array            0\n#> 1139                                sin            0\n#> 1140                             single            0\n#> 1141                               sinh            0\n#> 1142                        sink.number            0\n#> 1143                              sinpi            0\n#> 1144                        slice.index            0\n#> 1145                       socketAccept            0\n#> 1146                   socketConnection            0\n#> 1147                       socketSelect            0\n#> 1148                      socketTimeout            0\n#> 1149                      solve.default            0\n#> 1150                           solve.qr            0\n#> 1151                 sort_by.data.frame            0\n#> 1152                    sort_by.default            0\n#> 1153                       sort.default            0\n#> 1154                           sort.int            0\n#> 1155                          sort.list            0\n#> 1156                       sort.POSIXlt            0\n#> 1157                             source            0\n#> 1158                   split.data.frame            0\n#> 1159                         split.Date            0\n#> 1160                      split.default            0\n#> 1161                      split.POSIXct            0\n#> 1162                 split<-.data.frame            0\n#> 1163                    split<-.default            0\n#> 1164                            sprintf            0\n#> 1165                               sqrt            0\n#> 1166                             sQuote            0\n#> 1167                            srcfile            0\n#> 1168                       srcfilealias            0\n#> 1169                        srcfilecopy            0\n#> 1170                             srcref            0\n#> 1171                    standardGeneric            0\n#> 1172                         startsWith            0\n#> 1173                             stderr            0\n#> 1174                              stdin            0\n#> 1175                             stdout            0\n#> 1176                               stop            0\n#> 1177                          stopifnot            0\n#> 1178                       storage.mode            0\n#> 1179                     storage.mode<-            0\n#> 1180                     str2expression            0\n#> 1181                           str2lang            0\n#> 1182                           strftime            0\n#> 1183                           strptime            0\n#> 1184                             strrep            0\n#> 1185                           strsplit            0\n#> 1186                             strtoi            0\n#> 1187                            strtrim            0\n#> 1188                          structure            0\n#> 1189                            strwrap            0\n#> 1190                                sub            0\n#> 1191                  subset.data.frame            0\n#> 1192                     subset.default            0\n#> 1193                      subset.matrix            0\n#> 1194                         substitute            0\n#> 1195                             substr            0\n#> 1196                           substr<-            0\n#> 1197                          substring            0\n#> 1198                        substring<-            0\n#> 1199                 summary.connection            0\n#> 1200                 summary.data.frame            0\n#> 1201                 Summary.data.frame            0\n#> 1202                       summary.Date            0\n#> 1203                       Summary.Date            0\n#> 1204                    summary.default            0\n#> 1205                   summary.difftime            0\n#> 1206                   Summary.difftime            0\n#> 1207                     summary.factor            0\n#> 1208                     Summary.factor            0\n#> 1209                     summary.matrix            0\n#> 1210            Summary.numeric_version            0\n#> 1211                    Summary.ordered            0\n#> 1212                    summary.POSIXct            0\n#> 1213                    Summary.POSIXct            0\n#> 1214                    summary.POSIXlt            0\n#> 1215                    Summary.POSIXlt            0\n#> 1216                  summary.proc_time            0\n#> 1217                    summary.srcfile            0\n#> 1218                     summary.srcref            0\n#> 1219                      summary.table            0\n#> 1220                   summary.warnings            0\n#> 1221                   suppressMessages            0\n#> 1222     suppressPackageStartupMessages            0\n#> 1223                   suppressWarnings            0\n#> 1224                  suspendInterrupts            0\n#> 1225                                svd            0\n#> 1226                              sweep            0\n#> 1227                             switch            0\n#> 1228                           sys.call            0\n#> 1229                          sys.calls            0\n#> 1230                          Sys.chmod            0\n#> 1231                           Sys.Date            0\n#> 1232                          sys.frame            0\n#> 1233                         sys.frames            0\n#> 1234                       sys.function            0\n#> 1235                         Sys.getenv            0\n#> 1236                      Sys.getlocale            0\n#> 1237                         Sys.getpid            0\n#> 1238                           Sys.glob            0\n#> 1239                           Sys.info            0\n#> 1240                     sys.load.image            0\n#> 1241                     Sys.localeconv            0\n#> 1242                         sys.nframe            0\n#> 1243                        sys.on.exit            0\n#> 1244                         sys.parent            0\n#> 1245                        sys.parents            0\n#> 1246                       Sys.readlink            0\n#> 1247                     sys.save.image            0\n#> 1248                         Sys.setenv            0\n#> 1249                    Sys.setFileTime            0\n#> 1250                    Sys.setLanguage            0\n#> 1251                      Sys.setlocale            0\n#> 1252                          Sys.sleep            0\n#> 1253                         sys.source            0\n#> 1254                         sys.status            0\n#> 1255                           Sys.time            0\n#> 1256                       Sys.timezone            0\n#> 1257                          Sys.umask            0\n#> 1258                       Sys.unsetenv            0\n#> 1259                          Sys.which            0\n#> 1260                        system.file            0\n#> 1261                        system.time            0\n#> 1262                            system2            0\n#> 1263                       t.data.frame            0\n#> 1264                          t.default            0\n#> 1265                              table            0\n#> 1266                           tabulate            0\n#> 1267                           Tailcall            0\n#> 1268                                tan            0\n#> 1269                               tanh            0\n#> 1270                              tanpi            0\n#> 1271                             tapply            0\n#> 1272                taskCallbackManager            0\n#> 1273                         tcrossprod            0\n#> 1274                            tempdir            0\n#> 1275                           tempfile            0\n#> 1276                     textConnection            0\n#> 1277                textConnectionValue            0\n#> 1278                            tolower            0\n#> 1279                             topenv            0\n#> 1280                   toString.default            0\n#> 1281                            toupper            0\n#> 1282                              trace            0\n#> 1283                          traceback            0\n#> 1284                           tracemem            0\n#> 1285                       tracingState            0\n#> 1286               transform.data.frame            0\n#> 1287                  transform.default            0\n#> 1288                           trigamma            0\n#> 1289                             trimws            0\n#> 1290                         trunc.Date            0\n#> 1291                       trunc.POSIXt            0\n#> 1292                truncate.connection            0\n#> 1293                                try            0\n#> 1294                           tryCatch            0\n#> 1295                   tryInvokeRestart            0\n#> 1296                             typeof            0\n#> 1297                     unCfillPOSIXlt            0\n#> 1298                            unclass            0\n#> 1299                            undebug            0\n#> 1300                       unique.array            0\n#> 1301                  unique.data.frame            0\n#> 1302                     unique.default            0\n#> 1303                      unique.matrix            0\n#> 1304             unique.numeric_version            0\n#> 1305                     unique.POSIXlt            0\n#> 1306                    unique.warnings            0\n#> 1307                     units.difftime            0\n#> 1308                   units<-.difftime            0\n#> 1309                          unix.time            0\n#> 1310                             unlink            0\n#> 1311                    unloadNamespace            0\n#> 1312                      unlockBinding            0\n#> 1313                             unname            0\n#> 1314                        unserialize            0\n#> 1315                            unsplit            0\n#> 1316                            untrace            0\n#> 1317                         untracemem            0\n#> 1318                                unz            0\n#> 1319                          upper.tri            0\n#> 1320                                use            0\n#> 1321                          UseMethod            0\n#> 1322                          utf8ToInt            0\n#> 1323                           validEnc            0\n#> 1324                          validUTF8            0\n#> 1325                             vapply            0\n#> 1326                             vector            0\n#> 1327                          Vectorize            0\n#> 1328                            warning            0\n#> 1329                   warningCondition            0\n#> 1330                           warnings            0\n#> 1331                      weekdays.Date            0\n#> 1332                    weekdays.POSIXt            0\n#> 1333                          which.max            0\n#> 1334                          which.min            0\n#> 1335                              while            0\n#> 1336                       with.default            0\n#> 1337                      withAutoprint            0\n#> 1338                withCallingHandlers            0\n#> 1339                  within.data.frame            0\n#> 1340                        within.list            0\n#> 1341                       withRestarts            0\n#> 1342                        withVisible            0\n#> 1343                          write.dcf            0\n#> 1344                           writeBin            0\n#> 1345                          writeChar            0\n#> 1346                         writeLines            0\n#> 1347                                xor            0\n#> 1348                 xpdrows.data.frame            0\n#> 1349                         xtfrm.AsIs            0\n#> 1350                   xtfrm.data.frame            0\n#> 1351                         xtfrm.Date            0\n#> 1352                      xtfrm.default            0\n#> 1353                     xtfrm.difftime            0\n#> 1354                       xtfrm.factor            0\n#> 1355              xtfrm.numeric_version            0\n#> 1356                      xtfrm.POSIXct            0\n#> 1357                      xtfrm.POSIXlt            0\n#> 1358                             xzfile            0\n#> 1359                           zapsmall            0\n#> 1360                           zstdfile            0\n```\n\n\n:::\n:::\n\n\n\n\nThis brute-force code unsurprisingly identifies `print()` as having the greatest number of methods. A bug in `s3_methods_generic()` prevents its use (error below).\n\n```\nError in gsub(paste0(\"^\", generic_esc, \"[.,]\"), \"\", info$method) : \ninvalid regular expression '^([.,]', reason 'Missing ')''\n```\n\nAR Solutions: A little experimentation (and thinking about the most popular functions) suggests that the `print()` generic has the most defined methods.\n\nLet's verify this programmatically with the tools we have learned in this and the previous chapters.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nls(all.names = TRUE, envir = baseenv()) %>%\n  mget(envir = baseenv()) %>%\n  keep(is_function) %>%\n  names() %>%\n  keep(is_s3_generic) %>%\n  map(~ set_names(nrow(s3_methods_generic(.x)), .x)) %>%\n  flatten_int() %>%\n  sort(decreasing = TRUE) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>         print        format             [       summary as.data.frame \n#>           280           126            49            40            33 \n#>  as.character \n#>            32\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n5.  Carefully read the documentation for `UseMethod()` and explain why the\n    following code returns the results that it does. What two usual rules\n    of function evaluation does `UseMethod()` violate?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng <- function(x) {\n  x <- 10\n  y <- 10\n  UseMethod(\"g\")\n}\ng.default <- function(x) c(x = x, y = y)\nx <- 1\ny <- 1\ng(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> x y \n#> 1 1\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: the documentation states in **Technical Details**:\n\n> `UseMethod` creates a new function call with arguments matched as they came in to the generic. Any local variables defined before the call to `UseMethod` are retained (unlike S).\n\nSo, `UseMethod()` creates a new function call where `x` matches `x <- 1` and the local variable `y <- 10` is retained. This is passed to `g.default()`. This violates both lazy evaluation and lexical scoping.\n\nAR Solutions: Let's take this step by step. If you call `g.default(x)` directly you get `c(1, 1)` as you might expect. \n\nThe value bound to `x` comes from the argument, the value from `y` comes from the global environment.\n\nBut when we call `g(x)` we get `c(1, 10)`.\n\nThis is seemingly inconsistent: why does `x` come from the value defined inside of `g()`, and `y` still come from the global environment? It's because `UseMethod()` calls `g.default()` in a special way so that variables defined inside the generic are available to methods. The exception are arguments supplied to the function: they are passed on as is and cannot be affected by code inside the generic.\n\n---\n\n6.  What are the arguments to `[`? Why is this a hard question to answer?\n\nAnswer: the possible arguments include the `x`, the object being extracted (or replaced), indices (`i`, `j`, `...`), `name`, `drop`, `exact`, and `value`.\n\nThis is a hard question to answer since `[` is an irregular primitive function that can be called in multiple ways, none of which support using all possible arguments.\n\nAR Solutions: The subsetting operator `[` is a primitive and a generic function, which can be confirmed via `ftype()`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nftype(`[`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"primitive\" \"generic\"\n```\n\n\n:::\n:::\n\n\n\n\nFor primitive functions `formals([)` returns `NULL` so we need to find another way to determine the functions arguments. One possible way to figure out `[`'s arguments would be to inspect the underlying C source code, which can be searched for via `pryr::show_c_source(.Primitive(\"[\"))`.\nWhen we inspect the arguments of some of `[`'s methods, we see that the arguments vary with the class of `x`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(formals(`[.data.frame`))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"x\"    \"i\"    \"j\"    \"drop\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(formals(`[.table`))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"x\"    \"i\"    \"j\"    \"...\"  \"drop\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(formals(`[.Date`))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"x\"    \"...\"  \"drop\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(formals(`[.AsIs`))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"x\"   \"i\"   \"...\"\n```\n\n\n:::\n:::\n\n\n\n\nTo finally get a better overview, we have to put in a little more effort and also use `s3_methods_generic()` again.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_methods_generic(\"[\") %>%\n  filter(visible) %>%\n  mutate(\n    method = paste0(\"[.\", class),\n    argnames = purrr::map(method, ~ names(formals(.x))),\n    args = purrr::map(method, ~ formals(.x)),\n    args = purrr::map2(\n      argnames, args,\n      ~ paste(.x, .y, sep = \" = \")\n    ),\n    args = purrr::set_names(args, method)\n  ) %>%\n  pull(args) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $`[.AsIs`\n#> [1] \"x = \"   \"i = \"   \"... = \"\n#> \n#> $`[.data.frame`\n#> [1] \"x = \"                                              \n#> [2] \"i = \"                                              \n#> [3] \"j = \"                                              \n#> [4] \"drop = if (missing(i)) TRUE else length(cols) == 1\"\n#> \n#> $`[.Date`\n#> [1] \"x = \"        \"... = \"      \"drop = TRUE\"\n#> \n#> $`[.difftime`\n#> [1] \"x = \"        \"... = \"      \"drop = TRUE\"\n#> \n#> $`[.Dlist`\n#> [1] \"x = \"   \"i = \"   \"... = \"\n#> \n#> $`[.DLLInfoList`\n#> [1] \"x = \"   \"... = \"\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n## 13.5.1 Exercises\n\n1.  Categorise the objects returned by `lm()`, `factor()`, `table()`, \n    `as.Date()`, `as.POSIXct()`, `ecdf()`, `ordered()`, `I()` into the\n    styles described above.\n\nAnswer:\n\n- `lm()`, `ecdf()`: scalar\n- `factor()`, `as.Date()`, `as.POSIXct()`, `ordered`: vector\n- `table()`: data frame\n- `I()`: same as the source object\n\nAR Solutions: We can categorise the return values into the various object styles by observing how the [number of observations](https://vctrs.r-lib.org/articles/type-size.html#size) is calculated: For vector style classes, `length(x)` represents the number of observations. Record style objects use a list of equal length elements to represent individual components. For data frames and matrices, the observations are represented by the rows. Scalar style objects use a list to represent a single thing.\n\nThis leads us to:\n\n- Vector object-style: `factor()`, `table()`, `as.Date()`, `as.POSIXct()`, `ordered()`\n- Record object-style: not observed\n- Data frame object-style: not observed\n- Scalar object-style: `lm()`, `ecdf()`  \n\nThe object style of `I()` depends on the input since this function returns a \"copy of the object with class `AsIs` prepended to the class(es)\".\n\n---\n\n2.  What would a constructor function for `lm` objects, `new_lm()`, look like?\n    Use `?lm` and experimentation to figure out the required fields and their\n    types.\n\nAnswer: the only required field is `formula`, provided that the variables listed in the formula exist (and are both vectors). `formula` must be of type \"`formula`\".\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmpg <- pull(mtcars, mpg)\nwt <- pull(mtcars, wt)\nlm(mpg ~ wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> lm(formula = mpg ~ wt)\n#> \n#> Coefficients:\n#> (Intercept)           wt  \n#>      37.285       -5.344\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: The constructor needs to populate the attributes of an `lm` object and check their types for correctness. Let's start by creating a simple `lm` object and explore its underlying base type and attributes:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmod <- lm(cyl ~ ., data = mtcars)\ntypeof(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $names\n#>  [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n#>  [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n#>  [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n#> \n#> $class\n#> [1] \"lm\"\n```\n\n\n:::\n:::\n\n\n\n\nAs `mod` is built upon a list, we can simply use `map(mod, typeof)` to find out the base types of its elements. (Additionally, we inspect `?lm`, to learn more about the individual attributes.)\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_chr(mod, typeof)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  coefficients     residuals       effects          rank fitted.values \n#>      \"double\"      \"double\"      \"double\"     \"integer\"      \"double\" \n#>        assign            qr   df.residual       xlevels          call \n#>     \"integer\"        \"list\"     \"integer\"        \"list\"    \"language\" \n#>         terms         model \n#>    \"language\"        \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nNow we should have enough information to write a constructor for new `lm` objects.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_lm <- function(coefficients, residuals, effects, rank, fitted.values, assign,\n                   qr, df.residual, xlevels, call, terms, model) {\n  stopifnot(\n    is.double(coefficients), is.double(residuals),\n    is.double(effects), is.integer(rank), is.double(fitted.values),\n    is.integer(assign), is.list(qr), is.integer(df.residual),\n    is.list(xlevels), is.language(call), is.language(terms),\n    is.list(model)\n  )\n\n  structure(\n    list(\n      coefficients = coefficients,\n      residuals = residuals,\n      effects = effects,\n      rank = rank,\n      fitted.values = fitted.values,\n      assign = assign,\n      qr = qr,\n      df.residual = df.residual,\n      xlevels = xlevels,\n      call = call,\n      terms = terms,\n      model = model\n    ),\n    class = \"lm\"\n  )\n}\n```\n:::\n\n\n\n\n---\n\n## 13.6.3 Exercises\n\n1.  How does `[.Date` support subclasses? How does it fail to support \n    subclasses?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`[.Date`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ..., drop = TRUE) \n#> {\n#>     .Date(NextMethod(\"[\"), oldClass(x))\n#> }\n#> <bytecode: 0x136072840>\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\n`.Date`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (xx, cl = \"Date\") \n#> `class<-`(xx, cl)\n#> <bytecode: 0x145cbc588>\n#> <environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: by passing the object's class to `.Date`, `[.Date` avoids the problem of `[.secret` and can return subclasses of `Date`. However, the `.Date` method can return objects that don't contain the class `Date`.\n\nAR Solutions: `[.Date` calls `.Date` with the result of calling `[` on the parent class, along with `oldClass()`:\n\n`.Date` is kind of like a constructor for date classes, although it doesn't check the input is the correct type:\n\n`oldClass()` is basically the same as `class()`, except that it doesn't return implicit classes, i.e. it's basically `attr(x, \"class\")` (looking at the C code that's exactly what it does, except that it also handles S4 objects).\n\nAs `oldClass()` is \"basically\" `class()`, we can rewrite `[.Date` to make the implementation more clear:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`[.Date` <- function(x, ..., drop = TRUE) {\n  out <- NextMethod(\"[\")\n  class(out) <- class(x)\n  out\n}\n```\n:::\n\n\n\n                                                        \nSo, `[.Date` ensures that the output has the same class as in the input. But what about other attributes that a subclass might possess? They get lost:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- structure(1:4, test = \"test\", class = c(\"myDate\", \"Date\"))\nattributes(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $class\n#> [1] \"myDate\" \"Date\"\n```\n\n\n:::\n:::\n\n\n\n\nNote: this is a better explanation of how it fails to support subclasses; it drops non-class attributes.\n\n---\n\n2.  R has two classes for representing date time data, `POSIXct` and\n    `POSIXlt`, which both inherit from `POSIXt`. Which generics have\n    different behaviours for the two classes? Which generics share the same\n    behaviour?\n\nAnswer: if a generic is defined for either class, it must have different behaviors. Generics that aren't defined for either class must have the same behavior. We can get the list of generics defined for either class using `sloop::s3_methods_class()`. These generics have different behaviors for the two classes:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nct_generics <- s3_methods_class(\"POSIXct\")$generic\nlt_generics <- s3_methods_class(\"POSIXlt\")$generic\ndefined_generics <- union(ct_generics, lt_generics)\ndefined_generics\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"[\"             \"[[\"            \"[<-\"           \"as.data.frame\"\n#>  [5] \"as.Date\"       \"as.list\"       \"as.POSIXlt\"    \"c\"            \n#>  [9] \"format\"        \"length<-\"      \"mean\"          \"mtfrm\"        \n#> [13] \"print\"         \"range\"         \"rep\"           \"split\"        \n#> [17] \"summary\"       \"Summary\"       \"weighted.mean\" \"xtfrm\"        \n#> [21] \"[[<-\"          \"$<-\"           \"anyNA\"         \"as.double\"    \n#> [25] \"as.matrix\"     \"as.POSIXct\"    \"as.vector\"     \"duplicated\"   \n#> [29] \"is.finite\"     \"is.infinite\"   \"is.na\"         \"is.nan\"       \n#> [33] \"length\"        \"names\"         \"names<-\"       \"sort\"         \n#> [37] \"unique\"\n```\n\n\n:::\n:::\n\n\n\n\nWe adapt work from previous exercises to get the list of all generics, and identify S3 generics that aren't defined for either class, which must have the same behavior:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_generic_funs <- Filter(is_s3_generic, names(funs))\nunion(setdiff(defined_generics, s3_generic_funs), setdiff(s3_generic_funs, defined_generics))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   [1] \"Summary\"                  \"weighted.mean\"           \n#>   [3] \"-\"                        \"!=\"                      \n#>   [5] \"*\"                        \"/\"                       \n#>   [7] \"&\"                        \"%/%\"                     \n#>   [9] \"%%\"                       \"^\"                       \n#>  [11] \"+\"                        \"<\"                       \n#>  [13] \"<=\"                       \"==\"                      \n#>  [15] \">\"                        \">=\"                      \n#>  [17] \"|\"                        \"$\"                       \n#>  [19] \"abs\"                      \"acos\"                    \n#>  [21] \"acosh\"                    \"all\"                     \n#>  [23] \"all.equal\"                \"any\"                     \n#>  [25] \"anyDuplicated\"            \"aperm\"                   \n#>  [27] \"Arg\"                      \"as.array\"                \n#>  [29] \"as.call\"                  \"as.character\"            \n#>  [31] \"as.complex\"               \"as.environment\"          \n#>  [33] \"as.expression\"            \"as.function\"             \n#>  [35] \"as.integer\"               \"as.logical\"              \n#>  [37] \"as.null\"                  \"as.numeric\"              \n#>  [39] \"as.raw\"                   \"as.single\"               \n#>  [41] \"as.table\"                 \"asin\"                    \n#>  [43] \"asinh\"                    \"atan\"                    \n#>  [45] \"atanh\"                    \"by\"                      \n#>  [47] \"cbind\"                    \"ceiling\"                 \n#>  [49] \"chol\"                     \"chooseOpsMethod\"         \n#>  [51] \"close\"                    \"conditionCall\"           \n#>  [53] \"conditionMessage\"         \"Conj\"                    \n#>  [55] \"cos\"                      \"cosh\"                    \n#>  [57] \"cospi\"                    \"cummax\"                  \n#>  [59] \"cummin\"                   \"cumprod\"                 \n#>  [61] \"cumsum\"                   \"cut\"                     \n#>  [63] \"determinant\"              \"diff\"                    \n#>  [65] \"digamma\"                  \"dim\"                     \n#>  [67] \"dim<-\"                    \"dimnames\"                \n#>  [69] \"dimnames<-\"               \"droplevels\"              \n#>  [71] \"exp\"                      \"expm1\"                   \n#>  [73] \"floor\"                    \"flush\"                   \n#>  [75] \"gamma\"                    \"getDLLRegisteredRoutines\"\n#>  [77] \"Im\"                       \"is.array\"                \n#>  [79] \"is.matrix\"                \"is.na<-\"                 \n#>  [81] \"is.numeric\"               \"isSymmetric\"             \n#>  [83] \"julian\"                   \"kappa\"                   \n#>  [85] \"labels\"                   \"levels\"                  \n#>  [87] \"levels<-\"                 \"lgamma\"                  \n#>  [89] \"log\"                      \"log10\"                   \n#>  [91] \"log1p\"                    \"log2\"                    \n#>  [93] \"max\"                      \"merge\"                   \n#>  [95] \"min\"                      \"Mod\"                     \n#>  [97] \"months\"                   \"nameOfClass\"             \n#>  [99] \"open\"                     \"plot\"                    \n#> [101] \"pretty\"                   \"prod\"                    \n#> [103] \"qr\"                       \"quarters\"                \n#> [105] \"rbind\"                    \"Re\"                      \n#> [107] \"rev\"                      \"round\"                   \n#> [109] \"row.names\"                \"row.names<-\"             \n#> [111] \"rowsum\"                   \"scale\"                   \n#> [113] \"seek\"                     \"seq\"                     \n#> [115] \"seq.int\"                  \"sequence\"                \n#> [117] \"sign\"                     \"signif\"                  \n#> [119] \"sin\"                      \"sinh\"                    \n#> [121] \"sinpi\"                    \"solve\"                   \n#> [123] \"sort_by\"                  \"split<-\"                 \n#> [125] \"sqrt\"                     \"subset\"                  \n#> [127] \"sum\"                      \"t\"                       \n#> [129] \"tan\"                      \"tanh\"                    \n#> [131] \"tanpi\"                    \"toString\"                \n#> [133] \"transform\"                \"trigamma\"                \n#> [135] \"trunc\"                    \"truncate\"                \n#> [137] \"units\"                    \"units<-\"                 \n#> [139] \"unlist\"                   \"weekdays\"                \n#> [141] \"with\"                     \"within\"\n```\n\n\n:::\n:::\n\n\n\n\nNote: this code doesn't quite work, since `Summary` is a generic according to `isGeneric` and is not according to `is_s3_generic`, and `weighted.mean` is a non-base S3 generic.\n\nAR Solutions: To answer this question, we have to get the respective generics\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngenerics_t <- s3_methods_class(\"POSIXt\")$generic\ngenerics_ct <- s3_methods_class(\"POSIXct\")$generic\ngenerics_lt <- s3_methods_class(\"POSIXlt\")$generic\n```\n:::\n\n\n\n\nThe generics in `generics_t` with a method for the superclass `POSIXt` potentially share the same behaviour for both subclasses. However, if a generic has a specific method for one of the subclasses, it has to be subtracted:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# These generics provide subclass-specific methods\nunion(generics_ct, generics_lt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"[\"             \"[[\"            \"[<-\"           \"as.data.frame\"\n#>  [5] \"as.Date\"       \"as.list\"       \"as.POSIXlt\"    \"c\"            \n#>  [9] \"format\"        \"length<-\"      \"mean\"          \"mtfrm\"        \n#> [13] \"print\"         \"range\"         \"rep\"           \"split\"        \n#> [17] \"summary\"       \"Summary\"       \"weighted.mean\" \"xtfrm\"        \n#> [21] \"[[<-\"          \"$<-\"           \"anyNA\"         \"as.double\"    \n#> [25] \"as.matrix\"     \"as.POSIXct\"    \"as.vector\"     \"duplicated\"   \n#> [29] \"is.finite\"     \"is.infinite\"   \"is.na\"         \"is.nan\"       \n#> [33] \"length\"        \"names\"         \"names<-\"       \"sort\"         \n#> [37] \"unique\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# These generics share (inherited) methods for both subclasses\nsetdiff(generics_t, union(generics_ct, generics_lt))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"-\"            \"+\"            \"all.equal\"    \"as.character\" \"Axis\"        \n#>  [6] \"cut\"          \"diff\"         \"hist\"         \"is.numeric\"   \"julian\"      \n#> [11] \"Math\"         \"months\"       \"Ops\"          \"pretty\"       \"quantile\"    \n#> [16] \"quarters\"     \"round\"        \"seq\"          \"str\"          \"trunc\"       \n#> [21] \"weekdays\"\n```\n\n\n:::\n:::\n\n\n\n\nNote: again, advanced R gives a better answer to this question, by comparing to the generics supported by the parent class.\n\n---\n\n3.  What do you expect this code to return? What does it actually return?\n    Why?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngeneric2 <- function(x) UseMethod(\"generic2\")\ngeneric2.a1 <- function(x) \"a1\"\ngeneric2.a2 <- function(x) \"a2\"\ngeneric2.b <- function(x) {\n  class(x) <- \"a1\"\n  NextMethod()\n}\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a2\"\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: I'd expect this code to return `\"a2\"` with a class of `c(\"a1\", \"a2\")`. It actually returns \"a2\" with a class of `character`. This is because when `generic2.b` calls `NextMethod()`, `generic2.a2` is called which returns a bare `\"a2\"`, dropping the class assigned by `generic2.b`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(generic2(structure(list(), class = c(\"b\", \"a2\"))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\nAR Solutions: When we execute the code above, this is what is happening:\n\n- we pass an object of classes `b` and `a2` to `generic2()`, which prompts R to look for a method`generic2.b()`\n- the method `generic2.b()` then changes the class to `a1` and calls `NextMethod()`\n- One would think that this will lead R to call `generic2.a1()`, but in fact, as mentioned in *Advanced R*, `NextMethod()` \n    > doesn’t actually work with the class attribute of the object, but instead uses a special global variable (.Class) to keep track of which method to call next.\n    \n   This is why `generic2.a2()` is called instead.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a2\"\n```\n\n\n:::\n:::\n\n\n\n\nLet's just double check the statement above and evaluate `.Class` explicitly within the `generic2.b()` method.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngeneric2.b <- function(x) {\n  class(x) <- \"a1\"\n  print(.Class)\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"b\"  \"a2\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a2\"\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n## 13.7.5 Exercises\n\n1.  Explain the differences in dispatch below:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlength.integer <- function(x) 10\n\nx1 <- 1:5\nclass(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_dispatch(length(x1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  * length.integer\n#>    length.numeric\n#>    length.default\n#> => length (internal)\n```\n\n\n:::\n\n```{.r .cell-code}\nx2 <- structure(x1, class = \"integer\")\nclass(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_dispatch(length(x2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> => length.integer\n#>    length.default\n#>  * length (internal)\n```\n\n\n:::\n:::\n\n\n\n\nAnswer: `x1` dispatches using implicit class, which is `c(\"integer\", \"numeric\")`. `x2` has an explicit class, so it is dispatched to `length.integer`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_class(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\" \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_class(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: `class()` returns `integer` in both cases. However, while the class of `x1` is created implicitly and inherits from the `numeric` class, the class of `x2` is set explicitly. This is important because `length()` is an internal generic and internal generics only dispatch to methods when the class attribute has been set, i.e. internal generics do not use implicit classes.\n\nAn object has no explicit class if `attr(x, \"class\")` returns `NULL`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nattr(x1, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(x2, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\nTo see the relevant classes for the S3 dispatch, one can use `sloop::s3_class()`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_class(x1) # implicit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\" \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_class(x2) # explicit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\nFor a better understanding of `s3_dipatch()`'s output we quote from `?s3_dispatch`:\n- => method exists and is found by `UseMethod()`.\n- -> method exists and is used by `NextMethod()`.\n- \\* method exists but is not used.\n- Nothing (and greyed out in console): method does not exist.\n\nNote: AR Solutions includes an additional important detail, that \"internal generics only dispatch to methods when the class attribute has been set\", which explains why the internal generic is used for `x1`.\n\n---\n\n2.  What classes have a method for the `Math` group generic in base R? Read\n    the source code. How do the methods work?\n\nAnswer: four base classes have a method for `Math`: `data.frame`, `Date`, `difftime`, `factor`, and `POSIXt`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_methods_generic(\"Math\") |>\n  filter(source == \"base\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 5 × 4\n#>   generic class      visible source\n#>   <chr>   <chr>      <lgl>   <chr> \n#> 1 Math    data.frame TRUE    base  \n#> 2 Math    Date       TRUE    base  \n#> 3 Math    difftime   TRUE    base  \n#> 4 Math    factor     TRUE    base  \n#> 5 Math    POSIXt     TRUE    base\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nMath.data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> {\n#>     mode.ok <- vapply(x, function(x) is.numeric(x) || is.logical(x) || \n#>         is.complex(x), NA)\n#>     if (all(mode.ok)) {\n#>         x[] <- lapply(X = x, FUN = .Generic, ...)\n#>         return(x)\n#>     }\n#>     else {\n#>         vnames <- names(x)\n#>         if (is.null(vnames)) \n#>             vnames <- seq_along(x)\n#>         stop(\"non-numeric-alike variable(s) in data frame: \", \n#>             paste(vnames[!mode.ok], collapse = \", \"))\n#>     }\n#> }\n#> <bytecode: 0x1059242f0>\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\nMath.Date\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> stop(gettextf(\"%s not defined for \\\"Date\\\" objects\", .Generic), \n#>     domain = NA)\n#> <bytecode: 0x10592b450>\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\nMath.difftime\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> {\n#>     switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , \n#>         round = , signif = {\n#>             units <- attr(x, \"units\")\n#>             .difftime(NextMethod(), units)\n#>         }, stop(gettextf(\"'%s' not defined for \\\"difftime\\\" objects\", \n#>             .Generic), domain = NA))\n#> }\n#> <bytecode: 0x10592aa08>\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\nMath.factor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> stop(gettextf(\"%s not meaningful for factors\", sQuote(.Generic)))\n#> <bytecode: 0x10592fc08>\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\nMath.POSIXt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> {\n#>     stop(gettextf(\"'%s' not defined for \\\"POSIXt\\\" objects\", \n#>         .Generic), domain = NA)\n#> }\n#> <bytecode: 0x10592f118>\n#> <environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n\n\n- `Math.data.frame` performs math if all columns (variables) are either numeric, logical or complex,\n  and errors if any are not\n- `Math.difftime` performs only certain math functions: `abs`, `sign`, `floor`, `ceiling`, `trunc`,\n  `round`, and `signif`, and errors for other functions\n- `Math.Date`, `Math.factor`, and `Math.POSIXt` always error\n\nAR Solutions: : The following functions belong to this group (see ?`Math`):\n\n- `abs`, `sign`, `sqrt`, `floor`, `ceiling`, `trunc`, `round`, `signif`\n- `exp`, `log`, `expm1`, `log1p`, `cos`, `sin`, `tan`, `cospi`, `sinpi`, `tanpi`, `acos`, `asin`,\n  `atan`, `cosh`, `sinh`, `tanh`, `acosh`, `asinh`, `atanh`\n- `lgamma`, `gamma`, `digamma`, `trigamma`\n- `cumsum`, `cumprod`, `cummax`, `cummin`\n\nThe following classes have a method for this group generic:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_methods_generic(\"Math\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 8 × 4\n#>   generic class      visible source             \n#>   <chr>   <chr>      <lgl>   <chr>              \n#> 1 Math    data.frame TRUE    base               \n#> 2 Math    Date       TRUE    base               \n#> 3 Math    difftime   TRUE    base               \n#> 4 Math    factor     TRUE    base               \n#> 5 Math    POSIXt     TRUE    base               \n#> 6 Math    quosure    FALSE   registered S3method\n#> 7 Math    vctrs_sclr FALSE   registered S3method\n#> 8 Math    vctrs_vctr FALSE   registered S3method\n```\n\n\n:::\n:::\n\n\n\n\nTo explain the basic idea, we just overwrite the data frame method:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nMath.data.frame <- function(x) \"hello\"\n```\n:::\n\n\n\n\nNow all functions from the math generic group, will return `\"hello\"`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nabs(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nexp(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlgamma(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"hello\"\n```\n\n\n:::\n:::\n\n\n\n\nOf course, different functions should perform different calculations. Here `.Generic` comes into play, which provides us with the calling generic as a string\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nMath.data.frame <- function(x, ...) {\n  .Generic\n}\nabs(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"abs\"\n```\n\n\n:::\n\n```{.r .cell-code}\nexp(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"exp\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlgamma(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"lgamma\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(Math.data.frame)\n```\n:::\n\n\n\n\nThe original source code of `Math.data.frame()` is a good example on how to invoke the string returned by `.Generic` into a specific method. `Math.factor()` is a good example of a method, which is simply defined for better error messages.\n\nNote: I prefer my answer to the AR Solutions answer.\n\n---\n\n3.  `Math.difftime()` is more complicated than I described. Why?\n\nAnswer: the explanation in the text omits the fact that `Math.difftime()` first checks that the math function being called.\n\nAR Solutions: `Math.difftime()` also excludes cases apart from `abs`, `sign`, `floor`, `ceiling`, `trunc`, `round` and `signif` and needs to return a fitting error message.\n\n---\n\n# 14 R6\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n\n\nThis chapter describes the R6 OOP system. R6 has two special properties:\n\n* It uses the encapsulated OOP paradigm, which means that methods belong to \n  objects, not generics, and you call them like `object$method()`. \n  \n* R6 objects are __mutable__, which means that they are modified in place, and \n  hence have reference semantics.\n\nIf you've learned OOP in another programming language, it's likely that R6 will feel very natural, and you'll be inclined to prefer it over S3. Resist the temptation to follow the path of least resistance: in most cases R6 will lead you to non-idiomatic R code. We'll come back to this theme in Section 16.3.\n\nR6 is very similar to a base OOP system called __reference classes__, or RC for short. I describe why I teach R6 and not RC in Section 14.5.\n\n## 14.2.6 Exercises\n\n1.  Create a bank account R6 class that stores a balance and allows you to \n    deposit and withdraw money. Create a subclass that throws an error \n    if you attempt to go into overdraft. Create another subclass that allows\n    you to go into overdraft, but charges you a fee.\n\nAnswer: `Account` stores a balance as an integer value of cents, and prints in dollars (to avoid problems with floating point math).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nAccount <- R6Class(\"Account\", list(\n  balance = 0L,\n  initialize = function(balance = 0L) {\n    stopifnot(is.integer(balance), length(balance) == 1)\n    self$balance <- balance\n  },\n  print = function(...) {\n    cat(\"Account: \\n\")\n    cat(\"  Balance: $\", format(self$balance / 100, nsmall = 2), \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  deposit = function(value) {\n    stopifnot(is.integer(value), length(value) == 1)\n    self$balance <- self$balance + value\n    invisible(self)\n  },\n  withdraw = function(value) {\n    stopifnot(is.integer(value), length(value) == 1)\n    self$balance <- self$balance - value\n    invisible(self)\n  }\n))\n\nAccountOverdraft <- R6Class(\"AccountOverdraft\",\n  inherit = Account,\n  public = list(\n    withdraw = function(value) {\n      stopifnot(value <= self$balance)\n      super$withdraw(value)\n    }\n  )\n)\n\nAccountOverdraftFee <- R6Class(\"AccountOverdraftFee\",\n  inherit = Account,\n  public = list(\n    withdraw = function(value) {\n      if (value > self$balance) value <- value + 500L\n      super$withdraw(value)\n    }\n  )\n)\n\ntry(Account$new(1.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in initialize(...) : is.integer(balance) is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na <- Account$new(100L)\na$deposit(100L)\na$withdraw(250L)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Account: \n#>   Balance: $-0.50\n```\n\n\n:::\n\n```{.r .cell-code}\na2 <- AccountOverdraft$new(200L)\ntry(a2$withdraw(250L))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in a2$withdraw(250L) : value <= self$balance is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na2$withdraw(150L)\na2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Account: \n#>   Balance: $0.50\n```\n\n\n:::\n\n```{.r .cell-code}\na3 <- AccountOverdraftFee$new(200L)\na3$withdraw(250L)\na3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Account: \n#>   Balance: $-5.50\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: `BankAccount` is a similar, simpler approach:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nBankAccount <- R6Class(\n  classname = \"BankAccount\",\n  public = list(\n    balance = 0,\n    deposit = function(dep = 0) {\n      self$balance <- self$balance + dep\n      invisible(self)\n    },\n    withdraw = function(draw) {\n      self$balance <- self$balance - draw\n      invisible(self)\n    }\n  )\n)\n\nBankAccountStrict <- R6Class(\n  classname = \"BankAccountStrict\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(draw = 0) {\n      if (self$balance - draw < 0) {\n        stop(\"Your `withdraw` must be smaller \",\n          \"than your `balance`.\",\n          call. = FALSE\n        )\n      }\n      super$withdraw(draw = draw)\n    }\n  )\n)\n\nBankAccountCharging <- R6Class(\n  classname = \"BankAccountCharging\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(draw = 0) {\n      if (self$balance - draw < 0) {\n        draw <- draw + 1\n      }\n      super$withdraw(draw = draw)\n    }\n  )\n)\n```\n:::\n\n\n\n\nNote: my object name, `AccountOverdraftFee` is misleading, since it is not a subclass of `AccountOverdraft` - the R Solutions naming convention is clearer.\n\n---\n\n2.  Create an R6 class that represents a shuffled deck of cards. You should be\n    able to draw cards from the deck with `$draw(n)`, and return all cards to \n    the deck and reshuffle with `$reshuffle()`. Use the following code to make \n    a vector of cards.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsuit <- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue <- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste0(rep(value, 4), suit)\n```\n:::\n\n\n\n\nAnswer: `Cards` shuffles the deck using `sample()`. The `draw()` function prints the cards drawn and moves them into play.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCards <- R6Class(\"Cards\", list(\n  deck = sample(cards, 52),\n  play = NULL,\n  print = function(...) {\n    cat(\"Cards: \\n\")\n    cat(\"  Deck:\", self$deck, \"\\n\", sep = \" \")\n    cat(\"  Play:\", self$play, \"\\n\", sep = \" \")\n    invisible(self)\n  },\n  draw = function(n = 1L) {\n    stopifnot(is.integer(n), length(n) == 1, n > 0, n <= length(self$deck))\n    d <- head(self$deck, n)\n    self$play <- c(self$play, d)\n    self$deck <- tail(self$deck, -n)\n    invisible(self)\n  },\n  reshuffle = function() {\n    self$deck <- sample(cards, 52)\n    self$play <- NULL\n    invisible(self)\n  }\n))\n\nd <- Cards$new()\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Cards: \n#>   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#>   Play:\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(d$draw(1.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in d$draw(1.5) : is.integer(n) is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(d$draw(0L))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in d$draw(0L) : n > 0 is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(d$draw(53L))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in d$draw(53L) : n <= length(self$deck) is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nd$draw(13L)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Cards: \n#>   Deck: 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#>   Play: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠\n```\n\n\n:::\n\n```{.r .cell-code}\nd$draw(13L)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Cards: \n#>   Deck: 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#>   Play: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠\n```\n\n\n:::\n\n```{.r .cell-code}\nd$reshuffle()\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Cards: \n#>   Deck: K♠ Q♠ 9♠ 4♠ 5♣ 7♥ 10♥ 6♠ A♥ K♣ 8♦ 5♠ 6♣ J♠ J♦ 7♦ 2♠ 6♥ 2♦ 2♣ 10♣ A♣ 4♦ A♠ 8♠ J♥ K♥ 4♣ Q♥ 9♣ 9♥ 3♦ 6♦ 3♠ 8♣ 5♦ A♦ Q♦ 7♠ 3♣ 3♥ 4♥ 7♣ 5♥ J♣ 9♦ 2♥ 10♦ Q♣ 8♥ K♦ 10♠ \n#>   Play:\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: Our new `ShuffledDeck` class will use `sample()` and positive integer subsetting to implement the reshuffling and drawing functionality. We also add a check, so you cannot draw more cards than there are left in the deck.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nShuffledDeck <- R6Class(\n  classname = \"ShuffledDeck\",\n  public = list(\n    deck = NULL,\n    initialize = function(deck = cards) {\n      self$deck <- sample(deck)\n    },\n    reshuffle = function() {\n      self$deck <- sample(cards)\n      invisible(self)\n    },\n    n = function() {\n      length(self$deck)\n    },\n    draw = function(n = 1) {\n      if (n > self$n()) {\n        stop(\"Only \", self$n(), \" cards remaining.\", call. = FALSE)\n      }\n\n      output <- self$deck[seq_len(n)]\n      self$deck <- self$deck[-seq_len(n)]\n      output\n    }\n  )\n)\n```\n:::\n\n\n\n\nNotes: it seems simpler to set `deck` directly instead of using an `initialize` function, although `sample(cards)` is cleaner. `self$n()` is a useful function, and the choice of removing and returning cards with `draw()` is probably a better design. I prefer my approach using `head()` and `tail()` over R Solutions use of `seq_len()`.\n\nBug: per 14.4.3 setting fields directly fixes the order when the class is *defined*. This results in a bug: `Cards` has the same starting shuffle for each new object, but `ShuffledDeck` does not:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nCards$new()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Cards: \n#>   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#>   Play:\n```\n\n\n:::\n\n```{.r .cell-code}\nCards$new()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Cards: \n#>   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#>   Play:\n```\n\n\n:::\n\n```{.r .cell-code}\nShuffledDeck$new()$draw(52)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"K♥\"  \"4♠\"  \"7♥\"  \"9♠\"  \"9♥\"  \"6♥\"  \"Q♦\"  \"4♦\"  \"9♦\"  \"J♦\"  \"A♠\"  \"10♠\"\n#> [13] \"4♥\"  \"K♣\"  \"8♥\"  \"3♠\"  \"8♣\"  \"3♣\"  \"A♦\"  \"6♣\"  \"K♠\"  \"J♠\"  \"3♥\"  \"2♥\" \n#> [25] \"3♦\"  \"5♥\"  \"J♥\"  \"J♣\"  \"2♠\"  \"7♠\"  \"A♥\"  \"5♠\"  \"Q♥\"  \"Q♣\"  \"6♦\"  \"7♦\" \n#> [37] \"10♥\" \"5♣\"  \"5♦\"  \"6♠\"  \"4♣\"  \"2♦\"  \"9♣\"  \"10♣\" \"2♣\"  \"7♣\"  \"K♦\"  \"A♣\" \n#> [49] \"10♦\" \"8♠\"  \"8♦\"  \"Q♠\"\n```\n\n\n:::\n\n```{.r .cell-code}\nShuffledDeck$new()$draw(52)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"8♣\"  \"6♠\"  \"3♠\"  \"4♥\"  \"J♥\"  \"Q♣\"  \"J♣\"  \"8♦\"  \"5♦\"  \"K♠\"  \"10♣\" \"K♣\" \n#> [13] \"2♦\"  \"Q♥\"  \"A♦\"  \"9♠\"  \"7♦\"  \"3♥\"  \"7♣\"  \"9♦\"  \"A♥\"  \"J♠\"  \"8♥\"  \"A♣\" \n#> [25] \"8♠\"  \"7♠\"  \"K♥\"  \"5♥\"  \"2♣\"  \"2♥\"  \"5♠\"  \"10♠\" \"3♦\"  \"4♣\"  \"A♠\"  \"Q♠\" \n#> [37] \"9♥\"  \"9♣\"  \"6♥\"  \"10♥\" \"K♦\"  \"7♥\"  \"2♠\"  \"Q♦\"  \"3♣\"  \"10♦\" \"4♠\"  \"6♣\" \n#> [49] \"4♦\"  \"5♣\"  \"6♦\"  \"J♦\"\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n3.  Why can't you model a bank account or a deck of cards with an S3 class?\n\nAnswer: because S3 classes are copied-on-modify, they lack state. R6 classes are stateful since they are modified in-place. Both bank accounts and a deck of cards are stateful objects.\n\nAR Solutions: Because S3 classes obey R's usual semantics of copy-on-modify: every time you deposit money into your bank account or draw a card from the deck, you'd get a new copy of the object.\n\nIt is possible to combine S3 classes with an environment (which is how R6 works), but it is ill-advised to create an object that looks like a regular R object but has reference semantics.\n\n---\n\n4.  Create an R6 class that allows you to get and set the current time zone. \n    You can access the current time zone with `Sys.timezone()` and set it \n    with `Sys.setenv(TZ = \"newtimezone\")`. When setting the time zone, make\n    sure the new time zone is in the list provided by `OlsonNames()`.\n\nAnswer: `TimeZone` is initialized with the current time zone, stored as `tz` in the object.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norig_tz <- Sys.timezone()\n\nTimeZone <- R6Class(\"TimeZone\", list(\n  tz = Sys.timezone(),\n  get = function() {\n    cat(\"Current time zone: \", self$tz, \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  set = function(tz) {\n    stopifnot(tz %in% OlsonNames())\n    Sys.setenv(TZ = tz)\n    self$tz <- tz\n    cat(\"Set time zone: \", self$tz, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\ntz <- TimeZone$new()\ntz$get()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Current time zone: America/Chicago\n```\n\n\n:::\n\n```{.r .cell-code}\ndate()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Fri Apr 18 15:11:06 2025\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntz$set(\"America/New_York\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Set time zone: America/New_York\n```\n\n\n:::\n\n```{.r .cell-code}\ndate()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Fri Apr 18 16:11:06 2025\"\n```\n\n\n:::\n\n```{.r .cell-code}\nSys.setenv(TZ = orig_tz)\n```\n:::\n\n\n\n\nBug: like `Cards`, `TimeZone` should set `tz` in `initialize()`.\n\nAR Solutions: To create an R6 class that allows us to get and set the time zone, we provide the respective functions as public methods to the R6 class.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nTimezone <- R6Class(\n  classname = \"Timezone\",\n  public = list(\n    get = function() {\n      Sys.timezone()\n    },\n    set = function(value) {\n      stopifnot(value %in% OlsonNames())\n      old <- self$get()\n      Sys.setenv(TZ = value)\n      invisible(old)\n    }\n  )\n)\n```\n:::\n\n\n\n\n(When setting, we return the old value invisibly because this makes it easy to restore the previous value.)\n\n---\n\n5.  Create an R6 class that manages the current working directory.\n    It should have `$get()` and `$set()` methods.\n\nAnswer: similar to `TimeZone`, `WorkingDirectory` initializes `wd` to `getwd()`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norig_wd <- getwd()\n\nWorkingDirectory <- R6Class(\"WorkingDirectory\", list(\n  wd = getwd(),\n  get = function() {\n    cat(\"Current directory: \", self$wd, \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  set = function(dir) {\n    self$wd <- setwd(dir)\n    cat(\"Set directory: \", self$wd, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\nwd <- WorkingDirectory$new()\nwd$get()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Current directory: /Users/agamemnon/GitHub/rtraining/analysis\n```\n\n\n:::\n\n```{.r .cell-code}\nwd$set(\"assets\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Set directory: /Users/agamemnon/GitHub/rtraining/analysis\n```\n\n\n:::\n\n```{.r .cell-code}\nlist.files()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"extra.css\"       \"recursive-1.png\" \"recursive-2.png\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsetwd(orig_wd)\n```\n:::\n\n\n\n\nAR Solutions: Take a look at the following implementation, which is quite minimalistic:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nWorkingDirectory <- R6Class(\n  classname = \"WorkingDirectory\",\n  public = list(\n    get = function() {\n      getwd()\n    },\n    set = function(value) {\n      setwd(value)\n    }\n  )\n)\n```\n:::\n\n\n\n\nBug: like `Cards`, `WorkingDirectory` should set `wd` in `initialize()`. Also, as AR Solutions notes in a comment:\n\n> You should never do `get = getwd()` etc because in packages, that inlines the function definition at package build time, creating a subtle dependency that will cause bugs that are extremely difficult to track down\n\n---\n\n6.  Why can't you model the time zone or current working directory with an S3\n    class?\n\nAnswer: per exercise 3, time zone and current working directory are both stateful.\n\nAR Solutions: Because S3 classes are not suitable for modelling a state that changes over time. S3 methods should (almost) always return the same result when called with the same inputs.\n\n---\n\n7.  What base type are R6 objects built on top of? What attributes do they\n    have?\n\nAnswer: R6n objects are built on environments, and have a class attribute with an S3 hierarchy including the base R6 class, per 14.2.5.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntypeof(tz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"environment\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(tz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $class\n#> [1] \"TimeZone\" \"R6\"\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: R6 objects are built on top of environments. They have a `class` attribute, which is a character vector containing the class name, the name of any super classes (if existent) and the string `\"R6\"` as the last element.\n\n---\n\n## 14.3.3 Exercises\n\n1.  Create a bank account class that prevents you from directly setting the \n    account balance, but you can still withdraw from and deposit to. Throw\n    an error if you attempt to go into overdraft.\n\nAnswer: `SecureAccount` uses a private internal balance exposed through an active function.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nSecureAccount <- R6Class(\"SecureAccount\",\n  private = list(\n    .balance = 0L\n  ),\n  public = list(\n    deposit = function(value) {\n      stopifnot(is.integer(value), length(value) == 1)\n      private$.balance <- private$.balance + value\n      invisible(self)\n    },\n    withdraw = function(value) {\n      stopifnot(is.integer(value), length(value) == 1, value <= private$.balance)\n      private$.balance <- private$.balance - value\n      invisible(self)\n    }\n  ),\n  active = list(\n    balance = function(value) {\n      if (missing(value)) {\n        private$.balance\n      } else {\n        stop(\"`$balance` is read only\", call. = FALSE)\n      }\n    }\n  )\n)\n\nsa <- SecureAccount$new()\nsa$deposit(10L)\nsa$withdraw(5L)\ntry(sa$withdraw(20L))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in sa$withdraw(20L) : value <= private$.balance is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(sa$balance <- 100L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : `$balance` is read only\n```\n\n\n:::\n\n```{.r .cell-code}\nsa$balance\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 5\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: To fulfill this requirement, we make balance a private field. The user has to use the `$deposit()` and `$withdraw()` methods which have access to the balance field.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nBankAccountStrict2 <- R6Class(\n  classname = \"BankAccountStrict2\",\n  public = list(\n    deposit = function(dep = 0) {\n      private$balance <- private$balance + dep\n      invisible(self)\n    },\n    withdraw = function(draw = 0) {\n      if (private$balance - draw < 0) {\n        stop(\n          \"Your `withdraw` must be smaller \",\n          \"than your `balance`.\",\n          call. = FALSE\n        )\n      }\n      private$balance <- private$balance - draw\n      invisible(self)\n    }\n  ),\n  private = list(\n    balance = 0\n  )\n)\n```\n:::\n\n\n\n\n---\n\n2.  Create a class with a write-only `$password` field. It should have \n    `$check_password(password)` method that returns `TRUE` or `FALSE`, but \n    there should be no way to view the complete password.\n\nAnswer: `Login` implements a write-only `$password` field using an active function. `check_password()` will error if a password hasn't been set. In real life, this should be implemented with a secure password hashing function, like `bcrypt` or `scrypt`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nLogin <- R6Class(\"Login\",\n  private = list(\n    .password = NULL\n  ),\n  public = list(\n    check_password = function(password) {\n      stopifnot(is.character(password), length(password) == 1)\n      if (is.null(private$.password)) stop(\"Error: password not set\")\n      password == private$.password\n    }\n  ),\n  active = list(\n    password = function(value) {\n      if (missing(value)) {\n        stop(\"`$password` is write only\", call. = FALSE)\n      } else {\n        stopifnot(is.character(value), length(value) == 1)\n        private$.password <- value\n        invisible(self)\n      }\n    }\n  )\n)\n\nl <- Login$new()\ntry(l$check_password(\"Password1\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in l$check_password(\"Password1\") : Error: password not set\n```\n\n\n:::\n\n```{.r .cell-code}\nl$password <- \"Password1\"\nl$check_password(\"Password1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nl$check_password(\"Password2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(l$password)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : `$password` is write only\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: To protect the password from changes and direct access, the password will be a private field. Further, our `Password` will get its own print method which hides the password.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nPassword <- R6Class(\n  classname = \"Password\",\n  public = list(\n    print = function(...) {\n      cat(\"<Password>: ********\\n\")\n      invisible(self)\n    },\n    set = function(value) {\n      private$password <- value\n    },\n    check = function(password) {\n      identical(password, private$password)\n    }\n  ),\n  private = list(\n    password = NULL\n  )\n)\n```\n:::\n\n\n\n\nLet's create one instance of our new class and confirm that the password is neither accessible nor visible, but still check-able.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_pw <- Password$new()\nmy_pw$set(\"snuffles\")\nmy_pw$password\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_pw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <Password>: ********\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_pw$check(\"snuggles\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_pw$check(\"snuffles\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nNote: the AR Solutions class properly masks the password when calling `print()`, but mine does not:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <Login>\n#>   Public:\n#>     check_password: function (password) \n#>     clone: function (deep = FALSE) \n#>     password: active binding\n#>   Private:\n#>     .password: Password1\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n3.  Extend the `Rando` class with another active binding that allows you to \n    access the previous random value. Ensure that active binding is the only\n    way to access the value.\n\nAnswer: the updated `Rando` class sets a private value when `random` is run that is accessible only through `previous`, initially set to `NA`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nRando <- R6::R6Class(\"Rando\",\n  private = list(\n    .previous = NA\n  ),\n  active = list(\n    random = function(value) {\n      if (missing(value)) {\n        private$.previous <- runif(1)\n        private$.previous\n      } else {\n        stop(\"Can't set `$random`\", call. = FALSE)\n      }\n    },\n    previous = function(value) {\n      if (missing(value)) {\n        private$.previous\n      } else {\n        stop(\"Can't set `$previous`\", call. = FALSE)\n      }\n    }\n  )\n)\nx <- Rando$new()\n\nx$previous\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nx$random\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.9643438\n```\n\n\n:::\n\n```{.r .cell-code}\nx$previous\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.9643438\n```\n\n\n:::\n\n```{.r .cell-code}\nx$random\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1186832\n```\n\n\n:::\n\n```{.r .cell-code}\nx$previous\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1186832\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: To access the previous random value from an instance, we add a private `$last_random` field to our class, and we modify `$random()` to write to this field, whenever it is called. To access the `$last_random` field we provide `$previous()`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nRando <- R6::R6Class(\n  classname = \"Rando\",\n  private = list(\n    last_random = NULL\n  ),\n  active = list(\n    random = function(value) {\n      if (missing(value)) {\n        private$last_random <- runif(1)\n        private$last_random\n      } else {\n        stop(\"Can't set `$random`.\", call. = FALSE)\n      }\n    },\n    previous = function(value) {\n      if (missing(value)) {\n        private$last_random\n      }\n    }\n  )\n)\n```\n:::\n\n\n\n\n---\n\n4.  Can subclasses access private fields/methods from their parent? Perform\n    an experiment to find out.\n\nAnswer: `LoginEvil` shows that subclasses *can* access private fields from their parent.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nLoginEvil <- R6Class(\"LoginEvil\",\n  inherit = Login,\n  public = list(\n    steal_password = function() {\n      cat(\"The password is: \", private$.password, \"\\n\", sep = \"\")\n    }\n  )\n)\n\nevil <- LoginEvil$new()\nevil$password <- \"SuperSecretPassword\"\nevil$steal_password()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> The password is: SuperSecretPassword\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: To find out if private fields/methods can be accessed from subclasses, we first create a class `A` with a private field `foo` and a private method `bar()`. Afterwards, an instance of a subclass `B`  is created and calls the `foobar()` methods, which tries to access the `foo` field and the `bar()` method from its superclass `A`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nA <- R6Class(\n  classname = \"A\",\n  private = list(\n    field = \"foo\",\n    method = function() {\n      \"bar\"\n    }\n  )\n)\nB <- R6Class(\n  classname = \"B\",\n  inherit = A,\n  public = list(\n    test = function() {\n      cat(\"Field:  \", super$field, \"\\n\", sep = \"\")\n      cat(\"Method: \", super$method(), \"\\n\", sep = \"\")\n    }\n  )\n)\nB$new()$test()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Field:  \n#> Method: bar\n```\n\n\n:::\n:::\n\n\n\n\nWe conclude that subclasses can access private methods from their superclasses, but not private fields.\n\nNote: as I discovered, private fields are not accessible through `super$`, but *are* accessible through `private$`.\n\n---\n\n## 14.4.4 Exercises\n\n1.  Create a class that allows you to write a line to a specified file. \n    You should open a connection to the file in `$initialize()`, append a\n    line using `cat()` in `$append_line()`, and close the connection in\n    `$finalize()`.\n\nAnswer: `WriteFile` implemented below.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nWriteFile <- R6Class(\"WriteFile\", list(\n  wfile = NULL,\n  initialize = function(filename) {\n    self$wfile <- file(filename, \"a\")\n  },\n  append_line = function(line) {\n    cat(line, file = self$wfile)\n  },\n  finalize = function() {\n    close(self$wfile)\n  }\n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> R6Class WriteFile: finalize() method is public, but it should be private as of R6 2.4.0. This code will continue to work, but in a future version of R6, finalize() will be required to be private.\n```\n\n\n:::\n\n```{.r .cell-code}\ntmp <- tempfile()\nwf <- WriteFile$new(tmp)\nwf$append_line(\"The quick brown fox jumps over the lazy dog.\\n\")\nreadLines(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"The quick brown fox jumps over the lazy dog.\"\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: Our `FileWriter` class will create a connection to a file at initialization. Therefore, we open a connection to a user specified file during the initialisation. Note that we need to set `open = \"a\"` in `file()` to open connection for appending text. Otherwise, `cat()` would only work when applied to files, but not with connections as explicitly asked for in the exercise. Further, we add the `append_line()` method and a `close()` statement as finalizer.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nFileWriter <- R6::R6Class(\n  classname = \"FileWriter\",\n  public = list(\n    con = NULL,\n    initialize = function(filename) {\n      self$con <- file(filename, open = \"a\")\n    },\n    finalize = function() {\n      close(self$con)\n    },\n    append_line = function(x) {\n      cat(x, \"\\n\", sep = \"\", file = self$con)\n    }\n  )\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> R6Class FileWriter: finalize() method is public, but it should be private as of R6 2.4.0. This code will continue to work, but in a future version of R6, finalize() will be required to be private.\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n# 15 S4\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n\n\nS4 provides a formal approach to functional OOP. The underlying ideas are similar to S3 (the topic of Chapter 13), but implementation is much stricter and makes use of specialised functions for creating classes (`setClass()`), generics (`setGeneric()`), and methods (`setMethod()`). Additionally, S4 provides both multiple inheritance (i.e. a class can have multiple parents) and multiple dispatch (i.e. method dispatch can use the class of multiple arguments).\n\nAn important new component of S4 is the __slot__, a named component of the object that is accessed using the specialised subsetting operator `@` (pronounced at). The set of slots, and their classes, forms an important part of the definition of an S4 class.\n\n## 15.2.1 Exercises\n\n1.  `lubridate::period()` returns an S4 class. What slots does it have?\n    What class is each slot? What accessors does it provide?\n\nAnswer: the S4 class, `Period`, has 6 slots: .Data, year, month, day, hour, and minute, all numeric. I couldn't figure out how to get the accessors.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np <- lubridate::period()\nis(p)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Period\"   \"Timespan\" \"numeric\"  \"vector\"\n```\n\n\n:::\n\n```{.r .cell-code}\nvapply(slotNames(p), function(x) class(slot(p, x)), character(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     .Data      year     month       day      hour    minute \n#> \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: Objects of the S4 `Period` class have six slots named `year`, `month`, `day`, `hour`, `minute`, and `.Data` (which contains the number of seconds). All slots are of type double. Most fields can be retrieved by an identically named accessor (e.g. `lubridate::year()` will return the field), use `second()` to get the `.Data` slot.\n\nAs a short example, we create a period of 1 second, 2 minutes, 3 hours, 4 days and 5 weeks.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexample_12345 <- lubridate::period(\n  c(1, 2, 3, 4, 5),\n  c(\"second\", \"minute\", \"hour\", \"day\", \"week\")\n)\n```\n:::\n\n\n\n\nThis should add up to a period of 39 days, 3 hours, 2 minutes and 1 second.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexample_12345\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"39d 3H 2M 1S\"\n```\n\n\n:::\n:::\n\n\n\n\nWhen we inspect `example_12345`, we see the fields and infer that the seconds are stored in the `.Data` field.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr(example_12345)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Formal class 'Period' [package \"lubridate\"] with 6 slots\n#>   ..@ .Data : num 1\n#>   ..@ year  : num 0\n#>   ..@ month : num 0\n#>   ..@ day   : num 39\n#>   ..@ hour  : num 3\n#>   ..@ minute: num 2\n```\n\n\n:::\n:::\n\n\n\n\nNotes: it is easier to just use `getClass` to enumerate slots and slot classes:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngetClass(is(lubridate::period()))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Class \"Period\" [package \"lubridate\"]\n#> \n#> Slots:\n#>                                                       \n#> Name:    .Data    year   month     day    hour  minute\n#> Class: numeric numeric numeric numeric numeric numeric\n#> \n#> Extends: \n#> Class \"Timespan\", directly\n#> Class \"numeric\", from data part\n#> Class \"vector\", by class \"numeric\", distance 2\n```\n\n\n:::\n:::\n\n\n\n\nMethods defined for a particular class can be listed using `showMethods()`, and S4 methods can be listed using `.S4methods()`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n.S4methods(\"Period\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> no methods found\n```\n\n\n:::\n:::\n\n\n\n\n`Period` has no S4 methods, only regular functions.\n\n---\n\n2.  What other ways can you find help for a method? Read `?\"?\"` and\n    summarise the details.\n\nAnswer: there are three ways to get help for a method:\n\n1. `?function` provides the function documentation\n1. `methods?function` provides the overall documentation methods for the function\n1. `methods?function(signature)` provides the documentation for a specific method\n\nAR Solutions: Besides adding `?` in front of a function call (i.e. `?method()`), we may find:\n\n- general documentation for a generic via `?genericName`\n- general documentation for the methods of a generic via `methods?genericName`\n- documentation for a specific method via `ClassName?methodName`.\n\n---\n\n## 15.3.6 Exercises\n\n1.  Extend the Person class with fields to match `utils::person()`.\n    Think about what slots you will need, what class each slot should have,\n    and what you'll need to check in your validity method.\n\nAnswer: the `Person` class uses the fields from `utils::person()`, excluding deprecated fields. Per the docs, `family` must be a string (length 1), others can be vectors (but this is not enforced).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Person\",\n  slots = c(\n    given = \"character\",\n    family = \"character\",\n    email = \"character\",\n    role = \"character\",\n    comment = \"character\"\n  ),\n  prototype = list(\n    given = NA_character_,\n    family = NA_character_,\n    email = NA_character_,\n    role = NA_character_,\n    comment = NA_character_\n  )\n)\n\nsetValidity(\"Person\", function(object) {\n  # regex from https://www.nicebread.de/validating-email-adresses-in-r/\n  regex <- \"\\\\<[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\>\"\n\n  if (length(object@family) > 1) {\n    \"@family must be a string (length 1)\"\n  } else if (!is.na(object@email) & !grepl(regex, object@email, ignore.case = TRUE)) {\n    \"invalid @email\"\n  } else {\n    TRUE\n  }\n}) |>\n  invisible()\n\nPerson <- function(given = NA_character_, family = NA_character_,\n                   email = NA_character_, role = NA_character_, comment = NA_character_) {\n  given <- as.character(given)\n  family <- as.character(family)\n  email <- as.character(email)\n  role <- as.character(role)\n  comment <- as.character(comment)\n\n  new(\"Person\", given = given, family = family, email = email, role = role, comment = comment)\n}\n\nPerson(\"John\", \"Benninghoff\", email = \"john@example.com\", comment = 51)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> An object of class \"Person\"\n#> Slot \"given\":\n#> [1] \"John\"\n#> \n#> Slot \"family\":\n#> [1] \"Benninghoff\"\n#> \n#> Slot \"email\":\n#> [1] \"john@example.com\"\n#> \n#> Slot \"role\":\n#> [1] NA\n#> \n#> Slot \"comment\":\n#> [1] \"51\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(Person(\"John\", c(\"Three\", \"Last\", \"Names\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in validObject(.Object) : \n#>   invalid class \"Person\" object: @family must be a string (length 1)\n```\n\n\n:::\n\n```{.r .cell-code}\ntry(Person(\"John\", email = \"invalid@local\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in validObject(.Object) : \n#>   invalid class \"Person\" object: invalid @email\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: The Person class from *Advanced R* contains the slots `name` and `age`. The person class from the `{utils}` package contains the slots `given` (vector of given names), `family`, `role`, `email` and `comment` (see `?utils::person`). \n\nAll slots from `utils::person()` besides `role` must be of type character and length 1. The entries in the `role` slot must match one of the following abbreviations \"aut\", \"com\", \"cph\", \"cre\", \"ctb\", \"ctr\", \"dtc\", \"fnd\", \"rev\", \"ths\", \"trl\". Therefore, `role` might be of different length than the other slots and we'll add a corresponding constraint within the validator.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Definition of the Person class\nsetClass(\"Person\",\n  slots = c(\n    age = \"numeric\",\n    given = \"character\",\n    family = \"character\",\n    role = \"character\",\n    email = \"character\",\n    comment = \"character\"\n  ),\n  prototype = list(\n    age = NA_real_,\n    given = NA_character_,\n    family = NA_character_,\n    role = NA_character_,\n    email = NA_character_,\n    comment = NA_character_\n  )\n)\n# Helper to create instances of the Person class\nPerson <- function(given, family,\n                   age = NA_real_,\n                   role = NA_character_,\n                   email = NA_character_,\n                   comment = NA_character_) {\n  age <- as.double(age)\n  new(\"Person\",\n    age = age,\n    given = given,\n    family = family,\n    role = role,\n    email = email,\n    comment = comment\n  )\n}\n# Validator to ensure that each slot is of length one\nsetValidity(\"Person\", function(object) { # nolint: cyclocomp_linter.\n  invalids <- character(0)\n  if (length(object@age) != 1 ||\n    length(object@given) != 1 ||\n    length(object@family) != 1 ||\n    length(object@email) != 1 ||\n    length(object@comment) != 1) {\n    invalids <- paste0(\n      \"@name, @age, @given, @family, @email, \",\n      \"@comment must be of length 1\"\n    )\n  }\n\n  known_roles <- c(\n    NA_character_, \"aut\", \"com\", \"cph\", \"cre\", \"ctb\",\n    \"ctr\", \"dtc\", \"fnd\", \"rev\", \"ths\", \"trl\"\n  )\n\n  if (!all(object@role %in% known_roles)) {\n    paste(\n      \"@role(s) must be one of\",\n      paste(known_roles, collapse = \", \") # nolint: paste_linter.\n    )\n  }\n\n  if (length(invalids)) {\n    return(invalids)\n  }\n  TRUE\n}) |>\n  invisible()\n```\n:::\n\n\n\n\nNotes: while I missed including `age`, our implementations are similar except for validations.\n\n---\n\n2.  What happens if you define a new S4 class that doesn't have any slots?\n    (Hint: read about virtual classes in `?setClass`.)\n\nAnswer: defining a new class with no slots makes it a virtual class, which can't be used to create new objects, but can be used to define a class union.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Virtual\")\ntry(new(\"Virtual\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in new(\"Virtual\") : \n#>   trying to generate an object from a virtual class (\"Virtual\")\n```\n\n\n:::\n\n```{.r .cell-code}\nsetClassUnion(\"Virtual\", \"Person\")\ngetClass(\"Virtual\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Extended class definition ( \"ClassUnionRepresentation\" )\n#> Virtual Class \"Virtual\" [in \".GlobalEnv\"]\n#> \n#> No Slots, prototype of class \"Person\"\n#> \n#> Known Subclasses: \"Person\"\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: It depends on the other arguments. If we inherit from another class, we get the same slots. But something interesting happens if we don't inherit from an existing class. We get a virtual class. A virtual class can't be instantiated:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Human\")\ntry(new(\"Human\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in new(\"Human\") : \n#>   trying to generate an object from a virtual class (\"Human\")\n```\n\n\n:::\n:::\n\n\n\n\nBut can be inherited from:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Programmer\", contains = \"Human\")\n```\n:::\n\n\n\n\n---\n\n3.  Imagine you were going to reimplement factors, dates, and data frames in \n    S4. Sketch out the `setClass()` calls that you would use to define the \n    classes. Think about appropriate `slots` and `prototype`.\n\nAnswer: sketch below. Default values would be set in `initialize()`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Factor\",\n  slots = list(\n    x = \"character\",\n    levels = \"character\",\n    labels = \"character\",\n    exclude = \"character\",\n    ordered = \"logical\",\n    nmax = \"integer\"\n  ),\n  prototype = list(\n    x = character(0),\n    levels = character(0),\n    labels = character(0),\n    exclude = NA_character_,\n    ordered = FALSE,\n    nmax = NA_integer_\n  )\n)\n\nsetClass(\"S4Date\",\n  slots = list(\n    days = \"integer\"\n  ),\n  prototype = list(\n    days = 0L\n  )\n)\n\nsetClass(\"DataFrame\",\n  slots = list(\n    data = \"matrix\",\n    col_names = \"character\",\n    row_names = \"character\"\n  ),\n  prototype = list(\n    data = matrix(nrow = 0, ncol = 0),\n    col_names = NULL,\n    row_names = NULL\n  )\n)\n```\n:::\n\n\n\n\nAR Solutions: For all these classes we need one slot for the data and one slot per attribute. Keep in mind, that inheritance matters for ordered factors and dates. For data frames, special checks like equal lengths of the underlying list's elements should be done within a validator.\n\nFor simplicity we don't introduce an explicit subclass for ordered factors. Instead, we introduce `ordered` as a slot.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Factor\",\n  slots = c(\n    data = \"integer\",\n    levels = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = list(\n    data = integer(),\n    levels = character(),\n    ordered = FALSE\n  )\n)\nnew(\"Factor\", data = c(1L, 2L), levels = letters[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> An object of class \"Factor\"\n#> Slot \"data\":\n#> [1] 1 2\n#> \n#> Slot \"levels\":\n#> [1] \"a\" \"b\" \"c\"\n#> \n#> Slot \"ordered\":\n#> [1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\nThe `Date2` class stores its dates as integers, similarly to base R which uses doubles. Dates don't have any other attributes.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Date2\",\n  slots = list(\n    data = \"integer\"\n  ),\n  prototype = list(\n    data = integer()\n  )\n)\n\nnew(\"Date2\", data = 1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> An object of class \"Date2\"\n#> Slot \"data\":\n#> [1] 1\n```\n\n\n:::\n:::\n\n\n\n\nOur `DataFrame` class consists of a list and a slot for `row.names`. Most of the logic (e.g. checking that all elements of the list are a vector, and that they all have the same length) would need to be part of a validator.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"DataFrame\",\n  slots = c(\n    data = \"list\",\n    row.names = \"character\"\n  ),\n  prototype = list(\n    data = list(),\n    row.names = character(0)\n  )\n)\n\nnew(\"DataFrame\", data = list(a = 1, b = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> An object of class \"DataFrame\"\n#> Slot \"data\":\n#> $a\n#> [1] 1\n#> \n#> $b\n#> [1] 2\n#> \n#> \n#> Slot \"row.names\":\n#> character(0)\n```\n\n\n:::\n:::\n\n\n\n\nNotes:\n\n- A key insight from AR Solutions is that the objects need one slot for data and one for each\n  attribute\n- My implementation of `Factor` is wrong, where the AR Solutions answer is clearly right\n- The implementations of the new `Date` object are similar; the prototype for AR Solutions is\n  better\n- The AR Solutions `DataFrame` omits column names (names), where mine does not; using a list for the\n  data in `DataFrame` is a better choice, but harder to implement\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nattributes(data.frame())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $names\n#> character(0)\n#> \n#> $row.names\n#> integer(0)\n#> \n#> $class\n#> [1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n## 15.4.5 Exercises\n\n1.  Add `age()` accessors for the `Person` class.\n\nAnswer: the code below adds age accessors to Advanced R `Person`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Person\",\n  slots = c(\n    name = \"character\",\n    age = \"numeric\"\n  ),\n  prototype = list(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\njohn <- new(\"Person\", name = \"John Smith\")\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\")) |>\n  invisible()\nsetMethod(\"age\", \"Person\", function(x) x@age)\n\nage(john)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nsetGeneric(\"age<-\", function(x, value) standardGeneric(\"age<-\")) |>\n  invisible()\nsetMethod(\"age<-\", \"Person\", function(x, value) {\n  x@age <- value\n  validObject(x)\n  x\n})\n\nage(john) <- 51\nage(john)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 51\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: We implement the accessors via an `age()` generic, with a method for the `Person` class and a corresponding replacement function `age<-`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"age\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsetMethod(\"age\", \"Person\", function(x) x@age)\n\nsetGeneric(\"age<-\", function(x, value) standardGeneric(\"age<-\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"age<-\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsetMethod(\"age<-\", \"Person\", function(x, value) {\n  x@age <- value\n  validObject(x)\n  x\n})\n```\n:::\n\n\n\n\n---\n\n2.  In the definition of the generic, why is it necessary to repeat the\n    name of the generic twice?\n\nAnswer: according to the R docs, `setGeneric(name)` specifies an existing function. When creating a new generic, the form `setGeneric(name, def)` is used, where `def` is `standardGeneric(name)`.\n\nAR Solutions: Within `setGeneric()` the `name` (1st argument) is needed as the name of the generic. Then, the name also explicitly incorporates method dispatch via `standardGeneric()` within the generic's body (`def` parameter of `setGeneric()`). This behaviour is similar to `UseMethod()` in S3.\n\n---\n\n3.  Why does the `show()` method defined in Section 15.4.3 use\n    `is(object)[[1]]`? (Hint: try printing the employee subclass.)\n\nAnswer: `is(object)` returns a vector for a subclass, with the current class first.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Employee\",\n  contains = \"Person\",\n  slots = c(\n    boss = \"Person\"\n  ),\n  prototype = list(\n    boss = new(\"Person\")\n  )\n)\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(is(object)[[1]], \"\\n\",\n    \"  Name: \", object@name, \"\\n\",\n    \"  Age:  \", object@age, \"\\n\",\n    sep = \"\"\n  )\n})\n\njohn\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Person\n#>   Name: John Smith\n#>   Age:  51\n```\n\n\n:::\n\n```{.r .cell-code}\njane <- new(\"Employee\", name = \"Jane Doe\")\nis(jane)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Employee\" \"Person\"\n```\n\n\n:::\n\n```{.r .cell-code}\njane\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Employee\n#>   Name: Jane Doe\n#>   Age:  NA\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: `is(object)` returns the class of the object. `is(object)` also contains the superclass, for subclasses like `Employee`. In order to always return the most specific class (the subclass), `show()` returns the first element of `is(object)`.\n\n---\n\n4.  What happens if you define a method with different argument names to\n    the generic?\n\nAnswer: this should cause method dispatch to fail, but I don't know of a way to test.\n\nAR Solutions: It depends. We first create the object `hadley` of class `Person`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n.Person <- setClass(\n  \"Person\",\n  slots = c(name = \"character\", age = \"numeric\")\n)\nhadley <- .Person(name = \"Hadley\")\nhadley\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Person\n#>   Name: Hadley\n#>   Age:\n```\n\n\n:::\n:::\n\n\n\n\nNow let's see which arguments can be supplied to the `show()` generic.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformals(\"show\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $object\n```\n\n\n:::\n:::\n\n\n\n\nUsually, we would use this argument when defining a new method.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(object@name, \"creates hard exercises\")\n})\n\nhadley\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Hadley creates hard exercises\n```\n\n\n:::\n:::\n\n\n\n\nWhen we supply another name as a first element of our method (e.g. `x` instead of `object`), this element will be matched to the correct `object` argument and we receive a warning. Our method will work, though:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetMethod(\"show\", \"Person\", function(x) {\n  cat(x@name, \"creates hard exercises\")\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: For function 'show', signature 'Person': argument in method definition\n#> changed from (x) to (object)\n```\n\n\n:::\n\n```{.r .cell-code}\nhadley\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Hadley creates hard exercises\n```\n\n\n:::\n:::\n\n\n\n\nIf we add more arguments to our method than our generic can handle, we will get an error.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntry(\n  setMethod(\"show\", \"Person\", function(x, y) {\n    cat(x@name, \"is\", x@age, \"years old\")\n  })\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in conformMethod(signature, mnames, fnames, f, fdef, definition) : \n#>   in method for 'show' with signature 'object=\"Person\"': formal arguments (object = \"Person\") omitted in the method definition cannot be in the signature\n```\n\n\n:::\n:::\n\n\n\n\nIf we do this with arguments added to the correctly written `object` argument, we will receive an informative error message. It states that we could add other argument names for generics, which can take the `...` argument.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntry(\n  setMethod(\"show\", \"Person\", function(object, y) {\n    cat(object@name, \"is\", object@age, \"years old\")\n  })\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in rematchDefinition(definition, fdef, mnames, fnames, signature) : \n#>   methods can add arguments to the generic 'show' only if '...' is an argument to the generic\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n## 15.5.5 Exercises\n\n1.  Draw the method graph for `f(sweat_smile, kissing_cat)`\n\nAnswer: skipped.\n\nAR Solutions: Look at the graph and repeat after me: \"I will keep my class structure simple and use multiple inheritance sparingly\".\n\n---\n\n2.  Draw the method graph for `f(smiley, wink, kissing_smiling_eyes)`\n\nAnswer: skipped.\n\nAR Solutions: We see that the method graph below looks simpler than the one above. Relatively speaking, multiple dispatch seems to introduce less complexity than multiple inheritance. Use it with care, though!\n\n---\n\n3.  Take the last example which shows multiple dispatch over two classes that\n    use multiple inheritance. What happens if you define a method for all\n    terminal classes? Why does method dispatch not save us much work here?\n\nAnswer: since all terminal nodes are equidistant from the classes, the method is ambiguous. This is true at the first level as well. The only way to avoid ambiguity is to avoid method dispatch altogether and define a method at the root node.\n\nAR Solutions: We will introduce ambiguity, since one class has distance 2 to all terminal nodes and the other four have distance 1 to two terminal nodes each. To resolve this ambiguity we have to define five more methods, one per class combination.\n\n---\n\n## 15.6.3 Exercises\n\n1.  What would a full `setOldClass()` definition look like for an ordered \n    factor (i.e. add `slots` and `prototype` the definition above)?\n\nAnswer: building on the AR Solutions example and the `factor` example in 15.6.1, the following S4 object behaves like the `ordered()` version:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Ordered\",\n  contains = \"integer\",\n  slots = c(\n    levels = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = structure(\n    integer(),\n    levels = character(),\n    ordered = TRUE\n  )\n)\nsetOldClass(\"ordered\", S4Class = \"Ordered\")\n\no <- new(\"Ordered\", 1:4, levels = letters[1:4])\no\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> An object of class \"Ordered\"\n#> [1] 1 2 3 4\n#> Slot \"levels\":\n#> [1] \"a\" \"b\" \"c\" \"d\"\n#> \n#> Slot \"ordered\":\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(ordered(c(\"a\", \"b\", \"c\", \"d\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  Ord.factor w/ 4 levels \"a\"<\"b\"<\"c\"<\"d\": 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: The purpose of `setOldClass()` lies in registering an S3 class as a \"formally defined class\", so that it can be used within the S4 object-oriented programming system. When using it, we may provide the argument `S4Class`, which will inherit the slots and their default values (prototype) to the registered class.\n\nLet's build an S4 `OrderedFactor` on top of the S3 factor in such a way.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetOldClass(\"factor\") # use build-in definition for brevity\nOrderedFactor <- setClass(\n  \"OrderedFactor\",\n  contains = \"factor\", # inherit from registered S3 class\n  slots = c(\n    levels = \"character\",\n    ordered = \"logical\" # add logical order slot\n  ),\n  prototype = structure(\n    integer(),\n    levels = character(),\n    ordered = logical() # add default value\n  )\n)\n```\n:::\n\n\n\n\nWe can now register the (S3) ordered-class, while providing an \"S4 template\". We can also use the S4-class to create new object directly.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetOldClass(\"ordered\", S4Class = \"OrderedFactor\")\nx <- OrderedFactor(\n  c(1L, 2L, 2L),\n  levels = c(\"a\", \"b\", \"c\"),\n  ordered = TRUE\n)\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Formal class 'OrderedFactor' [package \".GlobalEnv\"] with 4 slots\n#>   ..@ .Data   : int [1:3] 1 2 2\n#>   ..@ levels  : chr [1:3] \"a\" \"b\" \"c\"\n#>   ..@ ordered : logi TRUE\n#>   ..@ .S3Class: chr \"factor\"\n```\n\n\n:::\n:::\n\n\n\n\nNotes: while my class `Ordered` looks similar to the AR Solutions version, it does not include the S3 class:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr(o)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Formal class 'Ordered' [package \".GlobalEnv\"] with 3 slots\n#>   ..@ .Data  : int [1:4] 1 2 3 4\n#>   ..@ levels : chr [1:4] \"a\" \"b\" \"c\" \"d\"\n#>   ..@ ordered: logi TRUE\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n2.  Define a `length` method for the `Person` class.\n\nAnswer: since `Person` is a vector class, its length is the `length()` of any of its fields (we use Person2 here due to prevent conflicts with the already defined Person class):\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Person2\",\n  slots = c(\n    name = \"character\",\n    age = \"numeric\"\n  ),\n  prototype = list(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\nsetGeneric(\"length\") |>\n  invisible()\nsetMethod(\"length\", \"Person2\", function(x) length(x@name))\n\npeople <- new(\"Person2\", name = c(\"John Smith\", \"Jane Doe\"), age = c(NA_real_, NA_real_))\npeople\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> An object of class \"Person2\"\n#> Slot \"name\":\n#> [1] \"John Smith\" \"Jane Doe\"  \n#> \n#> Slot \"age\":\n#> [1] NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(people)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n\n\n\nAR Solutions: We keep things simple and will just return `\"180cm\"` when the `length()` method is called on a `Person` object. The method can be defined either as an S3 or S4 method.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlength.Person <- function(x) \"180cm\" # S3\nsetMethod(\"length\", \"Person\", function(x) \"180cm\") # S4\n```\n:::\n\n\n\n\n---\n\n# 16 Trade-offs\n\nYou now know about the three most important OOP toolkits available in R. Now that you understand their basic operation and the principles that underlie them, we can start to compare and contrast the systems in order to understand their strengths and weaknesses. This will help you pick the system that is most likely to solve new problems.\n\nOverall, when picking an OO system, I recommend that you default to S3. S3 is simple, and widely used throughout base R and CRAN. While it's far from perfect, its idiosyncrasies are well understood and there are known approaches to overcome most shortcomings. If you have an existing background in programming you are likely to lean towards R6, because it will feel familiar. I think you should resist this tendency for two reasons. Firstly, if you use R6 it's very easy to create a non-idiomatic API that will feel very odd to native R users, and will have surprising pain points because of the reference semantics. Secondly, if you stick to R6, you'll lose out on learning a new way of thinking about OOP that gives you a new set of tools for solving problems.\n",
    "supporting": [
      "advanced-r-3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}