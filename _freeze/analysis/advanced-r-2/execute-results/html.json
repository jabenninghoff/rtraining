{
  "hash": "e0241699ed5fdb2c763cdab58907ecde",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advanced R (Functional programming)\"\nauthor: \"John Benninghoff\"\ndate: '2022-07-31'\ndate-modified: '2023-11-11'\ncategories: [exercises, advanced-r]\norder: 202\noutput:\n  html_notebook:\n    theme:\n      version: 5\n      preset: bootstrap\n    css: assets/extra.css\n    pandoc_args: --shift-heading-level-by=1\n    toc: yes\n    toc_float:\n      collapsed: yes\n      smooth_scroll: no\n---\n\n\nWorkbook for completing quizzes and exercises from the \"Functional programming\" chapters of [Advanced R](https://adv-r.hadley.nz/index.html), second edition, with comparisons to solutions from [Advanced R Solutions](https://advanced-r-solutions.rbind.io).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(palmerpenguins)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(rlang)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)\n```\n:::\n\n\n# Introduction\n\nThis workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html) and [Advanced R Solutions](https://advanced-r-solutions.rbind.io), organized by chapter. It includes excerpts from both books, copied here.\n\n**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and exercises, don't read this notebook. It contains my (potentially wrong) answers to both.\n\n# 9 Functionals\n\n> To become significantly more reliable, code must become more transparent.\n> In particular, nested conditions and loops must be viewed with great\n> suspicion. Complicated control flows confuse programmers. Messy code often\n> hides bugs.\n>\n> --- Bjarne Stroustrup\n\nA __functional__ is a function that takes a function as an input and returns a vector as output. Here's a simple functional: it calls the function provided as input with 1000 random uniform numbers. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrandomise <- function(f) f(runif(1e3))\nrandomise(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.490206\n```\n\n\n:::\n\n```{.r .cell-code}\nrandomise(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.5041099\n```\n\n\n:::\n\n```{.r .cell-code}\nrandomise(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 502.0583\n```\n\n\n:::\n:::\n\n\nThe chances are that you've already used a functional. You might have used for-loop replacements like base R's `lapply()`, `apply()`, and `tapply()`; or purrr's `map()`; or maybe you've used a mathematical functional like `integrate()` or `optim()`. \n\nA common use of functionals is as an alternative to for loops. For loops have a bad rap in R because many people believe they are slow[^not-slow], but the real downside of for loops is that they're very flexible: a loop conveys that you're iterating, but not what should be done with the results. Just as it's better to use `while` than `repeat`, and it's better to use `for` than `while` (Section 5.3.2), it's better to use a functional than `for`. Each functional is tailored for a specific task, so when you recognise the functional you immediately know why it's being used.\n\n[^not-slow]: Typically it's not the for loop itself that's slow, but what you're doing inside of it. A common culprit of slow loops is modifying a data structure, where each modification generates a copy. See Sections 2.5.1 and 24.6 for more details.\n\nIf you're an experienced for loop user, switching to functionals is typically a pattern matching exercise. You look at the for loop and find a functional that matches the basic form. If one doesn't exist, don't try and torture an existing functional to fit the form you need. Instead, just leave it as a for loop! (Or once you've repeated the same loop two or more times, maybe think about writing your own functional).\n\n## 9.2.6 Exercises\n\n1.  Use `as_mapper()` to explore how purrr generates anonymous functions for\n    the integer, character, and list helpers. What helper allows you to \n    extract attributes? Read the documentation to find out.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_dbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (.x, .f, ..., .progress = FALSE) \n#> {\n#>     map_(\"double\", .x, .f, ..., .progress = .progress)\n#> }\n#> <bytecode: 0x113d3fc28>\n#> <environment: namespace:purrr>\n```\n\n\n:::\n\n```{.r .cell-code}\nmap_dbl(mtcars, ~ length(unique(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\n```\n\n\n:::\n\n```{.r .cell-code}\nas_mapper(~ length(unique(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> length(unique(.x))\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfunction(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))\n```\n\n\n:::\n\n```{.r .cell-code}\nas_mapper(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x1405749c0>\n#> <environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\nas_mapper(function(x) mean(x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function(x) mean(x, na.rm = TRUE)\n```\n\n\n:::\n\n```{.r .cell-code}\nas_mapper(~ mean(.x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> mean(.x, na.rm = TRUE)\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\n```\n\n\n:::\n:::\n\n\nAnswer: Exploration above. `attr_getter()` supports extraction of attributes.\n\nAR Solutions: `map()` offers multiple ways (functions, formulas, and extractor functions) to specify its function argument (`.f`). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of `as_mapper()` and it is called every time `map()` is used.\n\nGiven character, numeric or list input `as_mapper()` will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.\n\nThe extractor function is implemented as a call to `purrr::pluck()`, which accepts a list of accessors (accessors \"access\" some part of your data object).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nas_mapper(c(1, 2)) # equivalent to function(x) x[[1]][[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> pluck_raw(x, list(1, 2), .default = NULL)\n#> <environment: 0x125537d18>\n```\n\n\n:::\n\n```{.r .cell-code}\nas_mapper(c(\"a\", \"b\")) # equivalent to function(x) x[[\"a\"]][[\"b]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> pluck_raw(x, list(\"a\", \"b\"), .default = NULL)\n#> <environment: 0x124b97c70>\n```\n\n\n:::\n\n```{.r .cell-code}\nas_mapper(list(1, \"b\")) # equivalent to function(x) x[[1]][[\"b]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> pluck_raw(x, list(1, \"b\"), .default = NULL)\n#> <environment: 0x124a975a0>\n```\n\n\n:::\n:::\n\n\nBesides mixing positions and names, it is also possible to pass along an accessor function. This is basically an anonymous function that gets information about some aspect of the input data. You are free to define your own accessor functions. \n\nIf you need to access certain attributes, the helper `attr_getter(y)` is already predefined and will create the appropriate accessor function for you.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Define custom accessor function\nget_class <- function(x) attr(x, \"class\")\npluck(mtcars, get_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Use attr_getter() as a helper\npluck(mtcars, attr_getter(\"class\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\nNote: AR Solutions provides good additional insight into `as_mapper()`.\n\n---\n\n2.  `map(1:3, ~ runif(2))` is a useful pattern for generating random\n    numbers, but `map(1:3, runif(2))` is not. Why not? Can you explain why \n    it returns the result that it does?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap(1:3, ~ runif(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> [1] 0.87867860 0.03784156\n#> \n#> [[2]]\n#> [1] 0.4949940 0.3020369\n#> \n#> [[3]]\n#> [1] 0.9883319 0.8015935\n```\n\n\n:::\n\n```{.r .cell-code}\nmap(1:3, runif(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n#> \n#> [[3]]\n#> [1] 3\n```\n\n\n:::\n:::\n\n\nAnswer: `~ runif(2)` generates a mapper that returns 2 random values from the uniform distribution, where `runif(2)` creates a `pluck()` mapper with 2 random values, which will (nearly) always return `NULL`, as demonstrated by the code below: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nas_mapper(~ runif(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> runif(2)\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas_mapper(runif(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> pluck_raw(x, list(0.904492039233446, 0.102344793267548), .default = NULL)\n#> <environment: 0x115b7f390>\n```\n\n\n:::\n:::\n\n\nA more reasonable use of a pluck mapper for `1:3` is `1`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap(1:3, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n#> \n#> [[3]]\n#> [1] 3\n```\n\n\n:::\n:::\n\n\nAR Solutions: The first pattern creates multiple random numbers, because `~ runif(2)` successfully uses the formula interface. Internally `map()` applies `as_mapper()` to this formula, which converts `~ runif(2)` into an anonymous function. Afterwards `runif(2)` is applied three times (one time during each iteration), leading to three different pairs of random numbers.\n\nIn the second pattern `runif(2)` is evaluated once, then the results are passed to `map()`. Consequently `as_mapper()` creates an extractor function based on the return values from `runif(2)` (via `pluck()`). This leads to three `NULL`s (`pluck()`'s `.default` return), because no values corresponding to the index can be found.\n\nNote: AR Solutions provides additional detail, but is otherwise the same.\n\n---\n\n3.  Use the appropriate `map()` function to:\n    \n    a) Compute the standard deviation of every column in a numeric data frame.\n    \n    a) Compute the standard deviation of every numeric column in a mixed data\n       frame. (Hint: you'll need to do it in two steps.)\n       \n    a) Compute the number of levels for every factor in a data frame.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# a\nmap_dbl(mtcars, sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>         mpg         cyl        disp          hp        drat          wt \n#>   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574 \n#>        qsec          vs          am        gear        carb \n#>   1.7869432   0.5040161   0.4989909   0.7378041   1.6152000\n```\n\n\n:::\n\n```{.r .cell-code}\n# b\nmap_dbl(iris[map_lgl(iris, is.numeric)], sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#>    0.8280661    0.4358663    1.7652982    0.7622377\n```\n\n\n:::\n\n```{.r .cell-code}\n# c\nmap_int(warpbreaks, nlevels)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  breaks    wool tension \n#>       0       2       3\n```\n\n\n:::\n\n```{.r .cell-code}\n# c, excluding non-factor columns\nmap_int(warpbreaks[map_lgl(warpbreaks, is.factor)], nlevels)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    wool tension \n#>       2       3\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: To solve this exercise we take advantage of calling the type stable variants of `map()`, which give us more concise output, and use `map_lgl()` to select the columns of the data frame (later you'll learn about `keep()`, which simplifies this pattern a little).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_dbl(mtcars, sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>         mpg         cyl        disp          hp        drat          wt \n#>   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574 \n#>        qsec          vs          am        gear        carb \n#>   1.7869432   0.5040161   0.4989909   0.7378041   1.6152000\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins_numeric <- map_lgl(penguins, is.numeric)\nmap_dbl(penguins[penguins_numeric], sd, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    bill_length_mm     bill_depth_mm flipper_length_mm       body_mass_g \n#>         5.4595837         1.9747932        14.0617137       801.9545357 \n#>              year \n#>         0.8183559\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins_factor <- map_lgl(penguins, is.factor)\nmap_int(penguins[penguins_factor], ~ length(levels(.x))) # nolint: length_levels_linter.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> species  island     sex \n#>       3       3       2\n```\n\n\n:::\n:::\n\n\nNote: my code is more concise, both with selections and use of `nlevels()`, although using `keep()` is preferable.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_int(keep(warpbreaks, is.factor), nlevels)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    wool tension \n#>       2       3\n```\n\n\n:::\n:::\n\n\n---\n\n4.  The following code simulates the performance of a t-test for non-normal \n    data. Extract the p-value from each test, then visualise.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\nhist(map_dbl(trials, \"p.value\"), breaks = 10)\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: There are many ways to visualise this data. However, since there are only 100 data points, we choose a dot plot to visualise the distribution. (Unfortunately, `{ggplot2}`s `geom_dotplot()` doesn't compute proper counts as it was created to visualise distribution densities instead of frequencies, so a histogram would be a suitable alternative).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Advanced R Solutions uses different code for trials\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))\n\nlibrary(ggplot2)\n\ndf_trials <- tibble::tibble(p_value = map_dbl(trials, \"p.value\"))\n\ndf_trials %>%\n  ggplot(aes(x = p_value, fill = p_value < 0.05)) +\n  geom_dotplot(binwidth = 0.01) + # geom_histogram() as alternative\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    legend.position = \"top\"\n  )\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nNotes: the code AR Solutions uses for trials, `trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))`, appears to be correct compared to Advanced R.\n\n---\n\n5.  The following code uses a map nested inside another map to apply a\n    function to every element of a nested list. Why does it fail, and \n    what do you need to do to make it work?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\ntry(map(x, map, .f = triple))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in map(x, map, .f = triple) : ℹ In index: 1.\n#> Caused by error in `.f()`:\n#> ! unused argument (function (.x, .f, ..., .progress = FALSE) \n#> {\n#>     map_(\"list\", .x, .f, ..., .progress = .progress)\n#> })\n```\n\n\n:::\n:::\n\n\nAnswer: the call fails since the `.f = triple` specifies the function for the outer `map()`, and the `map` is passed as an additional argument to `triple()`, which generates the error since `triple()` only takes a single argument. The solution is to pass triple as an additional argument to the outer `map()`: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap(x, map, triple)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> [[1]][[1]]\n#> [1] 3\n#> \n#> [[1]][[2]]\n#> [1]  9 27\n#> \n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1]  9 18\n#> \n#> [[2]][[2]]\n#> [1] 21\n#> \n#> [[2]][[3]]\n#> [1] 12 21 18\n```\n\n\n:::\n:::\n\n\nAR Solutions: This function call fails, because `triple()` is specified as the `.f` argument and consequently belongs to the outer `map()`. The unnamed argument `map` is treated as an argument of `triple()`, which causes the error.\n\nThere are a number of ways we could resolve the problem. However, there is not much to choose between them for this simple example, although it is good to know your options for more complicated cases.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Don't name the argument\nmap(x, map, triple)\n\n# Use magrittr-style anonymous function\nmap(x, . %>% map(triple))\n\n# Use purrr-style anonymous function\nmap(x, ~ map(.x, triple))\n```\n:::\n\n\nNote: I don't like the magrittr-style anonymous function option. The others are good.\n\n---\n\n6.  Use `map()` to fit linear models to the `mtcars` dataset using the formulas\n    stored in this list:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\n```\n:::\n\n\nAnswer: the following code works, but doesn't display the text of the formula in the `Call:`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap(formulas, lm, mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> \n#> Call:\n#> .f(formula = .x[[i]], data = ..1)\n#> \n#> Coefficients:\n#> (Intercept)         disp  \n#>    29.59985     -0.04122  \n#> \n#> \n#> [[2]]\n#> \n#> Call:\n#> .f(formula = .x[[i]], data = ..1)\n#> \n#> Coefficients:\n#> (Intercept)    I(1/disp)  \n#>       10.75      1557.67  \n#> \n#> \n#> [[3]]\n#> \n#> Call:\n#> .f(formula = .x[[i]], data = ..1)\n#> \n#> Coefficients:\n#> (Intercept)         disp           wt  \n#>    34.96055     -0.01772     -3.35083  \n#> \n#> \n#> [[4]]\n#> \n#> Call:\n#> .f(formula = .x[[i]], data = ..1)\n#> \n#> Coefficients:\n#> (Intercept)    I(1/disp)           wt  \n#>      19.024     1142.560       -1.798\n```\n\n\n:::\n:::\n\n\nAR Solutions: The data (`mtcars`) is constant for all these models and so we iterate over the `formulas` provided. As the formula is the first argument of `lm()`, we don't need to specify it explicitly.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodels <- map(formulas, lm, data = mtcars)\n```\n:::\n\n\nNote: AR Solutions specifies `data = mtcars` but is otherwise the same.\n\n---\n\n7.  Fit the model `mpg ~ disp` to each of the bootstrap replicates of `mtcars` \n    in the list below, then extract the $R^2$ of the model fit (Hint: you can\n    compute the $R^2$ with `summary()`.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))\n\nmap_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 0.7567321 0.7244990 0.6324280 0.7947267 0.5716059 0.6304013 0.5817392\n#>  [8] 0.7713750 0.7795558 0.6131795\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: To accomplish this task, we take advantage of the \"list in, list out\"-functionality of `map()`. This allows us to chain multiple transformations together. We start by fitting the models. We then calculate the summaries and extract the $R^2$ values. For the last call we use `map_dbl()`, which provides convenient output.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbootstraps %>%\n  map(~ lm(mpg ~ disp, data = .x)) %>%\n  map(summary) %>%\n  map_dbl(\"r.squared\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 0.7567321 0.7244990 0.6324280 0.7947267 0.5716059 0.6304013 0.5817392\n#>  [8] 0.7713750 0.7795558 0.6131795\n```\n\n\n:::\n:::\n\n\nNote: while AR Solutions is arguably *slightly* more readable, my code should be faster:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbench::mark({\n  map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                           <bch> <bch:>     <dbl> <bch:byt>    <dbl>\n#> 1 { map_dbl(bootstraps, ~summary(lm(m… 1.9ms 1.96ms      507.    63.7KB     55.5\n```\n\n\n:::\n\n```{.r .cell-code}\nbench::mark({\n  bootstraps %>%\n    map(~ lm(mpg ~ disp, data = .x)) %>%\n    map(summary) %>%\n    map_dbl(\"r.squared\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                          <bch:> <bch:>     <dbl> <bch:byt>    <dbl>\n#> 1 { bootstraps %>% map(~lm(mpg ~ dis… 1.95ms 2.04ms      478.    63.7KB     58.8\n```\n\n\n:::\n:::\n\n\nIt is actually slightly slower! AR Solutions wins!\n\n---\n\n## 9.4.6 Exercises\n\n1.  Explain the results of `modify(mtcars, 1)`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodify(mtcars, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    mpg cyl disp  hp drat   wt  qsec vs am gear carb\n#> 1   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 2   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 3   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 4   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 5   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 6   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 7   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 8   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 9   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 10  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 11  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 12  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 13  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 14  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 15  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 16  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 17  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 18  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 19  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 20  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 21  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 22  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 23  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 24  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 25  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 26  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 27  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 28  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 29  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 30  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 31  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#> 32  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n```\n\n\n:::\n\n```{.r .cell-code}\nas_mapper(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x, ...) \n#> pluck_raw(x, list(1), .default = NULL)\n#> <environment: 0x15423fde0>\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(mtcars, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           mpg cyl disp  hp drat   wt  qsec vs am gear carb\n#> Mazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n```\n\n\n:::\n:::\n\n\nAnswer: `modify(mtcars, 1)` creates a mapper that plucks the first element of each column of `mtcars` and writes that value to every row.\n\nAR Solutions: `modify()` is based on `map()`, and in this case, the extractor interface will be used. It extracts the first element of each column in `mtcars`. `modify()` always returns the same structure as its input: in this case it forces the first row to be recycled 32 times. (Internally `modify()` uses `.x[] <- map(.x, .f, ...)` for assignment.)\n\nNotes: this code makes the recycling clear:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nunlist(map(mtcars, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#>  21.00   6.00 160.00 110.00   3.90   2.62  16.46   0.00   1.00   4.00   4.00\n```\n\n\n:::\n:::\n\n\n---\n\n2.  Rewrite the following code to use `iwalk()` instead of `walk2()`. What\n    are the advantages and disadvantages?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n```\n:::\n\n\nAnswer: code below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntemp <- tempfile()\ndir.create(temp)\n\ncyls <- split(mtcars, mtcars$cyl)\niwalk(cyls, ~ write.csv(.x, file.path(temp, paste0(\"cyl-\", .y, \".csv\"))))\ndir(temp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\"\n```\n\n\n:::\n:::\n\n\nThe main advantage of using `iwalk()` is that it will use `seq_along()` if `x` does not have names. In this case, x has names, and the resulting code is a bit harder to understand, and requires a formula (or function).\n\nAR Solutions: `iwalk()` allows us to use a single variable, storing the output path in the names.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntemp <- tempfile()\ndir.create(temp)\ncyls <- split(mtcars, mtcars$cyl)\nnames(cyls) <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\niwalk(cyls, ~ write.csv(.x, .y))\n```\n:::\n\n\nWe could do this in a single pipe by taking advantage of `set_names()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars %>%\n  split(mtcars$cyl) %>%\n  set_names(~ file.path(temp, paste0(\"cyl-\", .x, \".csv\"))) %>%\n  iwalk(~ write.csv(.x, .y))\n```\n:::\n\n\nNotes: the AR Solutions use of names and the pipe is clever.\n\n---\n\n3.  Explain how the following code transforms a data frame using functions\n    stored in a list.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nif (exists(\"mtcars\")) rm(mtcars)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning in rm(mtcars): object 'mtcars' not found\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#> Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#> Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#> Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#> Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#> Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#> Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#> Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#> Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#> Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#> Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#> Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#> Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#> Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#> Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#> Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#> Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#> Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#> Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#> Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#> Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#> Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#> AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#> Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#> Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#> Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#> Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#> Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#> Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#> Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#> Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#> Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\n\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                      mpg cyl     disp  hp drat    wt  qsec vs     am gear carb\n#> Mazda RX4           21.0   6 2.621936 110 3.90 2.620 16.46  0 manual    4    4\n#> Mazda RX4 Wag       21.0   6 2.621936 110 3.90 2.875 17.02  0 manual    4    4\n#> Datsun 710          22.8   4 1.769807  93 3.85 2.320 18.61  1 manual    4    1\n#> Hornet 4 Drive      21.4   6 4.227872 110 3.08 3.215 19.44  1   auto    3    1\n#> Hornet Sportabout   18.7   8 5.899356 175 3.15 3.440 17.02  0   auto    3    2\n#> Valiant             18.1   6 3.687098 105 2.76 3.460 20.22  1   auto    3    1\n#> Duster 360          14.3   8 5.899356 245 3.21 3.570 15.84  0   auto    3    4\n#> Merc 240D           24.4   4 2.403988  62 3.69 3.190 20.00  1   auto    4    2\n#> Merc 230            22.8   4 2.307304  95 3.92 3.150 22.90  1   auto    4    2\n#> Merc 280            19.2   6 2.746478 123 3.92 3.440 18.30  1   auto    4    4\n#> Merc 280C           17.8   6 2.746478 123 3.92 3.440 18.90  1   auto    4    4\n#> Merc 450SE          16.4   8 4.519562 180 3.07 4.070 17.40  0   auto    3    3\n#> Merc 450SL          17.3   8 4.519562 180 3.07 3.730 17.60  0   auto    3    3\n#> Merc 450SLC         15.2   8 4.519562 180 3.07 3.780 18.00  0   auto    3    3\n#> Cadillac Fleetwood  10.4   8 7.734711 205 2.93 5.250 17.98  0   auto    3    4\n#> Lincoln Continental 10.4   8 7.538066 215 3.00 5.424 17.82  0   auto    3    4\n#> Chrysler Imperial   14.7   8 7.210324 230 3.23 5.345 17.42  0   auto    3    4\n#> Fiat 128            32.4   4 1.289665  66 4.08 2.200 19.47  1 manual    4    1\n#> Honda Civic         30.4   4 1.240503  52 4.93 1.615 18.52  1 manual    4    2\n#> Toyota Corolla      33.9   4 1.165123  65 4.22 1.835 19.90  1 manual    4    1\n#> Toyota Corona       21.5   4 1.968091  97 3.70 2.465 20.01  1   auto    3    1\n#> Dodge Challenger    15.5   8 5.211098 150 2.76 3.520 16.87  0   auto    3    2\n#> AMC Javelin         15.2   8 4.981678 150 3.15 3.435 17.30  0   auto    3    2\n#> Camaro Z28          13.3   8 5.735485 245 3.73 3.840 15.41  0   auto    3    4\n#> Pontiac Firebird    19.2   8 6.554840 175 3.08 3.845 17.05  0   auto    3    2\n#> Fiat X1-9           27.3   4 1.294581  66 4.08 1.935 18.90  1 manual    4    1\n#> Porsche 914-2       26.0   4 1.971368  91 4.43 2.140 16.70  0 manual    5    2\n#> Lotus Europa        30.4   4 1.558413 113 3.77 1.513 16.90  1 manual    5    2\n#> Ford Pantera L      15.8   8 5.751872 264 4.22 3.170 14.50  0 manual    5    4\n#> Ferrari Dino        19.7   6 2.376130 175 3.62 2.770 15.50  0 manual    5    6\n#> Maserati Bora       15.0   8 4.932517 335 3.54 3.570 14.60  0 manual    5    8\n#> Volvo 142E          21.4   4 1.982839 109 4.11 2.780 18.60  1 manual    4    2\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(mtcars)\n```\n:::\n\n\nCompare and contrast the `map2()` approach to this `map()` approach:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n```\n:::\n\n\nAnswer: the `map2()` code applies the anonymous functions to the corresponding column in `mtcars` based on their name in the list:\n\n- `mtcars[nm]` is equivalent to `mtcars[c(\"disp\", \"am\")]`, so the code is modifying those two\n  columns\n- the mapping function, `function(f, var) f(var)` is run as `f(mtcars[[\"disp\"]])` and\n  `f(mtcars[[\"am\"]])`, with the corresponding function in `trans` as `f`, since `trans` and\n  `mtcars[nm]` are passed as parameters to the function\n\nThe equivalent `map()` approach isn't as clean: it's harder to understand what `map()` is doing.\n\nAR Solutions: In the first approach\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\n```\n:::\n\n\nthe list of the 2 functions (`trans`) and the 2 appropriately selected data frame columns (`mtcars[nm]`) are supplied to `map2()`. `map2()` creates an anonymous function (`f(var)`) which applies the functions to the variables when `map2()` iterates over their (similar) indices. On the left-hand side, the respective 2 elements of `mtcars` are being replaced by their new transformations.\n\nThe `map()` variant\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n```\n:::\n\n\ndoes basically the same. However, it directly iterates over the names (`nm`) of the transformations. Therefore, the data frame columns are selected during the iteration.\n\nBesides the iteration pattern, the approaches differ in the possibilities for appropriate argument naming in the `.f` argument. In the `map2()` approach we iterate over the elements of `x` and `y`. Therefore, it is possible to choose appropriate placeholders like `f` and `var`. This makes the anonymous function more expressive at the cost of making it longer. We think using the formula interface in this way is preferable compared to the rather cryptic `mtcars[nm] <- map2(trans, mtcars[nm], ~ .x(.y))`.\n\nIn the `map()` approach we map over the variable names. It is therefore not possible to introduce placeholders for the function and variable names. The formula syntax together with the `.x` pronoun is pretty compact. The object names and the brackets clearly indicate the application of transformations to specific columns of `mtcars`. In this case the iteration over the variable names comes in handy, as it highlights the importance of matching between `trans` and `mtcars` element names. Together with the replacement form on the left-hand side, this line is relatively easy to inspect.\n\nTo summarise, in situations where `map()` and `map2()` provide solutions for an iteration problem, several points may be considered before deciding for one or the other approach.\n\n---\n\n4.  What does `write.csv()` return, i.e. what happens if you use it with \n    `map2()` instead of `walk2()`?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nmap2(cyls, paths, write.csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $`4`\n#> NULL\n#> \n#> $`6`\n#> NULL\n#> \n#> $`8`\n#> NULL\n```\n\n\n:::\n:::\n\n\nAnswer: `write.csv()` is designed to return `NULL`, invisibly. While `walk2()` hides the `NULL` return values, `map2()` does not.\n\nAR Solutions: `write.csv()` returns `NULL`. As we call the function for its side effect (creating a CSV file), `walk2()` would be appropriate here. Otherwise, we receive a rather uninformative list of `NULL`s.\n\n---\n\n## 9.6.3 Exercises\n\n1.  Why isn't `is.na()` a predicate function? What base R function is closest\n    to being a predicate version of `is.na()`?\n\nAnswer: `is.na(x)` returns `logical(0)` when `x` is `NULL`, which violates the rule that predicate functions only return `TRUE` or `FALSE`. `anyNA(x, recursive = FALSE)` appears to be a predicate version of `is.na()`.\n\nAR Solutions: `is.na()` is not a predicate function, because it returns a logical _vector_ the same length as the input, not a single `TRUE` or `FALSE`.\n\n`anyNA()` is the closest equivalent because it always returns a single `TRUE` or `FALSE` if there are any missing values present. You could also imagine an `allNA()` which would return `TRUE` if all values were missing, but that's considerably less useful so base R does not provide it.\n\n---\n\n2.  `simple_reduce()` has a problem when `x` is length 0 or length 1. Describe\n    the source of the problem and how you might go about fixing it.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\n```\n:::\n\n\nAnswer: using `seq()` results in a backwards count when `x` is length 0 or 1.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nseq(2, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2 1 0\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(2, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2 1\n```\n\n\n:::\n:::\n\n\nThe fix is to check the length of `x` and return itself when length is 0 and throw an error when length is 1, as `reduce()` does.\n\nAR Solutions: The loop inside `simple_reduce()` always starts with the index 2, and `seq()` can count both up _and_ down:\n\nTherefore, subsetting length-0 and length-1 vectors via `[[` will lead to a *subscript out of bounds* error. To avoid this, we allow `simple_reduce()` to return before the for loop is started and include a default argument for 0-length vectors.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimple_reduce <- function(x, f, default) {\n  if (length(x) == 0L) {\n    return(default)\n  }\n  if (length(x) == 1L) {\n    return(x[[1L]])\n  }\n\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n\n  out\n}\n```\n:::\n\n\nOur new `simple_reduce()` now works as intended:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntry(simple_reduce(integer(0), `+`))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error in simple_reduce(integer(0), `+`) : \n#>   argument \"default\" is missing, with no default\n```\n\n\n:::\n\n```{.r .cell-code}\nsimple_reduce(integer(0), `+`, default = 0L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nsimple_reduce(1, `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nsimple_reduce(1:3, `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 6\n```\n\n\n:::\n:::\n\n\n---\n\n3.  Implement the `span()` function from Haskell: given a list `x` and a \n    predicate function `f`, `span(x, f)` returns the location of the longest \n    sequential run of elements where the predicate is true. (Hint: you \n    might find `rle()` helpful.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntest <- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:39))\ntest2 <- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:40))\n\nspan <- function(x, f) {\n  runs <- rle(map_lgl(x, f))\n  max_true <- max_index <- 0\n  index <- 1\n  for (i in seq_along(runs$values)) {\n    if (runs$values[i] && runs$lengths[i] > max_true) {\n      max_true <- runs$lengths[i]\n      max_index <- index\n    }\n    index <- index + runs$lengths[i]\n  }\n  max_index\n}\n\nspan(test, is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 22\n```\n\n\n:::\n\n```{.r .cell-code}\nspan(test2, is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 47\n```\n\n\n:::\n\n```{.r .cell-code}\nspan(1, is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nspan(\"a\", is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nspan(list(\"a\", 1:10, 1:20), is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions: Our `span_r()` function returns the indices of the (first occurring) longest sequential run of elements where the predicate is true. If the predicate is never true, the longest run has length 0, in which case we return `integer(0)`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nspan_r <- function(x, f) {\n  idx <- unname(map_lgl(x, ~ f(.x)))\n  rle <- rle(idx)\n\n  # Check if the predicate is never true\n  if (!any(rle$values)) {\n    return(integer(0))\n  }\n\n  # Find the length of the longest sequence of true values\n  longest <- max(rle$lengths[rle$values])\n  # Find the position of the (first) longest run in rle\n  longest_idx <- which(rle$values & rle$lengths == longest)[1]\n\n  # Add up all lengths in rle before the longest run\n  ind_before_longest <- sum(rle$lengths[seq_len(longest_idx - 1)])\n\n  out_start <- ind_before_longest + 1L\n  out_end <- ind_before_longest + longest\n  out_start:out_end\n}\n\n# Check that it works\nspan_r(c(0, 0, 0, 0, 0), is.na)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> integer(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nspan_r(c(NA, 0, 0, 0, 0), is.na)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nspan_r(c(NA, 0, NA, NA, NA), is.na)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3 4 5\n```\n\n\n:::\n:::\n\n\nNotes: AR Solutions shows how to find the index of the longest sequence using `which()`, which is new to me, and returns more information by returning indexes of the entire span. The AR Solutions approach is also significantly faster (which I did not expect).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbench::mark(span_r(test2, is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                     min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 span_r(test2, is.numeric)   50.8µs   53.5µs    17982.    4.01KB     62.4\n```\n\n\n:::\n\n```{.r .cell-code}\nbench::mark(span(test2, is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                   min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>              <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 span(test2, is.numeric)   67.2µs   70.9µs    13899.    4.01KB     20.8\n```\n\n\n:::\n:::\n\n\n---\n\n4.  Implement `arg_max()`. It should take a function and a vector of inputs, \n    and return the elements of the input where the function returns the highest \n    value. For example, `arg_max(-10:5, function(x) x ^ 2)` should return -10.\n    `arg_max(-5:5, function(x) x ^ 2)` should return `c(-5, 5)`.\n    Also implement the matching `arg_min()` function.\n\nAnswer: code below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\narg_max <- function(x, f) {\n  val <- map_dbl(x, f)\n  val_max <- max(val)\n  x[which(val == val_max)]\n}\n\narg_max(-10:5, function(x) x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -10\n```\n\n\n:::\n\n```{.r .cell-code}\narg_max(-5:5, function(x) x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -5  5\n```\n\n\n:::\n\n```{.r .cell-code}\narg_min <- function(x, f) {\n  val <- map_dbl(x, f)\n  val_min <- min(val)\n  x[which(val == val_min)]\n}\n\narg_min(-10:5, function(x) x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\narg_min(c(-5:-1, 1:5), function(x) x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -1  1\n```\n\n\n:::\n:::\n\n\nAR Solutions: Both functions take a vector of inputs and a function as an argument. The function output is then used to subset the input accordingly.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\narg_max <- function(x, f) {\n  y <- map_dbl(x, f)\n  x[y == max(y)]\n}\n\narg_min <- function(x, f) {\n  y <- map_dbl(x, f)\n  x[y == min(y)]\n}\n\narg_max(-10:5, function(x) x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -10\n```\n\n\n:::\n\n```{.r .cell-code}\narg_min(-10:5, function(x) x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0\n```\n\n\n:::\n:::\n\n\nNotes: using `which()` is unnecessary, AR Solutions is a better approach.\n\n---\n\n5.  The function below scales a vector so it falls in the range [0, 1]. How\n    would you apply it to every column of a data frame? How would you apply it \n    to every numeric column in a data frame?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n```\n:::\n\n\nAnswer: code below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# every column\nmodify(mtcars, scale01)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>          mpg cyl       disp         hp       drat         wt       qsec vs am\n#> 1  0.4510638 0.5 0.22175106 0.20494700 0.52534562 0.28304781 0.23333333  0  1\n#> 2  0.4510638 0.5 0.22175106 0.20494700 0.52534562 0.34824853 0.30000000  0  1\n#> 3  0.5276596 0.0 0.09204290 0.14487633 0.50230415 0.20634109 0.48928571  1  1\n#> 4  0.4680851 0.5 0.46620105 0.20494700 0.14746544 0.43518282 0.58809524  1  0\n#> 5  0.3531915 1.0 0.72062859 0.43462898 0.17972350 0.49271286 0.30000000  0  0\n#> 6  0.3276596 0.5 0.38388626 0.18727915 0.00000000 0.49782664 0.68095238  1  0\n#> 7  0.1659574 1.0 0.72062859 0.68197880 0.20737327 0.52595244 0.15952381  0  0\n#> 8  0.5957447 0.0 0.18857570 0.03533569 0.42857143 0.42879059 0.65476190  1  0\n#> 9  0.5276596 0.0 0.17385882 0.15194346 0.53456221 0.41856303 1.00000000  1  0\n#> 10 0.3744681 0.5 0.24070841 0.25088339 0.53456221 0.49271286 0.45238095  1  0\n#> 11 0.3148936 0.5 0.24070841 0.25088339 0.53456221 0.49271286 0.52380952  1  0\n#> 12 0.2553191 1.0 0.51060115 0.45229682 0.14285714 0.65379698 0.34523810  0  0\n#> 13 0.2936170 1.0 0.51060115 0.45229682 0.14285714 0.56686269 0.36904762  0  0\n#> 14 0.2042553 1.0 0.51060115 0.45229682 0.14285714 0.57964715 0.41666667  0  0\n#> 15 0.0000000 1.0 1.00000000 0.54063604 0.07834101 0.95551010 0.41428571  0  0\n#> 16 0.0000000 1.0 0.97006735 0.57597173 0.11059908 1.00000000 0.39523810  0  0\n#> 17 0.1829787 1.0 0.92017960 0.62897527 0.21658986 0.97980056 0.34761905  0  0\n#> 18 0.9361702 0.0 0.01895735 0.04946996 0.60829493 0.17565840 0.59166667  1  1\n#> 19 0.8510638 0.0 0.01147418 0.00000000 1.00000000 0.02608029 0.47857143  1  1\n#> 20 1.0000000 0.0 0.00000000 0.04593640 0.67281106 0.08233188 0.64285714  1  1\n#> 21 0.4723404 0.0 0.12222499 0.15901060 0.43317972 0.24341601 0.65595238  1  0\n#> 22 0.2170213 1.0 0.61586431 0.34628975 0.00000000 0.51316799 0.28214286  0  0\n#> 23 0.2042553 1.0 0.58094288 0.34628975 0.17972350 0.49143442 0.33333333  0  0\n#> 24 0.1234043 1.0 0.69568471 0.68197880 0.44700461 0.59498849 0.10833333  0  0\n#> 25 0.3744681 1.0 0.82040409 0.43462898 0.14746544 0.59626694 0.30357143  0  0\n#> 26 0.7191489 0.0 0.01970566 0.04946996 0.60829493 0.10790079 0.52380952  1  1\n#> 27 0.6638298 0.0 0.12272387 0.13780919 0.76958525 0.16031705 0.26190476  0  1\n#> 28 0.8510638 0.0 0.05986530 0.21554770 0.46543779 0.00000000 0.28571429  1  1\n#> 29 0.2297872 1.0 0.69817910 0.74911661 0.67281106 0.42367681 0.00000000  0  1\n#> 30 0.3957447 0.5 0.18433525 0.43462898 0.39631336 0.32140118 0.11904762  0  1\n#> 31 0.1957447 1.0 0.57345972 1.00000000 0.35944700 0.52595244 0.01190476  0  1\n#> 32 0.4680851 0.0 0.12446994 0.20141343 0.62211982 0.32395807 0.48809524  1  1\n#>    gear      carb\n#> 1   0.5 0.4285714\n#> 2   0.5 0.4285714\n#> 3   0.5 0.0000000\n#> 4   0.0 0.0000000\n#> 5   0.0 0.1428571\n#> 6   0.0 0.0000000\n#> 7   0.0 0.4285714\n#> 8   0.5 0.1428571\n#> 9   0.5 0.1428571\n#> 10  0.5 0.4285714\n#> 11  0.5 0.4285714\n#> 12  0.0 0.2857143\n#> 13  0.0 0.2857143\n#> 14  0.0 0.2857143\n#> 15  0.0 0.4285714\n#> 16  0.0 0.4285714\n#> 17  0.0 0.4285714\n#> 18  0.5 0.0000000\n#> 19  0.5 0.1428571\n#> 20  0.5 0.0000000\n#> 21  0.0 0.0000000\n#> 22  0.0 0.1428571\n#> 23  0.0 0.1428571\n#> 24  0.0 0.4285714\n#> 25  0.0 0.1428571\n#> 26  0.5 0.0000000\n#> 27  1.0 0.1428571\n#> 28  1.0 0.1428571\n#> 29  1.0 0.4285714\n#> 30  1.0 0.7142857\n#> 31  1.0 1.0000000\n#> 32  0.5 0.1428571\n```\n\n\n:::\n\n```{.r .cell-code}\n# every numeric column\nmodify_if(iris, is.numeric, scale01)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#> 1     0.22222222  0.62500000   0.06779661  0.04166667     setosa\n#> 2     0.16666667  0.41666667   0.06779661  0.04166667     setosa\n#> 3     0.11111111  0.50000000   0.05084746  0.04166667     setosa\n#> 4     0.08333333  0.45833333   0.08474576  0.04166667     setosa\n#> 5     0.19444444  0.66666667   0.06779661  0.04166667     setosa\n#> 6     0.30555556  0.79166667   0.11864407  0.12500000     setosa\n#> 7     0.08333333  0.58333333   0.06779661  0.08333333     setosa\n#> 8     0.19444444  0.58333333   0.08474576  0.04166667     setosa\n#> 9     0.02777778  0.37500000   0.06779661  0.04166667     setosa\n#> 10    0.16666667  0.45833333   0.08474576  0.00000000     setosa\n#> 11    0.30555556  0.70833333   0.08474576  0.04166667     setosa\n#> 12    0.13888889  0.58333333   0.10169492  0.04166667     setosa\n#> 13    0.13888889  0.41666667   0.06779661  0.00000000     setosa\n#> 14    0.00000000  0.41666667   0.01694915  0.00000000     setosa\n#> 15    0.41666667  0.83333333   0.03389831  0.04166667     setosa\n#> 16    0.38888889  1.00000000   0.08474576  0.12500000     setosa\n#> 17    0.30555556  0.79166667   0.05084746  0.12500000     setosa\n#> 18    0.22222222  0.62500000   0.06779661  0.08333333     setosa\n#> 19    0.38888889  0.75000000   0.11864407  0.08333333     setosa\n#> 20    0.22222222  0.75000000   0.08474576  0.08333333     setosa\n#> 21    0.30555556  0.58333333   0.11864407  0.04166667     setosa\n#> 22    0.22222222  0.70833333   0.08474576  0.12500000     setosa\n#> 23    0.08333333  0.66666667   0.00000000  0.04166667     setosa\n#> 24    0.22222222  0.54166667   0.11864407  0.16666667     setosa\n#> 25    0.13888889  0.58333333   0.15254237  0.04166667     setosa\n#> 26    0.19444444  0.41666667   0.10169492  0.04166667     setosa\n#> 27    0.19444444  0.58333333   0.10169492  0.12500000     setosa\n#> 28    0.25000000  0.62500000   0.08474576  0.04166667     setosa\n#> 29    0.25000000  0.58333333   0.06779661  0.04166667     setosa\n#> 30    0.11111111  0.50000000   0.10169492  0.04166667     setosa\n#> 31    0.13888889  0.45833333   0.10169492  0.04166667     setosa\n#> 32    0.30555556  0.58333333   0.08474576  0.12500000     setosa\n#> 33    0.25000000  0.87500000   0.08474576  0.00000000     setosa\n#> 34    0.33333333  0.91666667   0.06779661  0.04166667     setosa\n#> 35    0.16666667  0.45833333   0.08474576  0.04166667     setosa\n#> 36    0.19444444  0.50000000   0.03389831  0.04166667     setosa\n#> 37    0.33333333  0.62500000   0.05084746  0.04166667     setosa\n#> 38    0.16666667  0.66666667   0.06779661  0.00000000     setosa\n#> 39    0.02777778  0.41666667   0.05084746  0.04166667     setosa\n#> 40    0.22222222  0.58333333   0.08474576  0.04166667     setosa\n#> 41    0.19444444  0.62500000   0.05084746  0.08333333     setosa\n#> 42    0.05555556  0.12500000   0.05084746  0.08333333     setosa\n#> 43    0.02777778  0.50000000   0.05084746  0.04166667     setosa\n#> 44    0.19444444  0.62500000   0.10169492  0.20833333     setosa\n#> 45    0.22222222  0.75000000   0.15254237  0.12500000     setosa\n#> 46    0.13888889  0.41666667   0.06779661  0.08333333     setosa\n#> 47    0.22222222  0.75000000   0.10169492  0.04166667     setosa\n#> 48    0.08333333  0.50000000   0.06779661  0.04166667     setosa\n#> 49    0.27777778  0.70833333   0.08474576  0.04166667     setosa\n#> 50    0.19444444  0.54166667   0.06779661  0.04166667     setosa\n#> 51    0.75000000  0.50000000   0.62711864  0.54166667 versicolor\n#> 52    0.58333333  0.50000000   0.59322034  0.58333333 versicolor\n#> 53    0.72222222  0.45833333   0.66101695  0.58333333 versicolor\n#> 54    0.33333333  0.12500000   0.50847458  0.50000000 versicolor\n#> 55    0.61111111  0.33333333   0.61016949  0.58333333 versicolor\n#> 56    0.38888889  0.33333333   0.59322034  0.50000000 versicolor\n#> 57    0.55555556  0.54166667   0.62711864  0.62500000 versicolor\n#> 58    0.16666667  0.16666667   0.38983051  0.37500000 versicolor\n#> 59    0.63888889  0.37500000   0.61016949  0.50000000 versicolor\n#> 60    0.25000000  0.29166667   0.49152542  0.54166667 versicolor\n#> 61    0.19444444  0.00000000   0.42372881  0.37500000 versicolor\n#> 62    0.44444444  0.41666667   0.54237288  0.58333333 versicolor\n#> 63    0.47222222  0.08333333   0.50847458  0.37500000 versicolor\n#> 64    0.50000000  0.37500000   0.62711864  0.54166667 versicolor\n#> 65    0.36111111  0.37500000   0.44067797  0.50000000 versicolor\n#> 66    0.66666667  0.45833333   0.57627119  0.54166667 versicolor\n#> 67    0.36111111  0.41666667   0.59322034  0.58333333 versicolor\n#> 68    0.41666667  0.29166667   0.52542373  0.37500000 versicolor\n#> 69    0.52777778  0.08333333   0.59322034  0.58333333 versicolor\n#> 70    0.36111111  0.20833333   0.49152542  0.41666667 versicolor\n#> 71    0.44444444  0.50000000   0.64406780  0.70833333 versicolor\n#> 72    0.50000000  0.33333333   0.50847458  0.50000000 versicolor\n#> 73    0.55555556  0.20833333   0.66101695  0.58333333 versicolor\n#> 74    0.50000000  0.33333333   0.62711864  0.45833333 versicolor\n#> 75    0.58333333  0.37500000   0.55932203  0.50000000 versicolor\n#> 76    0.63888889  0.41666667   0.57627119  0.54166667 versicolor\n#> 77    0.69444444  0.33333333   0.64406780  0.54166667 versicolor\n#> 78    0.66666667  0.41666667   0.67796610  0.66666667 versicolor\n#> 79    0.47222222  0.37500000   0.59322034  0.58333333 versicolor\n#> 80    0.38888889  0.25000000   0.42372881  0.37500000 versicolor\n#> 81    0.33333333  0.16666667   0.47457627  0.41666667 versicolor\n#> 82    0.33333333  0.16666667   0.45762712  0.37500000 versicolor\n#> 83    0.41666667  0.29166667   0.49152542  0.45833333 versicolor\n#> 84    0.47222222  0.29166667   0.69491525  0.62500000 versicolor\n#> 85    0.30555556  0.41666667   0.59322034  0.58333333 versicolor\n#> 86    0.47222222  0.58333333   0.59322034  0.62500000 versicolor\n#> 87    0.66666667  0.45833333   0.62711864  0.58333333 versicolor\n#> 88    0.55555556  0.12500000   0.57627119  0.50000000 versicolor\n#> 89    0.36111111  0.41666667   0.52542373  0.50000000 versicolor\n#> 90    0.33333333  0.20833333   0.50847458  0.50000000 versicolor\n#> 91    0.33333333  0.25000000   0.57627119  0.45833333 versicolor\n#> 92    0.50000000  0.41666667   0.61016949  0.54166667 versicolor\n#> 93    0.41666667  0.25000000   0.50847458  0.45833333 versicolor\n#> 94    0.19444444  0.12500000   0.38983051  0.37500000 versicolor\n#> 95    0.36111111  0.29166667   0.54237288  0.50000000 versicolor\n#> 96    0.38888889  0.41666667   0.54237288  0.45833333 versicolor\n#> 97    0.38888889  0.37500000   0.54237288  0.50000000 versicolor\n#> 98    0.52777778  0.37500000   0.55932203  0.50000000 versicolor\n#> 99    0.22222222  0.20833333   0.33898305  0.41666667 versicolor\n#> 100   0.38888889  0.33333333   0.52542373  0.50000000 versicolor\n#> 101   0.55555556  0.54166667   0.84745763  1.00000000  virginica\n#> 102   0.41666667  0.29166667   0.69491525  0.75000000  virginica\n#> 103   0.77777778  0.41666667   0.83050847  0.83333333  virginica\n#> 104   0.55555556  0.37500000   0.77966102  0.70833333  virginica\n#> 105   0.61111111  0.41666667   0.81355932  0.87500000  virginica\n#> 106   0.91666667  0.41666667   0.94915254  0.83333333  virginica\n#> 107   0.16666667  0.20833333   0.59322034  0.66666667  virginica\n#> 108   0.83333333  0.37500000   0.89830508  0.70833333  virginica\n#> 109   0.66666667  0.20833333   0.81355932  0.70833333  virginica\n#> 110   0.80555556  0.66666667   0.86440678  1.00000000  virginica\n#> 111   0.61111111  0.50000000   0.69491525  0.79166667  virginica\n#> 112   0.58333333  0.29166667   0.72881356  0.75000000  virginica\n#> 113   0.69444444  0.41666667   0.76271186  0.83333333  virginica\n#> 114   0.38888889  0.20833333   0.67796610  0.79166667  virginica\n#> 115   0.41666667  0.33333333   0.69491525  0.95833333  virginica\n#> 116   0.58333333  0.50000000   0.72881356  0.91666667  virginica\n#> 117   0.61111111  0.41666667   0.76271186  0.70833333  virginica\n#> 118   0.94444444  0.75000000   0.96610169  0.87500000  virginica\n#> 119   0.94444444  0.25000000   1.00000000  0.91666667  virginica\n#> 120   0.47222222  0.08333333   0.67796610  0.58333333  virginica\n#> 121   0.72222222  0.50000000   0.79661017  0.91666667  virginica\n#> 122   0.36111111  0.33333333   0.66101695  0.79166667  virginica\n#> 123   0.94444444  0.33333333   0.96610169  0.79166667  virginica\n#> 124   0.55555556  0.29166667   0.66101695  0.70833333  virginica\n#> 125   0.66666667  0.54166667   0.79661017  0.83333333  virginica\n#> 126   0.80555556  0.50000000   0.84745763  0.70833333  virginica\n#> 127   0.52777778  0.33333333   0.64406780  0.70833333  virginica\n#> 128   0.50000000  0.41666667   0.66101695  0.70833333  virginica\n#> 129   0.58333333  0.33333333   0.77966102  0.83333333  virginica\n#> 130   0.80555556  0.41666667   0.81355932  0.62500000  virginica\n#> 131   0.86111111  0.33333333   0.86440678  0.75000000  virginica\n#> 132   1.00000000  0.75000000   0.91525424  0.79166667  virginica\n#> 133   0.58333333  0.33333333   0.77966102  0.87500000  virginica\n#> 134   0.55555556  0.33333333   0.69491525  0.58333333  virginica\n#> 135   0.50000000  0.25000000   0.77966102  0.54166667  virginica\n#> 136   0.94444444  0.41666667   0.86440678  0.91666667  virginica\n#> 137   0.55555556  0.58333333   0.77966102  0.95833333  virginica\n#> 138   0.58333333  0.45833333   0.76271186  0.70833333  virginica\n#> 139   0.47222222  0.41666667   0.64406780  0.70833333  virginica\n#> 140   0.72222222  0.45833333   0.74576271  0.83333333  virginica\n#> 141   0.66666667  0.45833333   0.77966102  0.95833333  virginica\n#> 142   0.72222222  0.45833333   0.69491525  0.91666667  virginica\n#> 143   0.41666667  0.29166667   0.69491525  0.75000000  virginica\n#> 144   0.69444444  0.50000000   0.83050847  0.91666667  virginica\n#> 145   0.66666667  0.54166667   0.79661017  1.00000000  virginica\n#> 146   0.66666667  0.41666667   0.71186441  0.91666667  virginica\n#> 147   0.55555556  0.20833333   0.67796610  0.75000000  virginica\n#> 148   0.61111111  0.41666667   0.71186441  0.79166667  virginica\n#> 149   0.52777778  0.58333333   0.74576271  0.91666667  virginica\n#> 150   0.44444444  0.41666667   0.69491525  0.70833333  virginica\n```\n\n\n:::\n:::\n\n\nAR Solutions: To apply a function to every column of a data frame, we can use `purrr::modify()` (or `purrr::map_dfr()`), which also conveniently returns a data frame. To limit the application to numeric columns, the scoped version `modify_if()` can be used.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodify_if(mtcars, is.numeric, scale01)\n```\n:::\n\n\n---\n\n## 9.7.3 Exercises\n\n1.  How does `apply()` arrange the output? Read the documentation and perform \n    some experiments.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# experiments\nm1 <- matrix(1:4, nrow = 1)\napply(m1, 1, sum)\napply(m1, 2, sum)\napply(m1, c(1, 2), `*`, 2)\napply(m1, 1, `*`, 2)\napply(m1, 1, `*`, 2, simplify = FALSE)\napply(m1, 2, `*`, 2)\napply(m1, 1, sum, simplify = FALSE)\n\nm1a <- matrix(1:4, ncol = 1)\napply(m1a, 1, `*`, 2)\n\nm2 <- matrix(1:20, ncol = 4)\napply(m2, 1, sum)\n\nm3 <- array(1:24, dim = c(2, 3, 4))\napply(m3, 1, sum)\napply(m3, 2, sum)\napply(m3, 3, sum)\napply(m3, 1, `*`, 2)\napply(m3, 2, `*`, 2)\napply(m3, 3, `*`, 2)\napply(m3, c(1, 2, 3), `*`, 2)\n```\n:::\n\n\nAnswer: the documentation states:\n\n> If each call to `FUN` returns a vector of length `n`, and simplify is `TRUE`, then apply returns an array of dimension `c(n, dim(X)[MARGIN])` if `n > 1`. If `n` equals 1, `apply` returns a vector if `MARGIN` has length 1 and an array of `dimension dim(X)[MARGIN]` otherwise. If `n` is 0, the result has length 0 but not necessarily the 'correct' dimension.\n> \n> If the calls to `FUN` return vectors of different lengths, or if simplify is `FALSE`, apply returns a list of `length prod(dim(X)[MARGIN])` with `dim` set to `MARGIN` if this has length greater than one.\n\nWith exploration, under normal circumstances:\n\n- If `MARGIN` includes all dimensions of an array or matrix (`c(1, 2)` or `c(1, 2, 3)`), the output\n  is arranged in the same shape as the input\n- Otherwise, the return value drops a dimension if modifying a vector in place (as with `*`), or\n  returns a vector when summarizing (as with `sum`)\n- Matrices of a single row are simplified to a vector\n- Matrices of a single column are returned as a matrix\n- When `simplify = FALSE` is set, a list is returned\n\nHowever, even with all this, the \"rules\" aren't clear to me.\n\nAR Solutions: Basically `apply()` applies a function over the margins of an array. In the two-dimensional case, the margins are just the rows and columns of a matrix. Let's make this concrete.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\narr2 <- array(1:12, dim = c(3, 4))\nrownames(arr2) <- paste0(\"row\", 1:3)\ncolnames(arr2) <- paste0(\"col\", 1:4)\narr2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      col1 col2 col3 col4\n#> row1    1    4    7   10\n#> row2    2    5    8   11\n#> row3    3    6    9   12\n```\n\n\n:::\n:::\n\n\nWhen we apply the `head()` function over the first margin of `arr2()` (i.e. the rows), the results are contained in the columns of the output, transposing the array compared to the original input.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(arr2, 1, function(x) x[1:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      row1 row2 row3\n#> col1    1    2    3\n#> col2    4    5    6\n```\n\n\n:::\n:::\n\n\nAnd vice versa if we apply over the second margin (the columns):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napply(arr2, 2, function(x) x[1:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      col1 col2 col3 col4\n#> row1    1    4    7   10\n#> row2    2    5    8   11\n```\n\n\n:::\n:::\n\n\nThe output of `apply()` is organised first by the margins being operated over, then the results of the function. This can become quite confusing for higher dimensional arrays.\n\nNotes: AR Solutions' explanation is better, but the output is still confusing.\n\n---\n\n2.  What do `eapply()` and `rapply()` do? Does purrr have equivalents?\n\nAnswer: `eapply()` applies a function to named values in an environment. `rapply()` is a recursive `lapply()`. There are no equivalents in purrr.\n\nAR Solutions: `eapply()` is a variant of `lapply()`, which iterates over the (named) elements of an environment. In `purrr` there is no equivalent for `eapply()` as `purrr` mainly provides functions that operate on vectors and functions, but not on environments.\n\n`rapply()` applies a function to all elements of a list recursively. This function makes it possible to limit the application of the function to specified classes (default `classes = ANY`). One may also specify how elements of other classes should remain: as their identity (`how = replace`) or another value (`default = NULL`). The closest equivalent in `purrr` is `modify_depth()`, which allows you to modify elements at a specified depth in a nested list.\n\nNotes: I wasn't aware of `purrr::modify_depth()`.\n\n---\n\n3.  Challenge: read about the \n    [fixed point algorithm](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html#%25_idx_1096).\n    Complete the exercises using R.\n\nNote: see [archive.org](https://web.archive.org/web/20220614001903/https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html), \"Finding fixed points of functions.\"\n\nAnswer: the fixed point algorithm is defined below, with an example solution:\n\n```\n(define tolerance 0.00001)\n(define (fixed-point f first-guess)\n  (define (close-enough? v1 v2)\n    (< (abs (- v1 v2)) tolerance))\n  (define (try guess)\n    (let ((next (f guess)))\n      (if (close-enough? guess next)\n          next\n          (try next))))\n  (try first-guess))\n\n(fixed-point cos 1.0)\n0.7390822985224023\n\n(fixed-point (lambda (y) (+ (sin y) (cos y)))\n             1.0)\n1.2587315962971173\n\n(define (sqrt x)\n  (fixed-point (lambda (y) (/ x y))\n               1.0))\n```\n\nImplementation in R:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfixed_point <- function(f, x) {\n  tolerance <- 0.00001\n  close_enough <- function(v1, v2) {\n    abs(v1 - v2) < tolerance\n  }\n\n  if (close_enough(f(x), x)) {\n    f(x)\n  } else {\n    fixed_point(f, f(x))\n  }\n}\n\nfixed_point(cos, 1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.7390823\n```\n\n\n:::\n\n```{.r .cell-code}\nfixed_point(function(y) sin(y) + cos(y), 1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1.258732\n```\n\n\n:::\n:::\n\n\nAR Solutions: A number $x$ is called a fixed point of a function $f$ if it satisfies the equation $f(x) = x$. For some functions we may find a fixed point by beginning with a starting value and applying $f$ repeatedly. Here `fixed_point()` acts as a functional because it takes a function as an argument.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfixed_point_ar <- function(f, x_init, n_max = 10000, tol = 0.0001) {\n  n <- 0\n  x <- x_init\n  y <- f(x)\n\n  is_fixed_point <- function(x, y) {\n    abs(x - y) < tol\n  }\n\n  while (!is_fixed_point(x, y)) {\n    x <- y\n    y <- f(y)\n\n    # Make sure we eventually stop\n    n <- n + 1\n    if (n > n_max) {\n      stop(\"Failed to converge.\", call. = FALSE)\n    }\n  }\n\n  x\n}\n\n# Functions with fixed points\nfixed_point_ar(sin, x_init = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.08430922\n```\n\n\n:::\n\n```{.r .cell-code}\nfixed_point_ar(cos, x_init = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.7391302\n```\n\n\n:::\n\n```{.r .cell-code}\n# Functions without fixed points\nadd_one <- function(x) x + 1\ntry(fixed_point_ar(add_one, x_init = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Error : Failed to converge.\n```\n\n\n:::\n:::\n\n\nNotes: AR Solutions offers a different approach using a `while()` loop that is guaranteed to stop. My approach using recursive calls does stop eventually with a stack limit error:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfixed_point(add_one, 1)\n```\n:::\n\n\nComparing benchmarks:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbench::mark(fixed_point_ar(cos, x_init = 1, tol = 0.00001))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                          <bch:> <bch:>     <dbl> <bch:byt>    <dbl>\n#> 1 fixed_point_ar(cos, x_init = 1, to… 11.4µs 12.3µs    77860.        0B     23.4\n```\n\n\n:::\n\n```{.r .cell-code}\nbench::mark(fixed_point(cos, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression               min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>          <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 fixed_point(cos, 1)   18.9µs   20.2µs    48549.        0B     29.1\n```\n\n\n:::\n:::\n\n\nAs usual, AR Solutions is faster. :-(\n\n---\n\n# 10 Function factories\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\nA __function factory__ is a function that makes functions. Here's a very simple example: we use a function factory (`power1()`) to make two child functions (`square()` and `cube()`):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npower1 <- function(exp) {\n  function(x) {\n    x^exp\n  }\n}\nsquare <- power1(2)\ncube <- power1(3)\n```\n:::\n\n\nDon't worry if this doesn't make sense yet, it should by the end of the chapter!\n\nI'll call `square()` and `cube()` __manufactured functions__, but this is just a term to ease communication with other humans: from R's perspective they are no different to functions created any other way. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsquare(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 9\n```\n\n\n:::\n\n```{.r .cell-code}\ncube(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 27\n```\n\n\n:::\n:::\n\n\nYou have already learned about the individual components that make function factories possible:\n\n* In Section 6.2.3, you learned about R's first-class \n  functions. In R, you bind a function to a name in the same way as you bind\n  any object to a name: with `<-`.\n\n* In Section 7.4.2, you learned that a function\n  captures (encloses) the environment in which it is created.\n\n* In Section 7.4.4, you learned that a function \n  creates a new execution environment every time it is run. This environment\n  is usually ephemeral, but here it becomes the enclosing environment of \n  the manufactured function.\n\nIn this chapter, you'll learn how the non-obvious combination of these three features leads to the function factory. You'll also see examples of their usage in visualisation and statistics.\n\nOf the three main functional programming tools (functionals, function factories, and function operators), function factories are the least used. Generally, they don't tend to reduce overall code complexity but instead partition complexity into more easily digested chunks. Function factories are also an important building block for the very useful function operators, which you'll learn about in Chapter 11.\n\n## 10.2.6 Exercises\n\n1.  The definition of `force()` is simple:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nforce\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (x) \n#> x\n#> <bytecode: 0x154046040>\n#> <environment: namespace:base>\n```\n\n\n:::\n:::\n\n\nWhy is it better to `force(x)` instead of just `x`?\n\nAnswer: as the R Documentation states, 'This is semantic sugar': in other words, `force(x)` makes the intent of the call explicit, to force evaluation, whereas `x` does not.\n\nAR Solutions: As you can see `force(x)` is similar to `x`. As mentioned in *Advanced R*, we prefer this explicit form, because\n\n> using this function clearly indicates that you’re forcing evaluation, not that you’ve accidentally typed `x`.\"\n\n---\n\n2.  Base R contains two function factories, `approxfun()` and `ecdf()`. \n    Read their documentation and experiment to figure out what the functions \n    do and what they return.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 3, 6, 10, 19)\ny <- x * 2\nplot(x, y, xlim = c(0, 20), ylim = c(0, 40))\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-57-1.png){fig-align='center' width=816}\n:::\n\n```{.r .cell-code}\naf <- approxfun(x, y)\nplot(0:20, af(0:20), xlim = c(0, 20), ylim = c(0, 40))\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-57-2.png){fig-align='center' width=816}\n:::\n:::\n\n\nAnswer: `approxfun()` returns \"a function performing the linear (or constant) interpolation.\" As the example above shows, `approxfun()` provides linear interpolation that by default does not return values outside the minimum and maximum.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(ecdf(rlnorm(1000)))\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-58-1.png){fig-align='center' width=816}\n:::\n\n```{.r .cell-code}\nplot(ecdf(rnorm(1000)))\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-58-2.png){fig-align='center' width=816}\n:::\n\n```{.r .cell-code}\nplot(ecdf(runif(1000)))\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-58-3.png){fig-align='center' width=816}\n:::\n:::\n\n\n`ecdf()` \"Compute[s] an empirical cumulative distribution function\", the Empirical Cumulative Distribution Function, which is a standard statistical plot. It plots the actual observations connected by a line, which is easier to see with fewer observations:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(ecdf(runif(50)))\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-59-1.png){fig-align='center' width=816}\n:::\n:::\n\n\nAR Solutions: (Note: full solution [here](https://advanced-r-solutions.rbind.io/function-factories.html#factory-fundamentals))\n\nLet's begin with `approxfun()` as it is used within `ecdf()` as well:\n\n`approxfun()` takes a combination of data points (x and y values) as input and returns a stepwise linear (or constant) interpolation function. To find out what this means exactly, we first create a few random data points.\n\nNext, we use `approxfun()` to construct the linear and constant interpolation functions for our `x` and `y` values.\n\nWhen we apply these functions to new x values, these are mapped to the lines connecting the initial y values (linear case) or to the same y value as for the next smallest initial x value (constant case).\n\nHowever, both functions are only defined within `range(x)`.\n\nTo change this behaviour, one can set `rule = 2`. This leads to the result that for values outside of `range(x)` the boundary values of the function are returned.\n\nAnother option is to customise the return values as individual constants for each side via `yleft` and/or `yright`.\n\nFurther, `approxfun()` provides the option to shift the y values for `method = \"constant\"` between their left and right values. According to the documentation this indicates a compromise between left- and right-continuous steps.\n\nFinally, the `ties` argument allows to aggregate y values if multiple ones were provided for the same x value. For example, in the following line we use `mean()` to aggregate these y values before they are used for the interpolation `approxfun(x = c(1,1,2), y = 1:3, ties = mean)`.\n\nNext, we focus on `ecdf()`. \"ecdf\" is an acronym for empirical cumulative distribution function. For a numeric vector of density values, `ecdf()` initially creates the (x, y) pairs for the nodes of the density function and then passes these pairs to `approxfun()`, which gets called with specifically adapted settings (`approxfun(vals, cumsum(tabulate(match(x, vals)))/n, method = \"constant\", yleft = 0, yright = 1, f = 0, ties = \"ordered\")`). \n\nNew values are then mapped on the y value of the next smallest x value from within the initial input.\n\n---\n\n3.  Create a function `pick()` that takes an index, `i`, as an argument and \n    returns a function with an argument `x` that subsets `x` with `i`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npick <- function(i) {\n  function(x) x[[i]]\n}\n\nx <- 2:8\npick(1)(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# should be equivalent to\nx[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nunlist(lapply(mtcars, pick(5)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#>  18.70   8.00 360.00 175.00   3.15   3.44  17.02   0.00   0.00   3.00   2.00\n```\n\n\n:::\n\n```{.r .cell-code}\n# should be equivalent to\nunlist(lapply(mtcars, function(x) x[[5]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#>  18.70   8.00 360.00 175.00   3.15   3.44  17.02   0.00   0.00   3.00   2.00\n```\n\n\n:::\n:::\n\n\nAnswer: code above. Modified to use `unlist()` to shorten output.\n\nAR Solutions: In this exercise `pick(i)` acts as a function factory, which returns the required subsetting function.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npick <- function(i) {\n  force(i)\n  function(x) x[[i]]\n}\n```\n:::\n\n\nNote: the AR Solutions version appropriately uses `force()`.\n\n---\n\n4.  Create a function that creates functions that compute the i^th^\n    [central moment](https://en.wikipedia.org/wiki/Central_moment) of a numeric \n    vector. You can test it by running the following code:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmoment <- function(i) {\n  function(x) mean((x - mean(x))^i)\n}\n\nm1 <- moment(1)\nm2 <- moment(2)\nx <- runif(100)\nstopifnot(\n  all.equal(m1(x), 0),\n  all.equal(m2(x), var(x) * 99 / 100)\n)\nbench::mark(m2(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 m2(x)        3.16µs   3.53µs   259192.      848B     25.9\n```\n\n\n:::\n:::\n\n\nAnswer: code above, following the formula $E[(X - E[X])^i]$, where $E$ is the [expected value](https://en.wikipedia.org/wiki/Expected_value), ie the *mean*.\n\nAR Solutions: The first moment is closely related to the mean and describes the average deviation from the mean, which is 0 (within numerical margin of error). The second moment describes the variance of the input data. If we want to compare it to `var()`, we need to undo [Bessel's correction](https://en.wikipedia.org/wiki/Bessel%27s_correction) by multiplying with $\\frac{N-1}{N}$.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmoment <- function(i) {\n  force(i)\n\n  function(x) sum((x - mean(x))^i) / length(x)\n}\nm1 <- moment(1)\nm2 <- moment(2)\nx <- runif(100)\nall.equal(m1(x), 0) # removed stopifnot() for clarity\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(m2(x), var(x) * 99 / 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nbench::mark(m2(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 m2(x)        2.09µs   2.38µs   393500.      848B     39.4\n```\n\n\n:::\n:::\n\n\nNote: isn't `sum() / length()` just `mean()`? For fun, compare `bench::mark()` (above). Curses, foiled again!\n\n---\n\n5.  What happens if you don't use a closure? Make predictions, then verify with \n    the code below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ni <- 0\nnew_counter2 <- function() {\n  i <<- i + 1\n  i\n}\n```\n:::\n\n\nAnswer: `i` should increment by 1 every time `new_counter2()` is run, but can be altered by changing the global variable `i`. [Correct!]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_counter2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_counter2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_counter2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\ni <- 5\nnew_counter2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\ni <- 0\n```\n:::\n\n\nAR Solutions: Without the captured and encapsulated environment of a closure the counts will be stored in the global environment. Here they can be overwritten or deleted as well as interfere with other counters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_counter2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nnew_counter2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\ni <- 0\nnew_counter2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\ni <- 0\n```\n:::\n\n\n---\n\n6.  What happens if you use `<-` instead of `<<-`? Make predictions, then verify \n    with the code below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_counter3 <- function() {\n  i <- 0\n  function() {\n    i <- i + 1\n    i\n  }\n}\n```\n:::\n\n\nAnswer: functions created by `new_counter3()` starts with a new value of `i <- 0` each time, and will always return 1. [Correct!]\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnc3 <- new_counter3()\n\nnc3()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nnc3()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n:::\n\n\nAR Solutions: Without the super assignment `<<-`, the counter will always return 1. The counter always starts in a new execution environment within the same enclosing environment, which contains an unchanged value for `i` (in this case it remains 0).\n\n---\n\n## 10.3.4 Exercises\n\n1.  Compare and contrast `ggplot2::label_bquote()` with \n    `scales::number_format()`\n\nAnswer: `ggplot2::label_bquote()` \"offers a flexible way of labelling facet rows or columns with plotmath expressions. Backquoted variables will be replaced with their value in the facet.\"\n\nThe example shows a scatterplot of weight and miles per gallon faceted by engine type (v-shaped).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  facet_grid(vs ~ ., labeller = label_bquote(vs == .(vs)))\n```\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-69-1.png){fig-align='center' width=816}\n:::\n:::\n\n\n`scales::number_format()` has been superseded by `scales::label_number()`:\n\n\"Use `label_number()` force decimal display of numbers (i.e. don't use scientific notation). `label_comma()` is a special case that inserts a comma every three digits.\"\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndemo_continuous(c(-1e6, 1e6), labels = label_number())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> scale_x_continuous(labels = label_number())\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](advanced-r-2_files/figure-html/unnamed-chunk-70-1.png){fig-align='center' width=816}\n:::\n:::\n\n\n`ggplot2::label_bquote()` is a special-purpose function for facets, while `scales::number_format()` can be applied more generally. Both are function factories that can be applied to changing labels.\n\nAR Solutions: Both functions will help you in styling your output, e.g. in your plots and they do this by returning the desired formatting function to you.\n\n`ggplot2::label_bquote()` takes relatively straightforward [plotmath](https://stat.ethz.ch/R-manual/R-patched/library/grDevices/html/plotmath.html) expressions and uses them for faceting labels in `{ggplot2}`. Because this function is used in `{ggplot2}` it needs to return a function of `class = \"labeller\"`.\n\n`scales::number_format()` initially `force()`s the computation of all parameters. It's essentially a parametrised wrapper around `scales::number()` and will help you format numbers appropriately. It will return a simple function.\n\n---\n\n## 10.4.4 Exercises\n\n1.  In `boot_model()`, why don't I need to force the evaluation of `df` \n    or `model`?\n\nAnswer: assuming `model` actually refers to `formula`, both are evaluated when `mod <- lm(formula, data = df)` is run.\n\nAR Solutions: `boot_model()` ultimately returns a function, and whenever you return a function you need to make sure all the inputs are explicitly evaluated. Here that happens automatically because we use `df` and `formula` in `lm()` before returning the function.\n\n---\n\n2.  Why might you formulate the Box-Cox transformation like this?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nboxcox3 <- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x^lambda - 1) / lambda\n    }\n  }\n}\n```\n:::\n\n\nAnswer: `boxcox3` returns a function where `x` is fixed and `lambda` can vary, which allows for easy exploration of different values of lambda, for example using `lapply()` or `optimize()`.\n\nAR Solutions: `boxcox3()` returns a function where `x` is fixed (though it is not forced, so it may be manipulated later). This allows us to apply and test different transformations for different inputs and give them a descriptive name.\n\nNote: I missed the fact that `x` is not forced.\n\n---\n\n3.  Why don't you need to worry that `boot_permute()` stores a copy of the \n    data inside the function that it generates?\n\nAnswer: as R is copy-on-write, and `boot_permute()` stores an unmodified copy of the data, the function contains only a reference to the original data.\n\nAR Solutions: We don't need to worry that it stores a copy of the data, because it actually doesn't store one; it's just a name that points to the same underlying object in memory.\n\n---\n\n4.  How much time does `ll_poisson2()` save compared to `ll_poisson1()`?\n    Use `bench::mark()` to see how much faster the optimisation occurs.\n    How does changing the length of `x` change the results?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nll_poisson1 <- function(x) {\n  n <- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\n\nll_poisson2 <- function(x) {\n  n <- length(x)\n  sum_x <- sum(x)\n  c <- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\n\nx1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\n\nbench::mark(optimize(ll_poisson1(x1), c(0, 100), maximum = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                          <bch:> <bch:>     <dbl> <bch:byt>    <dbl>\n#> 1 optimize(ll_poisson1(x1), c(0, 100… 12.7µs 13.6µs    70314.    12.8KB     21.1\n```\n\n\n:::\n\n```{.r .cell-code}\nbench::mark(optimize(ll_poisson2(x1), c(0, 100), maximum = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                          <bch:> <bch:>     <dbl> <bch:byt>    <dbl>\n#> 1 optimize(ll_poisson2(x1), c(0, 100… 7.01µs 7.46µs   128806.        0B     25.8\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- rpois(1e3, 100L)\nbench::mark(optimize(ll_poisson1(x), c(0, 100), maximum = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                           <bch> <bch:>     <dbl> <bch:byt>    <dbl>\n#> 1 optimize(ll_poisson1(x), c(0, 100),… 216µs  224µs     4449.     110KB     10.2\n```\n\n\n:::\n\n```{.r .cell-code}\nbench::mark(optimize(ll_poisson2(x), c(0, 100), maximum = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 6\n#>   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>                          <bch:> <bch:>     <dbl> <bch:byt>    <dbl>\n#> 1 optimize(ll_poisson2(x), c(0, 100)… 22.3µs 23.8µs    41237.    7.86KB     8.25\n```\n\n\n:::\n:::\n\n\n\nAnswer: `ll_poisson2()` is nearly twice as fast with `x1` and nearly 10 times as fast when the length of `x` is 100.\n\nNotes: consulting AR Solutions was needed to understand how to benchmark the two functions.\n\nAR Solutions:\n\nA benchmark on `x1` reveals a performance improvement of factor 2 for `ll_poisson2()` over `ll_poisson1()`\n\nAs the redundant calculations within `ll_poisson1()` become more expensive with growing length of `x1`, we expect even further relative performance improvements for `ll_poisson2()`. The following benchmark reveals a relative performance improvement of factor 20 for `ll_poisson2()` when `x1` is of length 100,000.\n\n---\n\n## 10.5.1 Exercises\n\n1. Which of the following commands is equivalent to `with(x, f(z))`?\n\n    (a) `x$f(x$z)`.\n    (b) `f(x$z)`.\n    (c) `x$f(z)`.\n    (d) `f(z)`.\n    (e) It depends.\n\nAnswer: (e). depending on the value of `x`, it could be any of (a) through (d).\n\nAR Solutions: (e) \"It depends\" is the correct answer. Usually `with()` is used with a data frame, so you'd usually expect (b), but if `x` is a list, it could be any of the options.\n\n---\n\n2. Compare and contrast the effects of `env_bind()` vs. `attach()` for the \n   following code.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> The following objects are masked from package:base:\n#> \n#>     mean, sum\n```\n\n\n:::\n\n```{.r .cell-code}\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\")\nenv_unbind(globalenv(), names(funs))\n```\n:::\n\n\nAnswer: `attach()` places the function names in the search path, and the `env_bind()` code places the function names in the global environment. Both have the effect of masking `mean()` and `sum()`, but as the chapter points out, when unbinding, \"there’s no guarantee that they haven’t been rebound in the meantime, and you might be deleting an object that someone else created.\"\n\nAR Solutions: `attach()` adds `funs` to the search path. Therefore, the provided functions are found before their respective versions from the `{base}` package. Further, they cannot get accidentally overwritten by similar named functions in the global environment. One annoying downside of using `attach()` is the possibility to attach the same object multiple times, making it necessary to call `detach()` equally often.\n\nIn contrast `rlang::env_bind()` just adds the functions in `fun` to the global environment. No further side effects are introduced, and the functions are overwritten when similarly named functions are defined.\n\nNotes: AR Solutions provides a more complete answer.\n\n---\n\n# 11 Function operators\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\nIn this chapter, you'll learn about function operators. A __function operator__ is a function that takes one (or more) functions as input and returns a function as output. The following code shows a simple function operator, `chatty()`. It wraps a function, making a new function that prints out its first argument. You might create a function like this because it gives you a window to see how functionals, like `map_int()`, work.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchatty <- function(f) {\n  force(f)\n\n  function(x, ...) {\n    res <- f(x, ...)\n    cat(\"Processing \", x, \"\\n\", sep = \"\")\n    res\n  }\n}\nf <- function(x) x^2\ns <- c(3, 2, 1)\npurrr::map_dbl(s, chatty(f))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Processing 3\n#> Processing 2\n#> Processing 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 9 4 1\n```\n\n\n:::\n:::\n\n\nFunction operators are closely related to function factories; indeed they're just a function factory that takes a function as input. Like factories, there's nothing you can't do without them, but they often allow you to factor out complexity in order to make your code more readable and reusable. \n\nFunction operators are typically paired with functionals. If you're using a for-loop, there's rarely a reason to use a function operator, as it will make your code more complex for little gain.\n\nIf you're familiar with Python, decorators is just another name for function operators.\n\n## 11.2.3 Exercises\n\n1.  Base R provides a function operator in the form of `Vectorize()`. \n    What does it do? When might you use it?\n\nAnswer: according to the R documentation, \"`Vectorize` creates a function wrapper that vectorizes the action of its argument `FUN`.\" \"The arguments named in the `vectorize.args` argument to `Vectorize` are the arguments passed in the `...` list to `mapply`. Only those that are actually passed will be vectorized; default values will not.\" and returns \"A function with the same arguments as `FUN`, wrapping a call to `mapply`.\"\n\nIn other words, it is a function operator that uses `mapply()` to iterate across the arguments. This is potentially simpler to understand than use of `mapply()`.\n\nIn the R documentation example, the vectorized `rep.int` is called for each pair of values: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvrep <- Vectorize(rep.int)\nvrep(1:4, 4:1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#> [1] 1 1 1 1\n#> \n#> [[2]]\n#> [1] 2 2 2\n#> \n#> [[3]]\n#> [1] 3 3\n#> \n#> [[4]]\n#> [1] 4\n```\n\n\n:::\n:::\n\n\nAR Solutions: In R a lot of functions are \"vectorised\". Vectorised has two meanings. First, it means (broadly) that a function inputs a vector or vectors and does something to each element. Secondly, it usually implies that these operations are implemented in a compiled language such as C or Fortran, so that the implementation is very fast.\n\nHowever, despite what the function's name implies, `Vectorize()` is not able to speed up the provided function. It rather changes the input format of the supplied arguments (`vectorize.args`), so that they can be iterated over.\n\n`Vectorize()` provides a convenient and concise notation to iterate over multiple arguments but has some major drawbacks that mean you generally shouldn't use it. See [this post](https://www.jimhester.com/post/2018-04-12-vectorize/) for more details.\n\nNotes: Jim Hester's article points out that most R functions are already vectorized, including `paste()`!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncolor <- c(\"blue\", \"red\", \"green\")\nobject <- c(\"ball\", \"hat\", \"coat\")\nname <- c(\"Sally\", \"Hank\", \"Darla\")\n\npaste(\"A\", color, object, \"for\", name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"A blue ball for Sally\"  \"A red hat for Hank\"     \"A green coat for Darla\"\n```\n\n\n:::\n:::\n\n\nIt also argues against use of `Vectorize()` because a) the functions it generates are not type stable, b) obfuscates the function code, c) can degrade performance, and d) can't improve performance.\n\nHe recommends using existing vectorized functions and either `vapply()` or `map()`.\n\n---\n\n2.  Read the source code for `possibly()`. How does it work?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npossibly\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (.f, otherwise = NULL, quiet = TRUE) \n#> {\n#>     .f <- as_mapper(.f)\n#>     force(otherwise)\n#>     check_bool(quiet)\n#>     function(...) {\n#>         tryCatch(.f(...), error = function(e) {\n#>             if (!quiet) \n#>                 message(\"Error: \", conditionMessage(e))\n#>             otherwise\n#>         })\n#>     }\n#> }\n#> <bytecode: 0x114afc3d8>\n#> <environment: namespace:purrr>\n```\n\n\n:::\n:::\n\n\nAnswer: `possibly()` returns a function that uses `tryCatch()` to return `otherwise` if the mapper `.f` errors, unless interrupted, forcing evaluation of `otherwise` before the mapper is called.\n\nAR Solutions: `possibly()` modifies functions to return a specified default value (`otherwise`) in case of an error and to suppress any error messages (`quiet = TRUE`).\n\nWhile reading the source code, we notice that `possibly()` internally uses `purrr::as_mapper()`. This enables users to supply not only functions, but also formulas or atomics via the same syntax as known from other functions in the `{purrr}` package. Besides this, the new default value (`otherwise`) gets evaluated once to make it (almost) immutable.\n\nThe main functionality of `possibly()` is provided by `base::tryCatch()`. In this part the supplied function (`.f`) gets wrapped and the error and interrupt handling are specified.\n\n---\n\n3.  Read the source code for `safely()`. How does it work?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsafely\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (.f, otherwise = NULL, quiet = TRUE) \n#> {\n#>     .f <- as_mapper(.f)\n#>     force(otherwise)\n#>     check_bool(quiet)\n#>     function(...) capture_error(.f(...), otherwise, quiet)\n#> }\n#> <bytecode: 0x113f941c8>\n#> <environment: namespace:purrr>\n```\n\n\n:::\n\n```{.r .cell-code}\npurrr:::capture_error\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> function (code, otherwise = NULL, quiet = TRUE) \n#> {\n#>     tryCatch(list(result = code, error = NULL), error = function(e) {\n#>         if (!quiet) \n#>             message(\"Error: \", conditionMessage(e))\n#>         list(result = otherwise, error = e)\n#>     })\n#> }\n#> <bytecode: 0x113f20428>\n#> <environment: namespace:purrr>\n```\n\n\n:::\n:::\n\n\nAnswer: `safely()` returns a function that uses the internal `capture_error()` function to store the evaluation of the mapper `.f` in `result`, and any error in `error`.\n\nAR Solutions: `safely()` modifies functions to return a list, containing the elements `result` and `error`. It works in a similar fashion as `possibly()` and besides using `as_mapper()`, `safely()` also provides the `otherwise` and `quiet` arguments. However, in order to provide the result and the error in a consistent way, the `tryCatch()` part of the implementation returns a list with similar structure for both cases. In the case of successful evaluation `error` equals `NULL` and in case of an error `result` equals `otherwise`, which is `NULL` by default.\n\nAs the `tryCatch()` part is hidden in the internal `purrr:::capture_output()` function, we provide it here in addition to `safely()`.\n\nTake a look at *Advanced R* or the documentation of `safely()` to see how you can take advantage of this behaviour, e.g. when fitting many models.\n\n---\n\n## 11.3.1 Exercises\n\n1.  Weigh the pros and cons of \n    `download.file %>% dot_every(10) %>% delay_by(0.1)` versus\n    `download.file %>% delay_by(0.1) %>% dot_every(10)`.\n\nAnswer: in the first version, `download.file %>% dot_every(10) %>% delay_by(0.1)`, `delay_by` is the outer function, so a delay is added after the dot is written. In the second version, a dot is added after the delay. The first version seems better since the feedback dots aren't delayed.\n\nAR Solutions: Both commands will print a dot every 10 downloads and will take the same amount of time to run, so the differences may seem quite subtle.\n\nIn the first case, first the dot functionality is added to `download.file()`. Then the delay is added to this already tweaked function. This implies, that the printing of the dot will also be delayed, and the first dot will be printed as soon as the download for the 10th URL starts.\n\nIn the latter case the delay is added first and the dot-functionality is wrapped around it. This order will print the first dot immediately after the 9th download is finished, then the short delay occurs before the 10th download actually starts.\n\nNote: the first case seems like the better option.\n\n---\n\n2.  Should you memoise `file.download()`? Why or why not?\n\nAnswer: `download.file()` should not be memoised! As mentioned in the chapter, the function is not pure (the output doesn't depend only on the input), and has side effects (saving a file to disk).\n\nAR Solutions: Memoising `file.download()` will only work if the files are immutable, i.e. if the file at a given URL is always the same. There's no point memoising unless this is true. Even if this is true, however, memoise has to store the results in memory, and large files will potentially take up a lot of memory.\n\nThis implies that it's probably not beneficial to memoise `file.download()` in most cases. The only exception is if you are downloading small files many times, and the file at a given URL is guaranteed not to change.\n\nNote: AR Solutions offers a reasonable exception case when memoising makes sense.\n\n---\n\n3.  Create a function operator that reports whenever a file is created or \n    deleted in the working directory, using `dir()` and `setdiff()`. What other \n    global function effects might you want to track?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwd_changes <- function(f) {\n  function(...) {\n    before <- dir()\n    ret <- withVisible(f(...))\n    after <- dir()\n    removed <- setdiff(before, after)\n    added <- setdiff(after, before)\n    if (length(removed) != 0) cat(\"removed files: \", removed, \"\\n\")\n    if (length(added) != 0) cat(\"added files: \", added, \"\\n\")\n    if (ret$visible) {\n      ret$value\n    } else {\n      invisible(ret$value)\n    }\n  }\n}\n```\n:::\n\n\nAnswer: code above. Other effects you might want to track include changes to the global environment, output, and conditions.\n\nAR Solutions: We start with a function that reports the difference between two vectors containing file names:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndir_compare <- function(old, new) {\n  if (setequal(old, new)) {\n    return()\n  }\n\n  added <- setdiff(new, old)\n  removed <- setdiff(old, new)\n\n  changes <- c(\n    if (length(added) > 0) paste0(\" * '\", added, \"' was added\"),\n    if (length(removed) > 0) paste0(\" * '\", removed, \"' was removed\")\n  )\n  message(paste(changes, collapse = \"\\n\"))\n}\ndir_compare(c(\"x\", \"y\"), c(\"x\", \"y\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> NULL\n```\n\n\n:::\n\n```{.r .cell-code}\ndir_compare(c(\"x\", \"y\"), c(\"x\", \"a\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#>  * 'a' was added\n#>  * 'y' was removed\n```\n\n\n:::\n:::\n\n\nThen we wrap it up in a function operator\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntrack_dir <- function(f) {\n  force(f)\n  function(...) {\n    dir_old <- dir()\n    on.exit(dir_compare(dir_old, dir()), add = TRUE)\n\n    f(...)\n  }\n}\n```\n:::\n\n\nAnd try it out by creating wrappers around `file.create()` and `file.remove()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfile_create <- track_dir(file.create)\nfile_remove <- track_dir(file.remove)\nfile_create(\"delete_me\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#>  * 'delete_me' was added\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nfile_remove(\"delete_me\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#>  * 'delete_me' was removed\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\nTo create a more serious version of `track_dir()` one might provide optionality to set the `full.names` and `recursive` arguments of `dir()` to `TRUE`. This would enable to also track the creation/deletion of hidden files and files in folders contained in the working directory.\n\nOther global effects that might be worth tracking include changes regarding:\n\n- the search path and possibly introduced `conflicts()`\n- `options()` and `par()` which modify global settings\n- the path of the working directory\n- environment variables\n\nNotes: AR Solutions use of multiple functions, messages and `on.exit` is preferable.\n\n---\n\n4.  Write a function operator that logs a timestamp and message to a file \n    every time a function is run.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlog_call <- function(f, logfile = \"log_call.log\") {\n  name <- deparse(enexpr(f))\n  force(f)\n  force(logfile)\n\n  function(...) {\n    m <- paste0(Sys.time(), \" log_call: \", name)\n    write(m, file = logfile, append = TRUE)\n    f(...)\n  }\n}\n```\n:::\n\n\nAnswer: code above.\n\nAR Solutions: Our `logger()` function operator takes a function and a file path as input. One timestamp is written to the file under `log_path` when we call `logger()` and another timestamp is written to the same file each time the new function gets called.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nappend_line <- function(path, ...) {\n  cat(..., \"\\n\", sep = \"\", file = path, append = TRUE)\n}\n\nlogger <- function(f, log_path) {\n  force(f)\n  force(log_path)\n\n  append_line(log_path, \"created at: \", as.character(Sys.time()))\n  function(...) {\n    append_line(log_path, \"called at: \", as.character(Sys.time()))\n    f(...)\n  }\n}\n```\n:::\n\n\nNote: AR Solutions creates a function `append_line()` instead of using `write()`, and adds a \"created at: \" time, but is otherwise functionally the same. My solution also logs the name of the function called.\n\n---\n\n5.  Modify `delay_by()` so that instead of delaying by a fixed amount of time, \n    it ensures that a certain amount of time has elapsed since the function \n    was last called. That is, if you called \n    `g <- delay_by(1, f); g(); Sys.sleep(2); g()` there shouldn't be an \n    extra delay.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsleep_if <- function(start, end, delay) {\n  sleep_time <- delay - as.numeric(end - start)\n  if (sleep_time > 0) Sys.sleep(sleep_time)\n}\n\ndelay_by <- function(f, delay) {\n  force(f)\n  force(delay)\n\n  last_called <- NULL\n  function(...) {\n    if (!is.null(last_called)) {\n      sleep_if(last_called, Sys.time(), delay)\n    }\n    on.exit(last_called <<- Sys.time(), add = TRUE)\n\n    f(...)\n  }\n}\n\nf <- function() {\n  0\n}\ng <- delay_by(f, 1)\nh <- delay_by(f, 1)\n\nsystem.time({\n  h()\n  h()\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    user  system elapsed \n#>   0.003   0.000   1.006\n```\n\n\n:::\n\n```{.r .cell-code}\nsystem.time({\n  g()\n  Sys.sleep(2)\n  g()\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    user  system elapsed \n#>   0.007   0.000   2.010\n```\n\n\n:::\n:::\n\n\nAnswer: code above.\n\nAR Solutions:\n\nTo ensure that the function created by `delay_by()` waits that a certain amount of time has passed since its last execution, we incorporate three little changes into our new `delay_atleast()` as indicated in the corresponding comments below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndelay_atleast <- function(amount, f) {\n  force(f)\n  force(amount)\n\n  # Store the last time the function was run\n  last_time <- NULL\n\n  # Return modified \"delay-aware\" function\n  function(...) {\n    if (!is.null(last_time)) {\n      wait <- (last_time - Sys.time()) + amount\n      if (wait > 0) {\n        Sys.sleep(wait)\n      }\n    }\n\n    # Update the time after the function has finished\n    on.exit(last_time <<- Sys.time())\n\n    f(...)\n  }\n}\n```\n:::\n\n\nNotes: this was tricky; I had to consult AR Solutions for an answer.\n\n---\n",
    "supporting": [
      "advanced-r-2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}