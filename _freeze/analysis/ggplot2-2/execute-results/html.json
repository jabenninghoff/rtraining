{
  "hash": "fc0b1fc883e3795984ce88bc8620ba05",
  "result": {
    "markdown": "---\ntitle: \"ggplot2 (Layers)\"\nauthor: \"John Benninghoff\"\ndate: '2022-11-20'\nfile-modified: '2023-11-11'\ncategories: [exercises, ggplot2]\norder: 302\noutput:\n  html_notebook:\n    theme:\n      version: 5\n      preset: bootstrap\n    css: assets/extra.css\n    toc: yes\n    toc_float:\n      collapsed: yes\n      smooth_scroll: no\n---\n\n\nWorkbook for completing quizzes and exercises from the \"Layers\" chapters of [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/index.html), third edition, with comparisons to solutions from [Solutions to ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book-solutions-3ed.netlify.app).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(babynames)\nlibrary(jbplot)\nlibrary(modelr)\nlibrary(maps) # nolint: unused_import_linter. maps is required by map_data().\nlibrary(sf)\nlibrary(USAboundaries)\nlibrary(USAboundariesData) # nolint: unused_import_linter. Needed by USAboundaries.\nlibrary(ggraph)\nlibrary(tidygraph)\n\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  fig.align = \"center\"\n)\n```\n:::\n\n\n# Introduction\n\nThis workbook includes answers and solutions to the quizzes and exercises from [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/index.html) and [Solutions to ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book-solutions-3ed.netlify.app), organized by chapter. It includes excerpts from both books, copied here.\n\n**WARNING, SPOILERS!** If you haven't read the ggplot2 book and intend to complete the quizzes and exercises, don't read this notebook. It contains my (potentially wrong) answers to both.\n\n# 3 Individual geoms\n\n## 3.1.1 Exercises\n\n1.  What geoms would you use to draw each of the following named plots?\n    \n    1. Scatterplot\n    1. Line chart\n    1. Histogram\n    1. Bar chart\n    1. Pie chart\n\nAnswer:\n\n1. Scatterplot: `geom_point()`\n1. Line chart: `geom_line()`\n1. Histogram: `geom_histogram()`\n1. Bar chart: `geom_bar()`\n1. Pie chart: there is no native geom for a pie chart, but, as the\n   [R Graph Gallery](https://r-graph-gallery.com/piechart-ggplot2.html) demonstrates, it is possible\n   to create a pie chart using `geom_bar()` and `coord_polar()`\n\nGG Solutions:\n\n- Scatterplot: `geom_point()`\n- Line chart: `geom_line()`\n- Histogram: `geom_histogram()`\n- Bar chart: `geom_bar()`\n- Pie chart: ggplot2 does not have a geom to draw pie charts. One workaround, according to the [R Graph Gallery](https://r-graph-gallery.com/piechart-ggplot2.html) is to build a stacked bar chart with one bar only using the `geom_bar()` function and then make it circular with `coord_polar()`\n\n---\n\n2.  What's the difference between `geom_path()` and `geom_polygon()`?\n    What's the difference between `geom_path()` and `geom_line()`?\n\nAnswer: `geom_path()` connects observations with a line in the order they appear in the data, `geom_line()` connects them in order along the x axis, and `geom_polygon()` connects the start and end points of `geom_path()` and fills in the plot.\n\nGG Solutions:\n\n- `geom_polygon` draws the same graph (lines) as `geom_path`, but it fills these lines with color\n- `geom_line()` connects points from left to right, whereas `geom_path()` connects points in the order they appear in the data\n\n---\n\n3.  What low-level geoms are used to draw `geom_smooth()`? \n    What about `geom_boxplot()` and `geom_violin()`? \n\nAnswer: reviewing the source code:\n\n[`geom_smooth()`](https://github.com/tidyverse/ggplot2/blob/main/R/geom-smooth.R) uses:\n\n- `geom_path()` by way of `geom_line()`\n- `geom_area()` by way of `geom_ribbon()`\n\n[`geom_boxplot()`](https://github.com/tidyverse/ggplot2/blob/main/R/geom-boxplot.R) uses:\n\n- `geom_point()`\n- `geom_path()` by way of `geom_segment()` and `geom_crossbar()`\n- `geom_polygon()` by way of `geom_crossbar()`\n\n[`geom_violin()`](https://github.com/tidyverse/ggplot2/blob/main/R/geom-violin.R) uses:\n\n- `geom_path()`\n- `geom_polygon()`\n\nGG Solutions:\n\n(kangnade)\n\n- `geom_point()`, `geom_path()`, and `geom_area()` are used to draw `geom_smooth()`\n- `geom_rect()`, `geom_line()`, `geom_point()` are used for `geom_boxplot()`\n- `geom_area()` and `geom_path()` are used for `geom_violin()`\n\nNote: GG Solutions answers appear to be incorrect guesses.\n\n---\n\n# 4 Collective geoms\n\nGeoms can be roughly divided into individual and collective geoms. An __individual__ geom draws a distinct graphical object for each observation (row). For example, the point geom draws one point per row. A __collective__ geom displays multiple observations with one geometric object. This may be a result of a statistical summary, like a boxplot, or may be fundamental to the display of the geom, like a polygon. Lines and paths fall somewhere in between: each line is composed of a set of straight segments, but each segment represents two points. How do we control the assignment of observations to graphical elements?  This is the job of the `group` aesthetic.\n\n## 4.5 Exercises\n\nGG Solutions offers no answers for this section.\n\n1.  Draw a boxplot of `hwy` for each value of `cyl`, without turning\n    `cyl` into a factor. What extra aesthetic do you need to set?\n\nAnswer: the `group` aesthetic is required.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mpg, aes(cyl, hwy, group = cyl)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-1-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n---\n\n2.  Modify the following plot so that you get one boxplot per integer value \n    of `displ`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mpg, aes(displ, cty)) +\n  geom_boxplot()\n```\n:::\n\n\nAnswer: grouping by the floor of displacement works, but is arranged strangely. Mutating displacement first is a better solution:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mpg, aes(displ, cty, group = floor(displ))) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nmpg |>\n  mutate(displ = floor(displ)) |>\n  ggplot(aes(displ, cty, group = displ)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-3-2.png){fig-align='center' width=672}\n:::\n:::\n\n\n---\n\n3.  When illustrating the difference between mapping continuous and discrete\n    colours to a line, the discrete example needed `aes(group = 1)`. Why?\n    What happens if that is omitted? What's the difference between\n    `aes(group = 1)` and `aes(group = 2)`? Why?\n\nAnswer: using the example from the book, omitting the group aesthetic generates an error:\n\n```\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\n```\n\nThere is no difference between `aes(group = 1)` and `aes(group = 2)`, presumably because both methods put all observations into a single group.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3, y = 1:3, colour = c(1, 3, 5))\n\nggplot(df, aes(x, y, colour = factor(colour))) +\n  geom_line(aes(group = 1), linewidth = 2) +\n  geom_point(size = 5)\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nggplot(df, aes(x, y, colour = factor(colour))) +\n  geom_line(aes(group = 2), linewidth = 2) +\n  geom_point(size = 5)\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-4-2.png){fig-align='center' width=672}\n:::\n:::\n\n\n---\n\n4.  How many bars are in each of the following plots?\n    (Hint: try adding an outline around each bar with `colour = \"white\"`)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mpg, aes(drv)) +\n  geom_bar()\nggplot(mpg, aes(drv, fill = hwy, group = hwy)) +\n  geom_bar()\n\nmpg2 <- mpg %>%\n  arrange(hwy) %>%\n  mutate(id = seq_along(hwy))\nggplot(mpg2, aes(drv, fill = hwy, group = id)) +\n  geom_bar()\n```\n:::\n\n\nAnswer: in the first plot, there are three bars. In the second, there is one bar for each unique value for `hwy` in each column. In the third, there is one bar for each observation of `hwy`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mpg, aes(drv)) +\n  geom_bar(color = \"white\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nggplot(mpg, aes(drv, fill = hwy, group = hwy)) +\n  geom_bar(color = \"white\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-6-2.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nmpg |>\n  arrange(hwy) |>\n  mutate(id = seq_along(hwy)) |>\n  ggplot(aes(drv, fill = hwy, group = id)) +\n  geom_bar(color = \"white\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-6-3.png){fig-align='center' width=672}\n:::\n:::\n\n\n---\n\n5.  Install the babynames package. It contains data about the popularity of\n    babynames in the US. Run the following code and fix the resulting graph.\n    Why does this graph make me unhappy?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhadley <- filter(babynames, name == \"Hadley\")\nggplot(hadley, aes(year, n)) +\n  geom_line()\n```\n:::\n\n\nAnswer: the popularity of \"Hadley\" is sadly declining.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  filter(name == \"Hadley\") |>\n  ggplot(aes(year, n, group = sex, color = sex)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n---\n\nBonus: a comparison of the popularity of my name (John) and Hadley:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames |>\n  filter(name %in% c(\"Hadley\", \"John\")) |>\n  ggplot(aes(year, prop, color = interaction(name, sex, sep = \", \", lex.order = TRUE))) +\n  geom_line() +\n  scale_y_log10() +\n  scale_color_viridis_d() +\n  labs(x = \"\", y = \"\", color = \"Name, Sex\") +\n  labs(title = \"Relative popularity of the names Hadley and John\") +\n  theme_quo()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nNote: `group` is redundant for `geom_line()` when using `color`.\n\n---\n\n# 5 Statistical summaries\n\n## 5.4.1 Exercises\n\n1.  What `binwidth` tells you the most interesting story about the distribution\n    of `carat`?\n\nAnswer: as answered in [2.6.6 Exercises](ggplot2-1.html#266_Exercises):\n\nAnswer: using trial and error, `binwidth = 0.01` reveals that carat weight is skewed towards round numbers (1, 1.25, 1.5, 2, etc.). Using the smaller `binwidth = 0.005` doesn't improve the pattern, and makes it harder to see.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.01)\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nGG Solutions:\n\n- Highly subjective answer, but I would go with 0.2 since it gives you the right amount of information about the distribution of `carat`: right-skewed.\n\n---\n\n2.  Draw a histogram of `price`. What interesting patterns do you see?\n\nAnswer: price has a multi-modal distribution with a gap. Looking at the underlying data, there are no prices between \\$1454 and \\$1546\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(price)) +\n  geom_histogram(binwidth = 50)\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\ndiamonds |>\n  filter(price >= 1454, price <= 1546)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 24 × 10\n#>    carat cut       color clarity depth table price     x     y     z\n#>    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n#>  1  0.5  Very Good D     SI1      61.6    56  1454  5.09  5.11  3.14\n#>  2  0.52 Ideal     I     VVS1     60.1    56  1454  5.24  5.27  3.16\n#>  3  0.54 Ideal     H     VS1      61.2    55  1454  5.25  5.31  3.23\n#>  4  0.51 Premium   G     VS2      61.2    60  1546  5.17  5.12  3.15\n#>  5  0.51 Ideal     G     VS2      62.9    54  1546  5.12  5.08  3.21\n#>  6  0.51 Premium   G     VS2      62.4    57  1546  5.11  5.09  3.18\n#>  7  0.51 Premium   G     VS2      62.7    58  1546  5.12  5.09  3.2 \n#>  8  0.51 Premium   G     VS2      62.2    57  1546  5.15  5.1   3.19\n#>  9  0.51 Ideal     G     VS2      62.7    57  1546  5.12  5.05  3.19\n#> 10  0.51 Premium   G     VS2      62.9    58  1546  5.11  5.06  3.2 \n#> # ℹ 14 more rows\n```\n:::\n:::\n\n\nGG Solutions:\n\n- It's skewed to the right and has a long tail. Also, there is a small peak around 5000 and a huge peak around 0.\n\n---\n\n3.  How does the distribution of `price` vary with `clarity`?\n\nAnswer: a boxplot of price by clarity shows that diamonds with better clarity aren't necessarily more expensive.\n\nHowever, as noted in my [R Training Log](r-training-log.html) and as answered in [2.6.6 Exercises](ggplot2-1.html#266_Exercises):\n\n> [7.6 Patterns and models](https://r4ds.had.co.nz/exploratory-data-analysis.html#patterns-and-models) covers models and residuals, here showing how to reveal the expected relationship between cut and price:\n\nWe can remove the relationship between carats and price, and redo the boxplot, which shows the expected relationship:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(clarity, price)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\n# remove carat weight as a confounding variable\ndiamonds |>\n  add_residuals(lm(log(price) ~ log(carat), data = diamonds)) |>\n  mutate(resid = exp(resid)) |>\n  ggplot(aes(clarity, resid)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-12-2.png){fig-align='center' width=672}\n:::\n:::\n\n\nGG Solutions:\n\n- The range of prices is similar across clarity and the median and IQR vary greatly with clarity.  \n\n---\n\n4.  Overlay a frequency polygon and density plot of `depth`. What computed\n    variable do you need to map to `y` to make the two plots comparable? \n    (You can either modify `geom_freqpoly()` or `geom_density()`.)\n\nAnswer: you need to either divide or multiply `y` by the total number of observations, `nrow(diamonds)` using `after_stat()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(aes(y = after_stat(count) / nrow(diamonds)), binwidth = 1) +\n  geom_density() +\n  labs(y = \"\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(binwidth = 1) +\n  geom_density(aes(y = after_stat(density) * nrow(diamonds))) +\n  labs(y = \"\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-13-2.png){fig-align='center' width=672}\n:::\n:::\n\n\nNotes: from the documentation for `after_stat()`:\n\n> Most aesthetics are mapped from variables found in the data. Sometimes, however, you want to delay the mapping until later in the rendering process. ggplot2 has three stages of the data that you can map aesthetics from. The default is to map at the beginning, using the layer data provided by the user. The second stage is after the data has been transformed by the layer stat. The third and last stage is after the data has been transformed and mapped by the plot scales. The most common example of mapping from stat transformed data is the height of bars in `geom_histogram()`: the height does not come from a variable in the underlying data, but is instead mapped to the count computed by `stat_bin()`. An example of mapping from scaled data could be to use a desaturated version of the stroke colour for fill. If you want to map directly from the layer data you should not do anything special. In order to map from stat transformed data you should use the `after_stat()` function to flag that evaluation of the aesthetic mapping should be postponed until after stat transformation. Similarly, you should use `after_scale()` to flag evaluation of mapping for after data has been scaled. If you want to map the same aesthetic multiple times, e.g. map x to a data column for the stat, but remap it for the geom, you can use the `stage()` function to collect multiple mappings.\n\nGG Solutions answer not included here.\n\nNote: after reading the [Generated Variables](https://ggplot2-book.org/layers.html#generated-variables) section, there is an easier solution:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(aes(y = after_stat(density)), binwidth = 1) +\n  geom_density() +\n  labs(y = \"\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n---\n\nBonus: overlay a PDF and ECDF on a histogram.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(price)) +\n  geom_histogram(aes(y = after_stat(ncount)), binwidth = 50, fill = \"gray\") +\n  stat_ecdf() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nggplot(diamonds, aes(price)) +\n  geom_histogram(binwidth = 50, fill = \"gray\") +\n  # nolint next: line_length_linter.\n  # see https://stackoverflow.com/questions/27611438/density-curve-overlay-on-histogram-where-vertical-axis-is-frequency-aka-count\n  geom_density(aes(y = after_stat(density * nrow(diamonds) * 50))) +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-15-2.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nggplot(diamonds, aes(price)) +\n  geom_histogram(aes(y = after_stat(ncount)), binwidth = 50, fill = \"gray\") +\n  # TODO: the factor of 0.62 was determined by trial and error, find underlying formula\n  #       the maximum density / the maximum count of the previous plot = 930.57 / 1503 = 0.62\n  #       but that doesn't work here\n  geom_density(aes(y = after_stat(ndensity * 0.62))) +\n  stat_ecdf() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-15-3.png){fig-align='center' width=672}\n:::\n:::\n\n\n# 6 Maps\n\nPlotting geospatial data is a common visualisation task, and one that requires specialised tools. Typically the problem can be decomposed into two problems: using one data source to draw a map, and adding metadata from another information source to the map. This chapter will help you tackle both problems.\n\n## Bonus\n\nThere are no exercises, so let's draw a map of Minnesota using polygon maps!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap_data(\"county\", \"minnesota\") |>\n  select(lon = long, lat, group) |>\n  ggplot(aes(lon, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"grey50\") +\n  coord_quickmap() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nPolygon maps are superseded by simple features maps, so let's draw it again, adding Minneapolis, in red:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nus_counties(resolution = \"high\", states = \"MN\") |>\n  ggplot() +\n  geom_sf(fill = \"white\") +\n  geom_sf(data = filter(us_cities(states = \"MN\"), city == \"Minneapolis\"), color = \"red\") +\n  coord_sf() +\n  theme_quo()\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nSide note: although it creates files in `/usr/local`, which causes [Homebrew](https://brew.sh) to complain, [`rig`](https://github.com/r-lib/rig/), *The R Installation Manager*, supports multiple versions of R, and supports installation of binary packages, which is substantially faster and requires fewer local dependencies.\n\n# 7 Networks\n\nLike maps and spatial data, networks and graphs occupy a special part of the visualization landscape, but whereas spatial data mostly differ from regular plotting in their use of projections, networks bring their own data structure as well as their own visualization paradigms to the table. Because of these complications networks are not directly supported in ggplot2. Several efforts over the years have tried to add this missing piece and in this chapter we will see how to use [`ggraph`](https://ggraph.data-imaginist.com) for network visualization. Other packages that offer some of the same functionality includes [`geomnet`](http://sctyner.github.io/geomnet/), [`ggnetwork`](https://briatte.github.io/ggnetwork/), and [`GGally`](https://ggobi.github.io/ggally/) for regular network plots, and [`ggtree`](https://github.com/YuLab-SMU/ggtree) and [`ggdendro`](https://andrie.github.io/ggdendro/) for tree visualization specifically.\n\n## Notes\n\nWhile ggplot2 has limited support for maps, it has no direct support for networks and graphs. `ggraph` offers some interesting visualizations that are useful for understanding social networks, especially this one, which shows how friendships among high school boys changed from 1957 to 1958:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhighschool |>\n  as_tbl_graph(directed = FALSE) |>\n  ggraph(layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point() +\n  facet_edges(~year)\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n# 8 Annotations\n\nWhen constructing a data visualisation, it is often necessary to make annotations to\nthe data displayed. Conceptually, an annotation supplies *metadata* for the plot: that is,\nit provides additional information about the data being displayed. From a practical \nstandpoint, however, metadata is just another form of data. Because of this, the \nannotation tools in ggplot2 reuse the same geoms that are used to create other plots. \nHowever, to meet the specific needs that users often have when annotating plots, there\nare some helper functions in ggplot2 itself, and a number of other packages have \nextended ggplot2 in ways you may find helpful.\n\n## Notes\n\nAn important distinction on axis labels:\n\n> There are two ways to remove the axis label. Setting `labs(x = \"\")` omits the label but still allocates space; setting `labs(x = NULL)` removes the label and its space. \n\nConsider adopting [`showtext`](https://github.com/yixuan/showtext) for non-standard fonts, with caveats for using it in [R Markdown](https://statr.me/2014/07/showtext-with-knitr/).\n\nOne of the most useful alignments is “inward”. It aligns text towards the middle of the plot, which ensures that labels remain within the plot limits:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- data.frame(\n  x = c(1, 1, 2, 2, 1.5),\n  y = c(1, 2, 1, 2, 1.5),\n  text = c(\n    \"bottom-left\", \"top-left\",\n    \"bottom-right\", \"top-right\", \"center\"\n  ), stringsAsFactors = FALSE\n)\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text))\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text), vjust = \"inward\", hjust = \"inward\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-19-2.png){fig-align='center' width=672}\n:::\n:::\n\n\n*   The font size is controlled by the `size` aesthetic. Unlike most tools, \n    ggplot2 specifies the size in millimeters (mm), rather than the usual \n    points (pts). The reason for this choice is that it makes it the units for\n    font sizes consistent with how other sizes are specified in ggplot2. \n    (There are 72.27 pts in a inch, so to convert from points to mm, just \n    multiply by 72.27 / 25.4).\n\nLet's assign blame to unemployment!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npresidential <- subset(presidential, start > economics$date[1] & start < max(economics$date))\n\nggplot(economics) +\n  geom_rect(\n    aes(xmin = start, xmax = end, fill = party),\n    ymin = -Inf, ymax = Inf, alpha = 0.25,\n    data = presidential\n  ) +\n  geom_vline(\n    aes(xintercept = as.numeric(start)),\n    data = presidential,\n    colour = \"grey50\", alpha = 0.5\n  ) +\n  geom_text(\n    # themes only affect the non-data components of the plot, see:\n    #   https://github.com/tidyverse/ggplot2/issues/1859\n    aes(x = start, y = 0.0005, label = name, family = \"Lato\"),\n    data = presidential,\n    size = 3, vjust = 0, hjust = 0, nudge_x = 75\n  ) +\n  geom_line(aes(date, unemploy / pop)) +\n  scale_fill_manual(values = c(\"blue\", \"red\")) +\n  scale_y_continuous(labels = scales::percent, limits = c(0, NA)) +\n  scale_x_date(breaks = presidential$start, date_labels = \"%Y\") +\n  guides(fill = \"none\") +\n  labs(title = \"Unemployment rate by presidential term\", x = NULL, y = NULL) +\n  theme_quo(minor.y = FALSE, x = FALSE)\n```\n\n::: {.cell-output-display}\n![](ggplot2-2_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n# 9 Arranging plots\n\nThe grammar presented in ggplot2 is concerned with creating single plots. While the faceting system provides the means to produce several subplots all of these are part of the same main visualization, sharing layers, data, and scales. However, it is often necessary to use multiple disparate plots to tell a story or make an argument. These can of course be created individually and assembled in a layout program, but it is beneficial to do this in code to avoid time consuming and non-reproducible manual labor. A range of packages have risen to the occasion and provide different approaches to arranging separate plots. While this chapter will focus on the `patchwork` package you may also find some of the same functionalities in the `cowplot`, `gridExtra` and `ggpubr` packages.\n",
    "supporting": [
      "ggplot2-2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}