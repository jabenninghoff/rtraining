---
title: "Advanced R Workbook (Functional programming)"
date: '2022-07-31'
output:
  html_notebook:
    theme:
      version: 5
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: no
---

Workbook for completing quizzes and exercises from the "Functional programming" chapters of [Advanced R](https://adv-r.hadley.nz/index.html), second edition, with comparisons to solutions from [Advanced R Solutions](https://advanced-r-solutions.rbind.io).

```{r setup, message = FALSE, warning = FALSE}
library(purrr)
library(palmerpenguins) # nolint: unused_import_linter. Imported for `penguins` tibble.

# from https://github.com/hadley/adv-r/blob/master/common.R
knitr::opts_chunk$set(
  comment = "#>",
  fig.align = "center"
)

knitr::knit_hooks$set(
  small_mar = function(before, options, envir) {
    if (before) {
      par(mar = c(4.1, 4.1, 0.5, 0.5)) # nolint: undesirable_function_linter.
    }
  }
)
```

# Introduction

This workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html) and [Advanced R Solutions](https://advanced-r-solutions.rbind.io), organized by chapter. It includes excerpts from both books, copied here.

**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and exercises, don't read this notebook. It contains my (potentially wrong) answers to both.

# 9 Functionals

> To become significantly more reliable, code must become more transparent.
> In particular, nested conditions and loops must be viewed with great
> suspicion. Complicated control flows confuse programmers. Messy code often
> hides bugs.
>
> --- Bjarne Stroustrup

A __functional__ is a function that takes a function as an input and returns a vector as output. Here's a simple functional: it calls the function provided as input with 1000 random uniform numbers. 

```{r}
randomise <- function(f) f(runif(1e3))
randomise(mean)
randomise(mean)
randomise(sum)
```

The chances are that you've already used a functional. You might have used for-loop replacements like base R's `lapply()`, `apply()`, and `tapply()`; or purrr's `map()`; or maybe you've used a mathematical functional like `integrate()` or `optim()`. 

A common use of functionals is as an alternative to for loops. For loops have a bad rap in R because many people believe they are slow[^not-slow], but the real downside of for loops is that they're very flexible: a loop conveys that you're iterating, but not what should be done with the results. Just as it's better to use `while` than `repeat`, and it's better to use `for` than `while` (Section 5.3.2), it's better to use a functional than `for`. Each functional is tailored for a specific task, so when you recognise the functional you immediately know why it's being used.

[^not-slow]: Typically it's not the for loop itself that's slow, but what you're doing inside of it. A common culprit of slow loops is modifying a data structure, where each modification generates a copy. See Sections 2.5.1 and 24.6 for more details.

If you're an experienced for loop user, switching to functionals is typically a pattern matching exercise. You look at the for loop and find a functional that matches the basic form. If one doesn't exist, don't try and torture an existing functional to fit the form you need. Instead, just leave it as a for loop! (Or once you've repeated the same loop two or more times, maybe think about writing your own functional).

## 9.2.6 Exercises

1.  Use `as_mapper()` to explore how purrr generates anonymous functions for
    the integer, character, and list helpers. What helper allows you to 
    extract attributes? Read the documentation to find out.

```{r}
map_dbl
map_dbl(mtcars, ~ length(unique(.x)))
as_mapper(~ length(unique(.x)))
function(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))
as_mapper(mean)
as_mapper(function(x) mean(x, na.rm = TRUE))
as_mapper(~ mean(.x, na.rm = TRUE))
```

Answer: Exploration above. `attr_getter()` supports extraction of attributes.

AR Solutions: `map()` offers multiple ways (functions, formulas, and extractor functions) to specify its function argument (`.f`). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of `as_mapper()` and it is called every time `map()` is used.

Given character, numeric or list input `as_mapper()` will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.

The extractor function is implemented as a call to `purrr::pluck()`, which accepts a list of accessors (accessors "access" some part of your data object).

```{r}
as_mapper(c(1, 2)) # equivalent to function(x) x[[1]][[2]]
as_mapper(c("a", "b")) # equivalent to function(x) x[["a"]][["b]]
as_mapper(list(1, "b")) # equivalent to function(x) x[[1]][["b]]
```

Besides mixing positions and names, it is also possible to pass along an accessor function. This is basically an anonymous function that gets information about some aspect of the input data. You are free to define your own accessor functions. 

If you need to access certain attributes, the helper `attr_getter(y)` is already predefined and will create the appropriate accessor function for you.

```{r}
# Define custom accessor function
get_class <- function(x) attr(x, "class")
pluck(mtcars, get_class)

# Use attr_getter() as a helper
pluck(mtcars, attr_getter("class"))
```

Note: AR Solutions provides good additional insight into `as_mapper()`.

---

2.  `map(1:3, ~ runif(2))` is a useful pattern for generating random
    numbers, but `map(1:3, runif(2))` is not. Why not? Can you explain why 
    it returns the result that it does?

```{r}
map(1:3, ~ runif(2))
map(1:3, runif(2))
```

Answer: `~ runif(2)` generates a mapper that returns 2 random values from the uniform distribution, where `runif(2)` creates a `pluck()` mapper with 2 random values, which will (nearly) always return `NULL`, as demonstrated by the code below: 

```{r}
as_mapper(~ runif(2))
as_mapper(runif(2))
```

A more reasonable use of a pluck mapper for `1:3` is `1`:

```{r}
map(1:3, 1)
```

AR Solutions: The first pattern creates multiple random numbers, because `~ runif(2)` successfully uses the formula interface. Internally `map()` applies `as_mapper()` to this formula, which converts `~ runif(2)` into an anonymous function. Afterwards `runif(2)` is applied three times (one time during each iteration), leading to three different pairs of random numbers.

In the second pattern `runif(2)` is evaluated once, then the results are passed to `map()`. Consequently `as_mapper()` creates an extractor function based on the return values from `runif(2)` (via `pluck()`). This leads to three `NULL`s (`pluck()`'s `.default` return), because no values corresponding to the index can be found.

Note: AR Solutions provides additional detail, but is otherwise the same.

---

3.  Use the appropriate `map()` function to:
    
    a) Compute the standard deviation of every column in a numeric data frame.
    
    a) Compute the standard deviation of every numeric column in a mixed data
       frame. (Hint: you'll need to do it in two steps.)
       
    a) Compute the number of levels for every factor in a data frame.

```{r}
# a
map_dbl(mtcars, sd)
# b
map_dbl(iris[map_lgl(iris, is.numeric)], sd)
# c
map_int(warpbreaks, nlevels)
# c, excluding non-factor columns
map_int(warpbreaks[map_lgl(warpbreaks, is.factor)], nlevels)
```

Answer: code above.

AR Solutions: To solve this exercise we take advantage of calling the type stable variants of `map()`, which give us more concise output, and use `map_lgl()` to select the columns of the data frame (later you'll learn about `keep()`, which simplifies this pattern a little).

```{r}
map_dbl(mtcars, sd)
penguins_numeric <- map_lgl(penguins, is.numeric)
map_dbl(penguins[penguins_numeric], sd, na.rm = TRUE)
penguins_factor <- map_lgl(penguins, is.factor)
map_int(penguins[penguins_factor], ~ length(levels(.x)))
```

Note: my code is more concise, both with selections and use of `nlevels()`, although using `keep()` is preferable.

```{r}
map_int(keep(warpbreaks, is.factor), nlevels)
```

---

4.  The following code simulates the performance of a t-test for non-normal 
    data. Extract the p-value from each test, then visualise.

```{r}
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))
hist(map_dbl(trials, "p.value"), breaks = 10)
```

Answer: code above.

AR Solutions: There are many ways to visualise this data. However, since there are only 100 data points, we choose a dot plot to visualise the distribution. (Unfortunately, `{ggplot2}`s `geom_dotplot()` doesn't compute proper counts as it was created to visualise distribution densities instead of frequencies, so a histogram would be a suitable alternative).

```{r}
# Advanced R Solutions uses different code for trials
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))

library(ggplot2)

df_trials <- tibble::tibble(p_value = map_dbl(trials, "p.value"))

df_trials %>%
  ggplot(aes(x = p_value, fill = p_value < 0.05)) +
  geom_dotplot(binwidth = 0.01) + # geom_histogram() as alternative
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "top"
  )
```

Notes: the code AR Solutions uses for trials, `trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))`, appears to be correct compared to Advanced R.

---

5.  The following code uses a map nested inside another map to apply a
    function to every element of a nested list. Why does it fail, and 
    what do you need to do to make it work?

```{r, error = TRUE}
x <- list(
  list(1, c(3, 9)),
  list(c(3, 6), 7, c(4, 7, 6))
)

triple <- function(x) x * 3
try(map(x, map, .f = triple))
```

Answer: the call fails since the `.f = triple` specifies the function for the outer `map()`, and the `map` is passed as an additional argument to `triple()`, which generates the error since `triple()` only takes a single argument. The solution is to pass triple as an additional argument to the outer `map()`: 

```{r}
map(x, map, triple)
```

AR Solutions: This function call fails, because `triple()` is specified as the `.f` argument and consequently belongs to the outer `map()`. The unnamed argument `map` is treated as an argument of `triple()`, which causes the error.

There are a number of ways we could resolve the problem. However, there is not much to choose between them for this simple example, although it is good to know your options for more complicated cases.

```{r, eval = FALSE}
# Don't name the argument
map(x, map, triple)

# Use magrittr-style anonymous function
map(x, . %>% map(triple))

# Use purrr-style anonymous function
map(x, ~ map(.x, triple))
```

Note: I don't like the magrittr-style anonymous function option. The others are good.

---

6.  Use `map()` to fit linear models to the `mtcars` dataset using the formulas
    stored in this list:

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)
```

Answer: the following code works, but doesn't display the text of the formula in the `Call:`

```{r}
map(formulas, lm, mtcars)
```

AR Solutions: The data (`mtcars`) is constant for all these models and so we iterate over the `formulas` provided. As the formula is the first argument of `lm()`, we don't need to specify it explicitly.

```{r}
models <- map(formulas, lm, data = mtcars)
```

Note: AR Solutions specifies `data = mtcars` but is otherwise the same.

---

7.  Fit the model `mpg ~ disp` to each of the bootstrap replicates of `mtcars` 
    in the list below, then extract the $R^2$ of the model fit (Hint: you can
    compute the $R^2$ with `summary()`.)

```{r}
bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- map(1:10, ~ bootstrap(mtcars))

map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)
```

Answer: code above.

AR Solutions: To accomplish this task, we take advantage of the "list in, list out"-functionality of `map()`. This allows us to chain multiple transformations together. We start by fitting the models. We then calculate the summaries and extract the $R^2$ values. For the last call we use `map_dbl()`, which provides convenient output.

```{r}
bootstraps %>%
  map(~ lm(mpg ~ disp, data = .x)) %>%
  map(summary) %>%
  map_dbl("r.squared")
```

Note: while AR Solutions is arguably *slightly* more readable, my code should be faster:

```{r}
bench::mark({
  map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)
})

bench::mark({
  bootstraps %>%
    map(~ lm(mpg ~ disp, data = .x)) %>%
    map(summary) %>%
    map_dbl("r.squared")
})
```

It is actually slightly slower! AR Solutions wins!

---
