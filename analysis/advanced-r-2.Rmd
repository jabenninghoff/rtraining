---
title: "Advanced R Workbook (Functional programming)"
date: '2022-07-31'
output:
  html_notebook:
    theme:
      version: 5
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: no
---

Workbook for completing quizzes and exercises from the "Functional programming" chapters of [Advanced R](https://adv-r.hadley.nz/index.html), second edition, with comparisons to solutions from [Advanced R Solutions](https://advanced-r-solutions.rbind.io).

```{r setup, message = FALSE, warning = FALSE}
library(purrr)
library(palmerpenguins) # nolint: unused_import_linter. Imported for `penguins` tibble.

# from https://github.com/hadley/adv-r/blob/master/common.R
knitr::opts_chunk$set(
  comment = "#>",
  fig.align = "center"
)

knitr::knit_hooks$set(
  small_mar = function(before, options, envir) {
    if (before) {
      par(mar = c(4.1, 4.1, 0.5, 0.5)) # nolint: undesirable_function_linter.
    }
  }
)
```

# Introduction

This workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html) and [Advanced R Solutions](https://advanced-r-solutions.rbind.io), organized by chapter. It includes excerpts from both books, copied here.

**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and exercises, don't read this notebook. It contains my (potentially wrong) answers to both.

# 9 Functionals

> To become significantly more reliable, code must become more transparent.
> In particular, nested conditions and loops must be viewed with great
> suspicion. Complicated control flows confuse programmers. Messy code often
> hides bugs.
>
> --- Bjarne Stroustrup

A __functional__ is a function that takes a function as an input and returns a vector as output. Here's a simple functional: it calls the function provided as input with 1000 random uniform numbers. 

```{r}
randomise <- function(f) f(runif(1e3))
randomise(mean)
randomise(mean)
randomise(sum)
```

The chances are that you've already used a functional. You might have used for-loop replacements like base R's `lapply()`, `apply()`, and `tapply()`; or purrr's `map()`; or maybe you've used a mathematical functional like `integrate()` or `optim()`. 

A common use of functionals is as an alternative to for loops. For loops have a bad rap in R because many people believe they are slow[^not-slow], but the real downside of for loops is that they're very flexible: a loop conveys that you're iterating, but not what should be done with the results. Just as it's better to use `while` than `repeat`, and it's better to use `for` than `while` (Section 5.3.2), it's better to use a functional than `for`. Each functional is tailored for a specific task, so when you recognise the functional you immediately know why it's being used.

[^not-slow]: Typically it's not the for loop itself that's slow, but what you're doing inside of it. A common culprit of slow loops is modifying a data structure, where each modification generates a copy. See Sections 2.5.1 and 24.6 for more details.

If you're an experienced for loop user, switching to functionals is typically a pattern matching exercise. You look at the for loop and find a functional that matches the basic form. If one doesn't exist, don't try and torture an existing functional to fit the form you need. Instead, just leave it as a for loop! (Or once you've repeated the same loop two or more times, maybe think about writing your own functional).

## 9.2.6 Exercises

1.  Use `as_mapper()` to explore how purrr generates anonymous functions for
    the integer, character, and list helpers. What helper allows you to 
    extract attributes? Read the documentation to find out.

```{r}
map_dbl
map_dbl(mtcars, ~ length(unique(.x)))
as_mapper(~ length(unique(.x)))
function(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))
as_mapper(mean)
as_mapper(function(x) mean(x, na.rm = TRUE))
as_mapper(~ mean(.x, na.rm = TRUE))
```

Answer: Exploration above. `attr_getter()` supports extraction of attributes.

AR Solutions: `map()` offers multiple ways (functions, formulas, and extractor functions) to specify its function argument (`.f`). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of `as_mapper()` and it is called every time `map()` is used.

Given character, numeric or list input `as_mapper()` will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.

The extractor function is implemented as a call to `purrr::pluck()`, which accepts a list of accessors (accessors "access" some part of your data object).

```{r}
as_mapper(c(1, 2)) # equivalent to function(x) x[[1]][[2]]
as_mapper(c("a", "b")) # equivalent to function(x) x[["a"]][["b]]
as_mapper(list(1, "b")) # equivalent to function(x) x[[1]][["b]]
```

Besides mixing positions and names, it is also possible to pass along an accessor function. This is basically an anonymous function that gets information about some aspect of the input data. You are free to define your own accessor functions. 

If you need to access certain attributes, the helper `attr_getter(y)` is already predefined and will create the appropriate accessor function for you.

```{r}
# Define custom accessor function
get_class <- function(x) attr(x, "class")
pluck(mtcars, get_class)

# Use attr_getter() as a helper
pluck(mtcars, attr_getter("class"))
```

Note: AR Solutions provides good additional insight into `as_mapper()`.

---

2.  `map(1:3, ~ runif(2))` is a useful pattern for generating random
    numbers, but `map(1:3, runif(2))` is not. Why not? Can you explain why 
    it returns the result that it does?

```{r}
map(1:3, ~ runif(2))
map(1:3, runif(2))
```

Answer: `~ runif(2)` generates a mapper that returns 2 random values from the uniform distribution, where `runif(2)` creates a `pluck()` mapper with 2 random values, which will (nearly) always return `NULL`, as demonstrated by the code below: 

```{r}
as_mapper(~ runif(2))
as_mapper(runif(2))
```

A more reasonable use of a pluck mapper for `1:3` is `1`:

```{r}
map(1:3, 1)
```

AR Solutions: The first pattern creates multiple random numbers, because `~ runif(2)` successfully uses the formula interface. Internally `map()` applies `as_mapper()` to this formula, which converts `~ runif(2)` into an anonymous function. Afterwards `runif(2)` is applied three times (one time during each iteration), leading to three different pairs of random numbers.

In the second pattern `runif(2)` is evaluated once, then the results are passed to `map()`. Consequently `as_mapper()` creates an extractor function based on the return values from `runif(2)` (via `pluck()`). This leads to three `NULL`s (`pluck()`'s `.default` return), because no values corresponding to the index can be found.

Note: AR Solutions provides additional detail, but is otherwise the same.

---

3.  Use the appropriate `map()` function to:
    
    a) Compute the standard deviation of every column in a numeric data frame.
    
    a) Compute the standard deviation of every numeric column in a mixed data
       frame. (Hint: you'll need to do it in two steps.)
       
    a) Compute the number of levels for every factor in a data frame.

```{r}
# a
map_dbl(mtcars, sd)
# b
map_dbl(iris[map_lgl(iris, is.numeric)], sd)
# c
map_int(warpbreaks, nlevels)
# c, excluding non-factor columns
map_int(warpbreaks[map_lgl(warpbreaks, is.factor)], nlevels)
```

Answer: code above.

AR Solutions: To solve this exercise we take advantage of calling the type stable variants of `map()`, which give us more concise output, and use `map_lgl()` to select the columns of the data frame (later you'll learn about `keep()`, which simplifies this pattern a little).

```{r}
map_dbl(mtcars, sd)
penguins_numeric <- map_lgl(penguins, is.numeric)
map_dbl(penguins[penguins_numeric], sd, na.rm = TRUE)
penguins_factor <- map_lgl(penguins, is.factor)
map_int(penguins[penguins_factor], ~ length(levels(.x)))
```

Note: my code is more concise, both with selections and use of `nlevels()`, although using `keep()` is preferable.

```{r}
map_int(keep(warpbreaks, is.factor), nlevels)
```

---

4.  The following code simulates the performance of a t-test for non-normal 
    data. Extract the p-value from each test, then visualise.

```{r}
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))
hist(map_dbl(trials, "p.value"), breaks = 10)
```

Answer: code above.

AR Solutions: There are many ways to visualise this data. However, since there are only 100 data points, we choose a dot plot to visualise the distribution. (Unfortunately, `{ggplot2}`s `geom_dotplot()` doesn't compute proper counts as it was created to visualise distribution densities instead of frequencies, so a histogram would be a suitable alternative).

```{r}
# Advanced R Solutions uses different code for trials
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))

library(ggplot2)

df_trials <- tibble::tibble(p_value = map_dbl(trials, "p.value"))

df_trials %>%
  ggplot(aes(x = p_value, fill = p_value < 0.05)) +
  geom_dotplot(binwidth = 0.01) + # geom_histogram() as alternative
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "top"
  )
```

Notes: the code AR Solutions uses for trials, `trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))`, appears to be correct compared to Advanced R.

---

5.  The following code uses a map nested inside another map to apply a
    function to every element of a nested list. Why does it fail, and 
    what do you need to do to make it work?

```{r, error = TRUE}
x <- list(
  list(1, c(3, 9)),
  list(c(3, 6), 7, c(4, 7, 6))
)

triple <- function(x) x * 3
try(map(x, map, .f = triple))
```

Answer: the call fails since the `.f = triple` specifies the function for the outer `map()`, and the `map` is passed as an additional argument to `triple()`, which generates the error since `triple()` only takes a single argument. The solution is to pass triple as an additional argument to the outer `map()`: 

```{r}
map(x, map, triple)
```

AR Solutions: This function call fails, because `triple()` is specified as the `.f` argument and consequently belongs to the outer `map()`. The unnamed argument `map` is treated as an argument of `triple()`, which causes the error.

There are a number of ways we could resolve the problem. However, there is not much to choose between them for this simple example, although it is good to know your options for more complicated cases.

```{r, eval = FALSE}
# Don't name the argument
map(x, map, triple)

# Use magrittr-style anonymous function
map(x, . %>% map(triple))

# Use purrr-style anonymous function
map(x, ~ map(.x, triple))
```

Note: I don't like the magrittr-style anonymous function option. The others are good.

---

6.  Use `map()` to fit linear models to the `mtcars` dataset using the formulas
    stored in this list:

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)
```

Answer: the following code works, but doesn't display the text of the formula in the `Call:`

```{r}
map(formulas, lm, mtcars)
```

AR Solutions: The data (`mtcars`) is constant for all these models and so we iterate over the `formulas` provided. As the formula is the first argument of `lm()`, we don't need to specify it explicitly.

```{r}
models <- map(formulas, lm, data = mtcars)
```

Note: AR Solutions specifies `data = mtcars` but is otherwise the same.

---

7.  Fit the model `mpg ~ disp` to each of the bootstrap replicates of `mtcars` 
    in the list below, then extract the $R^2$ of the model fit (Hint: you can
    compute the $R^2$ with `summary()`.)

```{r}
bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- map(1:10, ~ bootstrap(mtcars))

map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)
```

Answer: code above.

AR Solutions: To accomplish this task, we take advantage of the "list in, list out"-functionality of `map()`. This allows us to chain multiple transformations together. We start by fitting the models. We then calculate the summaries and extract the $R^2$ values. For the last call we use `map_dbl()`, which provides convenient output.

```{r}
bootstraps %>%
  map(~ lm(mpg ~ disp, data = .x)) %>%
  map(summary) %>%
  map_dbl("r.squared")
```

Note: while AR Solutions is arguably *slightly* more readable, my code should be faster:

```{r}
bench::mark({
  map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)
})

bench::mark({
  bootstraps %>%
    map(~ lm(mpg ~ disp, data = .x)) %>%
    map(summary) %>%
    map_dbl("r.squared")
})
```

It is actually slightly slower! AR Solutions wins!

---

## 9.4.6 Exercises

1.  Explain the results of `modify(mtcars, 1)`.

```{r}
modify(mtcars, 1)
as_mapper(1)
head(mtcars, 1)
```

Answer: `modify(mtcars, 1)` creates a mapper that plucks the first element of each column of `mtcars` and writes that value to every row.

AR Solutions: `modify()` is based on `map()`, and in this case, the extractor interface will be used. It extracts the first element of each column in `mtcars`. `modify()` always returns the same structure as its input: in this case it forces the first row to be recycled 32 times. (Internally `modify()` uses `.x[] <- map(.x, .f, ...)` for assignment.)

Notes: this code makes the recycling clear:

```{r}
unlist(map(mtcars, 1))
```

---

2.  Rewrite the following code to use `iwalk()` instead of `walk2()`. What
    are the advantages and disadvantages?

```{r, eval = FALSE}
cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)
```

Answer: code below.

```{r}
temp <- tempfile()
dir.create(temp)

cyls <- split(mtcars, mtcars$cyl)
iwalk(cyls, ~ write.csv(.x, file.path(temp, paste0("cyl-", .y, ".csv"))))
dir(temp)
```

The main advantage of using `iwalk()` is that it will use `seq_along()` if `x` does not have names. In this case, x has names, and the resulting code is a bit harder to understand, and requires a formula (or function).

AR Solutions: `iwalk()` allows us to use a single variable, storing the output path in the names.

```{r, eval = FALSE}
temp <- tempfile()
dir.create(temp)
cyls <- split(mtcars, mtcars$cyl)
names(cyls) <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
iwalk(cyls, ~ write.csv(.x, .y))
```

We could do this in a single pipe by taking advantage of `set_names()`:

```{r, eval = FALSE}
mtcars %>%
  split(mtcars$cyl) %>%
  set_names(~ file.path(temp, paste0("cyl-", .x, ".csv"))) %>%
  iwalk(~ write.csv(.x, .y))
```

Notes: the AR Solutions use of names and the pipe is clever.

---

3.  Explain how the following code transforms a data frame using functions
    stored in a list.

```{r}
if (exists("mtcars")) rm(mtcars)
mtcars

trans <- list(
  disp = function(x) x * 0.0163871,
  am = function(x) factor(x, labels = c("auto", "manual"))
)

nm <- names(trans)
mtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))

mtcars
rm(mtcars)
```

Compare and contrast the `map2()` approach to this `map()` approach:

```{r, eval = FALSE}
mtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))
```

Answer: the `map2()` code applies the anonymous functions to the corresponding column in `mtcars` based on their name in the list:

- `mtcars[nm]` is equivalent to `mtcars[c("disp", "am")]`, so the code is modifying those two
  columns
- the mapping function, `function(f, var) f(var)` is run as `f(mtcars[["disp"]])` and
  `f(mtcars[["am"]])`, with the corresponding function in `trans` as `f`, since `trans` and
  `mtcars[nm]` are passed as parameters to the function

The equivalent `map()` approach isn't as clean: it's harder to understand what `map()` is doing.

AR Solutions: In the first approach

```{r, eval = FALSE}
mtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))
```

the list of the 2 functions (`trans`) and the 2 appropriately selected data frame columns (`mtcars[nm]`) are supplied to `map2()`. `map2()` creates an anonymous function (`f(var)`) which applies the functions to the variables when `map2()` iterates over their (similar) indices. On the left-hand side, the respective 2 elements of `mtcars` are being replaced by their new transformations.

The `map()` variant

```{r, eval = FALSE}
mtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))
```

does basically the same. However, it directly iterates over the names (`nm`) of the transformations. Therefore, the data frame columns are selected during the iteration.

Besides the iteration pattern, the approaches differ in the possibilities for appropriate argument naming in the `.f` argument. In the `map2()` approach we iterate over the elements of `x` and `y`. Therefore, it is possible to choose appropriate placeholders like `f` and `var`. This makes the anonymous function more expressive at the cost of making it longer. We think using the formula interface in this way is preferable compared to the rather cryptic `mtcars[nm] <- map2(trans, mtcars[nm], ~ .x(.y))`.

In the `map()` approach we map over the variable names. It is therefore not possible to introduce placeholders for the function and variable names. The formula syntax together with the `.x` pronoun is pretty compact. The object names and the brackets clearly indicate the application of transformations to specific columns of `mtcars`. In this case the iteration over the variable names comes in handy, as it highlights the importance of matching between `trans` and `mtcars` element names. Together with the replacement form on the left-hand side, this line is relatively easy to inspect.

To summarise, in situations where `map()` and `map2()` provide solutions for an iteration problem, several points may be considered before deciding for one or the other approach.

---

4.  What does `write.csv()` return, i.e. what happens if you use it with 
    `map2()` instead of `walk2()`?

```{r}
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
map2(cyls, paths, write.csv)
```

Answer: `write.csv()` is designed to return `NULL`, invisibly. While `walk2()` hides the `NULL` return values, `map2()` does not.

AR Solutions: `write.csv()` returns `NULL`. As we call the function for its side effect (creating a CSV file), `walk2()` would be appropriate here. Otherwise, we receive a rather uninformative list of `NULL`s.

---

## 9.6.3 Exercises

1.  Why isn't `is.na()` a predicate function? What base R function is closest
    to being a predicate version of `is.na()`?

Answer: `is.na(x)` returns `logical(0)` when `x` is `NULL`, which violates the rule that predicate functions only return `TRUE` or `FALSE`. `anyNA(x, recursive = FALSE)` appears to be a predicate version of `is.na()`.

AR Solutions: `is.na()` is not a predicate function, because it returns a logical _vector_ the same length as the input, not a single `TRUE` or `FALSE`.

`anyNA()` is the closest equivalent because it always returns a single `TRUE` or `FALSE` if there are any missing values present. You could also imagine an `allNA()` which would return `TRUE` if all values were missing, but that's considerably less useful so base R does not provide it.

---

2.  `simple_reduce()` has a problem when `x` is length 0 or length 1. Describe
    the source of the problem and how you might go about fixing it.

```{r}
simple_reduce <- function(x, f) {
  out <- x[[1]]
  for (i in seq(2, length(x))) {
    out <- f(out, x[[i]])
  }
  out
}
```

Answer: using `seq()` results in a backwards count when `x` is length 0 or 1.

```{r}
seq(2, 0)
seq(2, 1)
```

The fix is to check the length of `x` and return itself when length is 0 and throw an error when length is 1, as `reduce()` does.

AR Solutions: The loop inside `simple_reduce()` always starts with the index 2, and `seq()` can count both up _and_ down:

Therefore, subsetting length-0 and length-1 vectors via `[[` will lead to a *subscript out of bounds* error. To avoid this, we allow `simple_reduce()` to return before the for loop is started and include a default argument for 0-length vectors.

```{r}
simple_reduce <- function(x, f, default) {
  if (length(x) == 0L) {
    return(default)
  }
  if (length(x) == 1L) {
    return(x[[1L]])
  }

  out <- x[[1]]
  for (i in seq(2, length(x))) {
    out <- f(out, x[[i]])
  }

  out
}
```

Our new `simple_reduce()` now works as intended:

```{r, error = TRUE}
try(simple_reduce(integer(0), `+`))
simple_reduce(integer(0), `+`, default = 0L)
simple_reduce(1, `+`)
simple_reduce(1:3, `+`)
```

---

3.  Implement the `span()` function from Haskell: given a list `x` and a 
    predicate function `f`, `span(x, f)` returns the location of the longest 
    sequential run of elements where the predicate is true. (Hint: you 
    might find `rle()` helpful.)

```{r}
test <- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:39))
test2 <- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:40))

span <- function(x, f) {
  runs <- rle(map_lgl(x, f))
  max_true <- max_index <- 0
  index <- 1
  for (i in seq_along(runs$values)) {
    if (runs$values[i] && runs$lengths[i] > max_true) {
      max_true <- runs$lengths[i]
      max_index <- index
    }
    index <- index + runs$lengths[i]
  }
  max_index
}

span(test, is.numeric)
span(test2, is.numeric)
span(1, is.numeric)
span("a", is.numeric)
span(list("a", 1:10, 1:20), is.numeric)
```

Answer: code above.

AR Solutions: Our `span_r()` function returns the indices of the (first occurring) longest sequential run of elements where the predicate is true. If the predicate is never true, the longest run has length 0, in which case we return `integer(0)`.

```{r}
span_r <- function(x, f) {
  idx <- unname(map_lgl(x, ~ f(.x)))
  rle <- rle(idx)

  # Check if the predicate is never true
  if (!any(rle$values)) {
    return(integer(0))
  }

  # Find the length of the longest sequence of true values
  longest <- max(rle$lengths[rle$values])
  # Find the position of the (first) longest run in rle
  longest_idx <- which(rle$values & rle$lengths == longest)[1]

  # Add up all lengths in rle before the longest run
  ind_before_longest <- sum(rle$lengths[seq_len(longest_idx - 1)])

  out_start <- ind_before_longest + 1L
  out_end <- ind_before_longest + longest
  out_start:out_end
}

# Check that it works
span_r(c(0, 0, 0, 0, 0), is.na)
span_r(c(NA, 0, 0, 0, 0), is.na)
span_r(c(NA, 0, NA, NA, NA), is.na)
```

Notes: AR Solutions shows how to find the index of the longest sequence using `which()`, which is new to me, and returns more information by returning indexes of the entire span. The AR Solutions approach is also significantly faster (which I did not expect).

```{r}
bench::mark(span_r(test2, is.numeric))
bench::mark(span(test2, is.numeric))
```

---

4.  Implement `arg_max()`. It should take a function and a vector of inputs, 
    and return the elements of the input where the function returns the highest 
    value. For example, `arg_max(-10:5, function(x) x ^ 2)` should return -10.
    `arg_max(-5:5, function(x) x ^ 2)` should return `c(-5, 5)`.
    Also implement the matching `arg_min()` function.

Answer: code below.

```{r}
arg_max <- function(x, f) {
  val <- map_dbl(x, f)
  val_max <- max(val)
  x[which(val == val_max)]
}

arg_max(-10:5, function(x) x^2)
arg_max(-5:5, function(x) x^2)

arg_min <- function(x, f) {
  val <- map_dbl(x, f)
  val_min <- min(val)
  x[which(val == val_min)]
}

arg_min(-10:5, function(x) x^2)
arg_min(c(-5:-1, 1:5), function(x) x^2)
```

AR Solutions: Both functions take a vector of inputs and a function as an argument. The function output is then used to subset the input accordingly.

```{r}
arg_max <- function(x, f) {
  y <- map_dbl(x, f)
  x[y == max(y)]
}

arg_min <- function(x, f) {
  y <- map_dbl(x, f)
  x[y == min(y)]
}

arg_max(-10:5, function(x) x^2)
arg_min(-10:5, function(x) x^2)
```

Notes: using `which()` is unnecessary, AR Solutions is a better approach.

---

5.  The function below scales a vector so it falls in the range [0, 1]. How
    would you apply it to every column of a data frame? How would you apply it 
    to every numeric column in a data frame?

```{r}
scale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

Answer: code below.

```{r}
# every column
modify(mtcars, scale01)

# every numeric column
modify_if(iris, is.numeric, scale01)
```

AR Solutions: To apply a function to every column of a data frame, we can use `purrr::modify()` (or `purrr::map_dfr()`), which also conveniently returns a data frame. To limit the application to numeric columns, the scoped version `modify_if()` can be used.

```{r, eval = FALSE}
modify_if(mtcars, is.numeric, scale01)
```

---

## 9.7.3 Exercises

1.  How does `apply()` arrange the output? Read the documentation and perform 
    some experiments.

```{r, eval = FALSE}
# experiments
m1 <- matrix(1:4, nrow = 1)
apply(m1, 1, sum)
apply(m1, 2, sum)
apply(m1, c(1, 2), `*`, 2)
apply(m1, 1, `*`, 2)
apply(m1, 1, `*`, 2, simplify = FALSE)
apply(m1, 2, `*`, 2)
apply(m1, 1, sum, simplify = FALSE)

m1a <- matrix(1:4, ncol = 1)
apply(m1a, 1, `*`, 2)

m2 <- matrix(1:20, ncol = 4)
apply(m2, 1, sum)

m3 <- array(1:24, dim = c(2, 3, 4))
apply(m3, 1, sum)
apply(m3, 2, sum)
apply(m3, 3, sum)
apply(m3, 1, `*`, 2)
apply(m3, 2, `*`, 2)
apply(m3, 3, `*`, 2)
apply(m3, c(1, 2, 3), `*`, 2)
```

Answer: the documentation states:

> If each call to `FUN` returns a vector of length `n`, and simplify is `TRUE`, then apply returns an array of dimension `c(n, dim(X)[MARGIN])` if `n > 1`. If `n` equals 1, `apply` returns a vector if `MARGIN` has length 1 and an array of `dimension dim(X)[MARGIN]` otherwise. If `n` is 0, the result has length 0 but not necessarily the 'correct' dimension.
> 
> If the calls to `FUN` return vectors of different lengths, or if simplify is `FALSE`, apply returns a list of `length prod(dim(X)[MARGIN])` with `dim` set to `MARGIN` if this has length greater than one.

With exploration, under normal circumstances:

- If `MARGIN` includes all dimensions of an array or matrix (`c(1, 2)` or `c(1, 2, 3)`), the output
  is arranged in the same shape as the input
- Otherwise, the return value drops a dimension if modifying a vector in place (as with `*`), or
  returns a vector when summarizing (as with `sum`)
- Matrices of a single row are simplified to a vector
- Matrices of a single column are returned as a matrix
- When `simplify = FALSE` is set, a list is returned

However, even with all this, the "rules" aren't clear to me.

AR Solutions: Basically `apply()` applies a function over the margins of an array. In the two-dimensional case, the margins are just the rows and columns of a matrix. Let's make this concrete.

```{r}
arr2 <- array(1:12, dim = c(3, 4))
rownames(arr2) <- paste0("row", 1:3)
colnames(arr2) <- paste0("col", 1:4)
arr2
```

When we apply the `head()` function over the first margin of `arr2()` (i.e. the rows), the results are contained in the columns of the output, transposing the array compared to the original input.

```{r}
apply(arr2, 1, function(x) x[1:2])
```

And vice versa if we apply over the second margin (the columns):

```{r}
apply(arr2, 2, function(x) x[1:2])
```

The output of `apply()` is organised first by the margins being operated over, then the results of the function. This can become quite confusing for higher dimensional arrays.

Notes: AR Solutions' explanation is better, but the output is still confusing.

---

2.  What do `eapply()` and `rapply()` do? Does purrr have equivalents?

Answer: `eapply()` applies a function to named values in an environment. `rapply()` is a recursive `lapply()`. There are no equivalents in purrr.

AR Solutions: `eapply()` is a variant of `lapply()`, which iterates over the (named) elements of an environment. In `purrr` there is no equivalent for `eapply()` as `purrr` mainly provides functions that operate on vectors and functions, but not on environments.

`rapply()` applies a function to all elements of a list recursively. This function makes it possible to limit the application of the function to specified classes (default `classes = ANY`). One may also specify how elements of other classes should remain: as their identity (`how = replace`) or another value (`default = NULL`). The closest equivalent in `purrr` is `modify_depth()`, which allows you to modify elements at a specified depth in a nested list.

Notes: I wasn't aware of `purrr::modify_depth()`.

---

3.  Challenge: read about the 
    [fixed point algorithm](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html#%25_idx_1096).
    Complete the exercises using R.

Answer: the fixed point algorithm is defined below, with an example solution:

```
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point cos 1.0)
0.7390822985224023

(fixed-point (lambda (y) (+ (sin y) (cos y)))
             1.0)
1.2587315962971173

(define (sqrt x)
  (fixed-point (lambda (y) (/ x y))
               1.0))
```

Implementation in R:

```{r}
fixed_point <- function(f, x) {
  tolerance <- 0.00001
  close_enough <- function(v1, v2) {
    abs(v1 - v2) < tolerance
  }

  if (close_enough(f(x), x)) {
    f(x)
  } else {
    fixed_point(f, f(x))
  }
}

fixed_point(cos, 1.0)
fixed_point(function(y) sin(y) + cos(y), 1.0)
```

AR Solutions: A number $x$ is called a fixed point of a function $f$ if it satisfies the equation $f(x) = x$. For some functions we may find a fixed point by beginning with a starting value and applying $f$ repeatedly. Here `fixed_point()` acts as a functional because it takes a function as an argument.

```{r, error = TRUE}
fixed_point_ar <- function(f, x_init, n_max = 10000, tol = 0.0001) {
  n <- 0
  x <- x_init
  y <- f(x)

  is_fixed_point <- function(x, y) {
    abs(x - y) < tol
  }

  while (!is_fixed_point(x, y)) {
    x <- y
    y <- f(y)

    # Make sure we eventually stop
    n <- n + 1
    if (n > n_max) {
      stop("Failed to converge.", call. = FALSE)
    }
  }

  x
}

# Functions with fixed points
fixed_point_ar(sin, x_init = 1)
fixed_point_ar(cos, x_init = 1)

# Functions without fixed points
add_one <- function(x) x + 1
try(fixed_point_ar(add_one, x_init = 1))
```

Notes: AR Solutions offers a different approach using a `while()` loop that is guaranteed to stop. My approach using recursive calls does stop eventually with a stack limit error (however, this stops `build_analysis_site()`):

```{r, eval = FALSE}
fixed_point(add_one, 1)
```

Comparing benchmarks:

```{r}
bench::mark(fixed_point_ar(cos, x_init = 1, tol = 0.00001))
bench::mark(fixed_point(cos, 1))
```

As usual, AR Solutions is faster. :-(

---
