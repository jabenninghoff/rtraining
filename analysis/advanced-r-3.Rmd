---
title: "Advanced R Workbook (Object-oriented programming)"
date: '2022-08-15'
output:
  html_notebook:
    theme:
      version: 5
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: no
---

Workbook for completing quizzes and exercises from the "Object-oriented programming" chapters of [Advanced R](https://adv-r.hadley.nz/index.html), second edition, with comparisons to solutions from [Advanced R Solutions](https://advanced-r-solutions.rbind.io).

```{r setup, message = FALSE, warning = FALSE}
library(sloop)
library(purrr)
library(dplyr)

# from https://github.com/hadley/adv-r/blob/master/common.R
knitr::opts_chunk$set(
  comment = "#>",
  fig.align = "center"
)

knitr::knit_hooks$set(
  small_mar = function(before, options, envir) {
    if (before) {
      par(mar = c(4.1, 4.1, 0.5, 0.5)) # nolint: undesirable_function_linter.
    }
  }
)
```

# Introduction

This workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html) and [Advanced R Solutions](https://advanced-r-solutions.rbind.io), organized by chapter. It includes excerpts from both books, copied here.

**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and exercises, don't read this notebook. It contains my (potentially wrong) answers to both.

# 12 Base types

To talk about objects and OOP in R we first need to clear up a fundamental confusion about two uses of the word "object". So far in this book, we've used the word in the general sense captured by John Chambers' pithy quote: "Everything that exists in R is an object". However, while everything _is_ an object, not everything is object-oriented. This confusion arises because the base objects come from S, and were developed before anyone thought that S might need an OOP system. The tools and nomenclature evolved organically over many years without a single guiding principle.

Most of the time, the distinction between objects and object-oriented objects is not important. But here we need to get into the nitty gritty details so we'll use the terms __base objects__ and __OO objects__ to distinguish them.

# 13 S3

S3 is R's first and simplest OO system. S3 is informal and ad hoc, but there is a certain elegance in its minimalism: you can't take away any part of it and still have a useful OO system. For these reasons, you should use it, unless you have a compelling reason to do otherwise. S3 is the only OO system used in the base and stats packages, and it's the most commonly used system in CRAN packages.

S3 is very flexible, which means it allows you to do things that are quite ill-advised. If you're coming from a strict environment like Java this will seem pretty frightening, but it gives R programmers a tremendous amount of freedom.  It may be very difficult to prevent people from doing something you don't want them to do, but your users will never be held back because there is something you haven't implemented yet. Since S3 has few built-in constraints, the key to its successful use is applying the constraints yourself. This chapter will therefore teach you the conventions you should (almost) always follow.

The goal of this chapter is to show you how the S3 system works, not how to use it effectively to create new classes and generics. I'd recommend coupling the theoretical knowledge from this chapter with the practical knowledge encoded in the [vctrs package](https://vctrs.r-lib.org).

## 13.2.1 Exercises

1.  Describe the difference between `t.test()` and `t.data.frame()`.
    When is each function called?

```{r}
ftype(t.test)
ftype(t.data.frame)
s3_dispatch(t.test(formula()))
s3_dispatch(t(data.frame()))
```

Answer: As noted by `sloop::ftype()` and the docs, `t.test()` is a S3 generic, and `t.data.frame()` is an S3 method for `t()` (transpose). `t.data.frame()` is called as a method when calling `t(x)` when `x` is a `data.frame`. `t.test()` calls either `t.test.default` or `t.test.formula`.

AR Solutions: Because of S3's `generic.class()` naming scheme, both functions may initially look similar, while they are in fact unrelated.

- `t.test()` is a *generic* function that performs a t-test. 
- `t.data.frame()` is a *method* that gets called by the generic `t()` to transpose data frame input.

Due to R's S3 dispatch rules, `t.test()` would also get called when `t()` is applied to an object of class `test`

---

2.  Make a list of commonly used base R functions that contain `.` in their
    name but are not S3 methods.

```{r}
ftype(as.character)
ftype(as.data.frame)
ftype(data.frame)
ftype(eval.parent)
ftype(file.path)
ftype(file.copy)
ftype(is.null)
ftype(is.data.frame)
ftype(Sys.localeconv)
ftype(Sys.time)
```

Answer:

- All of the `as.` functions
- `data.frame`
- All of the `file.` functions
- All of the `is.` functions
- All of the `Sys.` functions

AR Solutions: In recent years "snake_case"-style has become increasingly common when naming functions and variables in R. But many functions in base R will continue to be "point.separated", which is why some inconsistency in your R code most likely cannot be avoided. (`install.packages(), read.csv(), list.files(), download.file(), data.frame(), as.character(), Sys.Date(), all.equal(), do.call(), on.exit()`)

---

3.  What does the `as.data.frame.data.frame()` method do? Why is
    it confusing? How could you avoid this confusion in your own
    code?

```{r}
s3_dispatch(as.data.frame(data.frame()))
```

Answer: `as.data.frame.data.frame()` is the method used to coerce a `data.frame` to a `data.frame`. This is confusing because the class contains a period (as does the function call); avoiding periods improves readability: `as_dataframe.dataframe` makes the generic and method clear.

AR Solutions: The function `as.data.frame.data.frame()` implements the `data.frame()` *method* for the `as.data.frame()` *generic*, which coerces objects to data frames.

The name is confusing, because it does not clearly communicate the type of the function, which could be a regular function, a generic or a method. Even if we assume a method, the amount of `.`'s makes it difficult to separate the generic- and the class-part of the name. Is it the `data.frame.data.frame()` method for the `as()` generic? Is it the `frame.data.frame()` method for the `as.data()` generic?

We could avoid this confusion by applying a different naming convention (e.g. "snake_case") for our class and function names.

---

4.  Describe the difference in behaviour in these two calls.

```{r}
set.seed(1014)
some_days <- as.Date("2017-01-31") + sample(10, 5)
mean(some_days)
mean(unclass(some_days))

s3_dispatch(mean(some_days))
s3_dispatch(mean(unclass(some_days)))
```

Answer: the first call calculates the mean using `mean.Date()`, and so returns a date. using `unclass()` changes the date to its underlying value (double) which calculates the mean using `mean.default()`.

AR Solutions: `mean()` is a generic function, which will select the appropriate method based on the class of the input. `some_days` has the class `Date` and `mean.Date(some_days)` will be used to calculate the mean date of `some_days`.

After `unclass()` has removed the class attribute from `some_date`, the default method is chosen. `mean.default(unclass(some_days))` then calculates the mean of the underlying double.

---

5.  What class of object does the following code return? What base type is it 
    built on? What attributes does it use?

```{r}
x <- ecdf(rpois(100, 10))
x

str(x)
```

Answer: the code returns an object of class `ecdf`, which is build on the `stepfun` object, and the `function` base type. It additionally includes the `call` attribute.

AR Solutions: It returns an object of the class `ecdf` (empirical cumulative distribution function) with the superclasses `stepfun` and `function`. The `ecdf` object is built on the base type `closure` (a function). The expression, which was used to create it (`rpois(100, 10)`), is stored in the `call` attribute.

```{r}
typeof(x)
```

---

6.  What class of object does the following code return? What base type is it 
    built on? What attributes does it use?

```{r}
x <- table(rpois(100, 5))
x

str(x)
str(unclass(x))
```

Answer: per the docs, the code returns an object of class `table`, which is built on `array`, which uses the `dimnames` attribute in combination with a vector.

AR Solutions: This code returns a `table` object, which is built upon the `integer` type. The attribute `dimnames` is used to name the elements of the integer vector.

---

## 13.3.4 Exercises

1.  Write a constructor for `data.frame` objects. What base type is a data
    frame built on? What attributes does it use? What are the restrictions
    placed on the individual elements? What about the names?

```{r}
dput(data.frame())
dput(data.frame(a = 1:2, b = 3:4))
unclass(data.frame(a = 1:2, b = 3:4))
```

Answer: code below. The data frame is built on the list base type, and includes the names, row.names, and class attributes. This implementation requires values to be a list, names to be a character, and row.names to be an integer.

```{r}
new_data.frame <- function(values = list(), # nolint: object_name_linter.
                           names = character(length(values)),
                           row.names = integer(length(values))) { # nolint: object_name_linter.
  stopifnot(
    is.list(values),
    is.character(names),
    is.integer(row.names)
  )
  structure(values, names = names, row.names = row.names, class = "data.frame")
}

new_data.frame()
new_data.frame(list(1:3, 4:6, 7:9))
new_data.frame(list(1:3, 4:6, 7:9), names = c("a", "b", "c"), row.names = 1:3)
```

AR Solutions: Data frames are built on named lists of vectors, which all have the same length. Besides the `class` and the column names (`names`), the `row.names` are their only further attribute. This must be a character vector with the same length as the other vectors.

We need to provide the number of rows as an input to make it possible to create data frames with 0 columns but multiple rows.

This leads to the following constructor:

```{r, error = TRUE}
new_data.frame <- function(x, n, row.names = NULL) { # nolint: object_name_linter.
  # nolint start: consecutive_stopifnot_linter.
  # Check if the underlying object is a list
  stopifnot(is.list(x))

  # Check all inputs are the same length
  # (This check also allows that x has length 0)
  stopifnot(all(lengths(x) == n))
  # nolint end

  if (is.null(row.names)) {
    # Use special row names helper from base R
    row.names <- .set_row_names(n) # nolint: object_name_linter.
  } else {
    # Otherwise check that they're a character vector with the
    # correct length
    stopifnot(is.character(row.names), length(row.names) == n)
  }

  structure(
    x,
    class = "data.frame",
    row.names = row.names
  )
}

# Test
x <- list(a = 1, b = 2)
new_data.frame(x, n = 1)
new_data.frame(x, n = 1, row.names = "l1")

# Create a data frame with 0 columns and 2 rows
new_data.frame(list(), n = 2)
```

Note: AR Solutions approach also validates that all inputs are same length, and supports creation of dataframes with 0 columns but multiple rows.

---

2.  Enhance my `factor()` helper to have better behaviour when one or
    more `values` is not found in `levels`. What does `base::factor()` do
    in this situation?

```{r}
new_factor <- function(x = integer(), levels = character()) {
  stopifnot(
    is.integer(x),
    is.character(levels)
  )

  structure(
    x,
    levels = levels,
    class = "factor"
  )
}
```

Answer: the fix is to update `validate_factor()` to allow `NA` values, since the helper already fills in `NA` when `values` is not found in `levels`. This matches the behavior of `base::factor()`. 

```{r}
validate_factor <- function(x) {
  values <- unclass(x)
  levels <- attr(x, "levels")

  if (!all(is.na(values) | values > 0)) {
    stop(
      "All non-missing `x` values must be greater than zero",
      call. = FALSE
    )
  }

  if (length(levels) < max(values, na.rm = TRUE)) {
    stop(
      "There must be at least as many `levels` as possible values in `x`",
      call. = FALSE
    )
  }

  x
}

my_factor <- function(x = character(), levels = unique(x)) {
  ind <- match(x, levels)
  validate_factor(new_factor(ind, levels))
}

factor(c("a", "a", "b"), levels = "a")
my_factor(c("a", "a", "b"), levels = "a")
```

AR Solutions: `base::factor()` converts these values (silently) into `NA`s.

The `factor()` helper including the constructor (`new_factor()`) and its validator (`validate_factor()`) were given in *Advanced R*. However, as the goal of this question is to throw an early error within the helper, we only repeat the code for the helper:

To improve the `factor()` helper we choose to return an informative error message instead.

```{r, error = TRUE}
factor2 <- function(x, levels = unique(x)) {
  new_levels <- match(x, levels)

  # Error if levels don't include all values
  missing <- unique(setdiff(x, levels))
  if (length(missing) > 0) {
    stop(
      "The following values do not occur in the levels of x: ",
      paste0("'", missing, "'", collapse = ", "), ".",
      call. = FALSE
    )
  }

  validate_factor(new_factor(new_levels, levels))
}

# Test
try(factor2(c("a", "b", "c"), levels = c("a", "b")))
```

---

3.  Carefully read the source code of `factor()`. What does it do that
    my constructor does not?

```{r}
factor(c("a", "a", "b", "c"), labels = c("alpha", "beta", "beta"))
class(factor(1:10, ordered = TRUE))
```

Answer: the base implementation:

- sets the value to `character(0)` if the value is null
- retains value names
- allows an upper bound on the number of levels, `nmax`
- coerces the value to character
- provides a method for excluding values from levels, `exclude`
- provides `labels` for remapping factors
- adds an "ordered" class if the value is ordered (`ordered = TRUE`)

Note: labels are an interesting and unexpected feature of `factor()`

```{r}
factor
```

AR Solutions: The original implementation (`base::factor()`) allows more flexible input for `x`. It coerces `x` to character or replaces it with `character(0)` (in case of `NULL`). It also ensures that the `levels` are unique. This is achieved by setting them via `base::levels<-`, which fails when duplicate values are supplied.

Note: I missed the fact that `base::levels<-` fails when duplicate values are supplied.

---
    
4.  Factors have an optional "contrasts" attribute. Read the help for `C()`, 
    and briefly describe the purpose of the attribute. What type should it 
    have? Rewrite the `new_factor()` constructor to include this attribute.

Answer: per the "contrast {stats}" documentation, contrast matrices are used in fitting analysis of variance and regression models, so the attribute should be a matrix.

```{r}
new_factor <- function(x = integer(), levels = character(), contr = matrix()) {
  stopifnot(is.integer(x), is.character(levels), is.matrix(contr))

  structure(
    x,
    levels = levels,
    class = "factor",
    contrasts = contr
  )
}
```

AR Solutions: When factor variables (representing nominal or ordinal information) are used in statistical models, they are typically encoded as dummy variables and by default each level is compared with the first factor level. However, many different encodings ("contrasts") are possible, see [Contrast](https://en.wikipedia.org/wiki/Contrast_(statistics)).

Within R's formula interface you can wrap a factor in `stats::C()` and specify the contrast of your choice. Alternatively, you can set the `contrasts` attribute of your factor variable, which accepts matrix input. (See `?contr.helmert` or similar for details.)

Our updated `new_factor()` constructor gets a `contrasts` argument, which accepts a numeric matrix or `NULL` (default).

```{r}
# Updated new_factor() constructor
new_factor <- function(x = integer(),
                       levels = character(),
                       contrasts = NULL) {
  # nolint start: consecutive_stopifnot_linter.
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))
  # nolint end

  if (!is.null(constrasts)) { # nolint: object_usage_linter. not sure why lintr flags this.
    stopifnot(is.matrix(contrasts) && is.numeric(contrasts)) # nolint: conjunct_test_linter.
  }

  structure(
    x,
    levels = levels,
    class = "factor",
    contrasts = contrasts
  )
}
```

---

5.  Read the documentation for `utils::as.roman()`. How would you write a
    constructor for this class? Does it need a validator? What might a helper 
    do?

```{r}
dput(as.roman(3899))

new_roman <- function(x = integer()) {
  stopifnot(is.integer(x))

  structure(
    x,
    class = "roman"
  )
}

new_roman(2022L)
```

Answer: the structure of the class "roman" is simple, an integer with a defined class. A simple constructor would take an integer and return an object of class "roman" as above. A validator is probably not needed, but could validate that the integer is within the supported range of integers (1-3899). A helper might coerce the number to be an integer using `as.integer()`.

AR Solutions: This function transforms numeric input into Roman numbers. It is built on the integer type, which results in the following constructor.

```{r}
new_roman <- function(x = integer()) {
  stopifnot(is.integer(x))
  structure(x, class = "roman")
}
```

The documentation tells us, that only values between 1 and 3899 are uniquely represented, which we then include in our validation function.

```{r}
validate_roman <- function(x) {
  values <- unclass(x)

  if (any(values < 1 | values > 3899)) {
    stop(
      "Roman numbers must fall between 1 and 3899.",
      call. = FALSE
    )
  }

  x
}
```

For convenience, we allow the user to also pass real values to a helper function.

```{r, error = TRUE}
roman <- function(x = integer()) {
  x <- as.integer(x)

  validate_roman(new_roman(x))
}

# Test
roman(c(1, 753, 2019))
try(roman(0))
```

---

## 13.4.4 Exercises

1.  Read the source code for `t()` and `t.test()` and confirm that
    `t.test()` is an S3 generic and not an S3 method. What happens if
    you create an object with class `test` and call `t()` with it? Why?

```{r}
x <- structure(1:10, class = "test")
t(x)
```

Answer: both `t()` and `t.test()` simply call `UseMethod()`, and are S3 generics.

```{r}
t
t.test
```

Creating an object with class `test` and calling `t()` uses the default method since `t.test()` is not a registered method for `t()`, as this code shows:

```{r}
methods("t")
s3_dispatch(t(x))
```

AR Solutions: We can see that `t.test()` is a generic because it calls `UseMethod()`.

```{r}
# or simply call
ftype(t.test)
```

Interestingly, R also provides helpers, which list functions that look like methods, but in fact are not:

```{r}
tools::nonS3methods("stats")
```

When we create an object with class `test`, `t()` dispatches to the `t.default()` method. This happens, because `UseMethod()` simply searches for functions named `paste0("generic", ".", c(class(x), "default"))`.

However, in older versions of R (pre R 4.0.0; when *Advanced R* was written) this behaviour was slightly different. Instead of dispatching to the `t.default()` method, the `t.test()` generic was erroneously treated as a method of `t()` which then dispatched to `t.test.default()` or (when defined) to `t.test.test()`.

---

2.  What generics does the `table` class have methods for?

Answer: `s3_methods_class()` answers this question:

```{r warning = FALSE}
s3_methods_class("table")
```

AR Solutions: This is a simple application of `sloop::s3_methods_class()`.

Interestingly, the `table` class has a number of methods designed to help plotting with base graphics.

```{r}
x <- rpois(100, 5)
plot(table(x))
```

---

3.  What generics does the `ecdf` class have methods for?

Answer:

```{r warning = FALSE}
s3_methods_class("ecdf")
```

AR Solutions: We use the same approach as above.

The methods are primarily designed for display (`plot()`, `print()`, `summary()`), but you can also extract quantiles with `quantile()`.

---

4.  Which base generic has the greatest number of defined methods?

Answer: using code from 6.2.5, identify generics and count defined methods:

```{r, warning = FALSE}
# from 6.2.5 exercises, this code makes a list of all functions in the base package
funs <- Filter(is.function, mget(ls("package:base", all.names = TRUE), inherits = TRUE))

get_method_count <- function(fname) {
  data.frame(
    name = fname,
    # this code should work but doesn't:
    # method_count = nrow(s3_methods_generic(fname)) # nolint: commented_code_linter.
    method_count = length(methods(fname))
  )
}

map_dfr(names(funs), get_method_count) |>
  arrange(desc(method_count))
```

This brute-force code unsurprisingly identifies `print()` as having the greatest number of methods. A bug in `s3_methods_generic()` prevents its use (error below).

```
Error in gsub(paste0("^", generic_esc, "[.,]"), "", info$method) : 
invalid regular expression '^([.,]', reason 'Missing ')''
```

AR Solutions: A little experimentation (and thinking about the most popular functions) suggests that the `print()` generic has the most defined methods.

Let's verify this programmatically with the tools we have learned in this and the previous chapters.

```{r, message = FALSE}
ls(all.names = TRUE, envir = baseenv()) %>%
  mget(envir = baseenv()) %>%
  keep(is_function) %>%
  names() %>%
  keep(is_s3_generic) %>%
  map(~ set_names(nrow(s3_methods_generic(.x)), .x)) %>%
  flatten_int() %>%
  sort(decreasing = TRUE) %>%
  head()
```

---

5.  Carefully read the documentation for `UseMethod()` and explain why the
    following code returns the results that it does. What two usual rules
    of function evaluation does `UseMethod()` violate?

```{r}
g <- function(x) {
  x <- 10
  y <- 10 # nolint: object_usage_linter.
  UseMethod("g")
}
g.default <- function(x) c(x = x, y = y)
x <- 1
y <- 1
g(x)
```

Answer: the documentation states in **Technical Details**:

> `UseMethod` creates a new function call with arguments matched as they came in to the generic. Any local variables defined before the call to `UseMethod` are retained (unlike S).

So, `UseMethod()` creates a new function call where `x` matches `x <- 1` and the local variable `y <- 10` is retained. This is passed to `g.default()`. This violates both lazy evaluation and lexical scoping.

AR Solutions: Let's take this step by step. If you call `g.default(x)` directly you get `c(1, 1)` as you might expect. 

The value bound to `x` comes from the argument, the value from `y` comes from the global environment.

But when we call `g(x)` we get `c(1, 10)`.

This is seemingly inconsistent: why does `x` come from the value defined inside of `g()`, and `y` still come from the global environment? It's because `UseMethod()` calls `g.default()` in a special way so that variables defined inside the generic are available to methods. The exception are arguments supplied to the function: they are passed on as is and cannot be affected by code inside the generic.

---

6.  What are the arguments to `[`? Why is this a hard question to answer?

Answer: the possible arguments include the `x`, the object being extracted (or replaced), indices (`i`, `j`, `...`), `name`, `drop`, `exact`, and `value`.

This is a hard question to answer since `[` is an irregular primitive function that can be called in multiple ways, none of which support using all possible arguments.

AR Solutions: The subsetting operator `[` is a primitive and a generic function, which can be confirmed via `ftype()`.

```{r}
ftype(`[`)
```

For primitive functions `formals([)` returns `NULL` so we need to find another way to determine the functions arguments. One possible way to figure out `[`'s arguments would be to inspect the underlying C source code, which can be searched for via `pryr::show_c_source(.Primitive("["))`.
When we inspect the arguments of some of `[`'s methods, we see that the arguments vary with the class of `x`.

```{r}
names(formals(`[.data.frame`))
names(formals(`[.table`))
names(formals(`[.Date`))
names(formals(`[.AsIs`))
```

To finally get a better overview, we have to put in a little more effort and also use `s3_methods_generic()` again.

```{r, message = FALSE, warning = FALSE}
s3_methods_generic("[") %>%
  filter(visible) %>%
  mutate(
    method = paste0("[.", class),
    argnames = purrr::map(method, ~ names(formals(.x))),
    args = purrr::map(method, ~ formals(.x)),
    args = purrr::map2( # nolint: duplicate_argument_linter.
      argnames, args,
      ~ paste(.x, .y, sep = " = ")
    ),
    args = purrr::set_names(args, method) # nolint: duplicate_argument_linter.
  ) %>%
  pull(args) %>%
  head()
```

---
