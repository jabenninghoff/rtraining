---
title: "Advanced R Workbook"
date: '2022-06-12'
output:
  html_notebook:
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
---

Workbook for completing quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html), second edition.

```{r setup, message = FALSE, warning = FALSE}
library(lobstr)
library(bench)
```

# Introduction

This workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html), organized by chapter. It includes excerpts from the book, copied here.

**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and
exercises, don't read this notebook. It contains my (potentially wrong) answers to both.

# 2 Names and values

In R, it is important to understand the distinction between an object and its name. Doing so will help you:

* More accurately predict the performance and memory usage of your code. 
* Write faster code by avoiding accidental copies, a major source of slow code. 
* Better understand R's functional programming tools.

The goal of this chapter is to help you understand the distinction between names and values, and when R will copy an object.

## 2 Quiz

1.  Given the following data frame, how do I create a new column called "3"
    that contains the sum of `1` and `2`? You may only use `$`, not `[[`.
    What makes `1`, `2`, and `3` challenging as variable names?

```{r}
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
```

Answer: use the following code.

```{r}
df2 <- data.frame(df, df$`1` + df$`2`)
names(df2) <- c(1, 2, 3)
```

Using numbers as names is problematic due to them being interpreted as numeric constants by default.

---

2.  In the following code, how much memory does `y` occupy?
   
```{r}
x <- runif(1e6)
y <- list(x, x, x)
```

Answer: 3 times the size of x, 24 MB. Note: this is incorrect, as shown by `obj_size` and `obj_addr`:

```{r}
obj_size(x)
obj_size(y)
obj_addr(y[[1]])
obj_addr(y[[2]])
obj_addr(y[[3]])
```

---

3.  On which line does `a` get copied in the following example?

```{r}
a <- c(1, 5, 3, 2)
obj_addr(a)

b <- a
obj_addr(b)

b[[1]] <- 10
obj_addr(b)
```

Answer: the third line (copy-on-write). [copy-on-modify]

## 2.2.2 Exercises

1.  Explain the relationship between `a`, `b`, `c` and `d` in the following 
    code:

```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
```

Answer: a, b, and c all point to the same object (1:10). d points to an identical object at a
different address.

```{r}
obj_addr(a)
obj_addr(b)
obj_addr(c)
obj_addr(d)
```

---

2.  The following code accesses the mean function in multiple ways. Do they all 
    point to the same underlying function object? Verify this with 
    `lobstr::obj_addr()`.
    
```{r, eval = FALSE}
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")
```

Check the `obj_addr`:

```{r}
obj_addr(mean)
obj_addr(base::mean)
obj_addr(get("mean"))
obj_addr(evalq(mean))
obj_addr(match.fun("mean"))
```

Answer: they do.

---

3.  By default, base R data import functions, like `read.csv()`, will 
    automatically convert non-syntactic names to syntactic ones. Why might 
    this be problematic? What option allows you to suppress this behaviour?

Answer: this could introduce problematic names, like `1`. Setting `check.names = FALSE` suppresses
this behavior.

---

4.  What rules does `make.names()` use to convert non-syntactic names into
    syntactic ones?

Answer: from `?make.names`:

> The character "X" is prepended if necessary. All invalid characters are translated to ".".
> A missing value is translated to "NA". Names which match R keywords have a dot appended to them.
> Duplicated values are altered by make.unique.
  
---

5.  I slightly simplified the rules that govern syntactic names. Why is `.123e1`
    not a syntactic name? Read `?make.names` for the full details.

Answer: from `?make.names`:

> A syntactically valid name consists of letters, numbers and the dot or underline characters and
starts with a letter or the dot not followed by a number. Names such as ".2way" are not valid, and
neither are the reserved words.

---

## 2.3.6 Exercises

1.  Why is `tracemem(1:10)` not useful?

Answer: this is tracing an 'immutable' object which will always have the same address.

---

2.  Explain why `tracemem()` shows two copies when you run this code.
    Hint: carefully look at the difference between this code and the code 
    shown earlier in the section.
     
```{r}
rm(list = ls())
x <- c(1L, 2L, 3L)
tracemem(x)

x[[3]] <- 4
untracemem(x)
```

Answer: unclear. The behavior in R 4.2.0 seems to have changed, since this code shows two copies:

```{r}
rm(list = ls())
x <- c(1, 2, 3)
tracemem(x)

y <- x
y[[3]] <- 4L
y[[3]] <- 5L
untracemem(x)
```

---

3.  Sketch out the relationship between the following objects:

```{r}
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)

print("first object")
obj_addr(a)
obj_addr(b[[1]])
obj_addr(b[[2]])
obj_addr(c[[2]])

print("second object")
obj_addr(b)
obj_addr(c[[1]])

print("third object")
obj_addr(c)

print("fourth object (?)")
obj_addr(c[[3]])
```

Answer: four different objects with multiple names.

---

4.  What happens when you run this code? Draw a picture.

```{r}
x <- list(1:10)

x[[2]] <- x

ref(x)
```

Initially x is a list of one element, an int vector 1:10. Then a second list element is added, which
points to the original int vector.

---

## 2.4.1 Exercises

1.  In the following example, why are `object.size(y)` and `obj_size(y)`
    so radically different? Consult the documentation of `object.size()`.

```{r}
y <- rep(list(runif(1e4)), 100)

object.size(y)
obj_size(y)
```

Answer: `object.size()` "does not detect if elements of a list are shared", which is the case here.
That is, it does not detect the list has been replicated 100 times, and overestimates by a factor of
100 compared to `object_size()`.

---

2.  Take the following list. Why is its size somewhat misleading?

```{r}
funs <- list(mean, sd, var)
obj_size(funs)
```

Answer: it doesn't seem misleading to me, but the list includes the function objects, not the
return values. Also, it calculates the size discarding the overlap between the functions. Per the
code below, there is some:

```{r}
obj_size(mean) + obj_size(sd) + obj_size(var)
```

---

3.  Predict the output of the following code:

```{r}
a <- runif(1e6)
obj_size(a) # 8,000,048 B ~ 8MB
# correct: from example above, runif(1e6) ~= 8MB

b <- list(a, a)
obj_size(b) # slightly larger than obj_size(a)
# correct: two lists containing numeric vectors
obj_size(a, b) # slightly larger than obj_size(b)
# wrong: a is entirely contained within b

b[[1]][[1]] <- 10
obj_size(b) # copy of b, same size
# wrong: double, since R copies an entire column, this adds the size of runif(1e6)
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)
# wrong: a is still entirely contained with b

b[[2]][[1]] <- 10
obj_size(b) # copy of b, same size
# wrong: same size since it's still 2 numeric vectors of 1e6 length
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)
# wrong: there is no longer any overlap, so the size of obj_size(a, b) = obj_size(a) = obj_size(b)
```

Answer: answers inline.

---

## 2.5.3 Exercises

1.  Explain why the following code doesn't create a circular list.

```{r}
x <- list()
x[[1]] <- x
```

Answer: the name x is assigned to the empty list, and then the first element of x is mapped to the
object that x points to, the empty list.

---

2.  Wrap the two methods for subtracting medians into two functions, then
    use the 'bench' package [@bench] to carefully compare their speeds. How does
    performance change as the number of columns increase?

```{r}
x_medians <- function(ncol) {
  x <- data.frame(matrix(runif(5 * 1e4), ncol = ncol))
  medians <- vapply(x, median, numeric(1))
  return(list(x = x, medians = medians))
}

df_medians <- function(x, medians) {
  # subtract medians using data.frame method
  for (i in seq_along(medians)) {
    x[[i]] <- x[[i]] - medians[[i]]
  }
  x
}

ls_medians <- function(x, medians) {
  y <- as.list(x)

  for (i in seq_along(medians)) {
    y[[i]] <- y[[i]] - medians[[i]]
  }
  y
}

# confirm they both work
xm <- x_medians(5)
head(df_medians(xm$x, xm$medians), 10)
head(as.data.frame(ls_medians(xm$x, xm$medians)), 10)

# benchmark
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))
mark(as.data.frame(ls_medians(xm$x, xm$medians))) # as.data.frame introduces significant overhead
```

Answer: with 5 columns, the list method is about twice as fast.

```{r}
xm <- x_medians(10)
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))

xm <- x_medians(20)
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))
```

With 10 columns, the list method is 3 times as fast. With 20, the list method is 5 times as fast.
So, the list method is near constant time regardless of columns, whereas the data.frame method
scales linearly with the number of columns.

---

3.  What happens if you attempt to use `tracemem()` on an environment?

```{r}
e <- rlang::env()
try(tracemem(e))
```

Answer: it throws an error!

---

# 3 Vectors

This chapter discusses the most important family of data types in base R: vectors. While you've probably already used many (if not all) of the different types of vectors, you may not have thought deeply about how they're interrelated. In this chapter, I won't cover individual vectors types in too much detail, but I will show you how all the types fit together as a whole. If you need more details, you can find them in R's documentation.

Vectors come in two flavours: atomic vectors and lists. They differ in terms of their elements' types: for atomic vectors, all elements must have the same type; for lists, elements can have different types. While not a vector, `NULL` is closely related to vectors and often serves the role of a generic zero length vector. This diagram, which we'll be expanding on throughout this chapter, illustrates the basic relationships:

Every vector can also have __attributes__, which you can think of as a named list of arbitrary metadata. Two attributes are particularly important. The __dimension__ attribute turns vectors into matrices and arrays and the __class__ attribute powers the S3 object system. While you'll learn how to use S3 in Chapter 13, here you'll learn about some of the most important S3 vectors: factors, date and times, data frames, and tibbles. And while 2D structures like matrices and data frames are not necessarily what come to mind when you think of vectors, you'll also learn why R considers them to be vectors.

```{r}
rm(list = ls())
```

## 3.2.5 Exercises

1. How do you create raw and complex scalars? (See `?raw` and 
   `?complex`.)

Answer: using either `raw()`, `complex()`, or `as.raw()`, `as.complex()`.

---

2. Test your knowledge of the vector coercion rules by predicting the output of
   the following uses of `c()`:

```{r}
c(1, FALSE) # 1.0, 0.0 - double
c("a", 1) # "a", "1" - character
c(TRUE, 1L) # 1L, 1L - integer

typeof(c(1, FALSE))
typeof(c("a", 1))
typeof(c(TRUE, 1L))
```

Answer: guesses inline. [correct!]

---

3. Why is `1 == "1"` true? Why is `-1 < FALSE` true? Why is `"one" < 2` false?

Answers:

- `1 == "1"`: the 1 is coerced to "1"
- `-1 < FALSE`: FALSE is coerced to 0
- `"one" < 2: the 2 is coerced to "2"

---

4. Why is the default missing value, `NA`, a logical vector? What's special
   about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)

Answer: NA must be logical so that it can exist in a logical vector.

---

5. Precisely what do `is.atomic()`, `is.numeric()`, and `is.vector()` test for?

Answers:

- `is.atomic(x)`: tests if x is an atomic vector (logical, integer, numeric, complex, character,
  and raw) - is `FALSE` for lists
- `is.numeric(x)`: tests if x is an atomic numeric vector
- `is.vector(x, mode = "any")`: tests if x is an atomic vector OR a list or expression

---

## 3.3.4 Exercises

1.  How is `setNames()` implemented? How is `unname()` implemented?
    Read the source code.

```{r}
setNames
unname
```

Answer: using `names()`, and `dimnames()` for `unname()`.

---

2.  What does `dim()` return when applied to a 1-dimensional vector?
    When might you use `NROW()` or `NCOL()`?

```{r}
dim(1:3)
nrow(1:12)
NROW(1:12)
ncol(1:12)
NCOL(1:12)
```

Answers: `NULL`. `NROW` and `NCOL` are useful when comparing `NULL` dimensional vectors with
matrices and arrays.

---

3.  How would you describe the following three objects? What makes them
    different from `1:5`?

```{r}
x1 <- array(1:5, c(1, 1, 5))
x2 <- array(1:5, c(1, 5, 1))
x3 <- array(1:5, c(5, 1, 1))

x1
x2
x3
```

They have a 3-dimensional structure, arranged in different ways, along the z, x, and y axis.

---

4.  An early draft used this code to illustrate `structure()`:

```{r}
structure(1:5, comment = "my attribute")
```

    But when you print that object you don't see the comment attribute.
    Why? Is the attribute missing, or is there something else special about
    it? (Hint: try using help.)

```{r}
factor("green", levels = c("red", "amber", "green"))
dput(factor("green", levels = c("red", "amber", "green")))
```

Answer: print doesn't display the attributes for arbitrary structures, only defined classes, like
factors (for example, above).

---

## 3.4.5 Exercises

1.  What sort of object does `table()` return? What is its type? What 
    attributes does it have? How does the dimensionality change as you
    tabulate more variables?

```{r}
a <- letters[1:3]
a_table <- table(a, sample(a))
a_table

typeof(a_table)
attributes(a_table)

b <- letters[1:4]
b_table <- table(b, sample(b))
b_table

attributes(b_table)
```

Answer: an object of class "table", an array of integer values, with type "integer". Attributes
listed above, the dimensionality is always n by n, where n is the number of variables tabulated.

---

2.  What happens to a factor when you modify its levels? 

```{r}
f1 <- factor(letters)
f1
levels(f1) <- rev(levels(f1))
f1
```

Answer: ~~the factor will remain the same, but the attributes will change.~~ the factor and its
levels are reversed.

---

3.  What does this code do? How do `f2` and `f3` differ from `f1`?

```{r}
f2 <- rev(factor(letters))
f2
f3 <- factor(letters, levels = rev(letters))
f3
```

Answer: both create a reversed list of letters. f3 also has reversed levels but f2 does not.
(correct!)

---

## 3.5.4 Exercises

1.  List all the ways that a list differs from an atomic vector.

Answers:

- Each element can be a different type
- Each element is a reference to an object
- List size can be smaller since elements are references
- Lists can contain other lists

---

2.  Why do you need to use `unlist()` to convert a list to an 
    atomic vector? Why doesn't `as.vector()` work? 

```{r}
is.vector(list(1:4))
dput(as.vector(list(1:4)))
```

Answer: a list is considered a vector by `as.vector()`.

---

3.  Compare and contrast `c()` and `unlist()` when combining a 
    date and date-time into a single vector.

```{r}
d <- list(date = as.Date("2022-06-25"), datetime = as.POSIXct("2022-06-25 09:59:40 CDT"))
dput(d)

dput(c(d)) # nolint: unneeded_concatenation_linter.
dput(unlist(d))
```

Answer: `c()` preserves the list structure. `unlist()` converts both to `double`.

---

## 3.6.8 Exercises

1.  Can you have a data frame with zero rows? What about zero columns?

```{r}
# from data.frame() examples:
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

df
df[, FALSE]
df[FALSE, ]
df[FALSE, FALSE]
```

Answer: yes!

---

2.  What happens if you attempt to set rownames that are not unique?

```{r}
rownames(df)
try(rownames(df) <- c("a", "a", "b"))
```

Answer: error, duplicates not allowed.

---

3.  If `df` is a data frame, what can you say about `t(df)`, and `t(t(df))`? 
    Perform some experiments, making sure to try different column types.

```{r}
t(df)
t(t(df))

df2 <- data.frame(x = 1:3, y = c("a", "b", "c"), z = 4L:6L, stringsAsFactors = FALSE)
df2
t(df2)
t(t(df2))
```

Answer: `t()` coerces the vector types, so `t(t(df))` is the same as `df` only when all columns are
the same type.

---

4.  What does `as.matrix()` do when applied to a data frame with 
    columns of different types? How does it differ from `data.matrix()`?

```{r}
as.matrix(df)
as.matrix(df2)
data.matrix(df2)
as.data.frame(data.matrix(df2))
as.data.frame(data.matrix(data.frame(x = 1:3, y = c(0, 0.5, 1), z = 4:6)))
```

Answer: `as.matrix()` coerces all elements to the same type. `data.matrix()` coerces elements to
either integer (when possible) or double (when not).

---

# 4 Subsetting

R's subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:

* There are six ways to subset atomic vectors.

* There are three subsetting operators, `[[`, `[`, and `$`.

* Subsetting operators interact differently with different vector 
  types (e.g., atomic vectors, lists, factors, matrices, and data frames).

* Subsetting can be combined with assignment.

Subsetting is a natural complement to `str()`. While `str()` shows you all the pieces of any object (its structure), subsetting allows you to pull out the pieces that you're interested in. For large, complex objects, I highly recommend using the interactive RStudio Viewer, which you can activate with `View(my_object)`.

```{r}
rm(list = ls())
```

## 4.2.6 Exercises

1.  Fix each of the following common data frame subsetting errors:

```{r, eval = FALSE}
# nolint start: commented_code_linter.
# mtcars[mtcars$cyl = 4, ]
mtcars[mtcars$cyl == 4, ]

# mtcars[-1:4, ]
mtcars[-(1:4), ]

# mtcars[mtcars$cyl <= 5]
mtcars[mtcars$cyl <= 5, ]

# mtcars[mtcars$cyl == 4 | 6, ]
mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]
# nolint end
```

Answer: fixed!

---

2.  Why does the following code yield five missing values? (Hint: why is 
    it different from `x[NA_real_]`?)

```{r}
x <- 1:5
x[NA]

x[NA_real_]
x[TRUE]
```

Answer: NA is a logical constant of length 1.

---

3.  What does `upper.tri()` return? How does subsetting a matrix with it 
    work? Do we need any additional subsetting rules to describe its behaviour?

```{r}
x <- outer(1:5, 1:5, FUN = "*")
x
x[upper.tri(x)]
```

Answer: `upper.tri()` returns a matrix of logicals, which can be used to subset the upper triangle.
This is subsetting by matrix, which is new.

---

4.  Why does `mtcars[1:20]` return an error? How does it differ from the 
    similar `mtcars[1:20, ]`?

```{r}
try(mtcars[1:20])
mtcars[1:20, ]
```

Answer: `mtcars[1:20]` selects the first 20 columns, but there are only 11. `mtcars[1:20, ]` selects
the first 20 rows of `r nrow(mtcars)`.

---

5.  Implement your own function that extracts the diagonal entries from a
    matrix (it should behave like `diag(x)` where `x` is a matrix).

```{r}
m <- matrix(ncol = 3, byrow = TRUE, c(
  1, 4, 7,
  2, 5, 8,
  3, 6, 9
))
m
diag(m)

my_diag <- function(x) {
  diag_element <- function(n, x) {
    x[n, n]
  }
  vapply(seq_len(nrow(m)), diag_element, 1, x)
}
my_diag(m)
```

Answer: code above.

---

5.  What does `df[is.na(df)] <- 0` do? How does it work?

Answer: sets the `NA` values in `df` to `0`, by first selecting `NA` values then assigning `0`.

```{r}
df <- data.frame(x = c(1, 2, NA), y = c(4, NA, 6), z = c(NA, 8, 9))
df
df[is.na(df)] <- 0
df
```

Correct!

---

## 4.3.5 Exercises

1.  Brainstorm as many ways as possible to extract the third value from the
    `cyl` variable in the `mtcars` dataset.

```{r}
mtcars$cyl[3]
mtcars$cyl[[3]]
mtcars[["cyl"]][[3]]
mtcars[3, 2]
mtcars[[3, 2]]
mtcars[["Datsun 710", "cyl"]]
mtcars[-c(1:2, 4:32), -c(1, 3:11)]
```

Answer: code above (some variations omitted). There are many more.

---

2.  Given a linear model, e.g., `mod <- lm(mpg ~ wt, data = mtcars)`, extract
    the residual degrees of freedom. Then extract the R squared from the model
    summary (`summary(mod)`)

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
mod$df.residual

mod_sum <- summary(mod)
mod_sum$r.squared

mod_sum
```

Answer: code above.

---

## 4.5.9 Exercises

1.  How would you randomly permute the columns of a data frame? (This is an
    important technique in random forests.) Can you simultaneously permute 
    the rows and columns in one step?

```{r}
df <- data.frame(x = 1:5, y = 5:1, z = letters[1:5], row.names = 1:5)

df[, sample(ncol(df))]

df[sample(nrow(df)), sample(ncol(df))]
```

Answer: using `sample()`. Yes!

---

2.  How would you select a random sample of `m` rows from a data frame? 
    What if the sample had to be contiguous (i.e., with an initial row, a 
    final row, and every row in between)?

```{r}
sample_rows <- function(df, m, contiguous = FALSE) {
  if (m > nrow(df)) {
    stop("sample size '", m, "' is larger than the number of rows, '", nrow(df), "'")
  }
  if (contiguous) {
    first_row <- sample(nrow(df) - m + 1, 1)
    last_row <- first_row + m - 1
    return(df[first_row:last_row, ])
  }
  df[sample(nrow(df), m), ]
}

sample_rows(df, 3)
sample_rows(df, 3, contiguous = TRUE)
try(sample_rows(df, 6))
```

Answer: code above.

---
    
3.  How could you put the columns in a data frame in alphabetical order?

```{r}
mtcars[sort(colnames(mtcars))]
```

Answer: using `sort(colnames)`.

---

# 5 Control flow

There are two primary tools of control flow: choices and loops. Choices, like `if` statements and `switch()` calls, allow you to run different code depending on the input. Loops, like `for` and `while`, allow you to repeatedly run code, typically with changing options. I'd expect that you're already familiar with the basics of these functions so I'll briefly cover some technical details and then introduce some useful, but lesser known, features.

The condition system (messages, warnings, and errors), which you'll learn about in Chapter 8, also provides non-local control flow. 

```{r}
rm(list = ls())
```

## 5.2.4 Exercises

1.  What type of vector does each of the following calls to `ifelse()`
    return? Read the documentation and write down the rules in your own words.

```{r, eval = FALSE}
ifelse(TRUE, 1, "no")
typeof(ifelse(TRUE, 1, "no")) # double
ifelse(FALSE, 1, "no")
typeof(ifelse(FALSE, 1, "no")) # character
ifelse(NA, 1, "no")
typeof(ifelse(NA, 1, "no")) # logical
ifelse(NULL, 1, "no")
```


Answer:

- if `test` is true, return a vector of the same length as `test` (1) populated with "yes" - here 1
  is a double, 1L would be integer
- if `test` is false, return a vector of the same length as `test` (1) populated with "no" - here
  "no" is a character
- if `test` is `NA`, return `NA`, and if `test` is `NULL`, return `logical(0)`

---

2.  Why does the following code work?

```{r}
x <- 1:10
if (length(x)) "not empty" else "empty"

x <- numeric()
if (length(x)) "not empty" else "empty"
```

Answer: in the first example, `length(x)` is nonzero, which evaluates to `TRUE`. In the second
example, `numeric()` returns a vector of length 0 (the default), `length(x)` is zero, which
evaluates to `FALSE`.

---

## 5.3.3 Exercises

1.  Why does this code succeed without errors or warnings? 

```{r}
x <- numeric() # x is numeric(0)
out <- vector("list", length(x)) # out is list(0)
for (i in 1:length(x)) { # nolint: seq_linter. i is 1, then 0.
  out[i] <- x[i]^2 # when i = 1 x[1] is NA, sets out[1] to NA. when i = 0 nothing happens
}
out
```

Answer: in addition to notes above, `out[0]` and `x[0]` return a zero-length vector.

---

2.  When the following code is evaluated, what can you say about the 
    vector being iterated?

```{r}
xs <- c(1, 2, 3)
for (x in xs) {
  xs <- c(xs, x * 2)
}
xs
```

Answer: `x` iterates from 1 to 3, and is not affected by changes to `xs` during the loop, while `xs`
is updated.

---

3.  What does the following code tell you about when the index is updated?

```{r}
for (i in 1:3) {
  i <- i * 2
  print(i)
}
```

Answer: the index is updated at the beginning of each loop.

---

# 6 Functions

If you're reading this book, you've probably already created many R functions and know how to use them to reduce duplication in your code. In this chapter, you'll learn how to turn that informal, working knowledge into more rigorous, theoretical understanding. And while you'll see some interesting tricks and techniques along the way, keep in mind that what you'll learn here will be important for understanding the more advanced topics discussed later in the book.

```{r}
rm(list = ls())
```

## 6 Quiz

Answer the following questions to see if you can safely skip this chapter. You can find the answers in Section \@ref(function-answers).

1.  What are the three components of a function? a: arguments, code, return value [body, arguments,
    environment]

2.  What does the following code return? a: 11 [correct!]

```{r, eval = FALSE}
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```

3.  How would you usually write this code? a: `1 + 2 * 3` [correct! ... `1 + (2 * 3)`]

```{r, eval = FALSE}
`+`(1, `*`(2, 3))
```

4.  How could you make this call easier to read? `mean(c(1:10, NA), na.rm = TRUE)` [correct!]

```{r, eval = FALSE}
mean(, TRUE, x = c(1:10, NA)) # nolint: missing_argument_linter.
```

5.  Does the following code throw an error when executed? Why or why not? a: no, due to lazy
    evaluation, the `stop()` is never run [correct! ... second argument is never used]

```{r, eval = FALSE}
f2 <- function(a, b) {
  a * 10
}
f2(10, stop("This is an error!"))
```

6.  What is an infix function? How do you write it? What's a replacement 
    function? How do you write it? a: `function(x) x`. ??? [see 6.8.3 and 6.8.4]

7.  How do you ensure that cleanup action occurs regardless of how a function 
    exits? a: ??? [`on.exit()`]
