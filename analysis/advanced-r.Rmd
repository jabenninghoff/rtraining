---
title: "Advanced R Workbook"
date: '2022-06-12'
output:
  html_notebook:
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
---

Workbook for completing quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html), second edition.

```{r setup, message = FALSE, warning = FALSE}
library(lobstr)
library(bench)
```

# Introduction

This workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html), organized by chapter. It includes excerpts from the book, copied here.

**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and
exercises, don't read this notebook. It contains my (potentially wrong) answers to both.

# 2 Names and values

In R, it is important to understand the distinction between an object and its name. Doing so will help you:

* More accurately predict the performance and memory usage of your code. 
* Write faster code by avoiding accidental copies, a major source of slow code. 
* Better understand R's functional programming tools.

The goal of this chapter is to help you understand the distinction between names and values, and when R will copy an object.

## 2 Quiz

1.  Given the following data frame, how do I create a new column called "3"
    that contains the sum of `1` and `2`? You may only use `$`, not `[[`.
    What makes `1`, `2`, and `3` challenging as variable names?

```{r}
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
```

Answer: use the following code.

```{r}
df2 <- data.frame(df, df$`1` + df$`2`)
names(df2) <- c(1, 2, 3)
```

Using numbers as names is problematic due to them being interpreted as numeric constants by default.

---

2.  In the following code, how much memory does `y` occupy?
   
```{r}
x <- runif(1e6)
y <- list(x, x, x)
```

Answer: 3 times the size of x, 24 MB. Note: this is incorrect, as shown by `obj_size` and `obj_addr`:

```{r}
obj_size(x)
obj_size(y)
obj_addr(y[[1]])
obj_addr(y[[2]])
obj_addr(y[[3]])
```

---

3.  On which line does `a` get copied in the following example?

```{r}
a <- c(1, 5, 3, 2)
obj_addr(a)

b <- a
obj_addr(b)

b[[1]] <- 10
obj_addr(b)
```

Answer: the third line (copy-on-write). [copy-on-modify]

## 2.2.2 Exercises

1.  Explain the relationship between `a`, `b`, `c` and `d` in the following 
    code:

```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
```

Answer: a, b, and c all point to the same object (1:10). d points to an identical object at a
different address.

```{r}
obj_addr(a)
obj_addr(b)
obj_addr(c)
obj_addr(d)
```

---

2.  The following code accesses the mean function in multiple ways. Do they all 
    point to the same underlying function object? Verify this with 
    `lobstr::obj_addr()`.
    
```{r, eval = FALSE}
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")
```

Check the `obj_addr`:

```{r}
obj_addr(mean)
obj_addr(base::mean)
obj_addr(get("mean"))
obj_addr(evalq(mean))
obj_addr(match.fun("mean"))
```

Answer: they do.

---

3.  By default, base R data import functions, like `read.csv()`, will 
    automatically convert non-syntactic names to syntactic ones. Why might 
    this be problematic? What option allows you to suppress this behaviour?

Answer: this could introduce problematic names, like `1`. Setting `check.names = FALSE` suppresses
this behavior.

---

4.  What rules does `make.names()` use to convert non-syntactic names into
    syntactic ones?

Answer: from `?make.names`:

> The character "X" is prepended if necessary. All invalid characters are translated to ".".
> A missing value is translated to "NA". Names which match R keywords have a dot appended to them.
> Duplicated values are altered by make.unique.
  
---

5.  I slightly simplified the rules that govern syntactic names. Why is `.123e1`
    not a syntactic name? Read `?make.names` for the full details.

Answer: from `?make.names`:

> A syntactically valid name consists of letters, numbers and the dot or underline characters and
starts with a letter or the dot not followed by a number. Names such as ".2way" are not valid, and
neither are the reserved words.

---

## 2.3.6 Exercises

1.  Why is `tracemem(1:10)` not useful?

Answer: this is tracing an 'immutable' object which will always have the same address.

---

2.  Explain why `tracemem()` shows two copies when you run this code.
    Hint: carefully look at the difference between this code and the code 
    shown earlier in the section.
     
```{r}
rm(list = ls())
x <- c(1L, 2L, 3L)
tracemem(x)

x[[3]] <- 4
untracemem(x)
```

Answer: unclear. The behavior in R 4.2.0 seems to have changed, since this code shows two copies:

```{r}
rm(list = ls())
x <- c(1, 2, 3)
tracemem(x)

y <- x
y[[3]] <- 4L
y[[3]] <- 5L
untracemem(x)
```

---

3.  Sketch out the relationship between the following objects:

```{r}
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)

print("first object")
obj_addr(a)
obj_addr(b[[1]])
obj_addr(b[[2]])
obj_addr(c[[2]])

print("second object")
obj_addr(b)
obj_addr(c[[1]])

print("third object")
obj_addr(c)

print("fourth object (?)")
obj_addr(c[[3]])
```

Answer: four different objects with multiple names.

---

4.  What happens when you run this code? Draw a picture.

```{r}
x <- list(1:10)

x[[2]] <- x

ref(x)
```

Initially x is a list of one element, an int vector 1:10. Then a second list element is added, which
points to the original int vector.

---

## 2.4.1 Exercises

1.  In the following example, why are `object.size(y)` and `obj_size(y)`
    so radically different? Consult the documentation of `object.size()`.

```{r}
y <- rep(list(runif(1e4)), 100)

object.size(y)
obj_size(y)
```

Answer: `object.size()` "does not detect if elements of a list are shared", which is the case here.
That is, it does not detect the list has been replicated 100 times, and overestimates by a factor of
100 compared to `object_size()`.

---

2.  Take the following list. Why is its size somewhat misleading?

```{r}
funs <- list(mean, sd, var)
obj_size(funs)
```

Answer: it doesn't seem misleading to me, but the list includes the function objects, not the
return values. Also, it calculates the size discarding the overlap between the functions. Per the
code below, there is some:

```{r}
obj_size(mean) + obj_size(sd) + obj_size(var)
```

---

3.  Predict the output of the following code:

```{r}
a <- runif(1e6)
obj_size(a) # 8,000,048 B ~ 8MB
# correct: from example above, runif(1e6) ~= 8MB

b <- list(a, a)
obj_size(b) # slightly larger than obj_size(a)
# correct: two lists containing numeric vectors
obj_size(a, b) # slightly larger than obj_size(b)
# wrong: a is entirely contained within b

b[[1]][[1]] <- 10
obj_size(b) # copy of b, same size
# wrong: double, since R copies an entire column, this adds the size of runif(1e6)
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)
# wrong: a is still entirely contained with b

b[[2]][[1]] <- 10
obj_size(b) # copy of b, same size
# wrong: same size since it's still 2 numeric vectors of 1e6 length
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)
# wrong: there is no longer any overlap, so the size of obj_size(a, b) = obj_size(a) = obj_size(b)
```

Answer: answers inline.

---

## 2.5.3 Exercises

1.  Explain why the following code doesn't create a circular list.

```{r}
x <- list()
x[[1]] <- x
```

Answer: the name x is assigned to the empty list, and then the first element of x is mapped to the
object that x points to, the empty list.

---

2.  Wrap the two methods for subtracting medians into two functions, then
    use the 'bench' package [@bench] to carefully compare their speeds. How does
    performance change as the number of columns increase?

```{r}
x_medians <- function(ncol) {
  x <- data.frame(matrix(runif(5 * 1e4), ncol = ncol))
  medians <- vapply(x, median, numeric(1))
  return(list(x = x, medians = medians))
}

df_medians <- function(x, medians) {
  # subtract medians using data.frame method
  for (i in seq_along(medians)) {
    x[[i]] <- x[[i]] - medians[[i]]
  }
  x
}

ls_medians <- function(x, medians) {
  y <- as.list(x)

  for (i in seq_along(medians)) {
    y[[i]] <- y[[i]] - medians[[i]]
  }
  y
}

# confirm they both work
xm <- x_medians(5)
head(df_medians(xm$x, xm$medians), 10)
head(as.data.frame(ls_medians(xm$x, xm$medians)), 10)

# benchmark
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))
mark(as.data.frame(ls_medians(xm$x, xm$medians))) # as.data.frame introduces significant overhead
```

Answer: with 5 columns, the list method is about twice as fast.

```{r}
xm <- x_medians(10)
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))

xm <- x_medians(20)
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))
```

With 10 columns, the list method is 3 times as fast. With 20, the list method is 5 times as fast.
So, the list method is near constant time regardless of columns, whereas the data.frame method
scales linearly with the number of columns.

---

3.  What happens if you attempt to use `tracemem()` on an environment?

```{r}
e <- rlang::env()
try(tracemem(e))
```

Answer: it throws an error!

---

# 3 Vectors

This chapter discusses the most important family of data types in base R: vectors. While you've probably already used many (if not all) of the different types of vectors, you may not have thought deeply about how they're interrelated. In this chapter, I won't cover individual vectors types in too much detail, but I will show you how all the types fit together as a whole. If you need more details, you can find them in R's documentation.

Vectors come in two flavours: atomic vectors and lists. They differ in terms of their elements' types: for atomic vectors, all elements must have the same type; for lists, elements can have different types. While not a vector, `NULL` is closely related to vectors and often serves the role of a generic zero length vector. This diagram, which we'll be expanding on throughout this chapter, illustrates the basic relationships:

Every vector can also have __attributes__, which you can think of as a named list of arbitrary metadata. Two attributes are particularly important. The __dimension__ attribute turns vectors into matrices and arrays and the __class__ attribute powers the S3 object system. While you'll learn how to use S3 in Chapter 13, here you'll learn about some of the most important S3 vectors: factors, date and times, data frames, and tibbles. And while 2D structures like matrices and data frames are not necessarily what come to mind when you think of vectors, you'll also learn why R considers them to be vectors.

```{r}
rm(list = ls())
```

## 3.2.5 Exercises

1. How do you create raw and complex scalars? (See `?raw` and 
   `?complex`.)

Answer: using either `raw()`, `complex()`, or `as.raw()`, `as.complex()`.

---

2. Test your knowledge of the vector coercion rules by predicting the output of
   the following uses of `c()`:

```{r}
c(1, FALSE) # 1.0, 0.0 - double
c("a", 1) # "a", "1" - character
c(TRUE, 1L) # 1L, 1L - integer

typeof(c(1, FALSE))
typeof(c("a", 1))
typeof(c(TRUE, 1L))
```

Answer: guesses inline. [correct!]

---

3. Why is `1 == "1"` true? Why is `-1 < FALSE` true? Why is `"one" < 2` false?

Answers:

- `1 == "1"`: the 1 is coerced to "1"
- `-1 < FALSE`: FALSE is coerced to 0
- `"one" < 2: the 2 is coerced to "2"

---

4. Why is the default missing value, `NA`, a logical vector? What's special
   about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)

Answer: NA must be logical so that it can exist in a logical vector.

---

5. Precisely what do `is.atomic()`, `is.numeric()`, and `is.vector()` test for?

Answers:

- `is.atomic(x)`: tests if x is an atomic vector (logical, integer, numeric, complex, character,
  and raw) - is `FALSE` for lists
- `is.numeric(x)`: tests if x is an atomic numeric vector
- `is.vector(x, mode = "any")`: tests if x is an atomic vector OR a list or expression

---

## 3.3.4 Exercises

1.  How is `setNames()` implemented? How is `unname()` implemented?
    Read the source code.

```{r}
setNames
unname
```

Answer: using `names()`, and `dimnames()` for `unname()`.

---

2.  What does `dim()` return when applied to a 1-dimensional vector?
    When might you use `NROW()` or `NCOL()`?

```{r}
dim(1:3)
nrow(1:12)
NROW(1:12)
ncol(1:12)
NCOL(1:12)
```

Answers: `NULL`. `NROW` and `NCOL` are useful when comparing `NULL` dimensional vectors with
matrices and arrays.

---

3.  How would you describe the following three objects? What makes them
    different from `1:5`?

```{r}
x1 <- array(1:5, c(1, 1, 5))
x2 <- array(1:5, c(1, 5, 1))
x3 <- array(1:5, c(5, 1, 1))

x1
x2
x3
```

They have a 3-dimensional structure, arranged in different ways, along the z, x, and y axis.

---

4.  An early draft used this code to illustrate `structure()`:

```{r}
structure(1:5, comment = "my attribute")
```

    But when you print that object you don't see the comment attribute.
    Why? Is the attribute missing, or is there something else special about
    it? (Hint: try using help.)

```{r}
factor("green", levels = c("red", "amber", "green"))
dput(factor("green", levels = c("red", "amber", "green")))
```

Answer: print doesn't display the attributes for arbitrary structures, only defined classes, like
factors (for example, above).

---

## 3.4.5 Exercises

1.  What sort of object does `table()` return? What is its type? What 
    attributes does it have? How does the dimensionality change as you
    tabulate more variables?

```{r}
a <- letters[1:3]
a_table <- table(a, sample(a))
a_table

typeof(a_table)
attributes(a_table)

b <- letters[1:4]
b_table <- table(b, sample(b))
b_table

attributes(b_table)
```

Answer: an object of class "table", an array of integer values, with type "integer". Attributes
listed above, the dimensionality is always n by n, where n is the number of variables tabulated.

---

2.  What happens to a factor when you modify its levels? 

```{r}
f1 <- factor(letters)
f1
levels(f1) <- rev(levels(f1))
f1
```

Answer: ~~the factor will remain the same, but the attributes will change.~~ the factor and its
levels are reversed.

---

3.  What does this code do? How do `f2` and `f3` differ from `f1`?

```{r}
f2 <- rev(factor(letters))
f2
f3 <- factor(letters, levels = rev(letters))
f3
```

Answer: both create a reversed list of letters. f3 also has reversed levels but f2 does not.
(correct!)

---

## 3.5.4 Exercises

1.  List all the ways that a list differs from an atomic vector.

Answers:

- Each element can be a different type
- Each element is a reference to an object
- List size can be smaller since elements are references
- Lists can contain other lists

---

2.  Why do you need to use `unlist()` to convert a list to an 
    atomic vector? Why doesn't `as.vector()` work? 

```{r}
is.vector(list(1:4))
dput(as.vector(list(1:4)))
```

Answer: a list is considered a vector by `as.vector()`.

---

3.  Compare and contrast `c()` and `unlist()` when combining a 
    date and date-time into a single vector.

```{r}
d <- list(date = as.Date("2022-06-25"), datetime = as.POSIXct("2022-06-25 09:59:40 CDT"))
dput(d)

dput(c(d)) # nolint: unneeded_concatenation_linter.
dput(unlist(d))
```

Answer: `c()` preserves the list structure. `unlist()` converts both to `double`.

---
