---
title: "Advanced R Workbook (Foundations)"
date: '2022-06-12'
output:
  html_notebook:
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
---

Workbook for completing quizzes and exercises from the "Foundations" chapters of [Advanced R](https://adv-r.hadley.nz/index.html), second edition.

```{r setup, message = FALSE, warning = FALSE}
library(lobstr)
library(bench)
library(rlang)
```

# Introduction

This workbook includes answers and solutions to the quizzes and exercises from [Advanced R](https://adv-r.hadley.nz/index.html), organized by chapter. It includes excerpts from the book, copied here.

**WARNING, SPOILERS!** If you haven't read Advanced R and intend to complete the quizzes and
exercises, don't read this notebook. It contains my (potentially wrong) answers to both.

# 2 Names and values

In R, it is important to understand the distinction between an object and its name. Doing so will help you:

* More accurately predict the performance and memory usage of your code. 
* Write faster code by avoiding accidental copies, a major source of slow code. 
* Better understand R's functional programming tools.

The goal of this chapter is to help you understand the distinction between names and values, and when R will copy an object.

## 2 Quiz

1.  Given the following data frame, how do I create a new column called "3"
    that contains the sum of `1` and `2`? You may only use `$`, not `[[`.
    What makes `1`, `2`, and `3` challenging as variable names?

```{r}
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
```

Answer: use the following code.

```{r}
df2 <- data.frame(df, df$`1` + df$`2`)
names(df2) <- c(1, 2, 3)
```

Using numbers as names is problematic due to them being interpreted as numeric constants by default.

---

2.  In the following code, how much memory does `y` occupy?
   
```{r}
x <- runif(1e6)
y <- list(x, x, x)
```

Answer: 3 times the size of x, 24 MB. Note: this is incorrect, as shown by `obj_size` and `obj_addr`:

```{r}
obj_size(x)
obj_size(y)
obj_addr(y[[1]])
obj_addr(y[[2]])
obj_addr(y[[3]])
```

---

3.  On which line does `a` get copied in the following example?

```{r}
a <- c(1, 5, 3, 2)
obj_addr(a)

b <- a
obj_addr(b)

b[[1]] <- 10
obj_addr(b)
```

Answer: the third line (copy-on-write). [copy-on-modify]

## 2.2.2 Exercises

1.  Explain the relationship between `a`, `b`, `c` and `d` in the following 
    code:

```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
```

Answer: a, b, and c all point to the same object (1:10). d points to an identical object at a
different address.

```{r}
obj_addr(a)
obj_addr(b)
obj_addr(c)
obj_addr(d)
```

---

2.  The following code accesses the mean function in multiple ways. Do they all 
    point to the same underlying function object? Verify this with 
    `lobstr::obj_addr()`.
    
```{r, eval = FALSE}
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")
```

Check the `obj_addr`:

```{r}
obj_addr(mean)
obj_addr(base::mean)
obj_addr(get("mean"))
obj_addr(evalq(mean))
obj_addr(match.fun("mean"))
```

Answer: they do.

---

3.  By default, base R data import functions, like `read.csv()`, will 
    automatically convert non-syntactic names to syntactic ones. Why might 
    this be problematic? What option allows you to suppress this behaviour?

Answer: this could introduce problematic names, like `1`. Setting `check.names = FALSE` suppresses
this behavior.

---

4.  What rules does `make.names()` use to convert non-syntactic names into
    syntactic ones?

Answer: from `?make.names`:

> The character "X" is prepended if necessary. All invalid characters are translated to ".".
> A missing value is translated to "NA". Names which match R keywords have a dot appended to them.
> Duplicated values are altered by make.unique.
  
---

5.  I slightly simplified the rules that govern syntactic names. Why is `.123e1`
    not a syntactic name? Read `?make.names` for the full details.

Answer: from `?make.names`:

> A syntactically valid name consists of letters, numbers and the dot or underline characters and
starts with a letter or the dot not followed by a number. Names such as ".2way" are not valid, and
neither are the reserved words.

---

## 2.3.6 Exercises

1.  Why is `tracemem(1:10)` not useful?

Answer: this is tracing an 'immutable' object which will always have the same address.

---

2.  Explain why `tracemem()` shows two copies when you run this code.
    Hint: carefully look at the difference between this code and the code 
    shown earlier in the section.
     
```{r}
rm(list = ls())
x <- c(1L, 2L, 3L)
tracemem(x)

x[[3]] <- 4
untracemem(x)
```

Answer: unclear. The behavior in R 4.2.0 seems to have changed, since this code shows two copies:

```{r}
rm(list = ls())
x <- c(1, 2, 3)
tracemem(x)

y <- x
y[[3]] <- 4L
y[[3]] <- 5L
untracemem(x)
```

---

3.  Sketch out the relationship between the following objects:

```{r}
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)

print("first object")
obj_addr(a)
obj_addr(b[[1]])
obj_addr(b[[2]])
obj_addr(c[[2]])

print("second object")
obj_addr(b)
obj_addr(c[[1]])

print("third object")
obj_addr(c)

print("fourth object (?)")
obj_addr(c[[3]])
```

Answer: four different objects with multiple names.

---

4.  What happens when you run this code? Draw a picture.

```{r}
x <- list(1:10)

x[[2]] <- x

ref(x)
```

Initially x is a list of one element, an int vector 1:10. Then a second list element is added, which
points to the original int vector.

---

## 2.4.1 Exercises

1.  In the following example, why are `object.size(y)` and `obj_size(y)`
    so radically different? Consult the documentation of `object.size()`.

```{r}
y <- rep(list(runif(1e4)), 100)

object.size(y)
obj_size(y)
```

Answer: `object.size()` "does not detect if elements of a list are shared", which is the case here.
That is, it does not detect the list has been replicated 100 times, and overestimates by a factor of
100 compared to `object_size()`.

---

2.  Take the following list. Why is its size somewhat misleading?

```{r}
funs <- list(mean, sd, var)
obj_size(funs)
```

Answer: it doesn't seem misleading to me, but the list includes the function objects, not the
return values. Also, it calculates the size discarding the overlap between the functions. Per the
code below, there is some:

```{r}
obj_size(mean) + obj_size(sd) + obj_size(var)
```

---

3.  Predict the output of the following code:

```{r}
a <- runif(1e6)
obj_size(a) # 8,000,048 B ~ 8MB
# correct: from example above, runif(1e6) ~= 8MB

b <- list(a, a)
obj_size(b) # slightly larger than obj_size(a)
# correct: two lists containing numeric vectors
obj_size(a, b) # slightly larger than obj_size(b)
# wrong: a is entirely contained within b

b[[1]][[1]] <- 10
obj_size(b) # copy of b, same size
# wrong: double, since R copies an entire column, this adds the size of runif(1e6)
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)
# wrong: a is still entirely contained with b

b[[2]][[1]] <- 10
obj_size(b) # copy of b, same size
# wrong: same size since it's still 2 numeric vectors of 1e6 length
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)
# wrong: there is no longer any overlap, so the size of obj_size(a, b) = obj_size(a) = obj_size(b)
```

Answer: answers inline.

---

## 2.5.3 Exercises

1.  Explain why the following code doesn't create a circular list.

```{r}
x <- list()
x[[1]] <- x
```

Answer: the name x is assigned to the empty list, and then the first element of x is mapped to the
object that x points to, the empty list.

---

2.  Wrap the two methods for subtracting medians into two functions, then
    use the 'bench' package [@bench] to carefully compare their speeds. How does
    performance change as the number of columns increase?

```{r}
x_medians <- function(ncol) {
  x <- data.frame(matrix(runif(5 * 1e4), ncol = ncol))
  medians <- vapply(x, median, numeric(1))
  return(list(x = x, medians = medians))
}

df_medians <- function(x, medians) {
  # subtract medians using data.frame method
  for (i in seq_along(medians)) {
    x[[i]] <- x[[i]] - medians[[i]]
  }
  x
}

ls_medians <- function(x, medians) {
  y <- as.list(x)

  for (i in seq_along(medians)) {
    y[[i]] <- y[[i]] - medians[[i]]
  }
  y
}

# confirm they both work
xm <- x_medians(5)
head(df_medians(xm$x, xm$medians), 10)
head(as.data.frame(ls_medians(xm$x, xm$medians)), 10)

# benchmark
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))
mark(as.data.frame(ls_medians(xm$x, xm$medians))) # as.data.frame introduces significant overhead
```

Answer: with 5 columns, the list method is about twice as fast.

```{r}
xm <- x_medians(10)
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))

xm <- x_medians(20)
mark(df_medians(xm$x, xm$medians))
mark(ls_medians(xm$x, xm$medians))
```

With 10 columns, the list method is 3 times as fast. With 20, the list method is 5 times as fast.
So, the list method is near constant time regardless of columns, whereas the data.frame method
scales linearly with the number of columns.

---

3.  What happens if you attempt to use `tracemem()` on an environment?

```{r}
e <- rlang::env()
try(tracemem(e))
```

Answer: it throws an error!

---

# 3 Vectors

This chapter discusses the most important family of data types in base R: vectors. While you've probably already used many (if not all) of the different types of vectors, you may not have thought deeply about how they're interrelated. In this chapter, I won't cover individual vectors types in too much detail, but I will show you how all the types fit together as a whole. If you need more details, you can find them in R's documentation.

Vectors come in two flavours: atomic vectors and lists. They differ in terms of their elements' types: for atomic vectors, all elements must have the same type; for lists, elements can have different types. While not a vector, `NULL` is closely related to vectors and often serves the role of a generic zero length vector. This diagram, which we'll be expanding on throughout this chapter, illustrates the basic relationships:

Every vector can also have __attributes__, which you can think of as a named list of arbitrary metadata. Two attributes are particularly important. The __dimension__ attribute turns vectors into matrices and arrays and the __class__ attribute powers the S3 object system. While you'll learn how to use S3 in Chapter 13, here you'll learn about some of the most important S3 vectors: factors, date and times, data frames, and tibbles. And while 2D structures like matrices and data frames are not necessarily what come to mind when you think of vectors, you'll also learn why R considers them to be vectors.

```{r}
rm(list = ls())
```

## 3.2.5 Exercises

1. How do you create raw and complex scalars? (See `?raw` and 
   `?complex`.)

Answer: using either `raw()`, `complex()`, or `as.raw()`, `as.complex()`.

---

2. Test your knowledge of the vector coercion rules by predicting the output of
   the following uses of `c()`:

```{r}
c(1, FALSE) # 1.0, 0.0 - double
c("a", 1) # "a", "1" - character
c(TRUE, 1L) # 1L, 1L - integer

typeof(c(1, FALSE))
typeof(c("a", 1))
typeof(c(TRUE, 1L))
```

Answer: guesses inline. [correct!]

---

3. Why is `1 == "1"` true? Why is `-1 < FALSE` true? Why is `"one" < 2` false?

Answers:

- `1 == "1"`: the 1 is coerced to "1"
- `-1 < FALSE`: FALSE is coerced to 0
- `"one" < 2: the 2 is coerced to "2"

---

4. Why is the default missing value, `NA`, a logical vector? What's special
   about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)

Answer: NA must be logical so that it can exist in a logical vector.

---

5. Precisely what do `is.atomic()`, `is.numeric()`, and `is.vector()` test for?

Answers:

- `is.atomic(x)`: tests if x is an atomic vector (logical, integer, numeric, complex, character,
  and raw) - is `FALSE` for lists
- `is.numeric(x)`: tests if x is an atomic numeric vector
- `is.vector(x, mode = "any")`: tests if x is an atomic vector OR a list or expression

---

## 3.3.4 Exercises

1.  How is `setNames()` implemented? How is `unname()` implemented?
    Read the source code.

```{r}
setNames
unname
```

Answer: using `names()`, and `dimnames()` for `unname()`.

---

2.  What does `dim()` return when applied to a 1-dimensional vector?
    When might you use `NROW()` or `NCOL()`?

```{r}
dim(1:3)
nrow(1:12)
NROW(1:12)
ncol(1:12)
NCOL(1:12)
```

Answers: `NULL`. `NROW` and `NCOL` are useful when comparing `NULL` dimensional vectors with
matrices and arrays.

---

3.  How would you describe the following three objects? What makes them
    different from `1:5`?

```{r}
x1 <- array(1:5, c(1, 1, 5))
x2 <- array(1:5, c(1, 5, 1))
x3 <- array(1:5, c(5, 1, 1))

x1
x2
x3
```

They have a 3-dimensional structure, arranged in different ways, along the z, x, and y axis.

---

4.  An early draft used this code to illustrate `structure()`:

```{r}
structure(1:5, comment = "my attribute")
```

    But when you print that object you don't see the comment attribute.
    Why? Is the attribute missing, or is there something else special about
    it? (Hint: try using help.)

```{r}
factor("green", levels = c("red", "amber", "green"))
dput(factor("green", levels = c("red", "amber", "green")))
```

Answer: print doesn't display the attributes for arbitrary structures, only defined classes, like
factors (for example, above).

---

## 3.4.5 Exercises

1.  What sort of object does `table()` return? What is its type? What 
    attributes does it have? How does the dimensionality change as you
    tabulate more variables?

```{r}
a <- letters[1:3]
a_table <- table(a, sample(a))
a_table

typeof(a_table)
attributes(a_table)

b <- letters[1:4]
b_table <- table(b, sample(b))
b_table

attributes(b_table)
```

Answer: an object of class "table", an array of integer values, with type "integer". Attributes
listed above, the dimensionality is always n by n, where n is the number of variables tabulated.

---

2.  What happens to a factor when you modify its levels? 

```{r}
f1 <- factor(letters)
f1
levels(f1) <- rev(levels(f1))
f1
```

Answer: ~~the factor will remain the same, but the attributes will change.~~ the factor and its
levels are reversed.

---

3.  What does this code do? How do `f2` and `f3` differ from `f1`?

```{r}
f2 <- rev(factor(letters))
f2
f3 <- factor(letters, levels = rev(letters))
f3
```

Answer: both create a reversed list of letters. f3 also has reversed levels but f2 does not.
(correct!)

---

## 3.5.4 Exercises

1.  List all the ways that a list differs from an atomic vector.

Answers:

- Each element can be a different type
- Each element is a reference to an object
- List size can be smaller since elements are references
- Lists can contain other lists

---

2.  Why do you need to use `unlist()` to convert a list to an 
    atomic vector? Why doesn't `as.vector()` work? 

```{r}
is.vector(list(1:4))
dput(as.vector(list(1:4)))
```

Answer: a list is considered a vector by `as.vector()`.

---

3.  Compare and contrast `c()` and `unlist()` when combining a 
    date and date-time into a single vector.

```{r}
d <- list(date = as.Date("2022-06-25"), datetime = as.POSIXct("2022-06-25 09:59:40 CDT"))
dput(d)

dput(c(d)) # nolint: unneeded_concatenation_linter.
dput(unlist(d))
```

Answer: `c()` preserves the list structure. `unlist()` converts both to `double`.

---

## 3.6.8 Exercises

1.  Can you have a data frame with zero rows? What about zero columns?

```{r}
# from data.frame() examples:
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

df
df[, FALSE]
df[FALSE, ]
df[FALSE, FALSE]
```

Answer: yes!

---

2.  What happens if you attempt to set rownames that are not unique?

```{r}
rownames(df)
try(rownames(df) <- c("a", "a", "b"))
```

Answer: error, duplicates not allowed.

---

3.  If `df` is a data frame, what can you say about `t(df)`, and `t(t(df))`? 
    Perform some experiments, making sure to try different column types.

```{r}
t(df)
t(t(df))

df2 <- data.frame(x = 1:3, y = c("a", "b", "c"), z = 4L:6L, stringsAsFactors = FALSE)
df2
t(df2)
t(t(df2))
```

Answer: `t()` coerces the vector types, so `t(t(df))` is the same as `df` only when all columns are
the same type.

---

4.  What does `as.matrix()` do when applied to a data frame with 
    columns of different types? How does it differ from `data.matrix()`?

```{r}
as.matrix(df)
as.matrix(df2)
data.matrix(df2)
as.data.frame(data.matrix(df2))
as.data.frame(data.matrix(data.frame(x = 1:3, y = c(0, 0.5, 1), z = 4:6)))
```

Answer: `as.matrix()` coerces all elements to the same type. `data.matrix()` coerces elements to
either integer (when possible) or double (when not).

---

# 4 Subsetting

R's subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:

* There are six ways to subset atomic vectors.

* There are three subsetting operators, `[[`, `[`, and `$`.

* Subsetting operators interact differently with different vector 
  types (e.g., atomic vectors, lists, factors, matrices, and data frames).

* Subsetting can be combined with assignment.

Subsetting is a natural complement to `str()`. While `str()` shows you all the pieces of any object (its structure), subsetting allows you to pull out the pieces that you're interested in. For large, complex objects, I highly recommend using the interactive RStudio Viewer, which you can activate with `View(my_object)`.

```{r}
rm(list = ls())
```

## 4.2.6 Exercises

1.  Fix each of the following common data frame subsetting errors:

```{r, eval = FALSE}
# nolint start: commented_code_linter.
# mtcars[mtcars$cyl = 4, ]
mtcars[mtcars$cyl == 4, ]

# mtcars[-1:4, ]
mtcars[-(1:4), ]

# mtcars[mtcars$cyl <= 5]
mtcars[mtcars$cyl <= 5, ]

# mtcars[mtcars$cyl == 4 | 6, ]
mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]
# nolint end
```

Answer: fixed!

---

2.  Why does the following code yield five missing values? (Hint: why is 
    it different from `x[NA_real_]`?)

```{r}
x <- 1:5
x[NA]

x[NA_real_]
x[TRUE]
```

Answer: NA is a logical constant of length 1.

---

3.  What does `upper.tri()` return? How does subsetting a matrix with it 
    work? Do we need any additional subsetting rules to describe its behaviour?

```{r}
x <- outer(1:5, 1:5, FUN = "*")
x
x[upper.tri(x)]
```

Answer: `upper.tri()` returns a matrix of logicals, which can be used to subset the upper triangle.
This is subsetting by matrix, which is new.

---

4.  Why does `mtcars[1:20]` return an error? How does it differ from the 
    similar `mtcars[1:20, ]`?

```{r}
try(mtcars[1:20])
mtcars[1:20, ]
```

Answer: `mtcars[1:20]` selects the first 20 columns, but there are only 11. `mtcars[1:20, ]` selects
the first 20 rows of `r nrow(mtcars)`.

---

5.  Implement your own function that extracts the diagonal entries from a
    matrix (it should behave like `diag(x)` where `x` is a matrix).

```{r}
m <- matrix(ncol = 3, byrow = TRUE, c(
  1, 4, 7,
  2, 5, 8,
  3, 6, 9
))
m
diag(m)

my_diag <- function(x) {
  diag_element <- function(n, x) {
    x[n, n]
  }
  vapply(seq_len(nrow(m)), diag_element, 1, x)
}
my_diag(m)
```

Answer: code above.

---

5.  What does `df[is.na(df)] <- 0` do? How does it work?

Answer: sets the `NA` values in `df` to `0`, by first selecting `NA` values then assigning `0`.

```{r}
df <- data.frame(x = c(1, 2, NA), y = c(4, NA, 6), z = c(NA, 8, 9))
df
df[is.na(df)] <- 0
df
```

Correct!

---

## 4.3.5 Exercises

1.  Brainstorm as many ways as possible to extract the third value from the
    `cyl` variable in the `mtcars` dataset.

```{r}
mtcars$cyl[3]
mtcars$cyl[[3]]
mtcars[["cyl"]][[3]]
mtcars[3, 2]
mtcars[[3, 2]]
mtcars[["Datsun 710", "cyl"]]
mtcars[-c(1:2, 4:32), -c(1, 3:11)]
```

Answer: code above (some variations omitted). There are many more.

---

2.  Given a linear model, e.g., `mod <- lm(mpg ~ wt, data = mtcars)`, extract
    the residual degrees of freedom. Then extract the R squared from the model
    summary (`summary(mod)`)

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
mod$df.residual

mod_sum <- summary(mod)
mod_sum$r.squared

mod_sum
```

Answer: code above.

---

## 4.5.9 Exercises

1.  How would you randomly permute the columns of a data frame? (This is an
    important technique in random forests.) Can you simultaneously permute 
    the rows and columns in one step?

```{r}
df <- data.frame(x = 1:5, y = 5:1, z = letters[1:5], row.names = 1:5)

df[, sample(ncol(df))]

df[sample(nrow(df)), sample(ncol(df))]
```

Answer: using `sample()`. Yes!

---

2.  How would you select a random sample of `m` rows from a data frame? 
    What if the sample had to be contiguous (i.e., with an initial row, a 
    final row, and every row in between)?

```{r}
sample_rows <- function(df, m, contiguous = FALSE) {
  if (m > nrow(df)) {
    stop("sample size '", m, "' is larger than the number of rows, '", nrow(df), "'")
  }
  if (contiguous) {
    first_row <- sample(nrow(df) - m + 1, 1)
    last_row <- first_row + m - 1
    return(df[first_row:last_row, ])
  }
  df[sample(nrow(df), m), ]
}

sample_rows(df, 3)
sample_rows(df, 3, contiguous = TRUE)
try(sample_rows(df, 6))
```

Answer: code above.

---
    
3.  How could you put the columns in a data frame in alphabetical order?

```{r}
mtcars[sort(colnames(mtcars))]
```

Answer: using `sort(colnames)`.

---

# 5 Control flow

There are two primary tools of control flow: choices and loops. Choices, like `if` statements and `switch()` calls, allow you to run different code depending on the input. Loops, like `for` and `while`, allow you to repeatedly run code, typically with changing options. I'd expect that you're already familiar with the basics of these functions so I'll briefly cover some technical details and then introduce some useful, but lesser known, features.

The condition system (messages, warnings, and errors), which you'll learn about in Chapter 8, also provides non-local control flow. 

```{r}
rm(list = ls())
```

## 5.2.4 Exercises

1.  What type of vector does each of the following calls to `ifelse()`
    return? Read the documentation and write down the rules in your own words.

```{r, eval = FALSE}
ifelse(TRUE, 1, "no")
typeof(ifelse(TRUE, 1, "no")) # double
ifelse(FALSE, 1, "no")
typeof(ifelse(FALSE, 1, "no")) # character
ifelse(NA, 1, "no")
typeof(ifelse(NA, 1, "no")) # logical
ifelse(NULL, 1, "no")
```


Answer:

- if `test` is true, return a vector of the same length as `test` (1) populated with "yes" - here 1
  is a double, 1L would be integer
- if `test` is false, return a vector of the same length as `test` (1) populated with "no" - here
  "no" is a character
- if `test` is `NA`, return `NA`, and if `test` is `NULL`, return `logical(0)`

---

2.  Why does the following code work?

```{r}
x <- 1:10
if (length(x)) "not empty" else "empty"

x <- numeric()
if (length(x)) "not empty" else "empty"
```

Answer: in the first example, `length(x)` is nonzero, which evaluates to `TRUE`. In the second
example, `numeric()` returns a vector of length 0 (the default), `length(x)` is zero, which
evaluates to `FALSE`.

---

## 5.3.3 Exercises

1.  Why does this code succeed without errors or warnings? 

```{r}
x <- numeric() # x is numeric(0)
out <- vector("list", length(x)) # out is list(0)
for (i in 1:length(x)) { # nolint: seq_linter. i is 1, then 0.
  out[i] <- x[i]^2 # when i = 1 x[1] is NA, sets out[1] to NA. when i = 0 nothing happens
}
out
```

Answer: in addition to notes above, `out[0]` and `x[0]` return a zero-length vector.

---

2.  When the following code is evaluated, what can you say about the 
    vector being iterated?

```{r}
xs <- c(1, 2, 3)
for (x in xs) {
  xs <- c(xs, x * 2)
}
xs
```

Answer: `x` iterates from 1 to 3, and is not affected by changes to `xs` during the loop, while `xs`
is updated.

---

3.  What does the following code tell you about when the index is updated?

```{r}
for (i in 1:3) {
  i <- i * 2
  print(i)
}
```

Answer: the index is updated at the beginning of each loop.

---

# 6 Functions

If you're reading this book, you've probably already created many R functions and know how to use them to reduce duplication in your code. In this chapter, you'll learn how to turn that informal, working knowledge into more rigorous, theoretical understanding. And while you'll see some interesting tricks and techniques along the way, keep in mind that what you'll learn here will be important for understanding the more advanced topics discussed later in the book.

```{r}
rm(list = ls())
```

## 6 Quiz

Answer the following questions to see if you can safely skip this chapter. You can find the answers in Section \@ref(function-answers).

1.  What are the three components of a function? a: arguments, code, return value [body, arguments,
    environment]

2.  What does the following code return? a: 11 [correct!]

```{r, eval = FALSE}
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```

3.  How would you usually write this code? a: `1 + 2 * 3` [correct! ... `1 + (2 * 3)`]

```{r, eval = FALSE}
`+`(1, `*`(2, 3))
```

4.  How could you make this call easier to read? `mean(c(1:10, NA), na.rm = TRUE)` [correct!]

```{r, eval = FALSE}
mean(, TRUE, x = c(1:10, NA)) # nolint: missing_argument_linter.
```

5.  Does the following code throw an error when executed? Why or why not? a: no, due to lazy
    evaluation, the `stop()` is never run [correct! ... second argument is never used]

```{r, eval = FALSE}
f2 <- function(a, b) {
  a * 10
}
f2(10, stop("This is an error!"))
```

6.  What is an infix function? How do you write it? What's a replacement 
    function? How do you write it? a: `function(x) x`. ??? [see 6.8.3 and 6.8.4]

7.  How do you ensure that cleanup action occurs regardless of how a function 
    exits? a: ??? [`on.exit()`]

## 6.2.5 Exercises

1. Given a name, like `"mean"`, `match.fun()` lets you find a function. 
   Given a function, can you find its name? Why doesn't that make sense in R?

Answer: a function is an object and could have multiple names pointing to it.

---

2.  It's possible (although typically not useful) to call an anonymous function.
    Which of the two approaches below is correct? Why?

```{r, result = "hide"}
function(x) 3()
(function(x) 3)()
```

Answer: The second is correct, as the first is the form of defining a function.

---

3. A good rule of thumb is that an anonymous function should fit on one line 
   and shouldn't need to use `{}`. Review your code. Where could you have 
   used an anonymous function instead of a named function? Where should you 
   have used a named function instead of an anonymous function?

Answer: in `rdev::build_analysis_site()`, `analysis_menu_item()` is properly written as a named
function, where `get_component()` could be written as an anonymous function, with `dir_check_copy()`
and `dir_check_delete()` potentially either.

---

4.  What function allows you to tell if an object is a function? What function
    allows you to tell if a function is a primitive function?

Answer: `is.function()` and `is.primitive()`.

---

5.  This code makes a list of all functions in the base package. 

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

Use it to answer the following questions:

a. Which base function has the most arguments?
a. How many base functions have no arguments? What's special about those
   functions?
a. How could you adapt the code to find all primitive functions?

```{r}
fun_args <- data.frame(
  name = names(funs),
  args = unname(vapply(funs, function(x) length(formals(x)), 1L))
)
head(fun_args[order(fun_args$args, decreasing = TRUE), ], 10)
fun_args[fun_args$args == 0, ]
# check if all functions with 0 arguments are primitive
fun_args2 <- data.frame(
  name = names(funs),
  args = unname(vapply(funs, function(x) length(formals(x)), 1L)),
  prim = unname(vapply(funs, is.primitive, TRUE))
)
fun_args2[fun_args2$args == 0, ]
```

Answers:

a. `scan()` has the most arguments, 22
a. most (but not all) are primitive functions (204 of 254)
a. the `ls()` in the original code could be expanded to search all packages

---

6. What are the three important components of a function?

Answer: the `formals()`, `body()` and `environment()`.

---

7. When does printing a function not show the environment it was created in?

Answer: when it is created in the global environment.

---

## 6.4.5 Exercises

1. What does the following code return? Why? Describe how each of the three
   `c`'s is interpreted.

```{r, eval = FALSE}
c <- 10
c(c = c)
```

Answer: a named vector, `c 10`. The first and final c is a variable. The second c is a function
name. the third c is a name.

---

2. What are the four principles that govern how R looks for values?

Answer: name masking, functions versus variables, a fresh start, dynamic lookup.

---

3. What does the following function return? Make a prediction before 
   running the code yourself.

```{r, results = "hide"}
f <- function(x) {
  f <- function(x) { # return value of this is 101
    f <- function() {
      x^2
    }
    f() + 1
  }
  f(x) * 2
}
f(10)
```

Answer: 202. Correct!

---

## 6.5.4 Exercises

1.  What important property of `&&` makes `x_ok()` work?

```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)
x_ok(1)
x_ok(1:3)
```

Answer: From the `&&` docs, "The longer forms evaluates left to right, proceeding only until the
result is determined."

What is different with this code? Why is this behaviour undesirable here?

```{r}
x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)
x_ok(1)
x_ok(1:3)
```

Answer: "The shorter forms performs elementwise comparisons in much the same way as arithmetic
operators." This is undesirable because the intent of the function is to return `TRUE` or `FALSE`.

---

2.  What does this function return? Why? Which principle does it illustrate?

```{r, results = "hide"}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```

Answer: 100, lazy evaluation. `x = z` isn't evaluated until `x`.

---

3.  What does this function return? Why? Which principle does it illustrate?

```{r, results = "hide"}
y <- 10
# styler: off
f1 <- function(x = {y <- 1; 2}, y = 0) { # nolint brace_linter, semicolon_linter.
  # styler: on
  c(x, y)
}
f1()
y
```

Answer: `c(2, 1)`. default arguments.

---

4.  In `hist()`, the default value of `xlim` is `range(breaks)`, the default 
    value for `breaks` is `"Sturges"`, and

```{r}
range("Sturges")
```

Explain how `hist()` works to get a correct `xlim` value.

Answer: from the docs, "Note that `xlim` is *not* used to define the histogram (breaks), but only
for plotting (when `plot = TRUE`)." So, the breakpoints are calculated when the object is created,
and `xlim` is calculated when the histogram is plotted, in the second step.

---
    
5.  Explain why this function works. Why is it confusing?

```{r}
show_time <- function(x = stop("Error!")) {
  stop <- function(...) Sys.time()
  print(x)
}
show_time()
```

Answer: `stop` is redefined before `x` is evaluated. This is a confusing use of lazy evaluation.

---

6.  How many arguments are required when calling `library()`?

Answer: zero. `library()` uses `missing()` to return the list of available packages if there are no
arguments.

---

## 6.6.1 Exercises

1.  Explain the following results:

```{r}
sum(1, 2, 3)
mean(1, 2, 3)

sum(1, 2, 3, na.omit = TRUE)
mean(1, 2, 3, na.omit = TRUE)
```

Answer:

- "`sum()` returns the sum of all the values present in its arguments." The first example is
  straightforward. In the second sum example, `na.omit` isn't a valid argument (`na.rm` is), so the
  `TRUE` value is passed to `...`, coerced to 1, and included in the sum.
- `mean()` takes a single parameter, and passes on remaining arguments to `...`. In both cases, the
  arguments after the `1` are silently dropped. The correct form would be `mean(c(1, 2, 3))`.

---

2.  Explain how to find the documentation for the named arguments in the 
    following function call:

```{r, fig.asp = 1, small_mar = TRUE, fig.width = 3}
plot(1:10, col = "red", pch = 20, xlab = "x", col.lab = "blue")
```

Answer: in other functions, specifically `par()` and `plot.default()`.

---

3.  Why does `plot(1:10, col = "red")` only colour the points, not the axes 
    or labels? Read the source code of `plot.default()` to find out.

```r
localAxis <- function(..., col, bg, pch, cex, lty, lwd) Axis(...)
localBox <- function(..., col, bg, pch, cex, lty, lwd) box(...)
localWindow <- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)
localTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)
```

Answer: `plot.default()` discards `col` and several other arguments when calling `Axis()`, `box()`,
`plot.window()`, and `title()`.

---

## 6.7.5 Exercises

1.  What does `load()` return? Why don't you normally see these values?

Answer: from the docs, `load()` returns "A character vector of the names of objects created,
invisibly."

---

2.  What does `write.table()` return? What would be more useful?

Answer: it returns `invisible(NULL)`. Returning the written table or the argument `x` would be more
useful.

---

3.  How does the `chdir` parameter of `source()` compare to `with_dir()`? Why 
    might you prefer one to the other?

Answer: both temporarily change the working directory. `chdir` is preferable since this is expected
behavior for the function, unless you need to set a working directory other than the directory
containing `file`.

---

4.  Write a function that opens a graphics device, runs the supplied code, and 
    closes the graphics device (always, regardless of whether or not the 
    plotting code works).

```{r}
with_png <- function(code, ...) {
  png(...)
  on.exit(dev.off(), add = TRUE, after = TRUE)
  force(code)
}

with_png(
  plot(1:10),
  filename = "rendered/withpng-example.png",
  # use 3 times default resolution which is close to retina display ppi (218-254 depending on model)
  # https://support.apple.com/en-us/HT202471
  width = 480 * 3, height = 480 * 3, res = 72 * 3
)
```

![with_png output](rendered/withpng-example.png)

Answer: code example above.

---

5.  We can use `on.exit()` to implement a simple version of `capture.output()`.

```{r, eval = getRversion() >= "3.5"}
# nolint start: object_name_linter, undesirable_function_linter.
capture.output2 <- function(code) {
  temp <- tempfile()
  on.exit(file.remove(temp), add = TRUE, after = TRUE)
  sink(temp)
  on.exit(sink(), add = TRUE, after = TRUE)
  force(code)
  readLines(temp)
}
# nolint end
capture.output2(cat("a", "b", "c", sep = "\n"))
```

Compare `capture.output()` to `capture.output2()`. How do the functions 
differ? What features have I removed to make the key ideas easier to see? 
How have I rewritten the key ideas so they're easier to understand?

Answer: `capture.output2()` has fewer features and uses two separate calls to `on.exit()`. It simply
returns the output (by line) from the executed code, and highlights the key idea, using `sink()` to
capture output to a temporary file.

---

## 6.8.6 Exercises

1. Rewrite the following code snippets into prefix form:

```{r}
1 + 2 + 3
`+`(`+`(1, 2), 3)

1 + (2 + 3)
`+`(1, `+`(2, 3))

fxn <- function(x, n) if (length(x) <= 5) x[[5]] else x[[n]]
fxn(1:5, 2)
fxn(1:10, 2)

fxn2 <- function(x, n) `if`(`<=`(length(x), 5), `[[`(x, 5), `[[`(x, n))
fxn2(1:5, 2)
fxn2(1:10, 2)
```

Answer: inline above.

---

2.  Clarify the following list of odd function calls:

```{r, eval = FALSE}
x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)
```

Answers: improved code below.

```{r}
x <- sample(c(1:10, NA), 20, replace = TRUE)
y <- runif(20)
cor(x, y, use = "pairwise.complete.obs", method = "kendall")
```

---

3. Explain why the following code fails:

```{r, eval = FALSE}
`modify<-` <- function(x, position, value) {
  x[position] <- value
  x
}

try(modify(get("x"), 1) <- 10)
#> Error: target of assignment expands to non-language object
```

Answer: as explained on [stack overflow](https://stackoverflow.com/questions/27662162/error-in-my-code-target-of-assignment-expands-to-non-language-object),
the error is caused when assigning to an object directly, instead of a name that refers to the
object (like `x`).

---

4. Create a replacement function that modifies a random location in a vector.

```{r}
`modrand<-` <- function(x, value) {
  x[sample(length(x), 1)] <- value
  x
}

v <- 1:20
modrand(v) <- NA
v
```

Answer: code above.

---

5. Write your own version of `+` that pastes its inputs together if they are 
   character vectors but behaves as usual otherwise. In other words, make this 
   code work:

```{r}
`+` <- function(x, y) {
  if (is.character(x) && is.character(y)) {
    return(paste0(x, y))
  }
  base::`+`(x, y)
}

1 + 2
#> [1] 3

"a" + "b"
#> [1] "ab"

rm(`+`)
```

Answer: code above.

---

6. Create a list of all the replacement functions found in the base package. 
   Which ones are primitive functions? (Hint: use `apropos()`.)

```{r}
# all replacement functions in base
fun_args2[endsWith(fun_args2$name, "<-"), ]$name

# all replacement primitive functions in base
fun_args2[endsWith(fun_args2$name, "<-") & fun_args2$prim, ]$name
```

Answer: while you could use `apropos("<-")`, I leveraged the existing code from 6.2.5 #5.

---

7. What are valid names for user-created infix functions?

Answer: they must begin and end with `%`, and can contain any sequence of characters except `%`.

---

8. Create an infix `xor()` operator.

```{r}
`%xor%` <- function(x, y) xor(x, y)

xor(0, 0)
xor(1, 0)
xor(1, 1)

0 %xor% 0
1 %xor% 0
1 %xor% 1
```

Answer: code above.

---

9. Create infix versions of the set functions `intersect()`, `union()`, and
   `setdiff()`. You might call them `%n%`, `%u%`, and `%/%` to match 
   conventions from mathematics.

```{r}
`%n%` <- function(x, y) intersect(x, y)
`%u%` <- function(x, y) union(x, y)
`%s%` <- function(x, y) setdiff(x, y)

# taken from docs examples
(x <- c(sort(sample(1:20, 9)), NA))
(y <- c(sort(sample(3:23, 7)), NA))
x %u% y
x %n% y
x %s% y
y %s% x
```

Answer: code above.

---

# 7 Environments

The environment is the data structure that powers scoping. This chapter dives deep into environments, describing their structure in depth, and using them to improve your understanding of the four scoping rules described in Section 6.4. 
Understanding environments is not necessary for day-to-day use of R. But they are important to understand because they power many important R features like lexical scoping, namespaces, and R6 classes, and interact with evaluation to give you powerful tools for making domain specific languages, like dplyr and ggplot2.

```{r}
rm(list = ls())
```

## 7.2.7 Exercises

1.  List three ways in which an environment differs from a list.

Answer:

- Every name in an environment must be unique
- Environment names are not ordered
- Environments have parents (except the empty environment)
- Environments are not copied when modified

---

2.  Create an environment as illustrated by this picture.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("assets/recursive-1.png")

e1 <- env()
e1$loop <- e1
```

Answer: code above.

---

3.  Create a pair of environments as illustrated by this picture.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("assets/recursive-2.png")

e2 <- env()
e3 <- env()

e2$loop <- e3
e3$dedoop <- e2
```

Answer: code above.

---

4.  Explain why `e[[1]]` and `e[c("a", "b")]` don't make sense when `e` is
    an environment.

Answer: environment names are not ordered, and aren't copied when modified, so they aren't
subsettable.

---

5.  Create a version of `env_poke()` that will only bind new names, never 
    re-bind old names. Some programming languages only do this, and are known 
    as [single assignment languages](https://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment).

```{r}
env_poke_new <- function(env, nm, value) {
  if (!is.environment(env)) stop("env is not an enviornment")
  if (nm %in% names(env)) stop("nm '", nm, "' already bound")
  env[[nm]] <- value
}

e_test <- env(a = NULL, b = 2, c = "three")

env_poke_new(e_test, "d", "success")
try(env_poke_new(e_test, "a", "fail"))
env_print(e_test)
```

Answer: code above.

---

6.  What does this function do? How does it differ from `<<-` and why
    might you prefer it?

```{r, error = TRUE}
rm(a)
rebind <- function(name, value, env = caller_env()) {
  if (identical(env, empty_env())) {
    stop("Can't find `", name, "`", call. = FALSE)
  } else if (env_has(env, name)) {
    env_poke(env, name, value)
  } else {
    rebind(name, value, env_parent(env))
  }
}
try(rebind("a", 10))
(a <- 5)
rebind("a", 10)
a
```

Answer: `<<-` will assign a value to the name in the global environment if the name is not found,
`rebind()` does not.

---

## 7.3.1 Exercises

1.  Modify `where()` to return _all_ environments that contain a binding for
    `name`. Carefully think through what type of object the function will
    need to return.

```{r}
where <- function(name, env = caller_env()) {
  if (identical(env, empty_env())) {
    # Base case
    stop("Can't find ", name, call. = FALSE)
  } else if (env_has(env, name)) {
    # Success case
    env
  } else {
    # Recursive case
    where(name, env_parent(env))
  }
}

x <- 5
try(where("yyy"))
where("x")
where("mean")

all_where <- function(name, env = caller_env(), found = list()) {
  if (identical(env, empty_env())) {
    # Base case
    found
  } else if (env_has(env, name)) {
    # Success case
    all_where(name, env_parent(env), append(env, found, after = 0))
  } else {
    # Recursive case
    all_where(name, env_parent(env), found)
  }
}

all_where("x")
local({
  x <- 10
  all_where("x")
})
```

Answer: code above.

---

2.  Write a function called `fget()` that finds only function objects. It 
    should have two arguments, `name` and `env`, and should obey the regular 
    scoping rules for functions: if there's an object with a matching name 
    that's not a function, look in the parent. For an added challenge, also 
    add an `inherits` argument which controls whether the function recurses up 
    the parents or only looks in one environment.

```{r}
fget <- function(name, env = caller_env(), inherits = TRUE) {
  if (identical(env, empty_env())) {
    # Base case
    stop("Can't find ", name, call. = FALSE)
  } else if (env_has(env, name) && is.function(env[[name]])) {
    # Success case
    env
  } else if (inherits) {
    # Recursive case
    fget(name, env_parent(env))
  } else {
    stop("Can't find ", name, call. = FALSE)
  }
}

try(fget("x"))
fget("print")
try(fget("print", inherits = FALSE))
fget("all_where", inherits = FALSE)
```

Answer: code above.

---

## 7.4.5 Exercises

1.  How is `search_envs()` different from `env_parents(global_env())`?

Answer: `search_envs()` includes the global environment. `env_parents(global_env())` doesn't include
the global environment and also returns the empty environment (the top parent).

---

2.  Draw a diagram that shows the enclosing environments of this function:

```{r, eval = FALSE}
f1 <- function(x1) {
  f2 <- function(x2) {
    f3 <- function(x3) {
      x1 + x2 + x3
    }
    f3(3)
  }
  f2(2)
}
f1(1)
```

Answer: No.

---

3.  Write an enhanced version of `str()` that provides more information 
    about functions. Show where the function was found and what environment 
    it was defined in.

```{r}
e_str <- function(object, ...) {
  str(object, ...)
  if (is.function(object)) {
    message("fn_env():")
    print(fn_env(object))
    message("environment():")
    print(environment(object))
  }
}

e_str(print)
e_str(fget)
```

Answer: code above.

---

## 7.5.5 Exercises

1.  Write a function that lists all the variables defined in the environment
    in which it was called. It should return the same results as `ls()`.

```{r}
my_ls <- function() {
  vars <- sort(names(parent.frame()))
  vars[!startsWith(vars, ".")]
}

ls()
my_ls()
```

Answer: code above.

---

# 8 Conditions

The __condition__ system provides a paired set of tools that allow the author of a function to indicate that something unusual is happening, and the user of that function to deal with it. The function author __signals__ conditions with functions like `stop()` (for errors), `warning()` (for warnings), and `message()` (for messages), then the function user can handle them with functions like `tryCatch()` and `withCallingHandlers()`. Understanding the condition system is important because you'll often need to play both roles: signalling conditions from the functions you create, and handle conditions signalled by the functions you call.

R offers a very powerful condition system based on ideas from Common Lisp. Like R's approach to object-oriented programming, it is rather different to currently popular programming languages so it is easy to misunderstand, and there has been relatively little written about how to use it effectively. Historically, this has meant that few people (myself included) have taken full advantage of its power. The goal of this chapter is to remedy that situation. Here you will learn about the big ideas of R's condition system, as well as learning a bunch of practical tools that will make your code stronger.

I found two resources particularly useful when writing this chapter. You may also want to read them if you want to learn more about the inspirations and motivations for the system:

* [_A prototype of a condition system for R_](https://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html) by Robert Gentleman 
  and Luke Tierney. This describes an early version of R's condition system. 
  While the implementation has changed somewhat since this document was 
  written, it provides a good overview of how the pieces fit together, and 
  some motivation for its design.

* [_Beyond exception handling: conditions and restarts_](https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html)
  by Peter Seibel. This describes exception handling in Lisp, which happens 
  to be very similar to R's approach. It provides useful motivation and 
  more sophisticated examples. I have provided an R translation of the 
  chapter at <http://adv-r.had.co.nz/beyond-exception-handling.html>.

I also found it helpful to work through the underlying C code that implements these ideas. If you're interested in understanding how it all works, you might find [my notes](https://gist.github.com/hadley/4278d0a6d3a10e42533d59905fbed0ac) to be useful.

```{r}
rm(list = ls())
```
