[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "rtraining",
    "section": "",
    "text": "R Training: My notes and experiences learning R and RStudio, bundled as an R package (work-in-progress), and published to GitHub Pages using Quarto.\nFeel free to use and/or fork this project!"
  },
  {
    "objectID": "index.html#notebooks",
    "href": "index.html#notebooks",
    "title": "rtraining",
    "section": "Notebooks",
    "text": "Notebooks\nNotebooks in this package:"
  },
  {
    "objectID": "NEWS.html",
    "href": "NEWS.html",
    "title": "rtraining 1.1.7",
    "section": "",
    "text": "Maintenance updates"
  },
  {
    "objectID": "NEWS.html#new-features",
    "href": "NEWS.html#new-features",
    "title": "rtraining 1.1.7",
    "section": "New Features",
    "text": "New Features\n\nmajor update: build-site has been replaced with an R function, build_analysis_site(), which retains all of the functionality of the old shell script. It is still considered Experimental, due to lack of test coverage and some features that are not implemented, but should work for projects with limited pkgdown customization. The update also includes a function to convert notebooks to html_document, to_document().\nbuild_analysis_site() will be migrated to rdev in a future release"
  },
  {
    "objectID": "NEWS.html#new-content",
    "href": "NEWS.html#new-content",
    "title": "rtraining 1.1.7",
    "section": "New Content",
    "text": "New Content\n\nR Setup Log: added notes on the package layout I use for “analysis” packages (will be converted to an rdev vignette in a future release)\nR Setup Log: added notes on my R Workflow\nR Training Log: updated with notes on my current book, R Packages"
  },
  {
    "objectID": "NEWS.html#new-contentfeatures",
    "href": "NEWS.html#new-contentfeatures",
    "title": "rtraining 1.1.7",
    "section": "New Content/Features",
    "text": "New Content/Features\n\nci(): run continuous integration tests locally: lint, R CMD check, and style (off by default).\ncheck_renv(): convenience function that runs renv status(), clean(), and optionally update() (on by default)."
  },
  {
    "objectID": "NEWS.html#new-contentfeatures-1",
    "href": "NEWS.html#new-contentfeatures-1",
    "title": "rtraining 1.1.7",
    "section": "New Content/Features",
    "text": "New Content/Features\n\nR Setup Log Notebook (r-setup-log.Rmd): My notes on my personal R setup\nminor updates to R Training Log\nstyle_all(): style all .R and .Rmd files in a project using styler\nlint_all(): lint all .R and .Rmd files in a project using lintr\nadd GitHub Actions for continuous integration testing"
  },
  {
    "objectID": "NEWS.html#new-contentfeatures-2",
    "href": "NEWS.html#new-contentfeatures-2",
    "title": "rtraining 1.1.7",
    "section": "New Content/Features",
    "text": "New Content/Features\n\nR Training Log Notebook (r-training-log.Rmd): Notes on learning R and RStudio\ntools/setup-r: shell script to install development packages to site repository on macOS + Homebrew\nbuild-site: build a website from a collection of R Notebooks (html_notebook) in notebooks/"
  },
  {
    "objectID": "analysis/advanced-r-1.html",
    "href": "analysis/advanced-r-1.html",
    "title": "Advanced R (Foundations)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Foundations” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions.\nlibrary(lobstr)\nlibrary(bench)\nlibrary(rlang)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#quiz",
    "href": "analysis/advanced-r-1.html#quiz",
    "title": "Advanced R (Foundations)",
    "section": "2 Quiz",
    "text": "2 Quiz\n\nGiven the following data frame, how do I create a new column called “3” that contains the sum of 1 and 2? You may only use $, not [[. What makes 1, 2, and 3 challenging as variable names?\n\n\ndf &lt;- data.frame(runif(3), runif(3))\nnames(df) &lt;- c(1, 2)\n\nAnswer: use the following code.\n\ndf2 &lt;- data.frame(df, df$`1` + df$`2`)\nnames(df2) &lt;- c(1, 2, 3)\n\nUsing numbers as names is problematic due to them being interpreted as numeric constants by default.\n\n\nIn the following code, how much memory does y occupy?\n\n\nx &lt;- runif(1e6)\ny &lt;- list(x, x, x)\n\nAnswer: 3 times the size of x, 24 MB. Note: this is incorrect, as shown by obj_size and obj_addr:\n\nobj_size(x)\n\n#&gt; 8.00 MB\n\nobj_size(y)\n\n#&gt; 8.00 MB\n\nobj_addr(y[[1]])\n\n#&gt; [1] \"0x110b00000\"\n\nobj_addr(y[[2]])\n\n#&gt; [1] \"0x110b00000\"\n\nobj_addr(y[[3]])\n\n#&gt; [1] \"0x110b00000\"\n\n\n\n\nOn which line does a get copied in the following example?\n\n\na &lt;- c(1, 5, 3, 2)\nobj_addr(a)\n\n#&gt; [1] \"0x10fc74668\"\n\nb &lt;- a\nobj_addr(b)\n\n#&gt; [1] \"0x10fc74668\"\n\nb[[1]] &lt;- 10\nobj_addr(b)\n\n#&gt; [1] \"0x10fd3ef28\"\n\n\nAnswer: the third line (copy-on-write). [copy-on-modify]",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises",
    "href": "analysis/advanced-r-1.html#exercises",
    "title": "Advanced R (Foundations)",
    "section": "2.2.2 Exercises",
    "text": "2.2.2 Exercises\n\nExplain the relationship between a, b, c and d in the following code:\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\nAnswer: a, b, and c all point to the same object (1:10). d points to an identical object at a different address.\nAR Solutions: a, b, and c point to the same object (with the same address in memory). This object has the value 1:10. d points to a different object with the same value.\n\nobj_addr(a)\n\n#&gt; [1] \"0x10f505e10\"\n\nobj_addr(b)\n\n#&gt; [1] \"0x10f505e10\"\n\nobj_addr(c)\n\n#&gt; [1] \"0x10f505e10\"\n\nobj_addr(d)\n\n#&gt; [1] \"0x10f5f32e8\"\n\n\n\n\nThe following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with lobstr::obj_addr().\n\n\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")\n\nCheck the obj_addr:\n\nobj_addr(mean)\n\n#&gt; [1] \"0x12c39a538\"\n\nobj_addr(base::mean)\n\n#&gt; [1] \"0x12c39a538\"\n\nobj_addr(get(\"mean\"))\n\n#&gt; [1] \"0x12c39a538\"\n\nobj_addr(evalq(mean))\n\n#&gt; [1] \"0x12c39a538\"\n\nobj_addr(match.fun(\"mean\"))\n\n#&gt; [1] \"0x12c39a538\"\n\n\nAnswer: they do.\nAR Solutions: Yes, they point to the same object. We confirm this by inspecting the address of the underlying function object.\n\n\nBy default, base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behaviour?\n\nAnswer: this could introduce problematic names, like 1. Setting check.names = FALSE suppresses this behavior.\nAR Solutions: Column names are often data, and the underlying make.names() transformation is non-invertible, so the default behaviour corrupts data. To avoid this, set check.names = FALSE.\n\n\nWhat rules does make.names() use to convert non-syntactic names into syntactic ones?\n\nAnswer: from ?make.names:\n\nThe character “X” is prepended if necessary. All invalid characters are translated to “.”. A missing value is translated to “NA”. Names which match R keywords have a dot appended to them. Duplicated values are altered by make.unique.\n\nAR Solutions: A valid name must start with a letter or a dot (not followed by a number) and may further contain numbers and underscores (\"_\"s are allowed since R version 1.9.0).\nThree main mechanisms ensure syntactically valid names (see ?make.names):\n\nNames that do not start with a letter or a dot will be prepended with an \"X\". The same holds for names that begin with a dot followed by a number.\nAdditionally, non-valid characters are replaced by a dot.\nReserved R keywords (see ?reserved) are suffixed by a dot.\n\nInterestingly, some of these transformations are influenced by the current locale. From ?make.names:\n\nThe definition of a letter depends on the current locale, but only ASCII digits are considered to be digits.\n\n\n\nI slightly simplified the rules that govern syntactic names. Why is .123e1 not a syntactic name? Read ?make.names for the full details.\n\nAnswer: from ?make.names:\n\nA syntactically valid name consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number. Names such as “.2way” are not valid, and neither are the reserved words.\n\nAR Solutions: .123e1 is not a syntactic name, because it starts with one dot which is followed by a number. This makes it a double, 1.23.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-1",
    "href": "analysis/advanced-r-1.html#exercises-1",
    "title": "Advanced R (Foundations)",
    "section": "2.3.6 Exercises",
    "text": "2.3.6 Exercises\n\nWhy is tracemem(1:10) not useful?\n\nAnswer: this is tracing an ‘immutable’ object which will always have the same address.\nAR Solutions: When 1:10 is called an object with an address in memory is created, but it is not bound to a name. Therefore, the object cannot be called or manipulated from R. As no copies will be made, it is not useful to track the object for copying.\n\n\nExplain why tracemem() shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.\n\n\nrm(list = ls())\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n#&gt; [1] \"&lt;0x10ae53848&gt;\"\n\nx[[3]] &lt;- 4\n\n#&gt; tracemem[0x10ae53848 -&gt; 0x11a245b88]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers withCallingHandlers handle_error process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n#&gt; tracemem[0x11a245b88 -&gt; 0x11a0cb268]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers withCallingHandlers handle_error process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\nuntracemem(x)\n\nAnswer: unclear. The behavior in R 4.2.0 seems to have changed, since this code shows two copies:\n\nrm(list = ls())\nx &lt;- c(1, 2, 3)\ntracemem(x)\n\n#&gt; [1] \"&lt;0x10b8871f8&gt;\"\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\n#&gt; tracemem[0x10b8871f8 -&gt; 0x10b88b108]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers withCallingHandlers handle_error process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\ny[[3]] &lt;- 5L\nuntracemem(x)\n\nAR Solutions: Initially the vector x has integer type. The replacement call assigns a double to the third element of x, which triggers copy-on-modify.\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n#&gt; &lt;0x66a4a70&gt;\n\nx[[3]] &lt;- 4\n#&gt; tracemem[0x55eec7b3af38 -&gt; 0x55eec774cc18]:\n\nWe can avoid the copy by sub-assigning an integer instead of a double:\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n#&gt; &lt;0x55eec6940ae0&gt;\n\nx[[3]] &lt;- 4L\n\nPlease be aware that running this code in RStudio will result in additional copies because of the reference from the environment pane.\n\n\nSketch out the relationship between the following objects:\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nprint(\"first object\")\n\n#&gt; [1] \"first object\"\n\nobj_addr(a)\n\n#&gt; [1] \"0x10c915f30\"\n\nobj_addr(b[[1]])\n\n#&gt; [1] \"0x10c915f30\"\n\nobj_addr(b[[2]])\n\n#&gt; [1] \"0x10c915f30\"\n\nobj_addr(c[[2]])\n\n#&gt; [1] \"0x10c915f30\"\n\nprint(\"second object\")\n\n#&gt; [1] \"second object\"\n\nobj_addr(b)\n\n#&gt; [1] \"0x12c5f2a08\"\n\nobj_addr(c[[1]])\n\n#&gt; [1] \"0x12c5f2a08\"\n\nprint(\"third object\")\n\n#&gt; [1] \"third object\"\n\nobj_addr(c)\n\n#&gt; [1] \"0x10dd164a8\"\n\nprint(\"fourth object (?)\")\n\n#&gt; [1] \"fourth object (?)\"\n\nobj_addr(c[[3]])\n\n#&gt; [1] \"0x12cf92cf0\"\n\n\nAnswer: four different objects with multiple names.\nAR Solutions: a contains a reference to an address with the value 1:10. b contains a list of two references to the same address as a. c contains a list of b (containing two references to a), a (containing the same reference again) and a reference pointing to a different address containing the same value (1:10).\n\n\nWhat happens when you run this code? Draw a picture.\n\n\nx &lt;- list(1:10)\n\nx[[2]] &lt;- x\n\nref(x)\n\n#&gt; █ [1:0x12cc0fa48] &lt;list&gt; \n#&gt; ├─[2:0x12a360b58] &lt;int&gt; \n#&gt; └─█ [3:0x10e84ae88] &lt;list&gt; \n#&gt;   └─[2:0x12a360b58]\n\n\nInitially x is a list of one element, an int vector 1:10. Then a second list element is added, which points to the original int vector.\nAR Solutions: The initial reference tree of x shows that the name x binds to a list object. This object contains a reference to the integer vector 1:10. When x is assigned to an element of itself, copy-on-modify takes place and the list is copied to a new address in memory. The list object previously bound to x is now referenced in the newly created list object. It is no longer bound to a name. The integer vector is referenced twice.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-2",
    "href": "analysis/advanced-r-1.html#exercises-2",
    "title": "Advanced R (Foundations)",
    "section": "2.4.1 Exercises",
    "text": "2.4.1 Exercises\n\nIn the following example, why are object.size(y) and obj_size(y) so radically different? Consult the documentation of object.size().\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n#&gt; 8005648 bytes\n\nobj_size(y)\n\n#&gt; 80.90 kB\n\n\nAnswer: object.size() “does not detect if elements of a list are shared”, which is the case here. That is, it does not detect the list has been replicated 100 times, and overestimates by a factor of 100 compared to object_size().\nAR Solutions: object.size() doesn’t account for shared elements within lists. Therefore, the results differ by a factor of ~ 100.\n\n\nTake the following list. Why is its size somewhat misleading?\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n#&gt; 17.55 kB\n\n\nAnswer: it doesn’t seem misleading to me, but the list includes the function objects, not the return values. Also, it calculates the size discarding the overlap between the functions. Per the code below, there is some:\n\nobj_size(mean) + obj_size(sd) + obj_size(var)\n\n#&gt; 18.08 kB\n\n\nAR Solutions: All three functions are built-in to R as part of the {base} and {stats} packages and hence always available. So, what does it mean to measure the size of something that’s already included in R?\n(There’s typically a more general question about what you want to know when you ask for the size of something — do you want to know how much data you’d need to send to communicate the object to someone else (e.g. serialise it), or do you want to know how much memory you’d free if you deleted it?)\n\n\nPredict the output of the following code:\n\n\na &lt;- runif(1e6)\nobj_size(a) # 8,000,048 B ~ 8MB\n\n#&gt; 8.00 MB\n\n# correct: from example above, runif(1e6) ~= 8MB\n\nb &lt;- list(a, a)\nobj_size(b) # slightly larger than obj_size(a)\n\n#&gt; 8.00 MB\n\n# correct: two lists containing numeric vectors\nobj_size(a, b) # slightly larger than obj_size(b)\n\n#&gt; 8.00 MB\n\n# wrong: a is entirely contained within b\n\nb[[1]][[1]] &lt;- 10\nobj_size(b) # copy of b, same size\n\n#&gt; 16.00 MB\n\n# wrong: double, since R copies an entire column, this adds the size of runif(1e6)\nobj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)\n\n#&gt; 16.00 MB\n\n# wrong: a is still entirely contained with b\n\nb[[2]][[1]] &lt;- 10\nobj_size(b) # copy of b, same size\n\n#&gt; 16.00 MB\n\n# wrong: same size since it's still 2 numeric vectors of 1e6 length\nobj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)\n\n#&gt; 24.00 MB\n\n# wrong: there is no longer any overlap, so the size of obj_size(a, b) = obj_size(a) = obj_size(b)\n\nAnswer: answers inline.\nAR Solutions:\na &lt;- runif(1e6):\n\nIn R (on most platforms) a length-0 vector has 48 bytes of overhead.\nA single double takes up an additional 8 bytes of memory.\nSo, a 1 million double should take up 8,000,048 bytes.\n\nFor b &lt;- list(a, a) both list elements contain references to the same memory address. Therefore, no additional memory is required for the second list element. The list itself requires 64 bytes, 48 bytes for an empty list and 8 bytes for each element (obj_size(vector(\"list\", 2))). This lets us predict 8,000,048 B + 64 B = 8,000,112 B.\nb[[1]][[1]] &lt;- 10: When we modify the first element of b[[1]] copy-on-modify occurs. Both elements will still have the same size (8,000,040 B), but the first one gets a new address in memory. As b’s elements don’t share references anymore, its object size adds up to the sum of the elements and the length-2 list: 8,000,048 B + 8,000,048 B + 64 B = 16,000,160 B (16 MB). The second element of b still references the same address as a, so the combined size of a and b is the same as b.\nb[[2]][[1]] &lt;- 10: When we modify the second element of b, this element will also point to a new memory address. This does not affect the size of the list. However, as b doesn’t share references with a anymore, the memory usage of the combined objects increases.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-3",
    "href": "analysis/advanced-r-1.html#exercises-3",
    "title": "Advanced R (Foundations)",
    "section": "2.5.3 Exercises",
    "text": "2.5.3 Exercises\n\nExplain why the following code doesn’t create a circular list.\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\nAnswer: the name x is assigned to the empty list, and then the first element of x is mapped to the object that x points to, the empty list.\nAR Solutions: In this situation copy-on-modify prevents the creation of a circular list. Let us step through the details:\n\nx &lt;- list() # creates initial object\nobj_addr(x)\n#&gt; [1] \"0x55862f23ab80\"\ntracemem(x)\n#&gt; [1] \"&lt;0x55862f23ab80&gt;\"\nx[[1]] &lt;- x # Copy-on-modify triggers new copy\n#&gt; tracemem[0x55862f23ab80 -&gt; 0x55862e8ce028]:\nobj_addr(x) # copied object has new memory address\n#&gt; [1] \"0x55862e8ce028\"\nobj_addr(x[[1]]) # list element contains old memory address\n#&gt; [1] \"0x55862f23ab80\"\n\n\n\nWrap the two methods for subtracting medians into two functions, then use the ‘bench’ package [@bench] to carefully compare their speeds. How does performance change as the number of columns increase?\n\n\nx_medians &lt;- function(ncol) {\n  x &lt;- data.frame(matrix(runif(5 * 1e4), ncol = ncol))\n  medians &lt;- vapply(x, median, numeric(1))\n  return(list(x = x, medians = medians))\n}\n\ndf_medians &lt;- function(x, medians) {\n  # subtract medians using data.frame method\n  for (i in seq_along(medians)) {\n    x[[i]] &lt;- x[[i]] - medians[[i]]\n  }\n  x\n}\n\nls_medians &lt;- function(x, medians) {\n  y &lt;- as.list(x)\n\n  for (i in seq_along(medians)) {\n    y[[i]] &lt;- y[[i]] - medians[[i]]\n  }\n  y\n}\n\n# confirm they both work\nxm &lt;- x_medians(5)\nhead(df_medians(xm$x, xm$medians), 10)\n\n#&gt;             X1          X2          X3           X4          X5\n#&gt; 1   0.43687555 -0.15952321 -0.11049405 -0.447574305  0.09157020\n#&gt; 2   0.08749675 -0.10133035  0.48789948 -0.305568328 -0.02170975\n#&gt; 3  -0.03890698  0.20359297  0.10053737 -0.103263463  0.02597145\n#&gt; 4   0.34391284 -0.49424745  0.42974962 -0.296187179  0.34387263\n#&gt; 5  -0.21085900 -0.08537066  0.19801263  0.182952770  0.07282162\n#&gt; 6   0.11524745 -0.05050875  0.06630594 -0.004480693 -0.04276207\n#&gt; 7   0.25788382 -0.32080371 -0.10849797  0.392610683  0.12800799\n#&gt; 8   0.30113996  0.39646219  0.16874994 -0.402945732 -0.12120135\n#&gt; 9  -0.04427495 -0.21338661  0.14661082  0.363260208 -0.25625303\n#&gt; 10 -0.25597920 -0.08442713  0.37669364  0.126202677  0.48536194\n\nhead(as.data.frame(ls_medians(xm$x, xm$medians)), 10)\n\n#&gt;             X1          X2          X3           X4          X5\n#&gt; 1   0.43687555 -0.15952321 -0.11049405 -0.447574305  0.09157020\n#&gt; 2   0.08749675 -0.10133035  0.48789948 -0.305568328 -0.02170975\n#&gt; 3  -0.03890698  0.20359297  0.10053737 -0.103263463  0.02597145\n#&gt; 4   0.34391284 -0.49424745  0.42974962 -0.296187179  0.34387263\n#&gt; 5  -0.21085900 -0.08537066  0.19801263  0.182952770  0.07282162\n#&gt; 6   0.11524745 -0.05050875  0.06630594 -0.004480693 -0.04276207\n#&gt; 7   0.25788382 -0.32080371 -0.10849797  0.392610683  0.12800799\n#&gt; 8   0.30113996  0.39646219  0.16874994 -0.402945732 -0.12120135\n#&gt; 9  -0.04427495 -0.21338661  0.14661082  0.363260208 -0.25625303\n#&gt; 10 -0.25597920 -0.08442713  0.37669364  0.126202677  0.48536194\n\n# benchmark\nmark(df_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 df_medians(xm$x, xm$medians)   33.1µs   47.9µs    21409.     391KB     317.\n\nmark(ls_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 ls_medians(xm$x, xm$medians)   8.53µs   23.4µs    42221.     391KB     474.\n\nmark(as.data.frame(ls_medians(xm$x, xm$medians))) # as.data.frame introduces significant overhead\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                           &lt;bch&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 as.data.frame(ls_medians(xm$x, xm$m… 108µs  125µs     8215.     391KB     94.3\n\n\nAnswer: with 5 columns, the list method is about twice as fast.\n\nxm &lt;- x_medians(10)\nmark(df_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 df_medians(xm$x, xm$medians)   58.5µs   78.6µs    12454.     391KB     147.\n\nmark(ls_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 ls_medians(xm$x, xm$medians)   11.1µs   33.7µs    34530.     391KB     381.\n\nxm &lt;- x_medians(20)\nmark(df_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 df_medians(xm$x, xm$medians)    113µs    136µs     7358.     400KB     88.3\n\nmark(ls_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 ls_medians(xm$x, xm$medians)   12.9µs   29.6µs    35733.     392KB     401.\n\n\nWith 10 columns, the list method is 3 times as fast. With 20, the list method is 5 times as fast. So, the list method is near constant time regardless of columns, whereas the data.frame method scales linearly with the number of columns.\nAR Solutions:\nWhen working directly with the data frame, the execution time grows quadratically with the number of columns in the input data. This is because (e.g.) the first column must be copied n times, the second column n-1 times, and so on. When working with a list, the execution time increases only linearly.\nObviously in the long run, linear growth creates shorter run-times, but there is some cost to this strategy — we have to convert between data structures with as.list() and list2DF(). Even though this is fast and probably doesn’t hurt much, the improved approach doesn’t really pay off in this scenario until we get to a data frame that is about 300 columns wide (with the exact value depending on the characteristics of the system running the code).\n\n\nWhat happens if you attempt to use tracemem() on an environment?\n\n\ne &lt;- rlang::env()\ntry(tracemem(e))\n\n#&gt; Error in tracemem(e) : \n#&gt;   'tracemem' is not useful for promise and environment objects\n\n\nAnswer: it throws an error!\nAR Solutions: tracemem() cannot be used to mark and trace environments.\nThe error occurs because “it is not useful to trace NULL, environments, promises, weak references, or external pointer objects, as these are not duplicated” (see ?tracemem). Environments are always modified in place.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-4",
    "href": "analysis/advanced-r-1.html#exercises-4",
    "title": "Advanced R (Foundations)",
    "section": "3.2.5 Exercises",
    "text": "3.2.5 Exercises\n\nHow do you create raw and complex scalars? (See ?raw and ?complex.)\n\nAnswer: using either raw(), complex(), or as.raw(), as.complex().\nAR Solutions: In R, scalars are represented as vectors of length one. However, there’s no built-in syntax like there is for logicals, integers, doubles, and character vectors to create individual raw and complex values. Instead, you have to create them by calling a function. For raw vectors you can use either as.raw() or charToRaw() to create them from numeric or character values.\nIn the case of complex numbers, real and imaginary parts may be provided directly to the complex() constructor. You can create purely imaginary numbers (e.g.) 1i, but there is no way to create complex numbers without + (e.g. 1i + 1).\n\n\nTest your knowledge of the vector coercion rules by predicting the output of the following uses of c():\n\n\nc(1, FALSE) # 1.0, 0.0 - double\n\n#&gt; [1] 1 0\n\nc(\"a\", 1) # \"a\", \"1\" - character\n\n#&gt; [1] \"a\" \"1\"\n\nc(TRUE, 1L) # 1L, 1L - integer\n\n#&gt; [1] 1 1\n\ntypeof(c(1, FALSE))\n\n#&gt; [1] \"double\"\n\ntypeof(c(\"a\", 1))\n\n#&gt; [1] \"character\"\n\ntypeof(c(TRUE, 1L))\n\n#&gt; [1] \"integer\"\n\n\nAnswer: guesses inline. [correct!]\nAR Solutions:\n\nc(1, FALSE) # will be coerced to double    -&gt; 1 0\nc(\"a\", 1) # will be coerced to character -&gt; \"a\" \"1\"\nc(TRUE, 1L) # will be coerced to integer   -&gt; 1 1\n\n\n\nWhy is 1 == \"1\" true? Why is -1 &lt; FALSE true? Why is \"one\" &lt; 2 false?\n\nAnswers:\n\n1 == \"1\": the 1 is coerced to “1”\n-1 &lt; FALSE: FALSE is coerced to 0\n`“one” &lt; 2: the 2 is coerced to “2”\n\nAR Solutions: These comparisons are carried out by operator-functions (==, &lt;), which coerce their arguments to a common type. In the examples above, these types will be character, double and character: 1 will be coerced to \"1\", FALSE is represented as 0 and 2 turns into \"2\" (and numbers precede letters in lexicographic order (may depend on locale)).\n\n\nWhy is the default missing value, NA, a logical vector? What’s special about logical vectors? (Hint: think about c(FALSE, NA_character_).)\n\nAnswer: NA must be logical so that it can exist in a logical vector.\nAR Solutions: The presence of missing values shouldn’t affect the type of an object. Recall that there is a type-hierarchy for coercion from character → double → integer → logical. When combining NAs with other atomic types, the NAs will be coerced to integer (NA_integer_), double (NA_real_) or character (NA_character_) and not the other way round. If NA were a character and added to a set of other values all of these would be coerced to character as well.\n\n\nPrecisely what do is.atomic(), is.numeric(), and is.vector() test for?\n\nAnswers:\n\nis.atomic(x): tests if x is an atomic vector (logical, integer, numeric, complex, character, and raw) - is FALSE for lists\nis.numeric(x): tests if x is an atomic numeric vector\nis.vector(x, mode = \"any\"): tests if x is an atomic vector OR a list or expression\n\nAR Solutions: The documentation states that:\n\nis.atomic() tests if an object is an atomic vector (as defined in Advanced R) or is NULL (!).\nis.numeric() tests if an object has type integer or double and is not of class factor, Date, POSIXt or difftime.\nis.vector() tests if an object is a vector (as defined in Advanced R) or an expression and has no attributes, apart from names.\n\nAtomic vectors are defined in Advanced R as objects of type logical, integer, double, complex, character or raw. Vectors are defined as atomic vectors or lists.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-5",
    "href": "analysis/advanced-r-1.html#exercises-5",
    "title": "Advanced R (Foundations)",
    "section": "3.3.4 Exercises",
    "text": "3.3.4 Exercises\n\nHow is setNames() implemented? How is unname() implemented? Read the source code.\n\n\nsetNames\n\n#&gt; function (object = nm, nm) \n#&gt; {\n#&gt;     names(object) &lt;- nm\n#&gt;     object\n#&gt; }\n#&gt; &lt;bytecode: 0x10ccb5a28&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nunname\n\n#&gt; function (obj, force = FALSE) \n#&gt; {\n#&gt;     if (!is.null(names(obj))) \n#&gt;         names(obj) &lt;- NULL\n#&gt;     if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n#&gt;         dimnames(obj) &lt;- NULL\n#&gt;     obj\n#&gt; }\n#&gt; &lt;bytecode: 0x10abe0520&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\nAnswer: using names(), and dimnames() for unname().\nAR Solutions:\nBecause the data argument comes first, setNames() also works well with the magrittr-pipe operator. When no first argument is given, the result is a named vector (this is rather untypical as required arguments usually come first):\nunname() removes existing names (or dimnames) by setting them to NULL.\n\n\nWhat does dim() return when applied to a 1-dimensional vector? When might you use NROW() or NCOL()?\n\n\ndim(1:3)\n\n#&gt; NULL\n\nnrow(1:12)\n\n#&gt; NULL\n\nNROW(1:12)\n\n#&gt; [1] 12\n\nncol(1:12)\n\n#&gt; NULL\n\nNCOL(1:12)\n\n#&gt; [1] 1\n\n\nAnswers: NULL. NROW and NCOL are useful when comparing NULL dimensional vectors with matrices and arrays.\nAR Solutions: From ?nrow:\n\ndim() will return NULL when applied to a 1d vector.\n\nOne may want to use NROW() or NCOL() to handle atomic vectors, lists and NULL values in the same way as one column matrices or data frames.\n\n\nHow would you describe the following three objects? What makes them different from 1:5?\n\n\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))\n\nx1\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    1\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    2\n#&gt; \n#&gt; , , 3\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    3\n#&gt; \n#&gt; , , 4\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    4\n#&gt; \n#&gt; , , 5\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    5\n\nx2\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    2    3    4    5\n\nx3\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    1\n#&gt; [2,]    2\n#&gt; [3,]    3\n#&gt; [4,]    4\n#&gt; [5,]    5\n\n\nAnswer: They have a 3-dimensional structure, arranged in different ways, along the z, x, and y axis.\nAR Solutions: These are all “one dimensional”. If you imagine a 3d cube, x1 is in the x-dimension, x2 is in the y-dimension, and x3 is in the z-dimension. In contrast to 1:5, x1, x2 and x3 have a dim attribute.\n\n\nAn early draft used this code to illustrate structure():\n\n\nstructure(1:5, comment = \"my attribute\")\n\n#&gt; [1] 1 2 3 4 5\n\n\nBut when you print that object you don't see the comment attribute.\nWhy? Is the attribute missing, or is there something else special about\nit? (Hint: try using help.)\n\nfactor(\"green\", levels = c(\"red\", \"amber\", \"green\"))\n\n#&gt; [1] green\n#&gt; Levels: red amber green\n\ndput(factor(\"green\", levels = c(\"red\", \"amber\", \"green\")))\n\n#&gt; structure(3L, levels = c(\"red\", \"amber\", \"green\"), class = \"factor\")\n\n\nAnswer: print doesn’t display the attributes for arbitrary structures, only defined classes, like factors (for example, above).\nAR Solutions: The documentation states (see ?comment):\n\nContrary to other attributes, the comment is not printed (by print or print.default).\n\nAlso, from ?attributes:\n\nNote that some attributes (namely class, comment, dim, dimnames, names, row.names and tsp) are treated specially and have restrictions on the values which can be set.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-6",
    "href": "analysis/advanced-r-1.html#exercises-6",
    "title": "Advanced R (Foundations)",
    "section": "3.4.5 Exercises",
    "text": "3.4.5 Exercises\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\n\na &lt;- letters[1:3]\na_table &lt;- table(a, sample(a))\na_table\n\n#&gt;    \n#&gt; a   a b c\n#&gt;   a 0 1 0\n#&gt;   b 0 0 1\n#&gt;   c 1 0 0\n\ntypeof(a_table)\n\n#&gt; [1] \"integer\"\n\nattributes(a_table)\n\n#&gt; $dim\n#&gt; [1] 3 3\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames$a\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; $dimnames[[2]]\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; \n#&gt; $class\n#&gt; [1] \"table\"\n\nb &lt;- letters[1:4]\nb_table &lt;- table(b, sample(b))\nb_table\n\n#&gt;    \n#&gt; b   a b c d\n#&gt;   a 0 0 0 1\n#&gt;   b 0 0 1 0\n#&gt;   c 1 0 0 0\n#&gt;   d 0 1 0 0\n\nattributes(b_table)\n\n#&gt; $dim\n#&gt; [1] 4 4\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames$b\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n#&gt; \n#&gt; $dimnames[[2]]\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n#&gt; \n#&gt; \n#&gt; $class\n#&gt; [1] \"table\"\n\n\nAnswer: an object of class “table”, an array of integer values, with type “integer”. Attributes listed above, the dimensionality is always n by n, where n is the number of variables tabulated.\nAR Solutions: table() returns a contingency table of its input variables. It is implemented as an integer vector with class table and dimensions (which makes it act like an array). Its attributes are dim (dimensions) and dimnames (one name for each input column). The dimensions correspond to the number of unique values (factor levels) in each input variable.\n\n\nWhat happens to a factor when you modify its levels?\n\n\nf1 &lt;- factor(letters)\nf1\n\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nlevels(f1) &lt;- rev(levels(f1))\nf1\n\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n\nAnswer: the factor will remain the same, but the attributes will change. the factor and its levels are reversed.\nAR Solutions: The underlying integer values stay the same, but the levels are changed, making it look like the data has changed.\n\nf1 &lt;- factor(letters)\nf1\n\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nas.integer(f1)\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#&gt; [26] 26\n\nlevels(f1) &lt;- rev(levels(f1))\nf1\n\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n\n\n\nWhat does this code do? How do f2 and f3 differ from f1?\n\n\nf2 &lt;- rev(factor(letters))\nf2\n\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nf3 &lt;- factor(letters, levels = rev(letters))\nf3\n\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n\nAnswer: both create a reversed list of letters. f3 also has reversed levels but f2 does not. (correct!)\nAR Solutions: For f2 and f3 either the order of the factor elements or its levels are being reversed. For f1 both transformations are occurring.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-7",
    "href": "analysis/advanced-r-1.html#exercises-7",
    "title": "Advanced R (Foundations)",
    "section": "3.5.4 Exercises",
    "text": "3.5.4 Exercises\n\nList all the ways that a list differs from an atomic vector.\n\nAnswers:\n\nEach element can be a different type\nEach element is a reference to an object\nList size can be smaller since elements are references\nLists can contain other lists\n\nAR Solutions: To summarise:\n\nAtomic vectors are always homogeneous (all elements must be of the same type). Lists may be heterogeneous (the elements can be of different types) as described in the introduction of the vectors chapter.\nAtomic vectors point to one address in memory, while lists contain a separate reference for each element. (This was described in the list sections of the vectors and the names and values chapters.)\nSubsetting with out-of-bounds and NA values leads to different output. For example, [ returns NA for atomics and NULL for lists. (This is described in more detail within the subsetting chapter.)\n\n\n\nWhy do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?\n\n\nis.vector(list(1:4))\n\n#&gt; [1] TRUE\n\ndput(as.vector(list(1:4)))\n\n#&gt; list(1:4)\n\n\nAnswer: a list is considered a vector by as.vector().\nAR Solutions: A list is already a vector, though not an atomic one!\n\n\nCompare and contrast c() and unlist() when combining a date and date-time into a single vector.\n\n\nd &lt;- list(date = as.Date(\"2022-06-25\"), datetime = as.POSIXct(\"2022-06-25 09:59:40 CDT\"))\ndput(d)\n\n#&gt; list(date = structure(19168, class = \"Date\"), datetime = structure(1656169180, class = c(\"POSIXct\", \n#&gt; \"POSIXt\"), tzone = \"\"))\n\ndput(c(d))\n\n#&gt; list(date = structure(19168, class = \"Date\"), datetime = structure(1656169180, class = c(\"POSIXct\", \n#&gt; \"POSIXt\"), tzone = \"\"))\n\ndput(unlist(d))\n\n#&gt; c(date = 19168, datetime = 1656169180)\n\n\nAnswer: c() preserves the list structure. unlist() converts both to double.\nAR Solutions: Date and date-time objects are both built upon doubles. While dates store the number of days since the reference date 1970-01-01 (also known as “the Epoch”) in days, date-time-objects (POSIXct) store the time difference to this date in seconds.\n\ndate &lt;- as.Date(\"1970-01-02\")\ndttm_ct &lt;- as.POSIXct(\"1970-01-01 01:00\", tz = \"UTC\")\n# Internal representations\nunclass(date)\n\n#&gt; [1] 1\n\nunclass(dttm_ct)\n\n#&gt; [1] 3600\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\n\n\nAs the c() generic only dispatches on its first argument, combining date and date-time objects via c() could lead to surprising results in older R versions (pre R 4.0.0):\n\n# Output in R version 3.6.2\nc(date, dttm_ct) # equal to c.Date(date, dttm_ct)\n#&gt; [1] \"1970-01-02\" \"1979-11-10\"\nc(dttm_ct, date) # equal to c.POSIXct(date, dttm_ct)\n#&gt; [1] \"1970-01-01 02:00:00 CET\" \"1970-01-01 01:00:01 CET\"\n\nIn the first statement above c.Date() is executed, which incorrectly treats the underlying double of dttm_ct (3600) as days instead of seconds. Conversely, when c.POSIXct() is called on a date, one day is counted as one second only.\nWe can highlight these mechanics by the following code:\n\n# Output in R version 3.6.2\nunclass(c(date, dttm_ct)) # internal representation\n#&gt; [1] 1 3600\ndate + 3599\n#&gt; \"1979-11-10\"\n\nAs of R 4.0.0 these issues have been resolved and both methods now convert their input first into POSIXct and Date, respectively.\n\nc(dttm_ct, date)\n\n#&gt; [1] \"1970-01-01 01:00:00 UTC\" \"1970-01-02 00:00:00 UTC\"\n\nunclass(c(dttm_ct, date))\n\n#&gt; [1]  3600 86400\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\n\nc(date, dttm_ct)\n\n#&gt; [1] \"1970-01-02\" \"1970-01-01\"\n\nunclass(c(date, dttm_ct))\n\n#&gt; [1] 1 0\n\n\nHowever, as c() strips the time zone (and other attributes) of POSIXct objects, some caution is still recommended.\n\n(dttm_ct &lt;- as.POSIXct(\"1970-01-01 01:00\", tz = \"HST\"))\n\n#&gt; [1] \"1970-01-01 01:00:00 HST\"\n\nattributes(c(dttm_ct))\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"HST\"\n\n\nA package that deals with these kinds of problems in more depth and provides a structural solution for them is the vctrs package which is also used throughout the tidyverse.\nLet’s look at unlist(), which operates on list input.\n\n# Attributes are stripped\nunlist(list(date, dttm_ct))\n\n#&gt; [1]     1 39600\n\n\nWe see again that dates and date-times are internally stored as doubles. Unfortunately, this is all we are left with, when unlist strips the attributes of the list.\nTo summarise: c() coerces types and strips time zones. Errors may have occurred in older R versions because of inappropriate method dispatch/immature methods. unlist() strips attributes.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-8",
    "href": "analysis/advanced-r-1.html#exercises-8",
    "title": "Advanced R (Foundations)",
    "section": "3.6.8 Exercises",
    "text": "3.6.8 Exercises\n\nCan you have a data frame with zero rows? What about zero columns?\n\n\n# from data.frame() examples:\ndf &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9)\n\ndf\n\n#&gt;   x y z\n#&gt; 1 1 4 7\n#&gt; 2 2 5 8\n#&gt; 3 3 6 9\n\ndf[, FALSE]\n\n#&gt; data frame with 0 columns and 3 rows\n\ndf[FALSE, ]\n\n#&gt; [1] x y z\n#&gt; &lt;0 rows&gt; (or 0-length row.names)\n\ndf[FALSE, FALSE]\n\n#&gt; data frame with 0 columns and 0 rows\n\n\nAnswer: yes!\nAR Solutions: Yes, you can create these data frames easily; either during creation or via subsetting. Even both dimensions can be zero.\n\n\nWhat happens if you attempt to set rownames that are not unique?\n\n\nrownames(df)\n\n#&gt; [1] \"1\" \"2\" \"3\"\n\ntry(rownames(df) &lt;- c(\"a\", \"a\", \"b\"))\n\n#&gt; Warning: non-unique value when setting 'row.names': 'a'\n\n\n#&gt; Error in `.rowNamesDF&lt;-`(x, value = value) : \n#&gt;   duplicate 'row.names' are not allowed\n\n\nAnswer: error, duplicates not allowed.\nAR Solutions: Matrices can have duplicated row names, so this does not cause problems.\nData frames, however, require unique rownames and you get different results depending on how you attempt to set them. If you set them directly or via row.names(), you get an error. If you use subsetting, [ automatically deduplicates.\n\n\nIf df is a data frame, what can you say about t(df), and t(t(df))? Perform some experiments, making sure to try different column types.\n\n\nt(df)\n\n#&gt;   [,1] [,2] [,3]\n#&gt; x    1    2    3\n#&gt; y    4    5    6\n#&gt; z    7    8    9\n\nt(t(df))\n\n#&gt;      x y z\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\n#&gt; [3,] 3 6 9\n\ndf2 &lt;- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"), z = 4L:6L, stringsAsFactors = FALSE)\ndf2\n\n#&gt;   x y z\n#&gt; 1 1 a 4\n#&gt; 2 2 b 5\n#&gt; 3 3 c 6\n\nt(df2)\n\n#&gt;   [,1] [,2] [,3]\n#&gt; x \"1\"  \"2\"  \"3\" \n#&gt; y \"a\"  \"b\"  \"c\" \n#&gt; z \"4\"  \"5\"  \"6\"\n\nt(t(df2))\n\n#&gt;      x   y   z  \n#&gt; [1,] \"1\" \"a\" \"4\"\n#&gt; [2,] \"2\" \"b\" \"5\"\n#&gt; [3,] \"3\" \"c\" \"6\"\n\n\nAnswer: t() coerces the vector types, so t(t(df)) is the same as df only when all columns are the same type.\nAR Solutions: Both of t(df) and t(t(df)) will return matrices:\n\ndf &lt;- data.frame(x = 1:3, y = letters[1:3])\nis.matrix(df)\n\n#&gt; [1] FALSE\n\nis.matrix(t(df))\n\n#&gt; [1] TRUE\n\nis.matrix(t(t(df)))\n\n#&gt; [1] TRUE\n\n\nThe dimensions will respect the typical transposition rules:\n\ndim(df)\n\n#&gt; [1] 3 2\n\ndim(t(df))\n\n#&gt; [1] 2 3\n\ndim(t(t(df)))\n\n#&gt; [1] 3 2\n\n\nBecause the output is a matrix, every column is coerced to the same type. (It is implemented within t.data.frame() via as.matrix() which is described below).\n\ndf\n\n#&gt;   x y\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\nt(df)\n\n#&gt;   [,1] [,2] [,3]\n#&gt; x \"1\"  \"2\"  \"3\" \n#&gt; y \"a\"  \"b\"  \"c\"\n\n\n\n\nWhat does as.matrix() do when applied to a data frame with columns of different types? How does it differ from data.matrix()?\n\n\nas.matrix(df)\n\n#&gt;      x   y  \n#&gt; [1,] \"1\" \"a\"\n#&gt; [2,] \"2\" \"b\"\n#&gt; [3,] \"3\" \"c\"\n\nas.matrix(df2)\n\n#&gt;      x   y   z  \n#&gt; [1,] \"1\" \"a\" \"4\"\n#&gt; [2,] \"2\" \"b\" \"5\"\n#&gt; [3,] \"3\" \"c\" \"6\"\n\ndata.matrix(df2)\n\n#&gt;      x y z\n#&gt; [1,] 1 1 4\n#&gt; [2,] 2 2 5\n#&gt; [3,] 3 3 6\n\nas.data.frame(data.matrix(df2))\n\n#&gt;   x y z\n#&gt; 1 1 1 4\n#&gt; 2 2 2 5\n#&gt; 3 3 3 6\n\nas.data.frame(data.matrix(data.frame(x = 1:3, y = c(0, 0.5, 1), z = 4:6)))\n\n#&gt;   x   y z\n#&gt; 1 1 0.0 4\n#&gt; 2 2 0.5 5\n#&gt; 3 3 1.0 6\n\n\nAnswer: as.matrix() coerces all elements to the same type. data.matrix() coerces elements to either integer (when possible) or double (when not).\nAR Solutions: The type of the result of as.matrix depends on the types of the input columns (see ?as.matrix):\n\nThe method for data frames will return a character matrix if there is only atomic columns and any non-(numeric/logical/complex) column, applying as.vector to factors and format to other non-character columns. Otherwise the usual coercion hierarchy (logical &lt; integer &lt; double &lt; complex) will be used, e.g. all-logical data frames will be coerced to a logical matrix, mixed logical-integer will give an integer matrix, etc.\n\nOn the other hand, data.matrix will always return a numeric matrix (see ?data.matrix()).\n\nReturn the matrix obtained by converting all the variables in a data frame to numeric mode and then binding them together as the columns of a matrix. Factors and ordered factors are replaced by their internal codes. […] Character columns are first converted to factors and then to integers.\n\nWe can illustrate and compare the mechanics of these functions using a concrete example. as.matrix() makes it possible to retrieve most of the original information from the data frame but leaves us with characters. To retrieve all information from data.matrix()’s output, we would need a lookup table for each column.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-9",
    "href": "analysis/advanced-r-1.html#exercises-9",
    "title": "Advanced R (Foundations)",
    "section": "4.2.6 Exercises",
    "text": "4.2.6 Exercises\n\nFix each of the following common data frame subsetting errors:\n\n\n# mtcars[mtcars$cyl = 4, ]\nmtcars[mtcars$cyl == 4, ]\n\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# use `==`              (instead of `=`)\n\n# mtcars[-1:4, ]\nmtcars[-(1:4), ]\n\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#&gt; AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#&gt; Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#&gt; Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#&gt; Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#&gt; Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#&gt; Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#&gt; Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# use `-(1:4)`          (instead of `-1:4`)\n\n# mtcars[mtcars$cyl &lt;= 5]\nmtcars[mtcars$cyl &lt;= 5, ]\n\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# `,` is missing\n\n# mtcars[mtcars$cyl == 4 | 6, ]\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\n\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Valiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# use `mtcars$cyl == 6` (instead of `6`)\n#  or `%in% c(4, 6)`    (instead of `== 4 | 6`)\n\nAnswer: fixed!\nAR solutions: see the comments below the fixed code.\n\n\nWhy does the following code yield five missing values? (Hint: why is it different from x[NA_real_]?)\n\n\nx &lt;- 1:5\nx[NA]\n\n#&gt; [1] NA NA NA NA NA\n\nx[NA_real_]\n\n#&gt; [1] NA\n\nx[TRUE]\n\n#&gt; [1] 1 2 3 4 5\n\n\nAnswer: NA is a logical constant of length 1.\nAR Solutions: In contrast to NA_real, NA has logical type and logical vectors are recycled to the same length as the vector being subset, i.e. x[NA] is recycled to x[c(NA, NA, NA, NA, NA)].\n\n\nWhat does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?\n\n\nx &lt;- outer(1:5, 1:5, FUN = \"*\")\nx\n\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    2    3    4    5\n#&gt; [2,]    2    4    6    8   10\n#&gt; [3,]    3    6    9   12   15\n#&gt; [4,]    4    8   12   16   20\n#&gt; [5,]    5   10   15   20   25\n\nx[upper.tri(x)]\n\n#&gt;  [1]  2  3  6  4  8 12  5 10 15 20\n\n\nAnswer: upper.tri() returns a matrix of logicals, which can be used to subset the upper triangle. This is subsetting by matrix, which is new.\nAR Solutions: upper.tri(x) returns a logical matrix, which contains TRUE values above the diagonal and FALSE values everywhere else. In upper.tri() the positions for TRUE and FALSE values are determined by comparing x’s row and column indices via .row(dim(x)) &lt; .col(dim(x)).\nWhen subsetting with logical matrices, all elements that correspond to TRUE will be selected. Matrices extend vectors with a dimension attribute, so the vector forms of subsetting can be used (including logical subsetting). We should take care, that the dimensions of the subsetting matrix match the object of interest — otherwise unintended selections due to vector recycling may occur. Please also note, that this form of subsetting returns a vector instead of a matrix, as the subsetting alters the dimensions of the object.\n\n\nWhy does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?\n\n\ntry(mtcars[1:20])\n\n#&gt; Error in `[.data.frame`(mtcars, 1:20) : undefined columns selected\n\nmtcars[1:20, ]\n\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n\n\nAnswer: mtcars[1:20] selects the first 20 columns, but there are only 11. mtcars[1:20, ] selects the first 20 rows of 32.\nAR Solutions: When subsetting a data frame with a single vector, it behaves the same way as subsetting a list of columns. So, mtcars[1:20] would return a data frame containing the first 20 columns of the dataset. However, as mtcars has only 11 columns, the index will be out of bounds and an error is thrown. mtcars[1:20, ] is subsetted with two vectors, so 2d subsetting kicks in, and the first index refers to rows.\n\n\nImplement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).\n\n\nm &lt;- matrix(ncol = 3, byrow = TRUE, c(\n  1, 4, 7,\n  2, 5, 8,\n  3, 6, 9\n))\nm\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    4    7\n#&gt; [2,]    2    5    8\n#&gt; [3,]    3    6    9\n\ndiag(m)\n\n#&gt; [1] 1 5 9\n\nmy_diag &lt;- function(x) {\n  diag_element &lt;- function(n, x) {\n    x[n, n]\n  }\n  vapply(seq_len(nrow(m)), diag_element, 1, x)\n}\nmy_diag(m)\n\n#&gt; [1] 1 5 9\n\n\nAnswer: code above.\nAR Solutions: The elements in the diagonal of a matrix have the same row- and column indices. This characteristic can be used to create a suitable numeric matrix used for subsetting.\n\ndiag2 &lt;- function(x) {\n  n &lt;- min(nrow(x), ncol(x))\n  idx &lt;- cbind(seq_len(n), seq_len(n))\n  x[idx]\n}\n# Let's check if it works\n(x &lt;- matrix(1:30, 5))\n\n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]\n#&gt; [1,]    1    6   11   16   21   26\n#&gt; [2,]    2    7   12   17   22   27\n#&gt; [3,]    3    8   13   18   23   28\n#&gt; [4,]    4    9   14   19   24   29\n#&gt; [5,]    5   10   15   20   25   30\n\ndiag(x)\n\n#&gt; [1]  1  7 13 19 25\n\ndiag2(x)\n\n#&gt; [1]  1  7 13 19 25\n\n\n\n\nWhat does df[is.na(df)] &lt;- 0 do? How does it work?\n\nAnswer: sets the NA values in df to 0, by first selecting NA values then assigning 0.\n\ndf &lt;- data.frame(x = c(1, 2, NA), y = c(4, NA, 6), z = c(NA, 8, 9))\ndf\n\n#&gt;    x  y  z\n#&gt; 1  1  4 NA\n#&gt; 2  2 NA  8\n#&gt; 3 NA  6  9\n\ndf[is.na(df)] &lt;- 0\ndf\n\n#&gt;   x y z\n#&gt; 1 1 4 0\n#&gt; 2 2 0 8\n#&gt; 3 0 6 9\n\n\nCorrect!\nAR Solutions: This expression replaces the NAs in df with 0. Here is.na(df) returns a logical matrix that encodes the position of the missing values in df. Subsetting and assignment are then combined to replace only the missing values.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-10",
    "href": "analysis/advanced-r-1.html#exercises-10",
    "title": "Advanced R (Foundations)",
    "section": "4.3.5 Exercises",
    "text": "4.3.5 Exercises\n\nBrainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.\n\n\nmtcars$cyl[3]\n\n#&gt; [1] 4\n\nmtcars$cyl[[3]]\n\n#&gt; [1] 4\n\nmtcars[[\"cyl\"]][[3]]\n\n#&gt; [1] 4\n\nmtcars[3, 2]\n\n#&gt; [1] 4\n\nmtcars[[3, 2]]\n\n#&gt; [1] 4\n\nmtcars[[\"Datsun 710\", \"cyl\"]]\n\n#&gt; [1] 4\n\nmtcars[-c(1:2, 4:32), -c(1, 3:11)]\n\n#&gt; [1] 4\n\n\nAnswer: code above (some variations omitted). There are many more.\nAR Solutions: Base R already provides an abundance of possibilities:\n\n# Select column first\nmtcars$cyl[[3]]\n\n#&gt; [1] 4\n\nmtcars[, \"cyl\"][[3]]\n\n#&gt; [1] 4\n\nmtcars[[\"cyl\"]][[3]]\n\n#&gt; [1] 4\n\nwith(mtcars, cyl[[3]])\n\n#&gt; [1] 4\n\n# Select row first\nmtcars[3, ]$cyl\n\n#&gt; [1] 4\n\nmtcars[3, \"cyl\"]\n\n#&gt; [1] 4\n\nmtcars[3, ][, \"cyl\"]\n\n#&gt; [1] 4\n\nmtcars[3, ][[\"cyl\"]]\n\n#&gt; [1] 4\n\n# Select simultaneously\nmtcars[3, 2]\n\n#&gt; [1] 4\n\nmtcars[[c(2, 3)]]\n\n#&gt; [1] 4\n\n\n\n\nGiven a linear model, e.g., mod &lt;- lm(mpg ~ wt, data = mtcars), extract the residual degrees of freedom. Then extract the R squared from the model summary (summary(mod))\n\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\nmod$df.residual\n\n#&gt; [1] 30\n\nmod_sum &lt;- summary(mod)\nmod_sum$r.squared\n\n#&gt; [1] 0.7528328\n\nmod_sum\n\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ wt, data = mtcars)\n#&gt; \n#&gt; Residuals:\n#&gt;     Min      1Q  Median      3Q     Max \n#&gt; -4.5432 -2.3647 -0.1252  1.4096  6.8727 \n#&gt; \n#&gt; Coefficients:\n#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept)  37.2851     1.8776  19.858  &lt; 2e-16 ***\n#&gt; wt           -5.3445     0.5591  -9.559 1.29e-10 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 3.046 on 30 degrees of freedom\n#&gt; Multiple R-squared:  0.7528, Adjusted R-squared:  0.7446 \n#&gt; F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10\n\n\nAnswer: code above.\nAR Solutions: mod is of type list, which opens up several possibilities. We use $ or [[ to extract a single element:\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\n\nmod$df.residual\n\n#&gt; [1] 30\n\nmod[[\"df.residual\"]]\n\n#&gt; [1] 30\n\n\nThe same also applies to summary(mod), so we could use, e.g.:\n\nsummary(mod)$r.squared\n\n#&gt; [1] 0.7528328\n\n\n(Tip: The broom package provides a very useful approach to work with models in a tidy way.)",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-11",
    "href": "analysis/advanced-r-1.html#exercises-11",
    "title": "Advanced R (Foundations)",
    "section": "4.5.9 Exercises",
    "text": "4.5.9 Exercises\n\nHow would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?\n\n\ndf &lt;- data.frame(x = 1:5, y = 5:1, z = letters[1:5], row.names = 1:5)\n\ndf[, sample(ncol(df))]\n\n#&gt;   z y x\n#&gt; 1 a 5 1\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\n#&gt; 4 d 2 4\n#&gt; 5 e 1 5\n\ndf[sample(nrow(df)), sample(ncol(df))]\n\n#&gt;   y x z\n#&gt; 5 1 5 e\n#&gt; 3 3 3 c\n#&gt; 4 2 4 d\n#&gt; 1 5 1 a\n#&gt; 2 4 2 b\n\n\nAnswer: using sample(). Yes!\nAR Solutions: This can be achieved by combining [ and sample():\n\n# Permute columns\nmtcars[sample(ncol(mtcars))]\n\n# Permute columns and rows in one step\nmtcars[sample(nrow(mtcars)), sample(ncol(mtcars))]\n\n\n\nHow would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?\n\n\nsample_rows &lt;- function(df, m, contiguous = FALSE) {\n  if (m &gt; nrow(df)) {\n    stop(\"sample size '\", m, \"' is larger than the number of rows, '\", nrow(df), \"'\")\n  }\n  if (contiguous) {\n    first_row &lt;- sample(nrow(df) - m + 1, 1)\n    last_row &lt;- first_row + m - 1\n    return(df[first_row:last_row, ])\n  }\n  df[sample(nrow(df), m), ]\n}\n\nsample_rows(df, 3)\n\n#&gt;   x y z\n#&gt; 2 2 4 b\n#&gt; 4 4 2 d\n#&gt; 1 1 5 a\n\nsample_rows(df, 3, contiguous = TRUE)\n\n#&gt;   x y z\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n#&gt; 4 4 2 d\n\ntry(sample_rows(df, 6))\n\n#&gt; Error in sample_rows(df, 6) : \n#&gt;   sample size '6' is larger than the number of rows, '5'\n\n\nAnswer: code above.\nAR Solutions: Selecting m random rows from a data frame can be achieved through subsetting.\n\nm &lt;- 10\nmtcars[sample(nrow(mtcars), m), ]\n\nHolding successive lines together as a blocked sample requires only a certain amount of caution in order to obtain the correct start and end index.\n\nstart &lt;- sample(nrow(mtcars) - m + 1, 1)\nend &lt;- start + m - 1\nmtcars[start:end, , drop = FALSE]\n\n\n\nHow could you put the columns in a data frame in alphabetical order?\n\n\nmtcars[sort(colnames(mtcars))]\n\n#&gt;                     am carb cyl  disp drat gear  hp  mpg  qsec vs    wt\n#&gt; Mazda RX4            1    4   6 160.0 3.90    4 110 21.0 16.46  0 2.620\n#&gt; Mazda RX4 Wag        1    4   6 160.0 3.90    4 110 21.0 17.02  0 2.875\n#&gt; Datsun 710           1    1   4 108.0 3.85    4  93 22.8 18.61  1 2.320\n#&gt; Hornet 4 Drive       0    1   6 258.0 3.08    3 110 21.4 19.44  1 3.215\n#&gt; Hornet Sportabout    0    2   8 360.0 3.15    3 175 18.7 17.02  0 3.440\n#&gt; Valiant              0    1   6 225.0 2.76    3 105 18.1 20.22  1 3.460\n#&gt; Duster 360           0    4   8 360.0 3.21    3 245 14.3 15.84  0 3.570\n#&gt; Merc 240D            0    2   4 146.7 3.69    4  62 24.4 20.00  1 3.190\n#&gt; Merc 230             0    2   4 140.8 3.92    4  95 22.8 22.90  1 3.150\n#&gt; Merc 280             0    4   6 167.6 3.92    4 123 19.2 18.30  1 3.440\n#&gt; Merc 280C            0    4   6 167.6 3.92    4 123 17.8 18.90  1 3.440\n#&gt; Merc 450SE           0    3   8 275.8 3.07    3 180 16.4 17.40  0 4.070\n#&gt; Merc 450SL           0    3   8 275.8 3.07    3 180 17.3 17.60  0 3.730\n#&gt; Merc 450SLC          0    3   8 275.8 3.07    3 180 15.2 18.00  0 3.780\n#&gt; Cadillac Fleetwood   0    4   8 472.0 2.93    3 205 10.4 17.98  0 5.250\n#&gt; Lincoln Continental  0    4   8 460.0 3.00    3 215 10.4 17.82  0 5.424\n#&gt; Chrysler Imperial    0    4   8 440.0 3.23    3 230 14.7 17.42  0 5.345\n#&gt; Fiat 128             1    1   4  78.7 4.08    4  66 32.4 19.47  1 2.200\n#&gt; Honda Civic          1    2   4  75.7 4.93    4  52 30.4 18.52  1 1.615\n#&gt; Toyota Corolla       1    1   4  71.1 4.22    4  65 33.9 19.90  1 1.835\n#&gt; Toyota Corona        0    1   4 120.1 3.70    3  97 21.5 20.01  1 2.465\n#&gt; Dodge Challenger     0    2   8 318.0 2.76    3 150 15.5 16.87  0 3.520\n#&gt; AMC Javelin          0    2   8 304.0 3.15    3 150 15.2 17.30  0 3.435\n#&gt; Camaro Z28           0    4   8 350.0 3.73    3 245 13.3 15.41  0 3.840\n#&gt; Pontiac Firebird     0    2   8 400.0 3.08    3 175 19.2 17.05  0 3.845\n#&gt; Fiat X1-9            1    1   4  79.0 4.08    4  66 27.3 18.90  1 1.935\n#&gt; Porsche 914-2        1    2   4 120.3 4.43    5  91 26.0 16.70  0 2.140\n#&gt; Lotus Europa         1    2   4  95.1 3.77    5 113 30.4 16.90  1 1.513\n#&gt; Ford Pantera L       1    4   8 351.0 4.22    5 264 15.8 14.50  0 3.170\n#&gt; Ferrari Dino         1    6   6 145.0 3.62    5 175 19.7 15.50  0 2.770\n#&gt; Maserati Bora        1    8   8 301.0 3.54    5 335 15.0 14.60  0 3.570\n#&gt; Volvo 142E           1    2   4 121.0 4.11    4 109 21.4 18.60  1 2.780\n\n\nAnswer: using sort(colnames).\nAR Solutions: We combine [ with order() or sort():\n\nmtcars[order(names(mtcars))]\nmtcars[sort(names(mtcars))]",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-12",
    "href": "analysis/advanced-r-1.html#exercises-12",
    "title": "Advanced R (Foundations)",
    "section": "5.2.4 Exercises",
    "text": "5.2.4 Exercises\n\nWhat type of vector does each of the following calls to ifelse() return? Read the documentation and write down the rules in your own words.\n\n\nifelse(TRUE, 1, \"no\")\n\n#&gt; [1] 1\n\ntypeof(ifelse(TRUE, 1, \"no\")) # double\n\n#&gt; [1] \"double\"\n\nifelse(FALSE, 1, \"no\")\n\n#&gt; [1] \"no\"\n\ntypeof(ifelse(FALSE, 1, \"no\")) # character\n\n#&gt; [1] \"character\"\n\nifelse(NA, 1, \"no\")\n\n#&gt; [1] NA\n\ntypeof(ifelse(NA, 1, \"no\")) # logical\n\n#&gt; [1] \"logical\"\n\nifelse(NULL, 1, \"no\")\n\n#&gt; logical(0)\n\n\nAnswer:\n\nif test is true, return a vector of the same length as test (1) populated with “yes” - here 1 is a double, 1L would be integer\nif test is false, return a vector of the same length as test (1) populated with “no” - here “no” is a character\nif test is NA, return NA, and if test is NULL, return logical(0)\n\nAR Solutions: The arguments of ifelse() are named test, yes and no. In general, ifelse() returns the entry for yes when test is TRUE, the entry for no when test is FALSE and NA when test is NA. Therefore, the expressions above return vectors of type double (1), character (\"no\") and logical (NA).\nTo be a little more precise, we will cite the part of the documentation on the return value of ifelse():\n\nA vector of the same length and attributes (including dimensions and “class”) as test and data values from the values of yes or no. The mode of the answer will be coerced from logical to accommodate first any values taken from yes and then any values taken from no.\n\nThis is surprising because it uses the type of test. In practice this means, that test is first converted to logical and if the result is neither TRUE nor FALSE, simply as.logical(test) is returned.\n\n\nWhy does the following code work?\n\n\nx &lt;- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n\n#&gt; [1] \"not empty\"\n\nx &lt;- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n\n#&gt; [1] \"empty\"\n\n\nAnswer: in the first example, length(x) is nonzero, which evaluates to TRUE. In the second example, numeric() returns a vector of length 0 (the default), length(x) is zero, which evaluates to FALSE.\nAR Solutions: if() expects a logical condition, but also accepts a numeric vector where 0 is treated as FALSE and all other numbers are treated as TRUE. Numerical missing values (including NaN) lead to an error in the same way that a logical missing, NA, does.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-13",
    "href": "analysis/advanced-r-1.html#exercises-13",
    "title": "Advanced R (Foundations)",
    "section": "5.3.3 Exercises",
    "text": "5.3.3 Exercises\n\nWhy does this code succeed without errors or warnings?\n\n\nx &lt;- numeric() # x is numeric(0)\nout &lt;- vector(\"list\", length(x)) # out is list(0)\nfor (i in 1:length(x)) { # nolint: seq_linter. i is 1, then 0.\n  out[i] &lt;- x[i]^2 # when i = 1 x[1] is NA, sets out[1] to NA. when i = 0 nothing happens\n}\nout\n\n#&gt; [[1]]\n#&gt; [1] NA\n\n\nAnswer: in addition to notes above, out[0] and x[0] return a zero-length vector.\nAR Solutions: This loop is a delicate issue, and we have to consider a few points to explain why it is evaluated without raising any errors or warnings.\nThe beginning of this code smell is the statement 1:length(x) which creates the index of the for loop. As x has length 0 1:length(x) counts down from 1 to 0. This issue is typically avoided via usage of seq_along(x) or similar helpers which would just generate integer(0) in this case.\nAs we use [&lt;- and [ for indexing 0-length vectors at their first and zeroth position, we need to be aware of their subsetting behaviour for out-of-bounds and zero indices.\nDuring the first iteration x[1] will generate an NA (out-of-bounds indexing for atomics). The resulting NA (from squaring) will be assigned to the empty length-1 list out[1] (out-of-bounds indexing for lists).\nIn the next iteration, x[0] will return numeric(0) (zero indexing for atomics). Again, squaring doesn’t change the value and numeric(0) is assigned to out[0] (zero indexing for lists). Assigning a 0-length vector to a 0-length subset works but doesn’t change the object.\nOverall, the code works, because each step includes valid R operations (even though the result may not be what the user intended).\n\n\nWhen the following code is evaluated, what can you say about the vector being iterated?\n\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n\n#&gt; [1] 1 2 3 2 4 6\n\n\nAnswer: x iterates from 1 to 3, and is not affected by changes to xs during the loop, while xs is updated.\nAR Solution: In this loop x takes on the values of the initial xs (1, 2 and 3), indicating that it is evaluated just once in the beginning of the loop, not after each iteration. (Otherwise, we would run into an infinite loop.)\n\n\nWhat does the following code tell you about when the index is updated?\n\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i)\n}\n\n#&gt; [1] 2\n#&gt; [1] 4\n#&gt; [1] 6\n\n\nAnswer: the index is updated at the beginning of each loop.\nAR Solutions: In a for loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn’t affect the following iterations. (Again, we would otherwise run into an infinite loop.)",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#quiz-1",
    "href": "analysis/advanced-r-1.html#quiz-1",
    "title": "Advanced R (Foundations)",
    "section": "6 Quiz",
    "text": "6 Quiz\nAnswer the following questions to see if you can safely skip this chapter.\n\nWhat are the three components of a function? a: arguments, code, return value [body, arguments, environment]\nWhat does the following code return? a: 11 [correct!]\n\n\nx &lt;- 10\nf1 &lt;- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()\n\n#&gt; [1] 11\n\n\n\nHow would you usually write this code? a: 1 + 2 * 3 [correct! … 1 + (2 * 3)]\n\n\n`+`(1, `*`(2, 3))\n\n\nHow could you make this call easier to read? mean(c(1:10, NA), na.rm = TRUE) [correct!]\n\n\nmean(, TRUE, x = c(1:10, NA))\n\n\nDoes the following code throw an error when executed? Why or why not? a: no, due to lazy evaluation, the stop() is never run [correct! … second argument is never used]\n\n\nf2 &lt;- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))\n\n#&gt; [1] 100\n\n\n\nWhat is an infix function? How do you write it? What’s a replacement function? How do you write it? a: function(x) x. ??? [see 6.8.3 and 6.8.4]\nHow do you ensure that cleanup action occurs regardless of how a function exits? a: ??? [on.exit()]",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-14",
    "href": "analysis/advanced-r-1.html#exercises-14",
    "title": "Advanced R (Foundations)",
    "section": "6.2.5 Exercises",
    "text": "6.2.5 Exercises\n\nGiven a name, like \"mean\", match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R?\n\nAnswer: a function is an object and could have multiple names pointing to it.\nAR Solutions: In R there is no one-to-one mapping between functions and names. A name always points to a single object, but an object may have zero, one or many names.\n\n\nIt’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?\n\n\nfunction(x) 3()\n\n#&gt; function(x) 3()\n\n(function(x) 3)()\n\n#&gt; [1] 3\n\n\nAnswer: The second is correct, as the first is the form of defining a function.\nAR Solutions: The second approach is correct.\nThe anonymous function function(x) 3 is surrounded by a pair of parentheses before it is called by (). These extra parentheses separate the function call from the anonymous function’s body. Without them a function with the invalid body 3() is returned, which throws an error when we call it.\n\n\nA good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?\n\nAnswer: in rdev::build_analysis_site(), analysis_menu_item() is properly written as a named function, where get_component() could be written as an anonymous function, with dir_check_copy() and dir_check_delete() potentially either.\nAR Solutions: The use of anonymous functions allows concise and elegant code in certain situations. However, they miss a descriptive name and when re-reading the code, it can take a while to figure out what they do. That’s why it’s helpful to give long and complex functions a descriptive name. It may be worthwhile to take a look at your own projects or other people’s code to reflect on this part of your coding style.\n\n\nWhat function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?\n\nAnswer: is.function() and is.primitive().\nAR Solutions: Use is.function() to test if an object is a function. Consider using is.primitive() to test specifically for primitive functions.\n\n\nThis code makes a list of all functions in the base package.\n\n\nobjs &lt;- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\n\n#&gt; Warning in ls(\"package:base\", all = TRUE): partial argument match of 'all' to\n#&gt; 'all.names'\n\nfuns &lt;- Filter(is.function, objs)\n\nUse it to answer the following questions:\n\nWhich base function has the most arguments?\nHow many base functions have no arguments? What’s special about those functions?\nHow could you adapt the code to find all primitive functions?\n\n\nfun_args &lt;- data.frame(\n  name = names(funs),\n  args = unname(vapply(funs, function(x) length(formals(x)), 1L))\n)\nhead(fun_args[order(fun_args$args, decreasing = TRUE), ], 10)\n\n#&gt;                  name args\n#&gt; 1068             scan   22\n#&gt; 570    format.default   16\n#&gt; 1121           source   16\n#&gt; 583           formatC   15\n#&gt; 764           library   13\n#&gt; 821  merge.data.frame   13\n#&gt; 918         prettyNum   13\n#&gt; 1231          system2   11\n#&gt; 926     print.default   10\n#&gt; 1063             save   10\n\nfun_args[fun_args$args == 0, ]\n\n#&gt;                          name args\n#&gt; 1                           -    0\n#&gt; 4                           :    0\n#&gt; 5                          ::    0\n#&gt; 6                         :::    0\n#&gt; 7                           !    0\n#&gt; 10                         !=    0\n#&gt; 13                     ...elt    0\n#&gt; 14                  ...length    0\n#&gt; 15                   ...names    0\n#&gt; 20                         .C    0\n#&gt; 21               .cache_class    0\n#&gt; 22                      .Call    0\n#&gt; 23             .Call.graphics    0\n#&gt; 25                    .class2    0\n#&gt; 42                  .External    0\n#&gt; 43         .External.graphics    0\n#&gt; 44                 .External2    0\n#&gt; 45                 .First.sys    0\n#&gt; 48                   .Fortran    0\n#&gt; 56                  .Internal    0\n#&gt; 57       .isMethodsDispatchOn    0\n#&gt; 68         .NotYetImplemented    0\n#&gt; 70         .OptRequireMethods    0\n#&gt; 76                 .Primitive    0\n#&gt; 77                 .primTrace    0\n#&gt; 78               .primUntrace    0\n#&gt; 89          .standard_regexps    0\n#&gt; 90                    .subset    0\n#&gt; 91                   .subset2    0\n#&gt; 94        .tryResumeInterrupt    0\n#&gt; 96                          (    0\n#&gt; 97                          [    0\n#&gt; 115                        [[    0\n#&gt; 122                      [[&lt;-    0\n#&gt; 127                       [&lt;-    0\n#&gt; 135                         {    0\n#&gt; 136                         @    0\n#&gt; 137                       @&lt;-    0\n#&gt; 138                         *    0\n#&gt; 140                         /    0\n#&gt; 142                         &    0\n#&gt; 145                        &&    0\n#&gt; 146                       %*%    0\n#&gt; 147                       %/%    0\n#&gt; 148                        %%    0\n#&gt; 152                         ^    0\n#&gt; 153                         +    0\n#&gt; 156                         &lt;    0\n#&gt; 157                        &lt;-    0\n#&gt; 158                       &lt;&lt;-    0\n#&gt; 159                        &lt;=    0\n#&gt; 160                         =    0\n#&gt; 161                        ==    0\n#&gt; 162                         &gt;    0\n#&gt; 163                        &gt;=    0\n#&gt; 164                         |    0\n#&gt; 167                        ||    0\n#&gt; 168                         ~    0\n#&gt; 169                         $    0\n#&gt; 172                       $&lt;-    0\n#&gt; 176                       abs    0\n#&gt; 177                      acos    0\n#&gt; 178                     acosh    0\n#&gt; 185                       all    0\n#&gt; 202                       any    0\n#&gt; 208                     anyNA    0\n#&gt; 217                       Arg    0\n#&gt; 224                   as.call    0\n#&gt; 225              as.character    0\n#&gt; 236                as.complex    0\n#&gt; 270                 as.double    0\n#&gt; 273            as.environment    0\n#&gt; 280                as.integer    0\n#&gt; 292                as.logical    0\n#&gt; 302                as.numeric    0\n#&gt; 321                    as.raw    0\n#&gt; 331                      asin    0\n#&gt; 332                     asinh    0\n#&gt; 338                      atan    0\n#&gt; 340                     atanh    0\n#&gt; 343                      attr    0\n#&gt; 345                    attr&lt;-    0\n#&gt; 346                attributes    0\n#&gt; 347              attributes&lt;-    0\n#&gt; 352                   baseenv    0\n#&gt; 371                     break    0\n#&gt; 372                   browser    0\n#&gt; 381                         c    0\n#&gt; 390                      call    0\n#&gt; 397                   ceiling    0\n#&gt; 410                     class    0\n#&gt; 411                   class&lt;-    0\n#&gt; 417       closeAllConnections    0\n#&gt; 434                      Conj    0\n#&gt; 435              contributors    0\n#&gt; 436                       cos    0\n#&gt; 437                      cosh    0\n#&gt; 438                     cospi    0\n#&gt; 440               Cstack_info    0\n#&gt; 441                    cummax    0\n#&gt; 442                    cummin    0\n#&gt; 443                   cumprod    0\n#&gt; 444                    cumsum    0\n#&gt; 453                      date    0\n#&gt; 457  default.stringsAsFactors    0\n#&gt; 474                   digamma    0\n#&gt; 475                       dim    0\n#&gt; 477                     dim&lt;-    0\n#&gt; 478                  dimnames    0\n#&gt; 480                dimnames&lt;-    0\n#&gt; 509                  emptyenv    0\n#&gt; 510                enc2native    0\n#&gt; 511                  enc2utf8    0\n#&gt; 519             environment&lt;-    0\n#&gt; 527                       exp    0\n#&gt; 529                     expm1    0\n#&gt; 530                expression    0\n#&gt; 531            extSoftVersion    0\n#&gt; 558                     floor    0\n#&gt; 561                       for    0\n#&gt; 563              forceAndCall    0\n#&gt; 586                  function    0\n#&gt; 587                     gamma    0\n#&gt; 589                   gc.time    0\n#&gt; 595         getAllConnections    0\n#&gt; 603             geterrmessage    0\n#&gt; 606             getLoadedDLLs    0\n#&gt; 616               getRversion    0\n#&gt; 618      getTaskCallbackNames    0\n#&gt; 621                     getwd    0\n#&gt; 624                 globalenv    0\n#&gt; 636                 iconvlist    0\n#&gt; 641                        if    0\n#&gt; 643                        Im    0\n#&gt; 649               interactive    0\n#&gt; 654                 invisible    0\n#&gt; 657                  is.array    0\n#&gt; 658                 is.atomic    0\n#&gt; 659                   is.call    0\n#&gt; 660              is.character    0\n#&gt; 661                is.complex    0\n#&gt; 663                 is.double    0\n#&gt; 665            is.environment    0\n#&gt; 666             is.expression    0\n#&gt; 668                 is.finite    0\n#&gt; 670               is.function    0\n#&gt; 671               is.infinite    0\n#&gt; 673                is.integer    0\n#&gt; 674               is.language    0\n#&gt; 675                   is.list    0\n#&gt; 677                is.logical    0\n#&gt; 678                 is.matrix    0\n#&gt; 679                     is.na    0\n#&gt; 687                   is.name    0\n#&gt; 688                    is.nan    0\n#&gt; 690                   is.null    0\n#&gt; 691                is.numeric    0\n#&gt; 696                 is.object    0\n#&gt; 699               is.pairlist    0\n#&gt; 702                      is.R    0\n#&gt; 703                    is.raw    0\n#&gt; 704              is.recursive    0\n#&gt; 705                 is.single    0\n#&gt; 706                 is.symbol    0\n#&gt; 722                      isS4    0\n#&gt; 736                 l10n_info    0\n#&gt; 737                La_library    0\n#&gt; 738                La_version    0\n#&gt; 745           lazyLoadDBfetch    0\n#&gt; 748                    length    0\n#&gt; 750                  length&lt;-    0\n#&gt; 759                  levels&lt;-    0\n#&gt; 762                    lgamma    0\n#&gt; 763            libcurlVersion    0\n#&gt; 767                   licence    0\n#&gt; 768                   license    0\n#&gt; 769                      list    0\n#&gt; 775          loadedNamespaces    0\n#&gt; 776      loadingNamespaceInfo    0\n#&gt; 781                       log    0\n#&gt; 782                     log10    0\n#&gt; 783                     log1p    0\n#&gt; 784                      log2    0\n#&gt; 807                       max    0\n#&gt; 819            memory.profile    0\n#&gt; 825                       min    0\n#&gt; 826                   missing    0\n#&gt; 827                       Mod    0\n#&gt; 838                     names    0\n#&gt; 840                   names&lt;-    0\n#&gt; 847                     nargs    0\n#&gt; 853                      next    0\n#&gt; 862                  nullfile    0\n#&gt; 867                    nzchar    0\n#&gt; 869                  oldClass    0\n#&gt; 870                oldClass&lt;-    0\n#&gt; 872                   on.exit    0\n#&gt; 905               pcre_config    0\n#&gt; 914                pos.to.env    0\n#&gt; 957                 proc.time    0\n#&gt; 958                      prod    0\n#&gt; 981                     quote    0\n#&gt; 982             R_compiled_by    0\n#&gt; 985                 R.Version    0\n#&gt; 986                     range    0\n#&gt; 999                        Re    0\n#&gt; 1018                      rep    0\n#&gt; 1027                   repeat    0\n#&gt; 1034               retracemem    0\n#&gt; 1035                   return    0\n#&gt; 1043                    round    0\n#&gt; 1069                   search    0\n#&gt; 1070              searchpaths    0\n#&gt; 1074                seq_along    0\n#&gt; 1075                  seq_len    0\n#&gt; 1078                  seq.int    0\n#&gt; 1094                     sign    0\n#&gt; 1096                   signif    0\n#&gt; 1102                      sin    0\n#&gt; 1104                     sinh    0\n#&gt; 1107                    sinpi    0\n#&gt; 1131                     sqrt    0\n#&gt; 1137          standardGeneric    0\n#&gt; 1139                   stderr    0\n#&gt; 1140                    stdin    0\n#&gt; 1141                   stdout    0\n#&gt; 1145           storage.mode&lt;-    0\n#&gt; 1161               substitute    0\n#&gt; 1166                      sum    0\n#&gt; 1195                   switch    0\n#&gt; 1197                sys.calls    0\n#&gt; 1199                 Sys.Date    0\n#&gt; 1201               sys.frames    0\n#&gt; 1205               Sys.getpid    0\n#&gt; 1207                 Sys.info    0\n#&gt; 1209           Sys.localeconv    0\n#&gt; 1210               sys.nframe    0\n#&gt; 1211              sys.on.exit    0\n#&gt; 1213              sys.parents    0\n#&gt; 1222               sys.status    0\n#&gt; 1223                 Sys.time    0\n#&gt; 1237                      tan    0\n#&gt; 1238                     tanh    0\n#&gt; 1239                    tanpi    0\n#&gt; 1254                 tracemem    0\n#&gt; 1259                 trigamma    0\n#&gt; 1261                    trunc    0\n#&gt; 1270           unCfillPOSIXlt    0\n#&gt; 1271                  unclass    0\n#&gt; 1295               untracemem    0\n#&gt; 1299                UseMethod    0\n#&gt; 1315                    while    0\n#&gt; 1332                    xtfrm    0\n\n# check if all functions with 0 arguments are primitive\nfun_args2 &lt;- data.frame(\n  name = names(funs),\n  args = unname(vapply(funs, function(x) length(formals(x)), 1L)),\n  prim = unname(vapply(funs, is.primitive, TRUE))\n)\nfun_args2[fun_args2$args == 0, ]\n\n#&gt;                          name args  prim\n#&gt; 1                           -    0  TRUE\n#&gt; 4                           :    0  TRUE\n#&gt; 5                          ::    0  TRUE\n#&gt; 6                         :::    0  TRUE\n#&gt; 7                           !    0  TRUE\n#&gt; 10                         !=    0  TRUE\n#&gt; 13                     ...elt    0  TRUE\n#&gt; 14                  ...length    0  TRUE\n#&gt; 15                   ...names    0  TRUE\n#&gt; 20                         .C    0  TRUE\n#&gt; 21               .cache_class    0  TRUE\n#&gt; 22                      .Call    0  TRUE\n#&gt; 23             .Call.graphics    0  TRUE\n#&gt; 25                    .class2    0  TRUE\n#&gt; 42                  .External    0  TRUE\n#&gt; 43         .External.graphics    0  TRUE\n#&gt; 44                 .External2    0  TRUE\n#&gt; 45                 .First.sys    0 FALSE\n#&gt; 48                   .Fortran    0  TRUE\n#&gt; 56                  .Internal    0  TRUE\n#&gt; 57       .isMethodsDispatchOn    0  TRUE\n#&gt; 68         .NotYetImplemented    0 FALSE\n#&gt; 70         .OptRequireMethods    0 FALSE\n#&gt; 76                 .Primitive    0  TRUE\n#&gt; 77                 .primTrace    0  TRUE\n#&gt; 78               .primUntrace    0  TRUE\n#&gt; 89          .standard_regexps    0 FALSE\n#&gt; 90                    .subset    0  TRUE\n#&gt; 91                   .subset2    0  TRUE\n#&gt; 94        .tryResumeInterrupt    0 FALSE\n#&gt; 96                          (    0  TRUE\n#&gt; 97                          [    0  TRUE\n#&gt; 115                        [[    0  TRUE\n#&gt; 122                      [[&lt;-    0  TRUE\n#&gt; 127                       [&lt;-    0  TRUE\n#&gt; 135                         {    0  TRUE\n#&gt; 136                         @    0  TRUE\n#&gt; 137                       @&lt;-    0  TRUE\n#&gt; 138                         *    0  TRUE\n#&gt; 140                         /    0  TRUE\n#&gt; 142                         &    0  TRUE\n#&gt; 145                        &&    0  TRUE\n#&gt; 146                       %*%    0  TRUE\n#&gt; 147                       %/%    0  TRUE\n#&gt; 148                        %%    0  TRUE\n#&gt; 152                         ^    0  TRUE\n#&gt; 153                         +    0  TRUE\n#&gt; 156                         &lt;    0  TRUE\n#&gt; 157                        &lt;-    0  TRUE\n#&gt; 158                       &lt;&lt;-    0  TRUE\n#&gt; 159                        &lt;=    0  TRUE\n#&gt; 160                         =    0  TRUE\n#&gt; 161                        ==    0  TRUE\n#&gt; 162                         &gt;    0  TRUE\n#&gt; 163                        &gt;=    0  TRUE\n#&gt; 164                         |    0  TRUE\n#&gt; 167                        ||    0  TRUE\n#&gt; 168                         ~    0  TRUE\n#&gt; 169                         $    0  TRUE\n#&gt; 172                       $&lt;-    0  TRUE\n#&gt; 176                       abs    0  TRUE\n#&gt; 177                      acos    0  TRUE\n#&gt; 178                     acosh    0  TRUE\n#&gt; 185                       all    0  TRUE\n#&gt; 202                       any    0  TRUE\n#&gt; 208                     anyNA    0  TRUE\n#&gt; 217                       Arg    0  TRUE\n#&gt; 224                   as.call    0  TRUE\n#&gt; 225              as.character    0  TRUE\n#&gt; 236                as.complex    0  TRUE\n#&gt; 270                 as.double    0  TRUE\n#&gt; 273            as.environment    0  TRUE\n#&gt; 280                as.integer    0  TRUE\n#&gt; 292                as.logical    0  TRUE\n#&gt; 302                as.numeric    0  TRUE\n#&gt; 321                    as.raw    0  TRUE\n#&gt; 331                      asin    0  TRUE\n#&gt; 332                     asinh    0  TRUE\n#&gt; 338                      atan    0  TRUE\n#&gt; 340                     atanh    0  TRUE\n#&gt; 343                      attr    0  TRUE\n#&gt; 345                    attr&lt;-    0  TRUE\n#&gt; 346                attributes    0  TRUE\n#&gt; 347              attributes&lt;-    0  TRUE\n#&gt; 352                   baseenv    0  TRUE\n#&gt; 371                     break    0  TRUE\n#&gt; 372                   browser    0  TRUE\n#&gt; 381                         c    0  TRUE\n#&gt; 390                      call    0  TRUE\n#&gt; 397                   ceiling    0  TRUE\n#&gt; 410                     class    0  TRUE\n#&gt; 411                   class&lt;-    0  TRUE\n#&gt; 417       closeAllConnections    0 FALSE\n#&gt; 434                      Conj    0  TRUE\n#&gt; 435              contributors    0 FALSE\n#&gt; 436                       cos    0  TRUE\n#&gt; 437                      cosh    0  TRUE\n#&gt; 438                     cospi    0  TRUE\n#&gt; 440               Cstack_info    0 FALSE\n#&gt; 441                    cummax    0  TRUE\n#&gt; 442                    cummin    0  TRUE\n#&gt; 443                   cumprod    0  TRUE\n#&gt; 444                    cumsum    0  TRUE\n#&gt; 453                      date    0 FALSE\n#&gt; 457  default.stringsAsFactors    0 FALSE\n#&gt; 474                   digamma    0  TRUE\n#&gt; 475                       dim    0  TRUE\n#&gt; 477                     dim&lt;-    0  TRUE\n#&gt; 478                  dimnames    0  TRUE\n#&gt; 480                dimnames&lt;-    0  TRUE\n#&gt; 509                  emptyenv    0  TRUE\n#&gt; 510                enc2native    0  TRUE\n#&gt; 511                  enc2utf8    0  TRUE\n#&gt; 519             environment&lt;-    0  TRUE\n#&gt; 527                       exp    0  TRUE\n#&gt; 529                     expm1    0  TRUE\n#&gt; 530                expression    0  TRUE\n#&gt; 531            extSoftVersion    0 FALSE\n#&gt; 558                     floor    0  TRUE\n#&gt; 561                       for    0  TRUE\n#&gt; 563              forceAndCall    0  TRUE\n#&gt; 586                  function    0  TRUE\n#&gt; 587                     gamma    0  TRUE\n#&gt; 589                   gc.time    0  TRUE\n#&gt; 595         getAllConnections    0 FALSE\n#&gt; 603             geterrmessage    0 FALSE\n#&gt; 606             getLoadedDLLs    0 FALSE\n#&gt; 616               getRversion    0 FALSE\n#&gt; 618      getTaskCallbackNames    0 FALSE\n#&gt; 621                     getwd    0 FALSE\n#&gt; 624                 globalenv    0  TRUE\n#&gt; 636                 iconvlist    0 FALSE\n#&gt; 641                        if    0  TRUE\n#&gt; 643                        Im    0  TRUE\n#&gt; 649               interactive    0  TRUE\n#&gt; 654                 invisible    0  TRUE\n#&gt; 657                  is.array    0  TRUE\n#&gt; 658                 is.atomic    0  TRUE\n#&gt; 659                   is.call    0  TRUE\n#&gt; 660              is.character    0  TRUE\n#&gt; 661                is.complex    0  TRUE\n#&gt; 663                 is.double    0  TRUE\n#&gt; 665            is.environment    0  TRUE\n#&gt; 666             is.expression    0  TRUE\n#&gt; 668                 is.finite    0  TRUE\n#&gt; 670               is.function    0  TRUE\n#&gt; 671               is.infinite    0  TRUE\n#&gt; 673                is.integer    0  TRUE\n#&gt; 674               is.language    0  TRUE\n#&gt; 675                   is.list    0  TRUE\n#&gt; 677                is.logical    0  TRUE\n#&gt; 678                 is.matrix    0  TRUE\n#&gt; 679                     is.na    0  TRUE\n#&gt; 687                   is.name    0  TRUE\n#&gt; 688                    is.nan    0  TRUE\n#&gt; 690                   is.null    0  TRUE\n#&gt; 691                is.numeric    0  TRUE\n#&gt; 696                 is.object    0  TRUE\n#&gt; 699               is.pairlist    0  TRUE\n#&gt; 702                      is.R    0 FALSE\n#&gt; 703                    is.raw    0  TRUE\n#&gt; 704              is.recursive    0  TRUE\n#&gt; 705                 is.single    0  TRUE\n#&gt; 706                 is.symbol    0  TRUE\n#&gt; 722                      isS4    0  TRUE\n#&gt; 736                 l10n_info    0 FALSE\n#&gt; 737                La_library    0 FALSE\n#&gt; 738                La_version    0 FALSE\n#&gt; 745           lazyLoadDBfetch    0  TRUE\n#&gt; 748                    length    0  TRUE\n#&gt; 750                  length&lt;-    0  TRUE\n#&gt; 759                  levels&lt;-    0  TRUE\n#&gt; 762                    lgamma    0  TRUE\n#&gt; 763            libcurlVersion    0 FALSE\n#&gt; 767                   licence    0 FALSE\n#&gt; 768                   license    0 FALSE\n#&gt; 769                      list    0  TRUE\n#&gt; 775          loadedNamespaces    0 FALSE\n#&gt; 776      loadingNamespaceInfo    0 FALSE\n#&gt; 781                       log    0  TRUE\n#&gt; 782                     log10    0  TRUE\n#&gt; 783                     log1p    0  TRUE\n#&gt; 784                      log2    0  TRUE\n#&gt; 807                       max    0  TRUE\n#&gt; 819            memory.profile    0 FALSE\n#&gt; 825                       min    0  TRUE\n#&gt; 826                   missing    0  TRUE\n#&gt; 827                       Mod    0  TRUE\n#&gt; 838                     names    0  TRUE\n#&gt; 840                   names&lt;-    0  TRUE\n#&gt; 847                     nargs    0  TRUE\n#&gt; 853                      next    0  TRUE\n#&gt; 862                  nullfile    0 FALSE\n#&gt; 867                    nzchar    0  TRUE\n#&gt; 869                  oldClass    0  TRUE\n#&gt; 870                oldClass&lt;-    0  TRUE\n#&gt; 872                   on.exit    0  TRUE\n#&gt; 905               pcre_config    0 FALSE\n#&gt; 914                pos.to.env    0  TRUE\n#&gt; 957                 proc.time    0  TRUE\n#&gt; 958                      prod    0  TRUE\n#&gt; 981                     quote    0  TRUE\n#&gt; 982             R_compiled_by    0 FALSE\n#&gt; 985                 R.Version    0 FALSE\n#&gt; 986                     range    0  TRUE\n#&gt; 999                        Re    0  TRUE\n#&gt; 1018                      rep    0  TRUE\n#&gt; 1027                   repeat    0  TRUE\n#&gt; 1034               retracemem    0  TRUE\n#&gt; 1035                   return    0  TRUE\n#&gt; 1043                    round    0  TRUE\n#&gt; 1069                   search    0 FALSE\n#&gt; 1070              searchpaths    0 FALSE\n#&gt; 1074                seq_along    0  TRUE\n#&gt; 1075                  seq_len    0  TRUE\n#&gt; 1078                  seq.int    0  TRUE\n#&gt; 1094                     sign    0  TRUE\n#&gt; 1096                   signif    0  TRUE\n#&gt; 1102                      sin    0  TRUE\n#&gt; 1104                     sinh    0  TRUE\n#&gt; 1107                    sinpi    0  TRUE\n#&gt; 1131                     sqrt    0  TRUE\n#&gt; 1137          standardGeneric    0  TRUE\n#&gt; 1139                   stderr    0 FALSE\n#&gt; 1140                    stdin    0 FALSE\n#&gt; 1141                   stdout    0 FALSE\n#&gt; 1145           storage.mode&lt;-    0  TRUE\n#&gt; 1161               substitute    0  TRUE\n#&gt; 1166                      sum    0  TRUE\n#&gt; 1195                   switch    0  TRUE\n#&gt; 1197                sys.calls    0 FALSE\n#&gt; 1199                 Sys.Date    0 FALSE\n#&gt; 1201               sys.frames    0 FALSE\n#&gt; 1205               Sys.getpid    0 FALSE\n#&gt; 1207                 Sys.info    0 FALSE\n#&gt; 1209           Sys.localeconv    0 FALSE\n#&gt; 1210               sys.nframe    0 FALSE\n#&gt; 1211              sys.on.exit    0 FALSE\n#&gt; 1213              sys.parents    0 FALSE\n#&gt; 1222               sys.status    0 FALSE\n#&gt; 1223                 Sys.time    0 FALSE\n#&gt; 1237                      tan    0  TRUE\n#&gt; 1238                     tanh    0  TRUE\n#&gt; 1239                    tanpi    0  TRUE\n#&gt; 1254                 tracemem    0  TRUE\n#&gt; 1259                 trigamma    0  TRUE\n#&gt; 1261                    trunc    0  TRUE\n#&gt; 1270           unCfillPOSIXlt    0  TRUE\n#&gt; 1271                  unclass    0  TRUE\n#&gt; 1295               untracemem    0  TRUE\n#&gt; 1299                UseMethod    0  TRUE\n#&gt; 1315                    while    0  TRUE\n#&gt; 1332                    xtfrm    0  TRUE\n\n\nAnswers:\n\nscan() has the most arguments, 22\nmost (but not all) are primitive functions (204 of 254)\nthe ls() in the original code could be expanded to search all packages\n\nAR Solutions: Let’s look at each sub-question separately:\n\nTo find the function with the most arguments, we first compute the length of formals().\n\n\nlibrary(purrr)\n\nn_args &lt;- funs %&gt;%\n  map(formals) %&gt;%\n  map_int(length)\n\nThen we sort n_args in decreasing order and look at its first entries.\n\nn_args %&gt;%\n  sort(decreasing = TRUE) %&gt;%\n  head()\n#&gt; scan format.default source\n#&gt; 22 16 16\n#&gt; formatC library merge.data.frame\n#&gt; 15 13 13\n\n\nWe can further use n_args to find the number of functions with no arguments:\n\n\nsum(n_args == 0)\n\n#&gt; [1] 253\n\n\nHowever, this over counts because formals() returns NULL for primitive functions, and length(NULL) is 0. To fix this, we can first remove the primitive functions:\n\nn_args2 &lt;- funs %&gt;%\n  discard(is.primitive) %&gt;%\n  map(formals) %&gt;%\n  map_int(length)\n\nsum(n_args2 == 0)\n\n#&gt; [1] 48\n\n\nIndeed, most of the functions with no arguments are actually primitive functions.\n\nTo find all primitive functions, we can change the predicate in Filter() from is.function() to is.primitive():\n\n\nfuns &lt;- Filter(is.primitive, objs)\nlength(funs)\n\n#&gt; [1] 205\n\n\n\n\nWhat are the three important components of a function?\n\nAnswer: the formals(), body() and environment().\nAR Solutions: These components are the function’s body(), formals() and environment(). However, as mentioned in Advanced R:\n\nThere is one exception to the rule that functions have three components. Primitive functions, like sum(), call C code directly with .Primitive() and contain no R code. Therefore, their formals(), body(), and environment() are all NULL.\n\n\n\nWhen does printing a function not show the environment it was created in?\n\nAnswer: when it is created in the global environment.\nAR Solutions: Primitive functions and functions created in the global environment do not print their environment.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-15",
    "href": "analysis/advanced-r-1.html#exercises-15",
    "title": "Advanced R (Foundations)",
    "section": "6.4.5 Exercises",
    "text": "6.4.5 Exercises\n\nWhat does the following code return? Why? Describe how each of the three c’s is interpreted.\n\n\nc &lt;- 10\nc(c = c)\n\n#&gt;  c \n#&gt; 10\n\n\nAnswer: a named vector, c 10. The first and final c is a variable. The second c is a function name. the third c is a name.\nAR Solutions: This code returns a named numeric vector of length one — with one element of the value 10 and the name \"c\". The first c represents the c() function, the second c is interpreted as a (quoted) name and the third c as a value.\n\n\nWhat are the four principles that govern how R looks for values?\n\nAnswer: name masking, functions versus variables, a fresh start, dynamic lookup.\nAR Solutions: R’s lexical scoping rules are based on these four principles: - Name masking - Functions vs. variables - A fresh start - Dynamic lookup\n\n\nWhat does the following function return? Make a prediction before running the code yourself.\n\n\nf &lt;- function(x) {\n  f &lt;- function(x) { # return value of this is 101\n    f &lt;- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n\n#&gt; [1] 202\n\n\nAnswer: 202. Correct!\nAR Solutions: Within this nested function two more functions also named f are defined and called. Because the functions are each executed in their own environment R will look up and use the functions defined last in these environments. The innermost f() is called last, though it is the first function to return a value. Therefore, the order of the calculation passes “from the inside to the outside” and the function returns ((10 ^ 2) + 1) * 2, i.e. 202.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-16",
    "href": "analysis/advanced-r-1.html#exercises-16",
    "title": "Advanced R (Foundations)",
    "section": "6.5.4 Exercises",
    "text": "6.5.4 Exercises\n\nWhat important property of && makes x_ok() work?\n\n\nx_ok &lt;- function(x) {\n  !is.null(x) && length(x) == 1 && x &gt; 0\n}\n\nx_ok(NULL)\n\n#&gt; [1] FALSE\n\nx_ok(1)\n\n#&gt; [1] TRUE\n\nx_ok(1:3)\n\n#&gt; [1] FALSE\n\n\nAnswer: From the && docs, “The longer forms evaluates left to right, proceeding only until the result is determined.”\nWhat is different with this code? Why is this behaviour undesirable here?\n\nx_ok &lt;- function(x) {\n  !is.null(x) & length(x) == 1 & x &gt; 0\n}\n\nx_ok(NULL)\n\n#&gt; logical(0)\n\nx_ok(1)\n\n#&gt; [1] TRUE\n\nx_ok(1:3)\n\n#&gt; [1] FALSE FALSE FALSE\n\n\nAnswer: “The shorter forms performs elementwise comparisons in much the same way as arithmetic operators.” This is undesirable because the intent of the function is to return TRUE or FALSE.\nAR Solutions: In summary: && short-circuits which means that if the left-hand side is FALSE it doesn’t evaluate the right-hand side (because it doesn’t matter). Similarly, if the left-hand side of || is TRUE it doesn’t evaluate the right-hand side.\nWe expect x_ok() to validate its input via certain criteria: it must not be NULL, have length 1 and be greater than 0. Meaningful outcomes for this assertion will be TRUE, FALSE or NA. The desired behaviour is reached by combining the assertions through && instead of &.\n&& does not perform elementwise comparisons; instead it uses the first element of each value only. It also uses lazy evaluation, in the sense that evaluation “proceeds only until the result is determined” (from ?Logic). This means that the RHS of && won’t be evaluated if the LHS already determines the outcome of the comparison (e.g. evaluate to FALSE). This behaviour is also known as “short-circuiting”. For some situations (x = 1) both operators will lead to the same result. But this is not always the case. For x = NULL, the &&-operator will stop after the !is.null statement and return the result. The following conditions won’t even be evaluated! (If the other conditions are also evaluated (by the use of &), the outcome would change. NULL &gt; 0 returns logical(0), which is not helpful in this case.)\nWe can also see the difference in behaviour, when we set x = 1:3. The &&-operator returns the result from length(x) == 1, which is FALSE. Using & as the logical operator leads to the (vectorised) x &gt; 0 condition being evaluated and also returned.\n\n\nWhat does this function return? Why? Which principle does it illustrate?\n\n\nf2 &lt;- function(x = z) {\n  z &lt;- 100\n  x\n}\nf2()\n\n#&gt; [1] 100\n\n\nAnswer: 100, lazy evaluation. x = z isn’t evaluated until x.\nAR Solutions: The function returns 100. The default argument (x = z) gets lazily evaluated within the function environment when x gets accessed. At this time z has already been bound to the value 100. The illustrated principle here is lazy evaluation.\n\n\nWhat does this function return? Why? Which principle does it illustrate?\n\n\ny &lt;- 10\n# styler: off\nf1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { # nolint: semicolon_linter.\n  # styler: on\n  c(x, y)\n}\nf1()\n\n#&gt; [1] 2 1\n\ny\n\n#&gt; [1] 10\n\n\nAnswer: c(2, 1). default arguments.\nAR Solutions: The function returns c(2, 1) which is due to name masking. When x is accessed within c(), the promise x = {y &lt;- 1; 2} is evaluated inside f1()’s environment. y gets bound to the value 1 and the return value of {() (2) gets assigned to x. When y gets accessed next within c(), it has already the value 1 and R doesn’t need to look it up any further. Therefore, the promise y = 0 won’t be evaluated. Also, as y is assigned within f1()’s environment, the value of the global variable y is left untouched.\n\n\nIn hist(), the default value of xlim is range(breaks), the default value for breaks is \"Sturges\", and\n\n\nrange(\"Sturges\")\n\n#&gt; [1] \"Sturges\" \"Sturges\"\n\n\nExplain how hist() works to get a correct xlim value.\nAnswer: from the docs, “Note that xlim is not used to define the histogram (breaks), but only for plotting (when plot = TRUE).” So, the breakpoints are calculated when the object is created, and xlim is calculated when the histogram is plotted, in the second step.\nAR Solutions: The xlim argument of hist() defines the range of the histogram’s x-axis. In order to provide a valid axis xlim must contain a numeric vector of exactly two unique values. Consequently, for the default xlim = range(breaks)), breaks must evaluate to a vector with at least two unique values.\nDuring execution hist() overwrites the breaks argument. The breaks argument is quite flexible and allows the users to provide the breakpoints directly or compute them in several ways. Therefore, the specific behaviour depends highly on the input. But hist ensures that breaks evaluates to a numeric vector containing at least two unique elements before xlim is computed.\n\n\nExplain why this function works. Why is it confusing?\n\n\nshow_time &lt;- function(x = stop(\"Error!\")) {\n  stop &lt;- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n\n#&gt; [1] \"2023-12-04 15:10:35 CST\"\n\n\nAnswer: stop is redefined before x is evaluated. This is a confusing use of lazy evaluation.\nAR Solutions: Before show_time() accesses x (default stop(\"Error\")), the stop() function is masked by function(...) Sys.time(). As default arguments are evaluated in the function environment, print(x) will be evaluated as print(Sys.time()).\nThis function is confusing because its behaviour changes when x’s value is supplied directly. Now the value from the calling environment will be used and the overwriting of stop() won’t affect x anymore.\n\n\nHow many arguments are required when calling library()?\n\nAnswer: zero. library() uses missing() to return the list of available packages if there are no arguments.\nAR Solutions: library() doesn’t require any arguments. When called without arguments library() invisibly returns a list of class libraryIQR, which contains a results matrix with one row and three columns per installed package. These columns contain entries for the name of the package (“Package”), the path to the package (“LibPath”) and the title of the package (“Title”). library() also has its own print method (print.libraryIQR()), which displays this information conveniently in its own window.\nThis behaviour is also documented under the details section of library()’s help page (?library):\n\nIf library is called with no package or help argument, it lists all available packages in the libraries specified by lib.loc, and returns the corresponding information in an object of class “libraryIQR”. (The structure of this class may change in future versions.) Use .packages(all = TRUE) to obtain just the names of all available packages, and installed.packages() for even more information.\n\nBecause the package and help argument from library() do not show a default value, it’s easy to overlook the possibility to call library() without these arguments. (Instead of providing NULLs as default values library() uses missing() to check if these arguments were provided.)",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-17",
    "href": "analysis/advanced-r-1.html#exercises-17",
    "title": "Advanced R (Foundations)",
    "section": "6.6.1 Exercises",
    "text": "6.6.1 Exercises\n\nExplain the following results:\n\n\nsum(1, 2, 3)\n\n#&gt; [1] 6\n\nmean(1, 2, 3)\n\n#&gt; [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n\n#&gt; [1] 7\n\nmean(1, 2, 3, na.omit = TRUE)\n\n#&gt; [1] 1\n\n\nAnswer:\n\n“sum() returns the sum of all the values present in its arguments.” The first example is straightforward. In the second sum example, na.omit isn’t a valid argument (na.rm is), so the TRUE value is passed to ..., coerced to 1, and included in the sum.\nmean() takes a single parameter, and passes on remaining arguments to .... In both cases, the arguments after the 1 are silently dropped. The correct form would be mean(c(1, 2, 3)).\n\nAR Solutions: Let’s inspect the arguments and their order for both functions. For sum() these are ... and na.rm:\n\nstr(sum)\n\n#&gt; function (..., na.rm = FALSE)\n\n\nFor the ... argument sum() expects numeric, complex, or logical vector input (see ?sum). Unfortunately, when ... is used, misspelled arguments (!) like na.omit won’t raise an error (in case of no further input checks). So instead, na.omit is treated as a logical and becomes part of the ... argument. It will be coerced to 1 and be part of the sum. All other arguments are left unchanged. Therefore sum(1, 2, 3) returns 6 and sum(1, 2, 3, na.omit = TRUE) returns 7.\nIn contrast, the generic function mean() expects x, trim, na.rm and ... for its default method.\n\nstr(mean.default)\n\n#&gt; function (x, trim = 0, na.rm = FALSE, ...)\n\n\nAs na.omit is not one of mean()’s named arguments (x; and no candidate for partial matching), na.omit again becomes part of the ... argument. However, in contrast to sum() the elements of ... are not “part” of the mean. The other supplied arguments are matched by their order, i.e. x = 1, trim = 2 and na.rm = 3. As x is of length 1 and not NA, the settings of trim and na.rm do not affect the calculation of the mean. Both calls (mean(1, 2, 3) and mean(1, 2, 3, na.omit = TRUE)) return 1.\n\n\nExplain how to find the documentation for the named arguments in the following function call:\n\n\n\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\n\n\n\n\n\n\n\n\nAnswer: in other functions, specifically par() and plot.default().\nAR Solutions: First we type ?plot in the console and check the “Usage” section which contains:\nplot(x, y, ...)\nThe arguments we want to learn more about (col, pch, xlab, col.lab) are part of the ... argument. There we can find information for the xlab argument and a recommendation to visit ?par for the other arguments. Under ?par we type “col” into the search bar, which leads us to the section “Color Specification”. We also search for the pch argument, which leads to the recommendation to check ?points. Finally, col.lab is also directly documented within ?par.\n\n\nWhy does plot(1:10, col = \"red\") only colour the points, not the axes or labels? Read the source code of plot.default() to find out.\n\nlocalAxis &lt;- function(..., col, bg, pch, cex, lty, lwd) Axis(...)\nlocalBox &lt;- function(..., col, bg, pch, cex, lty, lwd) box(...)\nlocalWindow &lt;- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)\nlocalTitle &lt;- function(..., col, bg, pch, cex, lty, lwd) title(...)\nAnswer: plot.default() discards col and several other arguments when calling Axis(), box(), plot.window(), and title().\nAR Solutions: To learn about the internals of plot.default() we add browser() to the first line of the code and interactively run plot(1:10, col = \"red\"). This way we can see how the plot is built and learn where the axes are added. This leads us to the function call\n\nlocalTitle(main = main, sub = sub, xlab = xlab, ylab = ylab, ...)\n\nThe localTitle() function was defined in the first lines of plot.default() as:\n\nlocalTitle &lt;- function(..., col, bg, pch, cex, lty, lwd) title(...)\n\nThe call to localTitle() passes the col parameter as part of the ... argument to title(). ?title tells us that the title() function specifies four parts of the plot: Main (title of the plot), sub (sub-title of the plot) and both axis labels. Therefore, it would introduce ambiguity inside title() to use col directly. Instead, one has the option to supply col via the ... argument, via col.lab or as part of xlab in the form xlab = list(c(\"index\"), col = \"red\") (similar for ylab).",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-18",
    "href": "analysis/advanced-r-1.html#exercises-18",
    "title": "Advanced R (Foundations)",
    "section": "6.7.5 Exercises",
    "text": "6.7.5 Exercises\n\nWhat does load() return? Why don’t you normally see these values?\n\nAnswer: from the docs, load() returns “A character vector of the names of objects created, invisibly.”\nAR Solutions: load() loads objects saved to disk in .Rdata files by save(). When run successfully, load() invisibly returns a character vector containing the names of the newly loaded objects. To print these names to the console, one can set the argument verbose to TRUE or surround the call in parentheses to trigger R’s auto-printing mechanism.\n\n\nWhat does write.table() return? What would be more useful?\n\nAnswer: it returns invisible(NULL). Returning the written table or the argument x would be more useful.\nAR Solutions: write.table() writes an object, usually a data frame or a matrix, to disk. The function invisibly returns NULL. It would be more useful if write.table() would (invisibly) return the input data, x. This would allow to save intermediate results and directly take on further processing steps without breaking the flow of the code (i.e. breaking it into different lines). One package which uses this pattern is the {readr} package, which is part of the tidyverse-ecosystem.\n\n\nHow does the chdir parameter of source() compare to with_dir()? Why might you prefer one to the other?\n\nAnswer: both temporarily change the working directory. chdir is preferable since this is expected behavior for the function, unless you need to set a working directory other than the directory containing file.\nAR Solutions: with_dir() takes a path for a working directory (dir) as its first argument. This is the directory where the provided code (code) should be executed. Therefore, the current working directory is changed in with_dir() via setwd(). Then, on.exit() ensures that the modification of the working directory is reset to the initial value when the function exits. By passing the path explicitly, the user has full control over the directory to execute the code in.\nIn source() the code is passed via the file argument (a path to a file). The chdir argument specifies if the working directory should be changed to the directory containing the file. The default for chdir is FALSE, so you don’t have to provide a value. However, as you can only provide TRUE or FALSE, you are also less flexible in choosing the working directory for the code execution.\n\n\nWrite a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code works).\n\n\nwith_png &lt;- function(code, ...) {\n  png(...)\n  on.exit(dev.off(), add = TRUE, after = TRUE)\n  force(code)\n}\n\nwith_png(\n  plot(1:10),\n  filename = \"rendered/withpng-example.png\",\n  # use 3 times default resolution which is close to retina display ppi (218-254 depending on model)\n  # https://support.apple.com/en-us/HT202471\n  width = 480 * 3, height = 480 * 3, res = 72 * 3\n)\n\n\n\n\nwith_png output\n\n\nAnswer: code example above.\nAR Solutions: To control the graphics device we use pdf() and dev.off(). To ensure a clean termination on.exit() is used.\n\nplot_pdf &lt;- function(code) {\n  pdf(\"test.pdf\")\n  on.exit(dev.off(), add = TRUE)\n  code\n}\n\n\n\nWe can use on.exit() to implement a simple version of capture.output().\n\n\ncapture.output2 &lt;- function(code) {\n  temp &lt;- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n  force(code)\n  readLines(temp)\n}\n\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\n\nCompare capture.output() to capture.output2(). How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas so they’re easier to understand?\nAnswer: capture.output2() has fewer features and uses two separate calls to on.exit(). It simply returns the output (by line) from the executed code, and highlights the key idea, using sink() to capture output to a temporary file.\nAR Solutions: Using body(capture.output) we inspect the source code of the original capture.output() function: The implementation for capture.output() is quite a bit longer (39 lines vs. 7 lines).\nIn capture_output2() the code is simply forced, and the output is caught via sink() in a temporary file. An additional feature of capture_output() is that one can also capture messages by setting type = \"message\". As this is internally forwarded to sink(), this behaviour (and also sink()’s split argument) could be easily introduced within capture_output2() as well.\nThe main difference is that capture.output() calls print.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-19",
    "href": "analysis/advanced-r-1.html#exercises-19",
    "title": "Advanced R (Foundations)",
    "section": "6.8.6 Exercises",
    "text": "6.8.6 Exercises\n\nRewrite the following code snippets into prefix form:\n\n\n1 + 2 + 3\n\n#&gt; [1] 6\n\n`+`(`+`(1, 2), 3)\n\n#&gt; [1] 6\n\n1 + (2 + 3)\n\n#&gt; [1] 6\n\n`+`(1, `+`(2, 3))\n\n#&gt; [1] 6\n\nfxn &lt;- function(x, n) if (length(x) &lt;= 5) x[[5]] else x[[n]]\nfxn(1:5, 2)\n\n#&gt; [1] 5\n\nfxn(1:10, 2)\n\n#&gt; [1] 2\n\nfxn2 &lt;- function(x, n) `if`(`&lt;=`(length(x), 5), `[[`(x, 5), `[[`(x, n))\nfxn2(1:5, 2)\n\n#&gt; [1] 5\n\nfxn2(1:10, 2)\n\n#&gt; [1] 2\n\n\nAnswer: inline above.\nAR Solutions: Let’s rewrite the expressions to match the exact syntax from the code above. Because prefix functions already define the execution order, we may omit the parentheses in the second expression.\n\n`+`(`+`(1, 2), 3)\n`+`(1, `(`(`+`(2, 3)))\n`+`(1, `+`(2, 3))\n`if`(`&lt;=`(length(x), 5), `[[`(x, 5), `[[`(x, n))\n\n\n\nClarify the following list of odd function calls:\n\n\nx &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))\ny &lt;- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\n\nAnswers: improved code below.\n\nx &lt;- sample(c(1:10, NA), 20, replace = TRUE)\ny &lt;- runif(20)\ncor(x, y, use = \"pairwise.complete.obs\", method = \"kendall\")\n\n#&gt; [1] 0.07347184\n\n\nAR Solutions: None of these functions provides a ... argument. Therefore, the function arguments are first matched exactly, then via partial matching and finally by position. This leads us to the following explicit function calls:\n\nx &lt;- sample(c(1:10, NA), size = 20, replace = TRUE)\ny &lt;- runif(20, min = 0, max = 1)\ncor(x, y, use = \"pairwise.complete.obs\", method = \"kendall\")\n\n\n\nExplain why the following code fails:\n\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\n\ntry(modify(get(\"x\"), 1) &lt;- 10)\n\n#&gt; Error in modify(get(\"x\"), 1) &lt;- 10 : \n#&gt;   target of assignment expands to non-language object\n\n#&gt; Error: target of assignment expands to non-language object\n\nAnswer: as explained on stack overflow, the error is caused when assigning to an object directly, instead of a name that refers to the object (like x).\nAR Solutions: First, let’s define x and recall the definition of modify() from Advanced R:\n\nx &lt;- 1:3\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\n\nR internally transforms the code, and the transformed code reproduces the error above:\n\nget(\"x\") &lt;- `modify&lt;-`(get(\"x\"), 1, 10)\n#&gt; Error in get(\"x\") &lt;- `modify&lt;-`(get(\"x\"), 1, 10) :\n#&gt;   target of assignment expands to non-language object\n\nThe error occurs during the assignment because no corresponding replacement function, i.e. get&lt;-, exists for get(). To confirm this, we reproduce the error via the following simplified example.\n\nget(\"x\") &lt;- 2\n#&gt; Error in get(\"x\") &lt;- 2 :\n#&gt;   target of assignment expands to non-language object\n\n\n\nCreate a replacement function that modifies a random location in a vector.\n\n\n`modrand&lt;-` &lt;- function(x, value) {\n  x[sample(length(x), 1)] &lt;- value\n  x\n}\n\nv &lt;- 1:20\nmodrand(v) &lt;- NA\nv\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 NA 11 12 13 14 15 16 17 18 19 20\n\n\nAnswer: code above.\nAR Solutions: Let’s define random&lt;- like this:\n\n`random&lt;-` &lt;- function(x, value) {\n  idx &lt;- sample(length(x), 1)\n  x[idx] &lt;- value\n  x\n}\n\n\n\nWrite your own version of + that pastes its inputs together if they are character vectors but behaves as usual otherwise. In other words, make this code work:\n\n\n`+` &lt;- function(x, y) {\n  if (is.character(x) && is.character(y)) {\n    return(paste0(x, y))\n  }\n  base::`+`(x, y)\n}\n\n1 + 2\n\n#&gt; [1] 3\n\n#&gt; [1] 3\n\n\"a\" + \"b\"\n\n#&gt; [1] \"ab\"\n\n#&gt; [1] \"ab\"\n\nrm(`+`)\n\nAnswer: code above.\nAR Solutions: To achieve this behaviour, we need to override the + operator. We need to take care to not use the + operator itself inside of the function definition, as this would lead to an undesired infinite recursion. We also add b = 0L as a default value to keep the behaviour of + as a unary operator, i.e. to keep + 1 working and not throwing an error.\n\n`+` &lt;- function(a, b = 0L) {\n  if (is.character(a) && is.character(b)) {\n    paste0(a, b)\n  } else {\n    base::`+`(a, b)\n  }\n}\n# Test\n+1\n\n#&gt; [1] 1\n\n1 + 2\n\n#&gt; [1] 3\n\n\"a\" + \"b\"\n\n#&gt; [1] \"ab\"\n\n# Return back to the original `+` operator\nrm(`+`)\n\n\n\nCreate a list of all the replacement functions found in the base package. Which ones are primitive functions? (Hint: use apropos().)\n\n\n# all replacement functions in base\nfun_args2[endsWith(fun_args2$name, \"&lt;-\"), ]$name\n\n#&gt;  [1] \".rowNamesDF&lt;-\"    \"[[&lt;-\"             \"[&lt;-\"              \"@&lt;-\"             \n#&gt;  [5] \"&lt;-\"               \"&lt;&lt;-\"              \"$&lt;-\"              \"attr&lt;-\"          \n#&gt;  [9] \"attributes&lt;-\"     \"body&lt;-\"           \"class&lt;-\"          \"colnames&lt;-\"      \n#&gt; [13] \"comment&lt;-\"        \"diag&lt;-\"           \"dim&lt;-\"            \"dimnames&lt;-\"      \n#&gt; [17] \"Encoding&lt;-\"       \"environment&lt;-\"    \"formals&lt;-\"        \"is.na&lt;-\"         \n#&gt; [21] \"length&lt;-\"         \"levels&lt;-\"         \"mode&lt;-\"           \"mostattributes&lt;-\"\n#&gt; [25] \"names&lt;-\"          \"oldClass&lt;-\"       \"parent.env&lt;-\"     \"regmatches&lt;-\"    \n#&gt; [29] \"row.names&lt;-\"      \"rownames&lt;-\"       \"split&lt;-\"          \"storage.mode&lt;-\"  \n#&gt; [33] \"substr&lt;-\"         \"substring&lt;-\"      \"units&lt;-\"\n\n# all replacement primitive functions in base\nfun_args2[endsWith(fun_args2$name, \"&lt;-\") & fun_args2$prim, ]$name\n\n#&gt;  [1] \"[[&lt;-\"           \"[&lt;-\"            \"@&lt;-\"            \"&lt;-\"            \n#&gt;  [5] \"&lt;&lt;-\"            \"$&lt;-\"            \"attr&lt;-\"         \"attributes&lt;-\"  \n#&gt;  [9] \"class&lt;-\"        \"dim&lt;-\"          \"dimnames&lt;-\"     \"environment&lt;-\" \n#&gt; [13] \"length&lt;-\"       \"levels&lt;-\"       \"names&lt;-\"        \"oldClass&lt;-\"    \n#&gt; [17] \"storage.mode&lt;-\"\n\n\nAnswer: while you could use apropos(\"&lt;-\"), I leveraged the existing code from 6.2.5 #5.\nAR Solutions: The hint suggests to look for functions with a specific naming pattern: Replacement functions conventionally end on “&lt;-”. We can search for these objects by supplying the regular expression \"&lt;-$\" to apropos(). apropos() also allows to return the position on the search path (search()) for each of its matches via setting where = TRUE. Finally, we can set mode = function to narrow down our search to relevant objects only. This gives us the following statement to begin with:\n\nrepls &lt;- apropos(\"&lt;-\", where = TRUE, mode = \"function\")\nhead(repls, 30)\n\n#&gt;                     14                     14                     14 \n#&gt;        \".rowNamesDF&lt;-\"                 \"[[&lt;-\"      \"[[&lt;-.data.frame\" \n#&gt;                     14                     14                     14 \n#&gt;          \"[[&lt;-.factor\" \"[[&lt;-.numeric_version\"         \"[[&lt;-.POSIXlt\" \n#&gt;                     14                     14                     14 \n#&gt;                  \"[&lt;-\"       \"[&lt;-.data.frame\"             \"[&lt;-.Date\" \n#&gt;                     14                     14                     14 \n#&gt;         \"[&lt;-.difftime\"           \"[&lt;-.factor\"  \"[&lt;-.numeric_version\" \n#&gt;                     14                     14                     14 \n#&gt;          \"[&lt;-.POSIXct\"          \"[&lt;-.POSIXlt\"                  \"@&lt;-\" \n#&gt;                      3                     14                     14 \n#&gt;                \"%@%&lt;-\"                   \"&lt;-\"                  \"&lt;&lt;-\" \n#&gt;                     14                     14                     14 \n#&gt;                  \"$&lt;-\"       \"$&lt;-.data.frame\"          \"$&lt;-.POSIXlt\" \n#&gt;                     12                     14                     14 \n#&gt;                 \"as&lt;-\"               \"attr&lt;-\"         \"attributes&lt;-\" \n#&gt;                     12                     14                     14 \n#&gt;               \"body&lt;-\"               \"body&lt;-\"              \"class&lt;-\" \n#&gt;                     12                     14                     14 \n#&gt;             \"coerce&lt;-\"           \"colnames&lt;-\"            \"comment&lt;-\"\n\n\nTo restrict repl to names of replacement functions from the {base} package, we select only matches containing the relevant position on the search path.\n\nrepls_base &lt;- repls[names(repls) == length(search())]\nrepls_base\n\n#&gt;                        14                        14                        14 \n#&gt;           \".rowNamesDF&lt;-\"                    \"[[&lt;-\"         \"[[&lt;-.data.frame\" \n#&gt;                        14                        14                        14 \n#&gt;             \"[[&lt;-.factor\"    \"[[&lt;-.numeric_version\"            \"[[&lt;-.POSIXlt\" \n#&gt;                        14                        14                        14 \n#&gt;                     \"[&lt;-\"          \"[&lt;-.data.frame\"                \"[&lt;-.Date\" \n#&gt;                        14                        14                        14 \n#&gt;            \"[&lt;-.difftime\"              \"[&lt;-.factor\"     \"[&lt;-.numeric_version\" \n#&gt;                        14                        14                        14 \n#&gt;             \"[&lt;-.POSIXct\"             \"[&lt;-.POSIXlt\"                     \"@&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;                      \"&lt;-\"                     \"&lt;&lt;-\"                     \"$&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;          \"$&lt;-.data.frame\"             \"$&lt;-.POSIXlt\"                  \"attr&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;            \"attributes&lt;-\"                  \"body&lt;-\"                 \"class&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;              \"colnames&lt;-\"               \"comment&lt;-\"                  \"diag&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;                   \"dim&lt;-\"              \"dimnames&lt;-\"   \"dimnames&lt;-.data.frame\" \n#&gt;                        14                        14                        14 \n#&gt;              \"Encoding&lt;-\"           \"environment&lt;-\"               \"formals&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;                 \"is.na&lt;-\"         \"is.na&lt;-.default\"          \"is.na&lt;-.factor\" \n#&gt;                        14                        14                        14 \n#&gt; \"is.na&lt;-.numeric_version\"                \"length&lt;-\"           \"length&lt;-.Date\" \n#&gt;                        14                        14                        14 \n#&gt;       \"length&lt;-.difftime\"         \"length&lt;-.factor\"        \"length&lt;-.POSIXct\" \n#&gt;                        14                        14                        14 \n#&gt;        \"length&lt;-.POSIXlt\"                \"levels&lt;-\"         \"levels&lt;-.factor\" \n#&gt;                        14                        14                        14 \n#&gt;                  \"mode&lt;-\"        \"mostattributes&lt;-\"                 \"names&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;         \"names&lt;-.POSIXlt\"              \"oldClass&lt;-\"            \"parent.env&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;            \"regmatches&lt;-\"             \"row.names&lt;-\"  \"row.names&lt;-.data.frame\" \n#&gt;                        14                        14                        14 \n#&gt;     \"row.names&lt;-.default\"              \"rownames&lt;-\"                 \"split&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;      \"split&lt;-.data.frame\"         \"split&lt;-.default\"          \"storage.mode&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;                \"substr&lt;-\"             \"substring&lt;-\"                 \"units&lt;-\" \n#&gt;                        14 \n#&gt;        \"units&lt;-.difftime\"\n\n\nTo find out which of these functions are primitives, we first search for these functions via mget() and then subset the result using Filter() and is.primitive().\n\nrepls_base_prim &lt;- mget(repls_base, envir = baseenv()) %&gt;%\n  Filter(is.primitive, .) %&gt;%\n  names()\nrepls_base_prim\n\n#&gt;  [1] \"[[&lt;-\"           \"[&lt;-\"            \"@&lt;-\"            \"&lt;-\"            \n#&gt;  [5] \"&lt;&lt;-\"            \"$&lt;-\"            \"attr&lt;-\"         \"attributes&lt;-\"  \n#&gt;  [9] \"class&lt;-\"        \"dim&lt;-\"          \"dimnames&lt;-\"     \"environment&lt;-\" \n#&gt; [13] \"length&lt;-\"       \"levels&lt;-\"       \"names&lt;-\"        \"oldClass&lt;-\"    \n#&gt; [17] \"storage.mode&lt;-\"\n\n\nOverall the base package contains 63 replacement functions of which 17 are primitive functions.\n\n\nWhat are valid names for user-created infix functions?\n\nAnswer: they must begin and end with %, and can contain any sequence of characters except %.\n\n\nCreate an infix xor() operator.\n\n\n`%xor%` &lt;- function(x, y) xor(x, y)\n\nxor(0, 0)\n\n#&gt; [1] FALSE\n\nxor(1, 0)\n\n#&gt; [1] TRUE\n\nxor(1, 1)\n\n#&gt; [1] FALSE\n\n0 %xor% 0\n\n#&gt; [1] FALSE\n\n1 %xor% 0\n\n#&gt; [1] TRUE\n\n1 %xor% 1\n\n#&gt; [1] FALSE\n\n\nAnswer: code above.\nAR Solutions: We could create an infix %xor% like this:\n\n`%xor%` &lt;- function(a, b) {\n  xor(a, b)\n}\nTRUE %xor% TRUE\n\n#&gt; [1] FALSE\n\nFALSE %xor% TRUE\n\n#&gt; [1] TRUE\n\n\n\n\nCreate infix versions of the set functions intersect(), union(), and setdiff(). You might call them %n%, %u%, and %/% to match conventions from mathematics.\n\n\n`%n%` &lt;- function(x, y) intersect(x, y)\n`%u%` &lt;- function(x, y) union(x, y)\n`%s%` &lt;- function(x, y) setdiff(x, y)\n\n# taken from docs examples\n(x &lt;- c(sort(sample(1:20, 9)), NA))\n\n#&gt;  [1]  2  4  6  7 10 11 13 15 20 NA\n\n(y &lt;- c(sort(sample(3:23, 7)), NA))\n\n#&gt; [1]  4  6  9 10 19 20 22 NA\n\nx %u% y\n\n#&gt;  [1]  2  4  6  7 10 11 13 15 20 NA  9 19 22\n\nx %n% y\n\n#&gt; [1]  4  6 10 20 NA\n\nx %s% y\n\n#&gt; [1]  2  7 11 13 15\n\ny %s% x\n\n#&gt; [1]  9 19 22\n\n\nAnswer: code above.\nAR Solutions: These infix operators could be defined in the following way. (%/% is chosen instead of %\\%, because \\ serves as an escape character.)\n\n`%n%` &lt;- function(a, b) {\n  intersect(a, b)\n}\n\n`%u%` &lt;- function(a, b) {\n  union(a, b)\n}\n\n`%/%` &lt;- function(a, b) {\n  setdiff(a, b)\n}\n\nx &lt;- c(\"a\", \"b\", \"d\")\ny &lt;- c(\"a\", \"c\", \"d\")\n\nx %u% y\n\n#&gt; [1] \"a\" \"b\" \"d\" \"c\"\n\nx %n% y\n\n#&gt; [1] \"a\" \"d\"\n\nx %/% y\n\n#&gt; [1] \"b\"",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-20",
    "href": "analysis/advanced-r-1.html#exercises-20",
    "title": "Advanced R (Foundations)",
    "section": "7.2.7 Exercises",
    "text": "7.2.7 Exercises\n\nList three ways in which an environment differs from a list.\n\nAnswer:\n\nEvery name in an environment must be unique\nEnvironment names are not ordered\nEnvironments have parents (except the empty environment)\nEnvironments are not copied when modified\n\nAR Solutions: The most important differences between environments and lists are:\n\nenvironments have reference semantics (i.e. they don’t copy-on-modify)\nenvironments have parents\nthe contents of an environment must have unique names\nthe contents of an environment are not ordered\n(environments can only be compared via identical(); not with ==)\n(environments can contain themselves)\n\n\n\nCreate an environment as illustrated by this picture.\n\n\n\ne1 &lt;- env()\ne1$loop &lt;- e1\n\nAnswer: code above.\nAR Solutions: Let’s create an environment that contains itself.\n\ne1 &lt;- env()\ne1$loop &lt;- e1\n\n# Print the environment\nenv_print(e1)\n\n#&gt; &lt;environment: 0x11807d350&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • loop: &lt;env&gt;\n\n# Verify that it contains itself\nlobstr::ref(e1)\n\n#&gt; █ [1:0x11807d350] &lt;env&gt; \n#&gt; └─loop = [1:0x11807d350]\n\n\n\n\nCreate a pair of environments as illustrated by this picture.\n\n\n\ne2 &lt;- env()\ne3 &lt;- env()\n\ne2$loop &lt;- e3\ne3$dedoop &lt;- e2\n\nAnswer: code above.\nAR Solutions: These two environments contain each other:\n\ne1 &lt;- env()\ne2 &lt;- env()\n\ne1$loop &lt;- e2\ne2$dedoop &lt;- e1\n\nlobstr::ref(e1)\n\n#&gt; █ [1:0x12ab115e8] &lt;env&gt; \n#&gt; └─loop = █ [2:0x10ec39568] &lt;env&gt; \n#&gt;          └─dedoop = [1:0x12ab115e8]\n\nlobstr::ref(e2)\n\n#&gt; █ [1:0x10ec39568] &lt;env&gt; \n#&gt; └─dedoop = █ [2:0x12ab115e8] &lt;env&gt; \n#&gt;            └─loop = [1:0x10ec39568]\n\n\n\n\nExplain why e[[1]] and e[c(\"a\", \"b\")] don’t make sense when e is an environment.\n\nAnswer: environment names are not ordered, and aren’t copied when modified, so they aren’t subsettable.\nAR Solutions: The first option doesn’t make sense, because elements of an environment are not ordered. The second option would return two objects at the same time. What data structure would they be contained inside?\n\n\nCreate a version of env_poke() that will only bind new names, never re-bind old names. Some programming languages only do this, and are known as single assignment languages.\n\n\nenv_poke_new &lt;- function(env, nm, value) {\n  if (!is.environment(env)) stop(\"env is not an enviornment\")\n  if (nm %in% names(env)) stop(\"nm '\", nm, \"' already bound\")\n  env[[nm]] &lt;- value\n}\n\ne_test &lt;- env(a = NULL, b = 2, c = \"three\")\n\nenv_poke_new(e_test, \"d\", \"success\")\ntry(env_poke_new(e_test, \"a\", \"fail\"))\n\n#&gt; Error in env_poke_new(e_test, \"a\", \"fail\") : nm 'a' already bound\n\nenv_print(e_test)\n\n#&gt; &lt;environment: 0x10e216bc0&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;NULL&gt;\n#&gt; • b: &lt;dbl&gt;\n#&gt; • c: &lt;chr&gt;\n#&gt; • d: &lt;chr&gt;\n\n\nAnswer: code above.\nAR Solutions: As described in Advanced R rlang::env_poke() takes a name (as string) and a value to assign (or reassign) a binding in an environment.\n\ne3 &lt;- new.env()\n\nenv_poke(e3, \"a\", 100)\ne3$a\n\n#&gt; [1] 100\n\nenv_poke(e3, \"a\", 200)\ne3$a\n\n#&gt; [1] 200\n\n\nSo, we want env_poke2() to test, if the supplied name is already present in the given environment. This can be checked via env_has(). If this is the case, an (informative) error is thrown.\n\nenv_poke2 &lt;- function(env, name, value) {\n  if (env_has(env, name)) {\n    abort(paste0(\"\\\"\", name, \"\\\" is already assigned to a value.\"))\n  }\n\n  env_poke(env, name, value)\n  invisible(env)\n}\n\n# Test\nenv_poke2(e3, \"b\", 100)\ne3$b\n\n#&gt; [1] 100\n\ntry(env_poke2(e3, \"b\", 200))\n\n#&gt; Error in env_poke2(e3, \"b\", 200) : \"b\" is already assigned to a value.\n\n\n\n\nWhat does this function do? How does it differ from &lt;&lt;- and why might you prefer it?\n\n\nrm(a)\n\n#&gt; Warning in rm(a): object 'a' not found\n\nrebind &lt;- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\ntry(rebind(\"a\", 10))\n\n#&gt; Error : Can't find `a`\n\n(a &lt;- 5)\n\n#&gt; [1] 5\n\nrebind(\"a\", 10)\na\n\n#&gt; [1] 10\n\n\nAnswer: &lt;&lt;- will assign a value to the name in the global environment if the name is not found, rebind() does not.\nAR Solutions: The primary difference between rebind() and &lt;&lt;- is that rebind() will only carry out an assignment when it finds an existing binding; unlike &lt;&lt;- it will never create a new one in the global environment. This behaviour of &lt;&lt;- is usually undesirable because global variables introduce non-obvious dependencies between functions.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-21",
    "href": "analysis/advanced-r-1.html#exercises-21",
    "title": "Advanced R (Foundations)",
    "section": "7.3.1 Exercises",
    "text": "7.3.1 Exercises\n\nModify where() to return all environments that contain a binding for name. Carefully think through what type of object the function will need to return.\n\n\nwhere &lt;- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n\nx &lt;- 5\ntry(where(\"yyy\"))\n\n#&gt; Error : Can't find yyy\n\nwhere(\"x\")\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nwhere(\"mean\")\n\n#&gt; &lt;environment: base&gt;\n\nall_where &lt;- function(name, env = caller_env(), found = list()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    found\n  } else if (env_has(env, name)) {\n    # Success case\n    all_where(name, env_parent(env), append(env, found, after = 0))\n  } else {\n    # Recursive case\n    all_where(name, env_parent(env), found)\n  }\n}\n\nall_where(\"x\")\n\n#&gt; [[1]]\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nlocal({\n  x &lt;- 10\n  all_where(\"x\")\n})\n\n#&gt; [[1]]\n#&gt; &lt;environment: 0x10e2dfa68&gt;\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nAnswer: code above.\nAR Solutions: where() searches (recursively) for a given name within a given environment and its ancestors. If where() finds the name in one of these environments, it returns the environment’s name. Otherwise, it throws an error.\nOur modified version of where() will always recurse until it reaches the empty environment. No matter if it has already found the name or not. Along the way, it will check each environment for the given name. Finally, it will return a list of environments where the binding was found; if no binding was found, the list will be empty.\nPlease also note how the list is initialised via the default argument, when the function is called for the first time. This is a bit confusing, which is why it’s common to wrap a recursive function inside another, more user friendly, function.\n\nwhere2 &lt;- function(name, env = caller_env(), results = list()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    results\n  } else {\n    # Recursive case\n    if (env_has(env, name)) {\n      results &lt;- c(results, env)\n    }\n    where2(name, env_parent(env), results)\n  }\n}\n# Test\ne1a &lt;- env(empty_env(), a = 1, b = 2)\ne1b &lt;- env(e1a, b = 10, c = 11)\ne1c &lt;- env(e1b, a = 12, d = 13)\nwhere2(\"a\", e1c)\n\n#&gt; [[1]]\n#&gt; &lt;environment: 0x10ff16a58&gt;\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;environment: 0x10fe428d0&gt;\n\n\n\n\nWrite a function called fget() that finds only function objects. It should have two arguments, name and env, and should obey the regular scoping rules for functions: if there’s an object with a matching name that’s not a function, look in the parent. For an added challenge, also add an inherits argument which controls whether the function recurses up the parents or only looks in one environment.\n\n\nfget &lt;- function(name, env = caller_env(), inherits = TRUE) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name) && is.function(env[[name]])) {\n    # Success case\n    env\n  } else if (inherits) {\n    # Recursive case\n    fget(name, env_parent(env))\n  } else {\n    stop(\"Can't find \", name, call. = FALSE)\n  }\n}\n\ntry(fget(\"x\"))\n\n#&gt; Error : Can't find x\n\nfget(\"print\")\n\n#&gt; &lt;environment: base&gt;\n\ntry(fget(\"print\", inherits = FALSE))\n\n#&gt; Error : Can't find print\n\nfget(\"all_where\", inherits = FALSE)\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nAnswer: code above.\nAR Solutions: We follow a similar approach to the previous exercise. This time we additionally check if the found object is a function and implement an argument to turn off the recursion, if desired.\n\nfget &lt;- function(name, env = caller_env(), inherits = TRUE) {\n  # Base case\n  if (env_has(env, name)) {\n    obj &lt;- env_get(env, name)\n    if (is.function(obj)) {\n      return(obj)\n    }\n  }\n  if (identical(env, emptyenv()) || !inherits) {\n    stop(\"Could not find a function called \\\"\", name, \"\\\".\",\n      call. = FALSE\n    )\n  }\n\n  # Recursive Case\n  fget(name, env_parent(env))\n}\n\n# Test\nmean &lt;- 10\nfget(\"mean\", inherits = TRUE)\n\n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x12c39a5e0&gt;\n#&gt; &lt;environment: namespace:base&gt;",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-22",
    "href": "analysis/advanced-r-1.html#exercises-22",
    "title": "Advanced R (Foundations)",
    "section": "7.4.5 Exercises",
    "text": "7.4.5 Exercises\n\nHow is search_envs() different from env_parents(global_env())?\n\nAnswer: search_envs() includes the global environment. env_parents(global_env()) doesn’t include the global environment and also returns the empty environment (the top parent).\nAR Solutions: search_envs() returns all the environments on the search path, which is “a chain of environments containing exported functions of attached packages” (from ?search_envs). Every time you attach a new package, this search path will grow. The search path ends with the base-environment. The global environment is included, because functions present in the global environment will always be part of the search path.\nenv_parents(global_env()) will list all the ancestors of the global environment, therefore the global environment itself is not included. This also includes the “ultimate ancestor”, the empty environment. This environment is not considered part of the search path because it contains no objects.\n\n\nDraw a diagram that shows the enclosing environments of this function:\n\n\nf1 &lt;- function(x1) {\n  f2 &lt;- function(x2) {\n    f3 &lt;- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)\n\nAnswer: No.\n\n\nWrite an enhanced version of str() that provides more information about functions. Show where the function was found and what environment it was defined in.\n\n\ne_str &lt;- function(object, ...) {\n  str(object, ...)\n  if (is.function(object)) {\n    message(\"fn_env():\")\n    print(fn_env(object))\n    message(\"environment():\")\n    print(environment(object))\n  }\n}\n\ne_str(print)\n\n#&gt; function (x, ...)\n\n\n#&gt; fn_env():\n\n\n#&gt; &lt;environment: namespace:base&gt;\n\n\n#&gt; environment():\n\n\n#&gt; &lt;environment: namespace:base&gt;\n\ne_str(fget)\n\n#&gt; function (name, env = caller_env(), inherits = TRUE)  \n#&gt;  - attr(*, \"srcref\")= 'srcref' int [1:8] 1 9 17 1 9 1 1 17\n#&gt;   ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' &lt;environment: 0x118712dd0&gt;\n\n\n#&gt; fn_env():\n\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n#&gt; environment():\n\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nAnswer: code above.\nAR Solutions: To solve this problem, we need to write a function that takes the name of a function and looks for that function returning both the function and the environment that it was found in.\n\nfget2 &lt;- function(name, env = caller_env()) {\n  # Base case\n  if (env_has(env, name)) {\n    obj &lt;- env_get(env, name)\n    if (is.function(obj)) {\n      return(list(fun = obj, env = env))\n    }\n  }\n  if (identical(env, emptyenv())) {\n    stop(\"Could not find a function called \\\"\", name, \"\\\"\",\n      call. = FALSE\n    )\n  }\n  # Recursive Case\n  fget2(name, env_parent(env))\n}\n\nfstr &lt;- function(fun_name, env = caller_env()) {\n  if (!is.character(fun_name) && length(fun_name) == 1) {\n    stop(\"`fun_name` must be a string.\", call. = FALSE)\n  }\n  fun_env &lt;- fget2(fun_name, env)\n  list(\n    where = fun_env$env,\n    enclosing = fn_env(fun_env$fun)\n  )\n}\n\n# Test\nfstr(\"mean\")\n\n#&gt; $where\n#&gt; &lt;environment: base&gt;\n#&gt; \n#&gt; $enclosing\n#&gt; &lt;environment: namespace:base&gt;\n\n\nOnce you have learned about tidy evaluation, you could rewrite fstr() to use enquo() so that you’d call it more like str(), i.e. fstr(sum).",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-23",
    "href": "analysis/advanced-r-1.html#exercises-23",
    "title": "Advanced R (Foundations)",
    "section": "7.5.5 Exercises",
    "text": "7.5.5 Exercises\n\nWrite a function that lists all the variables defined in the environment in which it was called. It should return the same results as ls().\n\n\nmy_ls &lt;- function() {\n  vars &lt;- sort(names(parent.frame()))\n  vars[!startsWith(vars, \".\")]\n}\n\nls()\n\n#&gt;  [1] \"a\"            \"all_where\"    \"e_str\"        \"e_test\"       \"e1\"          \n#&gt;  [6] \"e1a\"          \"e1b\"          \"e1c\"          \"e2\"           \"e3\"          \n#&gt; [11] \"env_poke_new\" \"env_poke2\"    \"fget\"         \"fget2\"        \"fstr\"        \n#&gt; [16] \"mean\"         \"my_ls\"        \"rebind\"       \"where\"        \"where2\"      \n#&gt; [21] \"x\"\n\nmy_ls()\n\n#&gt;  [1] \"a\"            \"all_where\"    \"e_str\"        \"e_test\"       \"e1\"          \n#&gt;  [6] \"e1a\"          \"e1b\"          \"e1c\"          \"e2\"           \"e3\"          \n#&gt; [11] \"env_poke_new\" \"env_poke2\"    \"fget\"         \"fget2\"        \"fstr\"        \n#&gt; [16] \"mean\"         \"my_ls\"        \"rebind\"       \"where\"        \"where2\"      \n#&gt; [21] \"x\"\n\n\nAnswer: code above.\nAR Solutions: We can implement this dynamic scoping behaviour by explicitly referencing the caller environment. Please note that this approach returns also variables starting with a dot, an option that ls() usually requires.\n\nls2 &lt;- function(env = caller_env()) {\n  sort(env_names(env))\n}\n\n# Test in global environment\nls(all.names = TRUE)\n\n#&gt;  [1] \".main\"        \".Random.seed\" \"a\"            \"all_where\"    \"e_str\"       \n#&gt;  [6] \"e_test\"       \"e1\"           \"e1a\"          \"e1b\"          \"e1c\"         \n#&gt; [11] \"e2\"           \"e3\"           \"env_poke_new\" \"env_poke2\"    \"fget\"        \n#&gt; [16] \"fget2\"        \"fstr\"         \"ls2\"          \"mean\"         \"my_ls\"       \n#&gt; [21] \"rebind\"       \"where\"        \"where2\"       \"x\"\n\nls2()\n\n#&gt;  [1] \".main\"        \".Random.seed\" \"a\"            \"all_where\"    \"e_str\"       \n#&gt;  [6] \"e_test\"       \"e1\"           \"e1a\"          \"e1b\"          \"e1c\"         \n#&gt; [11] \"e2\"           \"e3\"           \"env_poke_new\" \"env_poke2\"    \"fget\"        \n#&gt; [16] \"fget2\"        \"fstr\"         \"ls2\"          \"mean\"         \"my_ls\"       \n#&gt; [21] \"rebind\"       \"where\"        \"where2\"       \"x\"\n\n# Test in \"sandbox\" environment\ne1 &lt;- env(a = 1, b = 2)\nls(e1)\n\n#&gt; [1] \"a\" \"b\"\n\nls2(e1)\n\n#&gt; [1] \"a\" \"b\"",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-24",
    "href": "analysis/advanced-r-1.html#exercises-24",
    "title": "Advanced R (Foundations)",
    "section": "8.2.4 Exercises",
    "text": "8.2.4 Exercises\n\nWrite a wrapper around file.remove() that throws an error if the file to be deleted does not exist.\n\n\nsafe_file_remove &lt;- function(...) {\n  if (!file.exists(...)) stop(\"file '\", ..., \"' does not exist\")\n  file.remove(...)\n}\n\ntmp &lt;- tempfile()\n\nfile.create(tmp)\n\n#&gt; [1] TRUE\n\nsafe_file_remove(tmp)\n\n#&gt; [1] TRUE\n\nfile.remove(tmp)\n\n#&gt; Warning in file.remove(tmp): cannot remove file\n#&gt; '/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//RtmpXZ1Q0P/file12f2836943044',\n#&gt; reason 'No such file or directory'\n\n\n#&gt; [1] FALSE\n\ntry(safe_file_remove(tmp))\n\n#&gt; Error in safe_file_remove(tmp) : \n#&gt;   file '/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//RtmpXZ1Q0P/file12f2836943044' does not exist\n\n\nAnswer: code above.\nAR Solutions: We prefer the following solution for its clarity and simplicity:\n\nfile_remove_strict &lt;- function(path) {\n  if (!file.exists(path)) {\n    stop(\"Can't delete the file \\\"\", path,\n      \"\\\" because it doesn't exist.\",\n      call. = FALSE\n    )\n  }\n  file.remove(path)\n}\n\n# Test\nsaveRDS(mtcars, \"mtcars.rds\")\nfile_remove_strict(\"mtcars.rds\")\n\n#&gt; [1] TRUE\n\ntry(file_remove_strict(\"mtcars.rds\"))\n\n#&gt; Error : Can't delete the file \"mtcars.rds\" because it doesn't exist.\n\n\n\n\nWhat does the appendLF argument to message() do? How is it related to cat()?\n\nAnswer: appendLF controls whether or not a newline is added to the message; by default, cat() does not add a newline.\nAR Solutions: The appendLF argument automatically appends a new line to the message.\nComparable behaviour regarding line breaks for cat() can be achieved via setting its sep argument to \"\\n\".",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-25",
    "href": "analysis/advanced-r-1.html#exercises-25",
    "title": "Advanced R (Foundations)",
    "section": "8.4.5 Exercises",
    "text": "8.4.5 Exercises\n\nWhat extra information does the condition generated by abort() contain compared to the condition generated by stop() i.e. what’s the difference between these two objects? Read the help for ?abort to learn more.\n\n\ncatch_cnd(stop(\"An error\"))\n\n#&gt; &lt;simpleError in force(expr): An error&gt;\n\ncatch_cnd(abort(\"An error\"))\n\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! An error\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆\n\n\nAnswer: abort() includes the error message and backtrace in the condition object. abort() uses the custom class rlang_error.\nAR Solutions: In contrast to stop(), which contains the call, abort() stores the whole backtrace generated by rlang::trace_back(). This is a lot of extra data!\n\n\nPredict the results of evaluating the following code\n\n\nshow_condition &lt;- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\")) #&gt; \"error\"\n\n#&gt; [1] \"error\"\n\nshow_condition(10) #&gt; 10 [NULL]\n\n#&gt; NULL\n\nshow_condition(warning(\"?!\")) #&gt; \"warning\"\n\n#&gt; [1] \"warning\"\n\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n#&gt; [1] \"message\"\n\n#&gt; 10\n#&gt; \"message\"\n#&gt; \"warning\"\n\nAnswer: predictions in comments. The prediction for show_condition(10) was incorrect; the correct answer is NULL as that’s what’s returned when there is no condition. The final prediction was also incorrect; the tryCatch() call stops further execution when the message() is caught.\nAR Solutions: The first three examples are straightforward:\n\nshow_condition(stop(\"!\")) # stop raises an error\n\n#&gt; [1] \"error\"\n\nshow_condition(10) # no condition is signalled\n\n#&gt; NULL\n\nshow_condition(warning(\"?!\")) # warning raises a warning\n\n#&gt; [1] \"warning\"\n\n\nThe last example is the most interesting and makes us aware of the exiting qualities of tryCatch(); it will terminate the evaluation of the code as soon as it is called.\n\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n#&gt; [1] \"message\"\n\n\n\n\nExplain the results of running this code:\n\n\nwithCallingHandlers(\n  message = function(cnd) message(\"b\"), # handler 1\n  withCallingHandlers(\n    message = function(cnd) message(\"a\"), # handler 2\n    message(\"c\")\n  )\n)\n\n#&gt; b\n\n\n#&gt; a\n\n\n#&gt; b\n\n\n#&gt; c\n\n\nAnswer:\n\nmessage(\"c\") is caught, handler 2 is called\nin handler 2, message(\"a\") is caught and handler 1 is called\nhandler 1 writes message b\ncode resumes and handler 2 writes message a\nmessage(\"c\") propagates to the parent, is caught, and handler 1 is called\nhandler 1 writes message b\ncode resumes and the code writes message c\n\nAR Solutions: It’s a little tricky to untangle the flow here: First, message(\"c\") is run, and it’s caught by (1). It then calls message(\"a\"), which is caught by (2), which calls message(\"b\"). message(\"b\") isn’t caught by anything, so we see a b on the console, followed by a. But why do we get another b before we see c? That’s because we haven’t handled the message, so it bubbles up to the outer calling handler.\n\n\nRead the source code for catch_cnd() and explain how it works.\n\n\ncatch_cnd\n\n#&gt; function (expr, classes = \"condition\") \n#&gt; {\n#&gt;     stopifnot(is_character(classes))\n#&gt;     handlers &lt;- rep_named(classes, list(identity))\n#&gt;     eval_bare(rlang::expr(tryCatch(!!!handlers, {\n#&gt;         force(expr)\n#&gt;         return(NULL)\n#&gt;     })))\n#&gt; }\n#&gt; &lt;bytecode: 0x10a06f398&gt;\n#&gt; &lt;environment: namespace:rlang&gt;\n\ncatch_cnd(stop(\"error\"))\n\n#&gt; &lt;simpleError in force(expr): error&gt;\n\n# replicate the core functionality\ntryCatch(condition = function(x) x, force(stop(\"error\")))\n\n#&gt; &lt;simpleError in force(stop(\"error\")): error&gt;\n\n\nAnswer: catch_cnd() uses tryCatch() to catch any condition and return itself using identity().\nAR Solutions: At the time Advanced R was written, the source for catch_cnd() was a little simpler:\n\ncatch_cnd &lt;- function(expr) {\n  tryCatch(\n    condition = function(cnd) cnd,\n    {\n      force(expr)\n      return(NULL)\n    }\n  )\n}\n\ncatch_cnd() is a simple wrapper around tryCatch(). If a condition is signalled, it’s caught and returned. If no condition is signalled, execution proceeds sequentially and the function returns NULL.\nThe current version of catch_cnd() is a little more complex because it allows you to specify which classes of condition you want to capture. This requires some manual code generation because the interface of tryCatch() provides condition classes as argument names.\n\n\nHow could you rewrite show_condition() to use a single handler?\n\n\nshow_condition2 &lt;- function(code) {\n  tryCatch(\n    condition = function(cnd) {\n      if (is_error(cnd)) {\n        return(\"error\")\n      }\n      if (is_warning(cnd)) {\n        return(\"warning\")\n      }\n      if (is_message(cnd)) {\n        return(\"message\")\n      }\n    },\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition2(stop(\"!\"))\n\n#&gt; [1] \"error\"\n\nshow_condition2(10)\n\n#&gt; NULL\n\nshow_condition2(warning(\"?!\"))\n\n#&gt; [1] \"warning\"\n\nshow_condition2({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n#&gt; [1] \"message\"\n\n\nAnswer: code above.\nAR Solutions: show_condition() was defined in one of the previous questions. Let’s use the condition argument of tryCatch() as shown in rlang::catch_cond() above for our re-implementation:\n\nshow_condition2 &lt;- function(code) {\n  tryCatch(\n    condition = function(cnd) {\n      if (inherits(cnd, \"error\")) {\n        return(\"error\")\n      }\n      if (inherits(cnd, \"warning\")) {\n        return(\"warning\")\n      }\n      if (inherits(cnd, \"message\")) {\n        return(\"message\")\n      }\n    },\n    {\n      code\n      NULL\n    }\n  )\n}\n\n# Test\nshow_condition2(stop(\"!\"))\n\n#&gt; [1] \"error\"\n\nshow_condition2(10)\n\n#&gt; NULL\n\nshow_condition2(warning(\"?!\"))\n\n#&gt; [1] \"warning\"\n\nshow_condition2({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n#&gt; [1] \"message\"\n\n\ntryCatch() executes the code and captures any condition raised. The function provided as the condition handles this condition. In this case it dispatches on the class of the condition.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-26",
    "href": "analysis/advanced-r-1.html#exercises-26",
    "title": "Advanced R (Foundations)",
    "section": "8.5.4 Exercises",
    "text": "8.5.4 Exercises\n\nInside a package, it’s occasionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with requireNamespace(\"pkg\", quietly = FALSE)) and if not, throws a custom condition that includes the package name in the metadata.\n\n\nmy_check_installed &lt;- function(pkg) {\n  if (!requireNamespace(pkg, quietly = TRUE)) {\n    abort(\n      \"error_not_found\",\n      message = paste0(\"package '\", pkg, \"' not found\"),\n      pkg = pkg\n    )\n  }\n}\n\nmy_check_installed(\"rlang\")\n# NOTE: this code causes renv::dependencies() to mistakenly report package 'pkg' as a dependency\n# requireNamespace(\"pkg\", quietly = FALSE)\n# err &lt;- catch_cnd(my_check_installed(\"pkg\"))\n# err\n# err$pkg\ntry(my_check_installed(\"pkg\"))\n\n#&gt; Error in my_check_installed(\"pkg\") : package 'pkg' not found\n\n\nAnswer: code above. The question specifies to use quietly = FALSE, but this approach makes more sense (to me). The alternative is to catch the ‘Failed with error:’ message which seems less reliable.\n\nmy_check_installed2 &lt;- function(pkg) {\n  tryCatch(\n    condition = function(cnd) {\n      abort(\n        \"error_not_found\",\n        message = paste0(\"package '\", pkg, \"' not found\"),\n        pkg = pkg\n      )\n    },\n    requireNamespace(pkg, quietly = FALSE)\n  )\n}\n\nmy_check_installed2(\"rlang\")\ntry(my_check_installed2(\"pkg\"))\n\n#&gt; Error in value[[3L]](cond) : package 'pkg' not found\n\n\nThe alternative version, my_check_installed2() works but its Backtrace is harder to read.\nAR Solutions: We use rlang::abort() to supply error metadata:\n\ncheck_installed &lt;- function(package) {\n  if (!requireNamespace(package, quietly = FALSE)) {\n    abort(\n      \"error_pkg_not_found\",\n      message = paste0(\"package '\", package, \"' not installed.\"),\n      package = package\n    )\n  }\n  TRUE\n}\ncheck_installed(\"rlang\")\n\n#&gt; [1] TRUE\n\ntry(check_installed(\"ggplot3\"))\n\n#&gt; Loading required namespace: ggplot3\n\n\n#&gt; Error in check_installed(\"ggplot3\") : package 'ggplot3' not installed.\n\n\n\n\nInside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?\n\nAnswer: return custom error objects that aren’t dependent on the error text (like in 8.5.3)\nAR Solutions: Instead of returning an error it might be preferable to throw a customised condition and place a standardised error message inside the metadata. Then the downstream package could check for the class of the condition, rather than inspecting the message.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#exercises-27",
    "href": "analysis/advanced-r-1.html#exercises-27",
    "title": "Advanced R (Foundations)",
    "section": "8.6.6 Exercises",
    "text": "8.6.6 Exercises\n\nCreate suppressConditions() that works like suppressMessages() and suppressWarnings() but suppresses everything. Think carefully about how you should handle errors.\n\n\nsuppressConditions &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) invisible(cnd),\n    withCallingHandlers(\n      condition = function(cnd) {\n        cnd_muffle(cnd)\n      },\n      expr\n    )\n  )\n}\n\nsup &lt;- suppressConditions({\n  message(\"processing...\")\n  warning(\"something went wrong\")\n  print(\"still running\")\n  stop(\"error\")\n  print(\"this shouldn't run\")\n})\n\n#&gt; [1] \"still running\"\n\nstr(sup)\n\n#&gt; List of 2\n#&gt;  $ message: chr \"error\"\n#&gt;  $ call   : language withCallingHandlers(condition = function(cnd) {     cnd_muffle(cnd) ...\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n\nAnswer: code above. Errors are not printed, but are returned, invisibly.\nAR Solutions: In general, we would like to catch errors, since they contain important information for debugging. To suppress the error message and hide the returned error object from the console, we handle errors within a tryCatch() and return the error object invisibly:\n\nsuppressErrors &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) invisible(cnd),\n    interrupt = function(cnd) {\n      stop(\"Terminated by the user.\",\n        call. = FALSE\n      )\n    },\n    expr\n  )\n}\n\nAfter we defined the error handling, we can just combine it with the other handlers to create suppressConditions():\n\nsuppressConditions &lt;- function(expr) {\n  suppressErrors(suppressWarnings(suppressMessages(expr)))\n}\n\nTo test the new function, we apply it to a set of conditions and inspect the returned error object.\n\n# The messages/warnings/conditions are suppressed successfully\nerror_obj &lt;- suppressConditions({\n  message(\"message\")\n  warning(\"warning\")\n  abort(\"error\")\n})\nerror_obj\n\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! error\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆\n\n\n\n\nCompare the following two implementations of message2error(). What is the main advantage of withCallingHandlers() in this scenario? (Hint: look carefully at the traceback.)\n\n\nmessage2error &lt;- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\n\nmessage2error2 &lt;- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\n\nAnswer: message2error() shows the invocation of message() in the traceback, but message2error2() does not.\nAR Solutions: Both functions differ in the way conditions are handled. withCallingHandlers() creates a calling handler, which is executed from within the signalling function. This makes it possible to record a detailed call stack, which helps us identify the signalling condition.\ntryCatch() defines an exiting handler, which means that the signalling function is terminated as soon as a condition is raised. It also returns control to the context where tryCatch() was called.\nIn this example the use of withCallingHandlers() returns more information than the use of tryCatch(). This allows us to determine the exact call that raised the condition.\n\nmessage2error1 &lt;- function(code) {\n  withCallingHandlers(code, message = function(e) stop(\"error\"))\n}\n\nmessage2error1({\n  1\n  message(\"hidden error\")\n  NULL\n})\n#&gt; Error in (function (e) : error\ntraceback()\n#&gt; 9: stop(\"error\") at #2\n#&gt; 8: (function (e)\n#&gt;    stop(\"error\"))(list(message = \"hidden error\\n\",\n#&gt;      call = message(\"hidden error\")))\n#&gt; 7: signalCondition(cond)\n#&gt; 6: doWithOneRestart(return(expr), restart)\n#&gt; 5: withOneRestart(expr, restarts[[1L]])\n#&gt; 4: withRestarts({\n#&gt;        signalCondition(cond)\n#&gt;        defaultHandler(cond)\n#&gt;    }, muffleMessage = function() NULL)\n#&gt; 3: message(\"hidden error\") at #1\n#&gt; 2: withCallingHandlers(code,\n#&gt;      message = function(e) stop(\"error\")) at #2\n#&gt; 1: message2error1({\n#&gt;        1\n#&gt;        message(\"hidden error\")\n#&gt;        NULL\n#&gt;    })\n\n\nmessage2error2 &lt;- function(code) {\n  tryCatch(code, message = function(e) (stop(\"error\")))\n}\n\nmessage2error2({\n  1\n  stop(\"hidden error\")\n  NULL\n})\n#&gt; Error in value[[3L]](cond) : error\ntraceback()\n#&gt; 6: stop(\"error\") at #2\n#&gt; 5: value[[3L]](cond)\n#&gt; 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt; 3: tryCatchList(expr, classes, parentenv, handlers)\n#&gt; 2: tryCatch(code, message = function(e) (stop(\"error\"))) at #2\n#&gt; 1: message2error2({\n#&gt;        1\n#&gt;        message(\"hidden error\")\n#&gt;        NULL\n#&gt;    })\n\n\n\nHow would you modify the catch_cnds() definition if you wanted to recreate the original intermingling of warnings and messages?\n\nAnswer: as noted in Advanced R Solutions, “It looks like Hadley wrote a part of the chapter after the exercises, as the catch_cnds() function defined in the chapter already solves this problem by storing all messages and warnings in their original order within a list.”\n\n\nWhy is catching interrupts dangerous? Run this code to find out.\n\n\nbottles_of_beer &lt;- function(i = 99) {\n  message(\n    \"There are \", i, \" bottles of beer on the wall, \",\n    i, \" bottles of beer.\"\n  )\n  while (i &gt; 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i &lt;&lt;- i - 1\n        if (i &gt; 0) {\n          message(\n            \"Take one down, pass it around, \", i,\n            \" bottle\", if (i &gt; 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \",\n    \"no more bottles of beer.\"\n  )\n}\n\nAnswer: this prevents user interrupts (control-c) from halting the code, which in this case can be pretty annoying if run with the defaults, requiring 99 interrupts (or just “Restart R”).\nAR Solutions: When running the bottles_of_beer() function in your console, the output should look somehow like the following:\n\nbottles_of_beer()\n#&gt; There are 99 bottles of beer on the wall, 99 bottles of beer.\n#&gt; Take one down, pass it around, 98 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 97 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 96 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 95 bottles of beer on the wall.\n#&gt;\n\nAt this point you’ll probably recognise how hard it is to get the number of bottles down from 99 to 0. There’s no way to break out of the function because we’re capturing the interrupt that you’d usually use!",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html",
    "href": "analysis/advanced-r-2.html",
    "title": "Advanced R (Functional programming)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Functional programming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions.\nlibrary(purrr)\nlibrary(palmerpenguins)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(rlang)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises",
    "href": "analysis/advanced-r-2.html#exercises",
    "title": "Advanced R (Functional programming)",
    "section": "9.2.6 Exercises",
    "text": "9.2.6 Exercises\n\nUse as_mapper() to explore how purrr generates anonymous functions for the integer, character, and list helpers. What helper allows you to extract attributes? Read the documentation to find out.\n\n\nmap_dbl\n\n#&gt; function (.x, .f, ..., .progress = FALSE) \n#&gt; {\n#&gt;     map_(\"double\", .x, .f, ..., .progress = .progress)\n#&gt; }\n#&gt; &lt;bytecode: 0x1166072a8&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\nmap_dbl(mtcars, ~ length(unique(.x)))\n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nas_mapper(~ length(unique(.x)))\n\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; length(unique(.x))\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\n\nfunction(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))\n\n#&gt; function(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))\n\nas_mapper(mean)\n\n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x105474aa8&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nas_mapper(function(x) mean(x, na.rm = TRUE))\n\n#&gt; function(x) mean(x, na.rm = TRUE)\n\nas_mapper(~ mean(.x, na.rm = TRUE))\n\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; mean(.x, na.rm = TRUE)\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\n\n\nAnswer: Exploration above. attr_getter() supports extraction of attributes.\nAR Solutions: map() offers multiple ways (functions, formulas, and extractor functions) to specify its function argument (.f). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of as_mapper() and it is called every time map() is used.\nGiven character, numeric or list input as_mapper() will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.\nThe extractor function is implemented as a call to purrr::pluck(), which accepts a list of accessors (accessors “access” some part of your data object).\n\nas_mapper(c(1, 2)) # equivalent to function(x) x[[1]][[2]]\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(1, 2), .default = NULL)\n#&gt; &lt;environment: 0x1056fa358&gt;\n\nas_mapper(c(\"a\", \"b\")) # equivalent to function(x) x[[\"a\"]][[\"b]]\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(\"a\", \"b\"), .default = NULL)\n#&gt; &lt;environment: 0x105670108&gt;\n\nas_mapper(list(1, \"b\")) # equivalent to function(x) x[[1]][[\"b]]\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(1, \"b\"), .default = NULL)\n#&gt; &lt;environment: 0x1056058e8&gt;\n\n\nBesides mixing positions and names, it is also possible to pass along an accessor function. This is basically an anonymous function that gets information about some aspect of the input data. You are free to define your own accessor functions.\nIf you need to access certain attributes, the helper attr_getter(y) is already predefined and will create the appropriate accessor function for you.\n\n# Define custom accessor function\nget_class &lt;- function(x) attr(x, \"class\")\npluck(mtcars, get_class)\n\n#&gt; [1] \"data.frame\"\n\n# Use attr_getter() as a helper\npluck(mtcars, attr_getter(\"class\"))\n\n#&gt; [1] \"data.frame\"\n\n\nNote: AR Solutions provides good additional insight into as_mapper().\n\n\nmap(1:3, ~ runif(2)) is a useful pattern for generating random numbers, but map(1:3, runif(2)) is not. Why not? Can you explain why it returns the result that it does?\n\n\nmap(1:3, ~ runif(2))\n\n#&gt; [[1]]\n#&gt; [1] 0.28898204 0.03080936\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 0.8084078 0.4821147\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 0.8528816 0.7083845\n\nmap(1:3, runif(2))\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\n\nAnswer: ~ runif(2) generates a mapper that returns 2 random values from the uniform distribution, where runif(2) creates a pluck() mapper with 2 random values, which will (nearly) always return NULL, as demonstrated by the code below:\n\nas_mapper(~ runif(2))\n\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; runif(2)\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\n\nas_mapper(runif(2))\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(0.604344471124932, 0.0218792946543545), .default = NULL)\n#&gt; &lt;environment: 0x10693af08&gt;\n\n\nA more reasonable use of a pluck mapper for 1:3 is 1:\n\nmap(1:3, 1)\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\n\nAR Solutions: The first pattern creates multiple random numbers, because ~ runif(2) successfully uses the formula interface. Internally map() applies as_mapper() to this formula, which converts ~ runif(2) into an anonymous function. Afterwards runif(2) is applied three times (one time during each iteration), leading to three different pairs of random numbers.\nIn the second pattern runif(2) is evaluated once, then the results are passed to map(). Consequently as_mapper() creates an extractor function based on the return values from runif(2) (via pluck()). This leads to three NULLs (pluck()’s .default return), because no values corresponding to the index can be found.\nNote: AR Solutions provides additional detail, but is otherwise the same.\n\n\nUse the appropriate map() function to:\n\nCompute the standard deviation of every column in a numeric data frame.\nCompute the standard deviation of every numeric column in a mixed data frame. (Hint: you’ll need to do it in two steps.)\nCompute the number of levels for every factor in a data frame.\n\n\n\n# a\nmap_dbl(mtcars, sd)\n\n#&gt;         mpg         cyl        disp          hp        drat          wt \n#&gt;   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574 \n#&gt;        qsec          vs          am        gear        carb \n#&gt;   1.7869432   0.5040161   0.4989909   0.7378041   1.6152000\n\n# b\nmap_dbl(iris[map_lgl(iris, is.numeric)], sd)\n\n#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#&gt;    0.8280661    0.4358663    1.7652982    0.7622377\n\n# c\nmap_int(warpbreaks, nlevels)\n\n#&gt;  breaks    wool tension \n#&gt;       0       2       3\n\n# c, excluding non-factor columns\nmap_int(warpbreaks[map_lgl(warpbreaks, is.factor)], nlevels)\n\n#&gt;    wool tension \n#&gt;       2       3\n\n\nAnswer: code above.\nAR Solutions: To solve this exercise we take advantage of calling the type stable variants of map(), which give us more concise output, and use map_lgl() to select the columns of the data frame (later you’ll learn about keep(), which simplifies this pattern a little).\n\nmap_dbl(mtcars, sd)\n\n#&gt;         mpg         cyl        disp          hp        drat          wt \n#&gt;   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574 \n#&gt;        qsec          vs          am        gear        carb \n#&gt;   1.7869432   0.5040161   0.4989909   0.7378041   1.6152000\n\npenguins_numeric &lt;- map_lgl(penguins, is.numeric)\nmap_dbl(penguins[penguins_numeric], sd, na.rm = TRUE)\n\n#&gt;    bill_length_mm     bill_depth_mm flipper_length_mm       body_mass_g \n#&gt;         5.4595837         1.9747932        14.0617137       801.9545357 \n#&gt;              year \n#&gt;         0.8183559\n\npenguins_factor &lt;- map_lgl(penguins, is.factor)\nmap_int(penguins[penguins_factor], ~ length(levels(.x))) # nolint: length_levels_linter.\n\n#&gt; species  island     sex \n#&gt;       3       3       2\n\n\nNote: my code is more concise, both with selections and use of nlevels(), although using keep() is preferable.\n\nmap_int(keep(warpbreaks, is.factor), nlevels)\n\n#&gt;    wool tension \n#&gt;       2       3\n\n\n\n\nThe following code simulates the performance of a t-test for non-normal data. Extract the p-value from each test, then visualise.\n\n\ntrials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\nhist(map_dbl(trials, \"p.value\"), breaks = 10)\n\n\n\n\n\n\n\n\nAnswer: code above.\nAR Solutions: There are many ways to visualise this data. However, since there are only 100 data points, we choose a dot plot to visualise the distribution. (Unfortunately, {ggplot2}s geom_dotplot() doesn’t compute proper counts as it was created to visualise distribution densities instead of frequencies, so a histogram would be a suitable alternative).\n\n# Advanced R Solutions uses different code for trials\ntrials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))\n\nlibrary(ggplot2)\n\ndf_trials &lt;- tibble::tibble(p_value = map_dbl(trials, \"p.value\"))\n\ndf_trials %&gt;%\n  ggplot(aes(x = p_value, fill = p_value &lt; 0.05)) +\n  geom_dotplot(binwidth = 0.01) + # geom_histogram() as alternative\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    legend.position = \"top\"\n  )\n\n\n\n\n\n\n\n\nNotes: the code AR Solutions uses for trials, trials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7))), appears to be correct compared to Advanced R.\n\n\nThe following code uses a map nested inside another map to apply a function to every element of a nested list. Why does it fail, and what do you need to do to make it work?\n\n\nx &lt;- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple &lt;- function(x) x * 3\ntry(map(x, map, .f = triple))\n\n#&gt; Error in map(x, map, .f = triple) : ℹ In index: 1.\n#&gt; Caused by error in `.f()`:\n#&gt; ! unused argument (function (.x, .f, ..., .progress = FALSE) \n#&gt; {\n#&gt;     map_(\"list\", .x, .f, ..., .progress = .progress)\n#&gt; })\n\n\nAnswer: the call fails since the .f = triple specifies the function for the outer map(), and the map is passed as an additional argument to triple(), which generates the error since triple() only takes a single argument. The solution is to pass triple as an additional argument to the outer map():\n\nmap(x, map, triple)\n\n#&gt; [[1]]\n#&gt; [[1]][[1]]\n#&gt; [1] 3\n#&gt; \n#&gt; [[1]][[2]]\n#&gt; [1]  9 27\n#&gt; \n#&gt; \n#&gt; [[2]]\n#&gt; [[2]][[1]]\n#&gt; [1]  9 18\n#&gt; \n#&gt; [[2]][[2]]\n#&gt; [1] 21\n#&gt; \n#&gt; [[2]][[3]]\n#&gt; [1] 12 21 18\n\n\nAR Solutions: This function call fails, because triple() is specified as the .f argument and consequently belongs to the outer map(). The unnamed argument map is treated as an argument of triple(), which causes the error.\nThere are a number of ways we could resolve the problem. However, there is not much to choose between them for this simple example, although it is good to know your options for more complicated cases.\n\n# Don't name the argument\nmap(x, map, triple)\n\n# Use magrittr-style anonymous function\nmap(x, . %&gt;% map(triple))\n\n# Use purrr-style anonymous function\nmap(x, ~ map(.x, triple))\n\nNote: I don’t like the magrittr-style anonymous function option. The others are good.\n\n\nUse map() to fit linear models to the mtcars dataset using the formulas stored in this list:\n\n\nformulas &lt;- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\n\nAnswer: the following code works, but doesn’t display the text of the formula in the Call:\n\nmap(formulas, lm, mtcars)\n\n#&gt; [[1]]\n#&gt; \n#&gt; Call:\n#&gt; .f(formula = .x[[i]], data = ..1)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)         disp  \n#&gt;    29.59985     -0.04122  \n#&gt; \n#&gt; \n#&gt; [[2]]\n#&gt; \n#&gt; Call:\n#&gt; .f(formula = .x[[i]], data = ..1)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)    I(1/disp)  \n#&gt;       10.75      1557.67  \n#&gt; \n#&gt; \n#&gt; [[3]]\n#&gt; \n#&gt; Call:\n#&gt; .f(formula = .x[[i]], data = ..1)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)         disp           wt  \n#&gt;    34.96055     -0.01772     -3.35083  \n#&gt; \n#&gt; \n#&gt; [[4]]\n#&gt; \n#&gt; Call:\n#&gt; .f(formula = .x[[i]], data = ..1)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)    I(1/disp)           wt  \n#&gt;      19.024     1142.560       -1.798\n\n\nAR Solutions: The data (mtcars) is constant for all these models and so we iterate over the formulas provided. As the formula is the first argument of lm(), we don’t need to specify it explicitly.\n\nmodels &lt;- map(formulas, lm, data = mtcars)\n\nNote: AR Solutions specifies data = mtcars but is otherwise the same.\n\n\nFit the model mpg ~ disp to each of the bootstrap replicates of mtcars in the list below, then extract the \\(R^2\\) of the model fit (Hint: you can compute the \\(R^2\\) with summary().)\n\n\nbootstrap &lt;- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps &lt;- map(1:10, ~ bootstrap(mtcars))\n\nmap_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)\n\n#&gt;  [1] 0.7453424 0.6263653 0.6717042 0.6913632 0.7044988 0.7600284 0.7257801\n#&gt;  [8] 0.7904557 0.7857444 0.6363400\n\n\nAnswer: code above.\nAR Solutions: To accomplish this task, we take advantage of the “list in, list out”-functionality of map(). This allows us to chain multiple transformations together. We start by fitting the models. We then calculate the summaries and extract the \\(R^2\\) values. For the last call we use map_dbl(), which provides convenient output.\n\nbootstraps %&gt;%\n  map(~ lm(mpg ~ disp, data = .x)) %&gt;%\n  map(summary) %&gt;%\n  map_dbl(\"r.squared\")\n\n#&gt;  [1] 0.7453424 0.6263653 0.6717042 0.6913632 0.7044988 0.7600284 0.7257801\n#&gt;  [8] 0.7904557 0.7857444 0.6363400\n\n\nNote: while AR Solutions is arguably slightly more readable, my code should be faster:\n\nbench::mark({\n  map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)\n})\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 { map_dbl(bootstraps, ~summary(lm(… 1.99ms 2.05ms      482.    63.7KB     55.7\n\nbench::mark({\n  bootstraps %&gt;%\n    map(~ lm(mpg ~ disp, data = .x)) %&gt;%\n    map(summary) %&gt;%\n    map_dbl(\"r.squared\")\n})\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 { bootstraps %&gt;% map(~lm(mpg ~ dis… 1.98ms 2.04ms      484.    63.7KB     61.4\n\n\nIt is actually slightly slower! AR Solutions wins!",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-1",
    "href": "analysis/advanced-r-2.html#exercises-1",
    "title": "Advanced R (Functional programming)",
    "section": "9.4.6 Exercises",
    "text": "9.4.6 Exercises\n\nExplain the results of modify(mtcars, 1).\n\n\nmodify(mtcars, 1)\n\n#&gt;    mpg cyl disp  hp drat   wt  qsec vs am gear carb\n#&gt; 1   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 2   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 3   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 4   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 5   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 6   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 7   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 8   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 9   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 10  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 11  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 12  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 13  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 14  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 15  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 16  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 17  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 18  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 19  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 20  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 21  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 22  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 23  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 24  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 25  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 26  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 27  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 28  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 29  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 30  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 31  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 32  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n\nas_mapper(1)\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(1), .default = NULL)\n#&gt; &lt;environment: 0x10708b3f8&gt;\n\nhead(mtcars, 1)\n\n#&gt;           mpg cyl disp  hp drat   wt  qsec vs am gear carb\n#&gt; Mazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n\n\nAnswer: modify(mtcars, 1) creates a mapper that plucks the first element of each column of mtcars and writes that value to every row.\nAR Solutions: modify() is based on map(), and in this case, the extractor interface will be used. It extracts the first element of each column in mtcars. modify() always returns the same structure as its input: in this case it forces the first row to be recycled 32 times. (Internally modify() uses .x[] &lt;- map(.x, .f, ...) for assignment.)\nNotes: this code makes the recycling clear:\n\nunlist(map(mtcars, 1))\n\n#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#&gt;  21.00   6.00 160.00 110.00   3.90   2.62  16.46   0.00   1.00   4.00   4.00\n\n\n\n\nRewrite the following code to use iwalk() instead of walk2(). What are the advantages and disadvantages?\n\n\ncyls &lt;- split(mtcars, mtcars$cyl)\npaths &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\nAnswer: code below.\n\ntemp &lt;- tempfile()\ndir.create(temp)\n\ncyls &lt;- split(mtcars, mtcars$cyl)\niwalk(cyls, ~ write.csv(.x, file.path(temp, paste0(\"cyl-\", .y, \".csv\"))))\ndir(temp)\n\n#&gt; [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\"\n\n\nThe main advantage of using iwalk() is that it will use seq_along() if x does not have names. In this case, x has names, and the resulting code is a bit harder to understand, and requires a formula (or function).\nAR Solutions: iwalk() allows us to use a single variable, storing the output path in the names.\n\ntemp &lt;- tempfile()\ndir.create(temp)\ncyls &lt;- split(mtcars, mtcars$cyl)\nnames(cyls) &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\niwalk(cyls, ~ write.csv(.x, .y))\n\nWe could do this in a single pipe by taking advantage of set_names():\n\nmtcars %&gt;%\n  split(mtcars$cyl) %&gt;%\n  set_names(~ file.path(temp, paste0(\"cyl-\", .x, \".csv\"))) %&gt;%\n  iwalk(~ write.csv(.x, .y))\n\nNotes: the AR Solutions use of names and the pipe is clever.\n\n\nExplain how the following code transforms a data frame using functions stored in a list.\n\n\nif (exists(\"mtcars\")) rm(mtcars)\n\n#&gt; Warning in rm(mtcars): object 'mtcars' not found\n\nmtcars\n\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#&gt; AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#&gt; Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#&gt; Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#&gt; Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#&gt; Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#&gt; Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#&gt; Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\ntrans &lt;- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm &lt;- names(trans)\nmtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))\n\nmtcars\n\n#&gt;                      mpg cyl     disp  hp drat    wt  qsec vs     am gear carb\n#&gt; Mazda RX4           21.0   6 2.621936 110 3.90 2.620 16.46  0 manual    4    4\n#&gt; Mazda RX4 Wag       21.0   6 2.621936 110 3.90 2.875 17.02  0 manual    4    4\n#&gt; Datsun 710          22.8   4 1.769807  93 3.85 2.320 18.61  1 manual    4    1\n#&gt; Hornet 4 Drive      21.4   6 4.227872 110 3.08 3.215 19.44  1   auto    3    1\n#&gt; Hornet Sportabout   18.7   8 5.899356 175 3.15 3.440 17.02  0   auto    3    2\n#&gt; Valiant             18.1   6 3.687098 105 2.76 3.460 20.22  1   auto    3    1\n#&gt; Duster 360          14.3   8 5.899356 245 3.21 3.570 15.84  0   auto    3    4\n#&gt; Merc 240D           24.4   4 2.403988  62 3.69 3.190 20.00  1   auto    4    2\n#&gt; Merc 230            22.8   4 2.307304  95 3.92 3.150 22.90  1   auto    4    2\n#&gt; Merc 280            19.2   6 2.746478 123 3.92 3.440 18.30  1   auto    4    4\n#&gt; Merc 280C           17.8   6 2.746478 123 3.92 3.440 18.90  1   auto    4    4\n#&gt; Merc 450SE          16.4   8 4.519562 180 3.07 4.070 17.40  0   auto    3    3\n#&gt; Merc 450SL          17.3   8 4.519562 180 3.07 3.730 17.60  0   auto    3    3\n#&gt; Merc 450SLC         15.2   8 4.519562 180 3.07 3.780 18.00  0   auto    3    3\n#&gt; Cadillac Fleetwood  10.4   8 7.734711 205 2.93 5.250 17.98  0   auto    3    4\n#&gt; Lincoln Continental 10.4   8 7.538066 215 3.00 5.424 17.82  0   auto    3    4\n#&gt; Chrysler Imperial   14.7   8 7.210324 230 3.23 5.345 17.42  0   auto    3    4\n#&gt; Fiat 128            32.4   4 1.289665  66 4.08 2.200 19.47  1 manual    4    1\n#&gt; Honda Civic         30.4   4 1.240503  52 4.93 1.615 18.52  1 manual    4    2\n#&gt; Toyota Corolla      33.9   4 1.165123  65 4.22 1.835 19.90  1 manual    4    1\n#&gt; Toyota Corona       21.5   4 1.968091  97 3.70 2.465 20.01  1   auto    3    1\n#&gt; Dodge Challenger    15.5   8 5.211098 150 2.76 3.520 16.87  0   auto    3    2\n#&gt; AMC Javelin         15.2   8 4.981678 150 3.15 3.435 17.30  0   auto    3    2\n#&gt; Camaro Z28          13.3   8 5.735485 245 3.73 3.840 15.41  0   auto    3    4\n#&gt; Pontiac Firebird    19.2   8 6.554840 175 3.08 3.845 17.05  0   auto    3    2\n#&gt; Fiat X1-9           27.3   4 1.294581  66 4.08 1.935 18.90  1 manual    4    1\n#&gt; Porsche 914-2       26.0   4 1.971368  91 4.43 2.140 16.70  0 manual    5    2\n#&gt; Lotus Europa        30.4   4 1.558413 113 3.77 1.513 16.90  1 manual    5    2\n#&gt; Ford Pantera L      15.8   8 5.751872 264 4.22 3.170 14.50  0 manual    5    4\n#&gt; Ferrari Dino        19.7   6 2.376130 175 3.62 2.770 15.50  0 manual    5    6\n#&gt; Maserati Bora       15.0   8 4.932517 335 3.54 3.570 14.60  0 manual    5    8\n#&gt; Volvo 142E          21.4   4 1.982839 109 4.11 2.780 18.60  1 manual    4    2\n\nrm(mtcars)\n\nCompare and contrast the map2() approach to this map() approach:\n\nmtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n\nAnswer: the map2() code applies the anonymous functions to the corresponding column in mtcars based on their name in the list:\n\nmtcars[nm] is equivalent to mtcars[c(\"disp\", \"am\")], so the code is modifying those two columns\nthe mapping function, function(f, var) f(var) is run as f(mtcars[[\"disp\"]]) and f(mtcars[[\"am\"]]), with the corresponding function in trans as f, since trans and mtcars[nm] are passed as parameters to the function\n\nThe equivalent map() approach isn’t as clean: it’s harder to understand what map() is doing.\nAR Solutions: In the first approach\n\nmtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))\n\nthe list of the 2 functions (trans) and the 2 appropriately selected data frame columns (mtcars[nm]) are supplied to map2(). map2() creates an anonymous function (f(var)) which applies the functions to the variables when map2() iterates over their (similar) indices. On the left-hand side, the respective 2 elements of mtcars are being replaced by their new transformations.\nThe map() variant\n\nmtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n\ndoes basically the same. However, it directly iterates over the names (nm) of the transformations. Therefore, the data frame columns are selected during the iteration.\nBesides the iteration pattern, the approaches differ in the possibilities for appropriate argument naming in the .f argument. In the map2() approach we iterate over the elements of x and y. Therefore, it is possible to choose appropriate placeholders like f and var. This makes the anonymous function more expressive at the cost of making it longer. We think using the formula interface in this way is preferable compared to the rather cryptic mtcars[nm] &lt;- map2(trans, mtcars[nm], ~ .x(.y)).\nIn the map() approach we map over the variable names. It is therefore not possible to introduce placeholders for the function and variable names. The formula syntax together with the .x pronoun is pretty compact. The object names and the brackets clearly indicate the application of transformations to specific columns of mtcars. In this case the iteration over the variable names comes in handy, as it highlights the importance of matching between trans and mtcars element names. Together with the replacement form on the left-hand side, this line is relatively easy to inspect.\nTo summarise, in situations where map() and map2() provide solutions for an iteration problem, several points may be considered before deciding for one or the other approach.\n\n\nWhat does write.csv() return, i.e. what happens if you use it with map2() instead of walk2()?\n\n\npaths &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nmap2(cyls, paths, write.csv)\n\n#&gt; $`4`\n#&gt; NULL\n#&gt; \n#&gt; $`6`\n#&gt; NULL\n#&gt; \n#&gt; $`8`\n#&gt; NULL\n\n\nAnswer: write.csv() is designed to return NULL, invisibly. While walk2() hides the NULL return values, map2() does not.\nAR Solutions: write.csv() returns NULL. As we call the function for its side effect (creating a CSV file), walk2() would be appropriate here. Otherwise, we receive a rather uninformative list of NULLs.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-2",
    "href": "analysis/advanced-r-2.html#exercises-2",
    "title": "Advanced R (Functional programming)",
    "section": "9.6.3 Exercises",
    "text": "9.6.3 Exercises\n\nWhy isn’t is.na() a predicate function? What base R function is closest to being a predicate version of is.na()?\n\nAnswer: is.na(x) returns logical(0) when x is NULL, which violates the rule that predicate functions only return TRUE or FALSE. anyNA(x, recursive = FALSE) appears to be a predicate version of is.na().\nAR Solutions: is.na() is not a predicate function, because it returns a logical vector the same length as the input, not a single TRUE or FALSE.\nanyNA() is the closest equivalent because it always returns a single TRUE or FALSE if there are any missing values present. You could also imagine an allNA() which would return TRUE if all values were missing, but that’s considerably less useful so base R does not provide it.\n\n\nsimple_reduce() has a problem when x is length 0 or length 1. Describe the source of the problem and how you might go about fixing it.\n\n\nsimple_reduce &lt;- function(x, f) {\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n  out\n}\n\nAnswer: using seq() results in a backwards count when x is length 0 or 1.\n\nseq(2, 0)\n\n#&gt; [1] 2 1 0\n\nseq(2, 1)\n\n#&gt; [1] 2 1\n\n\nThe fix is to check the length of x and return itself when length is 0 and throw an error when length is 1, as reduce() does.\nAR Solutions: The loop inside simple_reduce() always starts with the index 2, and seq() can count both up and down:\nTherefore, subsetting length-0 and length-1 vectors via [[ will lead to a subscript out of bounds error. To avoid this, we allow simple_reduce() to return before the for loop is started and include a default argument for 0-length vectors.\n\nsimple_reduce &lt;- function(x, f, default) {\n  if (length(x) == 0L) {\n    return(default)\n  }\n  if (length(x) == 1L) {\n    return(x[[1L]])\n  }\n\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n\n  out\n}\n\nOur new simple_reduce() now works as intended:\n\ntry(simple_reduce(integer(0), `+`))\n\n#&gt; Error in simple_reduce(integer(0), `+`) : \n#&gt;   argument \"default\" is missing, with no default\n\nsimple_reduce(integer(0), `+`, default = 0L)\n\n#&gt; [1] 0\n\nsimple_reduce(1, `+`)\n\n#&gt; [1] 1\n\nsimple_reduce(1:3, `+`)\n\n#&gt; [1] 6\n\n\n\n\nImplement the span() function from Haskell: given a list x and a predicate function f, span(x, f) returns the location of the longest sequential run of elements where the predicate is true. (Hint: you might find rle() helpful.)\n\n\ntest &lt;- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:39))\ntest2 &lt;- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:40))\n\nspan &lt;- function(x, f) {\n  runs &lt;- rle(map_lgl(x, f))\n  max_true &lt;- max_index &lt;- 0\n  index &lt;- 1\n  for (i in seq_along(runs$values)) {\n    if (runs$values[i] && runs$lengths[i] &gt; max_true) {\n      max_true &lt;- runs$lengths[i]\n      max_index &lt;- index\n    }\n    index &lt;- index + runs$lengths[i]\n  }\n  max_index\n}\n\nspan(test, is.numeric)\n\n#&gt; [1] 22\n\nspan(test2, is.numeric)\n\n#&gt; [1] 47\n\nspan(1, is.numeric)\n\n#&gt; [1] 1\n\nspan(\"a\", is.numeric)\n\n#&gt; [1] 0\n\nspan(list(\"a\", 1:10, 1:20), is.numeric)\n\n#&gt; [1] 2\n\n\nAnswer: code above.\nAR Solutions: Our span_r() function returns the indices of the (first occurring) longest sequential run of elements where the predicate is true. If the predicate is never true, the longest run has length 0, in which case we return integer(0).\n\nspan_r &lt;- function(x, f) {\n  idx &lt;- unname(map_lgl(x, ~ f(.x)))\n  rle &lt;- rle(idx)\n\n  # Check if the predicate is never true\n  if (!any(rle$values)) {\n    return(integer(0))\n  }\n\n  # Find the length of the longest sequence of true values\n  longest &lt;- max(rle$lengths[rle$values])\n  # Find the position of the (first) longest run in rle\n  longest_idx &lt;- which(rle$values & rle$lengths == longest)[1]\n\n  # Add up all lengths in rle before the longest run\n  ind_before_longest &lt;- sum(rle$lengths[seq_len(longest_idx - 1)])\n\n  out_start &lt;- ind_before_longest + 1L\n  out_end &lt;- ind_before_longest + longest\n  out_start:out_end\n}\n\n# Check that it works\nspan_r(c(0, 0, 0, 0, 0), is.na)\n\n#&gt; integer(0)\n\nspan_r(c(NA, 0, 0, 0, 0), is.na)\n\n#&gt; [1] 1\n\nspan_r(c(NA, 0, NA, NA, NA), is.na)\n\n#&gt; [1] 3 4 5\n\n\nNotes: AR Solutions shows how to find the index of the longest sequence using which(), which is new to me, and returns more information by returning indexes of the entire span. The AR Solutions approach is also significantly faster (which I did not expect).\n\nbench::mark(span_r(test2, is.numeric))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                     min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 span_r(test2, is.numeric)   51.2µs   52.9µs    18285.    4.01KB     65.1\n\nbench::mark(span(test2, is.numeric))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                   min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;              &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 span(test2, is.numeric)   68.7µs   71.4µs    13697.    4.01KB     20.8\n\n\n\n\nImplement arg_max(). It should take a function and a vector of inputs, and return the elements of the input where the function returns the highest value. For example, arg_max(-10:5, function(x) x ^ 2) should return -10. arg_max(-5:5, function(x) x ^ 2) should return c(-5, 5). Also implement the matching arg_min() function.\n\nAnswer: code below.\n\narg_max &lt;- function(x, f) {\n  val &lt;- map_dbl(x, f)\n  val_max &lt;- max(val)\n  x[which(val == val_max)]\n}\n\narg_max(-10:5, function(x) x^2)\n\n#&gt; [1] -10\n\narg_max(-5:5, function(x) x^2)\n\n#&gt; [1] -5  5\n\narg_min &lt;- function(x, f) {\n  val &lt;- map_dbl(x, f)\n  val_min &lt;- min(val)\n  x[which(val == val_min)]\n}\n\narg_min(-10:5, function(x) x^2)\n\n#&gt; [1] 0\n\narg_min(c(-5:-1, 1:5), function(x) x^2)\n\n#&gt; [1] -1  1\n\n\nAR Solutions: Both functions take a vector of inputs and a function as an argument. The function output is then used to subset the input accordingly.\n\narg_max &lt;- function(x, f) {\n  y &lt;- map_dbl(x, f)\n  x[y == max(y)]\n}\n\narg_min &lt;- function(x, f) {\n  y &lt;- map_dbl(x, f)\n  x[y == min(y)]\n}\n\narg_max(-10:5, function(x) x^2)\n\n#&gt; [1] -10\n\narg_min(-10:5, function(x) x^2)\n\n#&gt; [1] 0\n\n\nNotes: using which() is unnecessary, AR Solutions is a better approach.\n\n\nThe function below scales a vector so it falls in the range [0, 1]. How would you apply it to every column of a data frame? How would you apply it to every numeric column in a data frame?\n\n\nscale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nAnswer: code below.\n\n# every column\nmodify(mtcars, scale01)\n\n#&gt;          mpg cyl       disp         hp       drat         wt       qsec vs am\n#&gt; 1  0.4510638 0.5 0.22175106 0.20494700 0.52534562 0.28304781 0.23333333  0  1\n#&gt; 2  0.4510638 0.5 0.22175106 0.20494700 0.52534562 0.34824853 0.30000000  0  1\n#&gt; 3  0.5276596 0.0 0.09204290 0.14487633 0.50230415 0.20634109 0.48928571  1  1\n#&gt; 4  0.4680851 0.5 0.46620105 0.20494700 0.14746544 0.43518282 0.58809524  1  0\n#&gt; 5  0.3531915 1.0 0.72062859 0.43462898 0.17972350 0.49271286 0.30000000  0  0\n#&gt; 6  0.3276596 0.5 0.38388626 0.18727915 0.00000000 0.49782664 0.68095238  1  0\n#&gt; 7  0.1659574 1.0 0.72062859 0.68197880 0.20737327 0.52595244 0.15952381  0  0\n#&gt; 8  0.5957447 0.0 0.18857570 0.03533569 0.42857143 0.42879059 0.65476190  1  0\n#&gt; 9  0.5276596 0.0 0.17385882 0.15194346 0.53456221 0.41856303 1.00000000  1  0\n#&gt; 10 0.3744681 0.5 0.24070841 0.25088339 0.53456221 0.49271286 0.45238095  1  0\n#&gt; 11 0.3148936 0.5 0.24070841 0.25088339 0.53456221 0.49271286 0.52380952  1  0\n#&gt; 12 0.2553191 1.0 0.51060115 0.45229682 0.14285714 0.65379698 0.34523810  0  0\n#&gt; 13 0.2936170 1.0 0.51060115 0.45229682 0.14285714 0.56686269 0.36904762  0  0\n#&gt; 14 0.2042553 1.0 0.51060115 0.45229682 0.14285714 0.57964715 0.41666667  0  0\n#&gt; 15 0.0000000 1.0 1.00000000 0.54063604 0.07834101 0.95551010 0.41428571  0  0\n#&gt; 16 0.0000000 1.0 0.97006735 0.57597173 0.11059908 1.00000000 0.39523810  0  0\n#&gt; 17 0.1829787 1.0 0.92017960 0.62897527 0.21658986 0.97980056 0.34761905  0  0\n#&gt; 18 0.9361702 0.0 0.01895735 0.04946996 0.60829493 0.17565840 0.59166667  1  1\n#&gt; 19 0.8510638 0.0 0.01147418 0.00000000 1.00000000 0.02608029 0.47857143  1  1\n#&gt; 20 1.0000000 0.0 0.00000000 0.04593640 0.67281106 0.08233188 0.64285714  1  1\n#&gt; 21 0.4723404 0.0 0.12222499 0.15901060 0.43317972 0.24341601 0.65595238  1  0\n#&gt; 22 0.2170213 1.0 0.61586431 0.34628975 0.00000000 0.51316799 0.28214286  0  0\n#&gt; 23 0.2042553 1.0 0.58094288 0.34628975 0.17972350 0.49143442 0.33333333  0  0\n#&gt; 24 0.1234043 1.0 0.69568471 0.68197880 0.44700461 0.59498849 0.10833333  0  0\n#&gt; 25 0.3744681 1.0 0.82040409 0.43462898 0.14746544 0.59626694 0.30357143  0  0\n#&gt; 26 0.7191489 0.0 0.01970566 0.04946996 0.60829493 0.10790079 0.52380952  1  1\n#&gt; 27 0.6638298 0.0 0.12272387 0.13780919 0.76958525 0.16031705 0.26190476  0  1\n#&gt; 28 0.8510638 0.0 0.05986530 0.21554770 0.46543779 0.00000000 0.28571429  1  1\n#&gt; 29 0.2297872 1.0 0.69817910 0.74911661 0.67281106 0.42367681 0.00000000  0  1\n#&gt; 30 0.3957447 0.5 0.18433525 0.43462898 0.39631336 0.32140118 0.11904762  0  1\n#&gt; 31 0.1957447 1.0 0.57345972 1.00000000 0.35944700 0.52595244 0.01190476  0  1\n#&gt; 32 0.4680851 0.0 0.12446994 0.20141343 0.62211982 0.32395807 0.48809524  1  1\n#&gt;    gear      carb\n#&gt; 1   0.5 0.4285714\n#&gt; 2   0.5 0.4285714\n#&gt; 3   0.5 0.0000000\n#&gt; 4   0.0 0.0000000\n#&gt; 5   0.0 0.1428571\n#&gt; 6   0.0 0.0000000\n#&gt; 7   0.0 0.4285714\n#&gt; 8   0.5 0.1428571\n#&gt; 9   0.5 0.1428571\n#&gt; 10  0.5 0.4285714\n#&gt; 11  0.5 0.4285714\n#&gt; 12  0.0 0.2857143\n#&gt; 13  0.0 0.2857143\n#&gt; 14  0.0 0.2857143\n#&gt; 15  0.0 0.4285714\n#&gt; 16  0.0 0.4285714\n#&gt; 17  0.0 0.4285714\n#&gt; 18  0.5 0.0000000\n#&gt; 19  0.5 0.1428571\n#&gt; 20  0.5 0.0000000\n#&gt; 21  0.0 0.0000000\n#&gt; 22  0.0 0.1428571\n#&gt; 23  0.0 0.1428571\n#&gt; 24  0.0 0.4285714\n#&gt; 25  0.0 0.1428571\n#&gt; 26  0.5 0.0000000\n#&gt; 27  1.0 0.1428571\n#&gt; 28  1.0 0.1428571\n#&gt; 29  1.0 0.4285714\n#&gt; 30  1.0 0.7142857\n#&gt; 31  1.0 1.0000000\n#&gt; 32  0.5 0.1428571\n\n# every numeric column\nmodify_if(iris, is.numeric, scale01)\n\n#&gt;     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#&gt; 1     0.22222222  0.62500000   0.06779661  0.04166667     setosa\n#&gt; 2     0.16666667  0.41666667   0.06779661  0.04166667     setosa\n#&gt; 3     0.11111111  0.50000000   0.05084746  0.04166667     setosa\n#&gt; 4     0.08333333  0.45833333   0.08474576  0.04166667     setosa\n#&gt; 5     0.19444444  0.66666667   0.06779661  0.04166667     setosa\n#&gt; 6     0.30555556  0.79166667   0.11864407  0.12500000     setosa\n#&gt; 7     0.08333333  0.58333333   0.06779661  0.08333333     setosa\n#&gt; 8     0.19444444  0.58333333   0.08474576  0.04166667     setosa\n#&gt; 9     0.02777778  0.37500000   0.06779661  0.04166667     setosa\n#&gt; 10    0.16666667  0.45833333   0.08474576  0.00000000     setosa\n#&gt; 11    0.30555556  0.70833333   0.08474576  0.04166667     setosa\n#&gt; 12    0.13888889  0.58333333   0.10169492  0.04166667     setosa\n#&gt; 13    0.13888889  0.41666667   0.06779661  0.00000000     setosa\n#&gt; 14    0.00000000  0.41666667   0.01694915  0.00000000     setosa\n#&gt; 15    0.41666667  0.83333333   0.03389831  0.04166667     setosa\n#&gt; 16    0.38888889  1.00000000   0.08474576  0.12500000     setosa\n#&gt; 17    0.30555556  0.79166667   0.05084746  0.12500000     setosa\n#&gt; 18    0.22222222  0.62500000   0.06779661  0.08333333     setosa\n#&gt; 19    0.38888889  0.75000000   0.11864407  0.08333333     setosa\n#&gt; 20    0.22222222  0.75000000   0.08474576  0.08333333     setosa\n#&gt; 21    0.30555556  0.58333333   0.11864407  0.04166667     setosa\n#&gt; 22    0.22222222  0.70833333   0.08474576  0.12500000     setosa\n#&gt; 23    0.08333333  0.66666667   0.00000000  0.04166667     setosa\n#&gt; 24    0.22222222  0.54166667   0.11864407  0.16666667     setosa\n#&gt; 25    0.13888889  0.58333333   0.15254237  0.04166667     setosa\n#&gt; 26    0.19444444  0.41666667   0.10169492  0.04166667     setosa\n#&gt; 27    0.19444444  0.58333333   0.10169492  0.12500000     setosa\n#&gt; 28    0.25000000  0.62500000   0.08474576  0.04166667     setosa\n#&gt; 29    0.25000000  0.58333333   0.06779661  0.04166667     setosa\n#&gt; 30    0.11111111  0.50000000   0.10169492  0.04166667     setosa\n#&gt; 31    0.13888889  0.45833333   0.10169492  0.04166667     setosa\n#&gt; 32    0.30555556  0.58333333   0.08474576  0.12500000     setosa\n#&gt; 33    0.25000000  0.87500000   0.08474576  0.00000000     setosa\n#&gt; 34    0.33333333  0.91666667   0.06779661  0.04166667     setosa\n#&gt; 35    0.16666667  0.45833333   0.08474576  0.04166667     setosa\n#&gt; 36    0.19444444  0.50000000   0.03389831  0.04166667     setosa\n#&gt; 37    0.33333333  0.62500000   0.05084746  0.04166667     setosa\n#&gt; 38    0.16666667  0.66666667   0.06779661  0.00000000     setosa\n#&gt; 39    0.02777778  0.41666667   0.05084746  0.04166667     setosa\n#&gt; 40    0.22222222  0.58333333   0.08474576  0.04166667     setosa\n#&gt; 41    0.19444444  0.62500000   0.05084746  0.08333333     setosa\n#&gt; 42    0.05555556  0.12500000   0.05084746  0.08333333     setosa\n#&gt; 43    0.02777778  0.50000000   0.05084746  0.04166667     setosa\n#&gt; 44    0.19444444  0.62500000   0.10169492  0.20833333     setosa\n#&gt; 45    0.22222222  0.75000000   0.15254237  0.12500000     setosa\n#&gt; 46    0.13888889  0.41666667   0.06779661  0.08333333     setosa\n#&gt; 47    0.22222222  0.75000000   0.10169492  0.04166667     setosa\n#&gt; 48    0.08333333  0.50000000   0.06779661  0.04166667     setosa\n#&gt; 49    0.27777778  0.70833333   0.08474576  0.04166667     setosa\n#&gt; 50    0.19444444  0.54166667   0.06779661  0.04166667     setosa\n#&gt; 51    0.75000000  0.50000000   0.62711864  0.54166667 versicolor\n#&gt; 52    0.58333333  0.50000000   0.59322034  0.58333333 versicolor\n#&gt; 53    0.72222222  0.45833333   0.66101695  0.58333333 versicolor\n#&gt; 54    0.33333333  0.12500000   0.50847458  0.50000000 versicolor\n#&gt; 55    0.61111111  0.33333333   0.61016949  0.58333333 versicolor\n#&gt; 56    0.38888889  0.33333333   0.59322034  0.50000000 versicolor\n#&gt; 57    0.55555556  0.54166667   0.62711864  0.62500000 versicolor\n#&gt; 58    0.16666667  0.16666667   0.38983051  0.37500000 versicolor\n#&gt; 59    0.63888889  0.37500000   0.61016949  0.50000000 versicolor\n#&gt; 60    0.25000000  0.29166667   0.49152542  0.54166667 versicolor\n#&gt; 61    0.19444444  0.00000000   0.42372881  0.37500000 versicolor\n#&gt; 62    0.44444444  0.41666667   0.54237288  0.58333333 versicolor\n#&gt; 63    0.47222222  0.08333333   0.50847458  0.37500000 versicolor\n#&gt; 64    0.50000000  0.37500000   0.62711864  0.54166667 versicolor\n#&gt; 65    0.36111111  0.37500000   0.44067797  0.50000000 versicolor\n#&gt; 66    0.66666667  0.45833333   0.57627119  0.54166667 versicolor\n#&gt; 67    0.36111111  0.41666667   0.59322034  0.58333333 versicolor\n#&gt; 68    0.41666667  0.29166667   0.52542373  0.37500000 versicolor\n#&gt; 69    0.52777778  0.08333333   0.59322034  0.58333333 versicolor\n#&gt; 70    0.36111111  0.20833333   0.49152542  0.41666667 versicolor\n#&gt; 71    0.44444444  0.50000000   0.64406780  0.70833333 versicolor\n#&gt; 72    0.50000000  0.33333333   0.50847458  0.50000000 versicolor\n#&gt; 73    0.55555556  0.20833333   0.66101695  0.58333333 versicolor\n#&gt; 74    0.50000000  0.33333333   0.62711864  0.45833333 versicolor\n#&gt; 75    0.58333333  0.37500000   0.55932203  0.50000000 versicolor\n#&gt; 76    0.63888889  0.41666667   0.57627119  0.54166667 versicolor\n#&gt; 77    0.69444444  0.33333333   0.64406780  0.54166667 versicolor\n#&gt; 78    0.66666667  0.41666667   0.67796610  0.66666667 versicolor\n#&gt; 79    0.47222222  0.37500000   0.59322034  0.58333333 versicolor\n#&gt; 80    0.38888889  0.25000000   0.42372881  0.37500000 versicolor\n#&gt; 81    0.33333333  0.16666667   0.47457627  0.41666667 versicolor\n#&gt; 82    0.33333333  0.16666667   0.45762712  0.37500000 versicolor\n#&gt; 83    0.41666667  0.29166667   0.49152542  0.45833333 versicolor\n#&gt; 84    0.47222222  0.29166667   0.69491525  0.62500000 versicolor\n#&gt; 85    0.30555556  0.41666667   0.59322034  0.58333333 versicolor\n#&gt; 86    0.47222222  0.58333333   0.59322034  0.62500000 versicolor\n#&gt; 87    0.66666667  0.45833333   0.62711864  0.58333333 versicolor\n#&gt; 88    0.55555556  0.12500000   0.57627119  0.50000000 versicolor\n#&gt; 89    0.36111111  0.41666667   0.52542373  0.50000000 versicolor\n#&gt; 90    0.33333333  0.20833333   0.50847458  0.50000000 versicolor\n#&gt; 91    0.33333333  0.25000000   0.57627119  0.45833333 versicolor\n#&gt; 92    0.50000000  0.41666667   0.61016949  0.54166667 versicolor\n#&gt; 93    0.41666667  0.25000000   0.50847458  0.45833333 versicolor\n#&gt; 94    0.19444444  0.12500000   0.38983051  0.37500000 versicolor\n#&gt; 95    0.36111111  0.29166667   0.54237288  0.50000000 versicolor\n#&gt; 96    0.38888889  0.41666667   0.54237288  0.45833333 versicolor\n#&gt; 97    0.38888889  0.37500000   0.54237288  0.50000000 versicolor\n#&gt; 98    0.52777778  0.37500000   0.55932203  0.50000000 versicolor\n#&gt; 99    0.22222222  0.20833333   0.33898305  0.41666667 versicolor\n#&gt; 100   0.38888889  0.33333333   0.52542373  0.50000000 versicolor\n#&gt; 101   0.55555556  0.54166667   0.84745763  1.00000000  virginica\n#&gt; 102   0.41666667  0.29166667   0.69491525  0.75000000  virginica\n#&gt; 103   0.77777778  0.41666667   0.83050847  0.83333333  virginica\n#&gt; 104   0.55555556  0.37500000   0.77966102  0.70833333  virginica\n#&gt; 105   0.61111111  0.41666667   0.81355932  0.87500000  virginica\n#&gt; 106   0.91666667  0.41666667   0.94915254  0.83333333  virginica\n#&gt; 107   0.16666667  0.20833333   0.59322034  0.66666667  virginica\n#&gt; 108   0.83333333  0.37500000   0.89830508  0.70833333  virginica\n#&gt; 109   0.66666667  0.20833333   0.81355932  0.70833333  virginica\n#&gt; 110   0.80555556  0.66666667   0.86440678  1.00000000  virginica\n#&gt; 111   0.61111111  0.50000000   0.69491525  0.79166667  virginica\n#&gt; 112   0.58333333  0.29166667   0.72881356  0.75000000  virginica\n#&gt; 113   0.69444444  0.41666667   0.76271186  0.83333333  virginica\n#&gt; 114   0.38888889  0.20833333   0.67796610  0.79166667  virginica\n#&gt; 115   0.41666667  0.33333333   0.69491525  0.95833333  virginica\n#&gt; 116   0.58333333  0.50000000   0.72881356  0.91666667  virginica\n#&gt; 117   0.61111111  0.41666667   0.76271186  0.70833333  virginica\n#&gt; 118   0.94444444  0.75000000   0.96610169  0.87500000  virginica\n#&gt; 119   0.94444444  0.25000000   1.00000000  0.91666667  virginica\n#&gt; 120   0.47222222  0.08333333   0.67796610  0.58333333  virginica\n#&gt; 121   0.72222222  0.50000000   0.79661017  0.91666667  virginica\n#&gt; 122   0.36111111  0.33333333   0.66101695  0.79166667  virginica\n#&gt; 123   0.94444444  0.33333333   0.96610169  0.79166667  virginica\n#&gt; 124   0.55555556  0.29166667   0.66101695  0.70833333  virginica\n#&gt; 125   0.66666667  0.54166667   0.79661017  0.83333333  virginica\n#&gt; 126   0.80555556  0.50000000   0.84745763  0.70833333  virginica\n#&gt; 127   0.52777778  0.33333333   0.64406780  0.70833333  virginica\n#&gt; 128   0.50000000  0.41666667   0.66101695  0.70833333  virginica\n#&gt; 129   0.58333333  0.33333333   0.77966102  0.83333333  virginica\n#&gt; 130   0.80555556  0.41666667   0.81355932  0.62500000  virginica\n#&gt; 131   0.86111111  0.33333333   0.86440678  0.75000000  virginica\n#&gt; 132   1.00000000  0.75000000   0.91525424  0.79166667  virginica\n#&gt; 133   0.58333333  0.33333333   0.77966102  0.87500000  virginica\n#&gt; 134   0.55555556  0.33333333   0.69491525  0.58333333  virginica\n#&gt; 135   0.50000000  0.25000000   0.77966102  0.54166667  virginica\n#&gt; 136   0.94444444  0.41666667   0.86440678  0.91666667  virginica\n#&gt; 137   0.55555556  0.58333333   0.77966102  0.95833333  virginica\n#&gt; 138   0.58333333  0.45833333   0.76271186  0.70833333  virginica\n#&gt; 139   0.47222222  0.41666667   0.64406780  0.70833333  virginica\n#&gt; 140   0.72222222  0.45833333   0.74576271  0.83333333  virginica\n#&gt; 141   0.66666667  0.45833333   0.77966102  0.95833333  virginica\n#&gt; 142   0.72222222  0.45833333   0.69491525  0.91666667  virginica\n#&gt; 143   0.41666667  0.29166667   0.69491525  0.75000000  virginica\n#&gt; 144   0.69444444  0.50000000   0.83050847  0.91666667  virginica\n#&gt; 145   0.66666667  0.54166667   0.79661017  1.00000000  virginica\n#&gt; 146   0.66666667  0.41666667   0.71186441  0.91666667  virginica\n#&gt; 147   0.55555556  0.20833333   0.67796610  0.75000000  virginica\n#&gt; 148   0.61111111  0.41666667   0.71186441  0.79166667  virginica\n#&gt; 149   0.52777778  0.58333333   0.74576271  0.91666667  virginica\n#&gt; 150   0.44444444  0.41666667   0.69491525  0.70833333  virginica\n\n\nAR Solutions: To apply a function to every column of a data frame, we can use purrr::modify() (or purrr::map_dfr()), which also conveniently returns a data frame. To limit the application to numeric columns, the scoped version modify_if() can be used.\n\nmodify_if(mtcars, is.numeric, scale01)",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-3",
    "href": "analysis/advanced-r-2.html#exercises-3",
    "title": "Advanced R (Functional programming)",
    "section": "9.7.3 Exercises",
    "text": "9.7.3 Exercises\n\nHow does apply() arrange the output? Read the documentation and perform some experiments.\n\n\n# experiments\nm1 &lt;- matrix(1:4, nrow = 1)\napply(m1, 1, sum)\napply(m1, 2, sum)\napply(m1, c(1, 2), `*`, 2)\napply(m1, 1, `*`, 2)\napply(m1, 1, `*`, 2, simplify = FALSE)\napply(m1, 2, `*`, 2)\napply(m1, 1, sum, simplify = FALSE)\n\nm1a &lt;- matrix(1:4, ncol = 1)\napply(m1a, 1, `*`, 2)\n\nm2 &lt;- matrix(1:20, ncol = 4)\napply(m2, 1, sum)\n\nm3 &lt;- array(1:24, dim = c(2, 3, 4))\napply(m3, 1, sum)\napply(m3, 2, sum)\napply(m3, 3, sum)\napply(m3, 1, `*`, 2)\napply(m3, 2, `*`, 2)\napply(m3, 3, `*`, 2)\napply(m3, c(1, 2, 3), `*`, 2)\n\nAnswer: the documentation states:\n\nIf each call to FUN returns a vector of length n, and simplify is TRUE, then apply returns an array of dimension c(n, dim(X)[MARGIN]) if n &gt; 1. If n equals 1, apply returns a vector if MARGIN has length 1 and an array of dimension dim(X)[MARGIN] otherwise. If n is 0, the result has length 0 but not necessarily the ‘correct’ dimension.\nIf the calls to FUN return vectors of different lengths, or if simplify is FALSE, apply returns a list of length prod(dim(X)[MARGIN]) with dim set to MARGIN if this has length greater than one.\n\nWith exploration, under normal circumstances:\n\nIf MARGIN includes all dimensions of an array or matrix (c(1, 2) or c(1, 2, 3)), the output is arranged in the same shape as the input\nOtherwise, the return value drops a dimension if modifying a vector in place (as with *), or returns a vector when summarizing (as with sum)\nMatrices of a single row are simplified to a vector\nMatrices of a single column are returned as a matrix\nWhen simplify = FALSE is set, a list is returned\n\nHowever, even with all this, the “rules” aren’t clear to me.\nAR Solutions: Basically apply() applies a function over the margins of an array. In the two-dimensional case, the margins are just the rows and columns of a matrix. Let’s make this concrete.\n\narr2 &lt;- array(1:12, dim = c(3, 4))\nrownames(arr2) &lt;- paste0(\"row\", 1:3)\ncolnames(arr2) &lt;- paste0(\"col\", 1:4)\narr2\n\n#&gt;      col1 col2 col3 col4\n#&gt; row1    1    4    7   10\n#&gt; row2    2    5    8   11\n#&gt; row3    3    6    9   12\n\n\nWhen we apply the head() function over the first margin of arr2() (i.e. the rows), the results are contained in the columns of the output, transposing the array compared to the original input.\n\napply(arr2, 1, function(x) x[1:2])\n\n#&gt;      row1 row2 row3\n#&gt; col1    1    2    3\n#&gt; col2    4    5    6\n\n\nAnd vice versa if we apply over the second margin (the columns):\n\napply(arr2, 2, function(x) x[1:2])\n\n#&gt;      col1 col2 col3 col4\n#&gt; row1    1    4    7   10\n#&gt; row2    2    5    8   11\n\n\nThe output of apply() is organised first by the margins being operated over, then the results of the function. This can become quite confusing for higher dimensional arrays.\nNotes: AR Solutions’ explanation is better, but the output is still confusing.\n\n\nWhat do eapply() and rapply() do? Does purrr have equivalents?\n\nAnswer: eapply() applies a function to named values in an environment. rapply() is a recursive lapply(). There are no equivalents in purrr.\nAR Solutions: eapply() is a variant of lapply(), which iterates over the (named) elements of an environment. In purrr there is no equivalent for eapply() as purrr mainly provides functions that operate on vectors and functions, but not on environments.\nrapply() applies a function to all elements of a list recursively. This function makes it possible to limit the application of the function to specified classes (default classes = ANY). One may also specify how elements of other classes should remain: as their identity (how = replace) or another value (default = NULL). The closest equivalent in purrr is modify_depth(), which allows you to modify elements at a specified depth in a nested list.\nNotes: I wasn’t aware of purrr::modify_depth().\n\n\nChallenge: read about the fixed point algorithm. Complete the exercises using R.\n\nNote: see archive.org, “Finding fixed points of functions.”\nAnswer: the fixed point algorithm is defined below, with an example solution:\n(define tolerance 0.00001)\n(define (fixed-point f first-guess)\n  (define (close-enough? v1 v2)\n    (&lt; (abs (- v1 v2)) tolerance))\n  (define (try guess)\n    (let ((next (f guess)))\n      (if (close-enough? guess next)\n          next\n          (try next))))\n  (try first-guess))\n\n(fixed-point cos 1.0)\n0.7390822985224023\n\n(fixed-point (lambda (y) (+ (sin y) (cos y)))\n             1.0)\n1.2587315962971173\n\n(define (sqrt x)\n  (fixed-point (lambda (y) (/ x y))\n               1.0))\nImplementation in R:\n\nfixed_point &lt;- function(f, x) {\n  tolerance &lt;- 0.00001\n  close_enough &lt;- function(v1, v2) {\n    abs(v1 - v2) &lt; tolerance\n  }\n\n  if (close_enough(f(x), x)) {\n    f(x)\n  } else {\n    fixed_point(f, f(x))\n  }\n}\n\nfixed_point(cos, 1.0)\n\n#&gt; [1] 0.7390823\n\nfixed_point(function(y) sin(y) + cos(y), 1.0)\n\n#&gt; [1] 1.258732\n\n\nAR Solutions: A number \\(x\\) is called a fixed point of a function \\(f\\) if it satisfies the equation \\(f(x) = x\\). For some functions we may find a fixed point by beginning with a starting value and applying \\(f\\) repeatedly. Here fixed_point() acts as a functional because it takes a function as an argument.\n\nfixed_point_ar &lt;- function(f, x_init, n_max = 10000, tol = 0.0001) {\n  n &lt;- 0\n  x &lt;- x_init\n  y &lt;- f(x)\n\n  is_fixed_point &lt;- function(x, y) {\n    abs(x - y) &lt; tol\n  }\n\n  while (!is_fixed_point(x, y)) {\n    x &lt;- y\n    y &lt;- f(y)\n\n    # Make sure we eventually stop\n    n &lt;- n + 1\n    if (n &gt; n_max) {\n      stop(\"Failed to converge.\", call. = FALSE)\n    }\n  }\n\n  x\n}\n\n# Functions with fixed points\nfixed_point_ar(sin, x_init = 1)\n\n#&gt; [1] 0.08430922\n\nfixed_point_ar(cos, x_init = 1)\n\n#&gt; [1] 0.7391302\n\n# Functions without fixed points\nadd_one &lt;- function(x) x + 1\ntry(fixed_point_ar(add_one, x_init = 1))\n\n#&gt; Error : Failed to converge.\n\n\nNotes: AR Solutions offers a different approach using a while() loop that is guaranteed to stop. My approach using recursive calls does stop eventually with a stack limit error:\n\nfixed_point(add_one, 1)\n\nComparing benchmarks:\n\nbench::mark(fixed_point_ar(cos, x_init = 1, tol = 0.00001))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 fixed_point_ar(cos, x_init = 1, to… 11.8µs 12.5µs    78634.        0B     23.6\n\nbench::mark(fixed_point(cos, 1))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression               min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;          &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 fixed_point(cos, 1)   20.3µs   21.7µs    44672.        0B     26.8\n\n\nAs usual, AR Solutions is faster. :-(",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-4",
    "href": "analysis/advanced-r-2.html#exercises-4",
    "title": "Advanced R (Functional programming)",
    "section": "10.2.6 Exercises",
    "text": "10.2.6 Exercises\n\nThe definition of force() is simple:\n\n\nforce\n\n#&gt; function (x) \n#&gt; x\n#&gt; &lt;bytecode: 0x15314ffb0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\nWhy is it better to force(x) instead of just x?\nAnswer: as the R Documentation states, ‘This is semantic sugar’: in other words, force(x) makes the intent of the call explicit, to force evaluation, whereas x does not.\nAR Solutions: As you can see force(x) is similar to x. As mentioned in Advanced R, we prefer this explicit form, because\n\nusing this function clearly indicates that you’re forcing evaluation, not that you’ve accidentally typed x.”\n\n\n\nBase R contains two function factories, approxfun() and ecdf(). Read their documentation and experiment to figure out what the functions do and what they return.\n\n\nx &lt;- c(1, 3, 6, 10, 19)\ny &lt;- x * 2\nplot(x, y, xlim = c(0, 20), ylim = c(0, 40))\n\n\n\n\n\n\n\naf &lt;- approxfun(x, y)\nplot(0:20, af(0:20), xlim = c(0, 20), ylim = c(0, 40))\n\n\n\n\n\n\n\n\nAnswer: approxfun() returns “a function performing the linear (or constant) interpolation.” As the example above shows, approxfun() provides linear interpolation that by default does not return values outside the minimum and maximum.\n\nplot(ecdf(rlnorm(1000)))\n\n\n\n\n\n\n\nplot(ecdf(rnorm(1000)))\n\n\n\n\n\n\n\nplot(ecdf(runif(1000)))\n\n\n\n\n\n\n\n\necdf() “Compute[s] an empirical cumulative distribution function”, the Empirical Cumulative Distribution Function, which is a standard statistical plot. It plots the actual observations connected by a line, which is easier to see with fewer observations:\n\nplot(ecdf(runif(50)))\n\n\n\n\n\n\n\n\nAR Solutions: (Note: full solution here)\nLet’s begin with approxfun() as it is used within ecdf() as well:\napproxfun() takes a combination of data points (x and y values) as input and returns a stepwise linear (or constant) interpolation function. To find out what this means exactly, we first create a few random data points.\nNext, we use approxfun() to construct the linear and constant interpolation functions for our x and y values.\nWhen we apply these functions to new x values, these are mapped to the lines connecting the initial y values (linear case) or to the same y value as for the next smallest initial x value (constant case).\nHowever, both functions are only defined within range(x).\nTo change this behaviour, one can set rule = 2. This leads to the result that for values outside of range(x) the boundary values of the function are returned.\nAnother option is to customise the return values as individual constants for each side via yleft and/or yright.\nFurther, approxfun() provides the option to shift the y values for method = \"constant\" between their left and right values. According to the documentation this indicates a compromise between left- and right-continuous steps.\nFinally, the ties argument allows to aggregate y values if multiple ones were provided for the same x value. For example, in the following line we use mean() to aggregate these y values before they are used for the interpolation approxfun(x = c(1,1,2), y = 1:3, ties = mean).\nNext, we focus on ecdf(). “ecdf” is an acronym for empirical cumulative distribution function. For a numeric vector of density values, ecdf() initially creates the (x, y) pairs for the nodes of the density function and then passes these pairs to approxfun(), which gets called with specifically adapted settings (approxfun(vals, cumsum(tabulate(match(x, vals)))/n, method = \"constant\", yleft = 0, yright = 1, f = 0, ties = \"ordered\")).\nNew values are then mapped on the y value of the next smallest x value from within the initial input.\n\n\nCreate a function pick() that takes an index, i, as an argument and returns a function with an argument x that subsets x with i.\n\n\npick &lt;- function(i) {\n  function(x) x[[i]]\n}\n\nx &lt;- 2:8\npick(1)(x)\n\n#&gt; [1] 2\n\n# should be equivalent to\nx[[1]]\n\n#&gt; [1] 2\n\nunlist(lapply(mtcars, pick(5)))\n\n#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#&gt;  18.70   8.00 360.00 175.00   3.15   3.44  17.02   0.00   0.00   3.00   2.00\n\n# should be equivalent to\nunlist(lapply(mtcars, function(x) x[[5]]))\n\n#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#&gt;  18.70   8.00 360.00 175.00   3.15   3.44  17.02   0.00   0.00   3.00   2.00\n\n\nAnswer: code above. Modified to use unlist() to shorten output.\nAR Solutions: In this exercise pick(i) acts as a function factory, which returns the required subsetting function.\n\npick &lt;- function(i) {\n  force(i)\n  function(x) x[[i]]\n}\n\nNote: the AR Solutions version appropriately uses force().\n\n\nCreate a function that creates functions that compute the ith central moment of a numeric vector. You can test it by running the following code:\n\n\nmoment &lt;- function(i) {\n  function(x) mean((x - mean(x))^i)\n}\n\nm1 &lt;- moment(1)\nm2 &lt;- moment(2)\nx &lt;- runif(100)\nstopifnot(\n  all.equal(m1(x), 0),\n  all.equal(m2(x), var(x) * 99 / 100)\n)\nbench::mark(m2(x))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 m2(x)        3.16µs   3.53µs   267745.      848B     26.8\n\n\nAnswer: code above, following the formula \\(E[(X - E[X])^i]\\), where \\(E\\) is the expected value, ie the mean.\nAR Solutions: The first moment is closely related to the mean and describes the average deviation from the mean, which is 0 (within numerical margin of error). The second moment describes the variance of the input data. If we want to compare it to var(), we need to undo Bessel’s correction by multiplying with \\(\\frac{N-1}{N}\\).\n\nmoment &lt;- function(i) {\n  force(i)\n\n  function(x) sum((x - mean(x))^i) / length(x)\n}\nm1 &lt;- moment(1)\nm2 &lt;- moment(2)\nx &lt;- runif(100)\nall.equal(m1(x), 0) # removed stopifnot() for clarity\n\n#&gt; [1] TRUE\n\nall.equal(m2(x), var(x) * 99 / 100)\n\n#&gt; [1] TRUE\n\nbench::mark(m2(x))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 m2(x)        2.05µs   2.21µs   426175.      848B     42.6\n\n\nNote: isn’t sum() / length() just mean()? For fun, compare bench::mark() (above). Curses, foiled again!\n\n\nWhat happens if you don’t use a closure? Make predictions, then verify with the code below.\n\n\ni &lt;- 0\nnew_counter2 &lt;- function() {\n  i &lt;&lt;- i + 1\n  i\n}\n\nAnswer: i should increment by 1 every time new_counter2() is run, but can be altered by changing the global variable i. [Correct!]\n\nnew_counter2()\n\n#&gt; [1] 1\n\nnew_counter2()\n\n#&gt; [1] 2\n\nnew_counter2()\n\n#&gt; [1] 3\n\ni &lt;- 5\nnew_counter2()\n\n#&gt; [1] 6\n\ni &lt;- 0\n\nAR Solutions: Without the captured and encapsulated environment of a closure the counts will be stored in the global environment. Here they can be overwritten or deleted as well as interfere with other counters.\n\nnew_counter2()\n\n#&gt; [1] 1\n\ni\n\n#&gt; [1] 1\n\nnew_counter2()\n\n#&gt; [1] 2\n\ni\n\n#&gt; [1] 2\n\ni &lt;- 0\nnew_counter2()\n\n#&gt; [1] 1\n\ni\n\n#&gt; [1] 1\n\ni &lt;- 0\n\n\n\nWhat happens if you use &lt;- instead of &lt;&lt;-? Make predictions, then verify with the code below.\n\n\nnew_counter3 &lt;- function() {\n  i &lt;- 0\n  function() {\n    i &lt;- i + 1\n    i\n  }\n}\n\nAnswer: functions created by new_counter3() starts with a new value of i &lt;- 0 each time, and will always return 1. [Correct!]\n\nnc3 &lt;- new_counter3()\n\nnc3()\n\n#&gt; [1] 1\n\nnc3()\n\n#&gt; [1] 1\n\n\nAR Solutions: Without the super assignment &lt;&lt;-, the counter will always return 1. The counter always starts in a new execution environment within the same enclosing environment, which contains an unchanged value for i (in this case it remains 0).",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-5",
    "href": "analysis/advanced-r-2.html#exercises-5",
    "title": "Advanced R (Functional programming)",
    "section": "10.3.4 Exercises",
    "text": "10.3.4 Exercises\n\nCompare and contrast ggplot2::label_bquote() with scales::number_format()\n\nAnswer: ggplot2::label_bquote() “offers a flexible way of labelling facet rows or columns with plotmath expressions. Backquoted variables will be replaced with their value in the facet.”\nThe example shows a scatterplot of weight and miles per gallon faceted by engine type (v-shaped).\n\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  facet_grid(vs ~ ., labeller = label_bquote(vs == .(vs)))\n\n\n\n\n\n\n\n\nscales::number_format() has been superseded by scales::label_number():\n“Use label_number() force decimal display of numbers (i.e. don’t use scientific notation). label_comma() is a special case that inserts a comma every three digits.”\n\ndemo_continuous(c(-1e6, 1e6), labels = label_number())\n\n#&gt; scale_x_continuous(labels = label_number())\n\n\n\n\n\n\n\n\n\nggplot2::label_bquote() is a special-purpose function for facets, while scales::number_format() can be applied more generally. Both are function factories that can be applied to changing labels.\nAR Solutions: Both functions will help you in styling your output, e.g. in your plots and they do this by returning the desired formatting function to you.\nggplot2::label_bquote() takes relatively straightforward plotmath expressions and uses them for faceting labels in {ggplot2}. Because this function is used in {ggplot2} it needs to return a function of class = \"labeller\".\nscales::number_format() initially force()s the computation of all parameters. It’s essentially a parametrised wrapper around scales::number() and will help you format numbers appropriately. It will return a simple function.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-6",
    "href": "analysis/advanced-r-2.html#exercises-6",
    "title": "Advanced R (Functional programming)",
    "section": "10.4.4 Exercises",
    "text": "10.4.4 Exercises\n\nIn boot_model(), why don’t I need to force the evaluation of df or model?\n\nAnswer: assuming model actually refers to formula, both are evaluated when mod &lt;- lm(formula, data = df) is run.\nAR Solutions: boot_model() ultimately returns a function, and whenever you return a function you need to make sure all the inputs are explicitly evaluated. Here that happens automatically because we use df and formula in lm() before returning the function.\n\n\nWhy might you formulate the Box-Cox transformation like this?\n\n\nboxcox3 &lt;- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x^lambda - 1) / lambda\n    }\n  }\n}\n\nAnswer: boxcox3 returns a function where x is fixed and lambda can vary, which allows for easy exploration of different values of lambda, for example using lapply() or optimize().\nAR Solutions: boxcox3() returns a function where x is fixed (though it is not forced, so it may be manipulated later). This allows us to apply and test different transformations for different inputs and give them a descriptive name.\nNote: I missed the fact that x is not forced.\n\n\nWhy don’t you need to worry that boot_permute() stores a copy of the data inside the function that it generates?\n\nAnswer: as R is copy-on-write, and boot_permute() stores an unmodified copy of the data, the function contains only a reference to the original data.\nAR Solutions: We don’t need to worry that it stores a copy of the data, because it actually doesn’t store one; it’s just a name that points to the same underlying object in memory.\n\n\nHow much time does ll_poisson2() save compared to ll_poisson1()? Use bench::mark() to see how much faster the optimisation occurs. How does changing the length of x change the results?\n\n\nll_poisson1 &lt;- function(x) {\n  n &lt;- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\n\nll_poisson2 &lt;- function(x) {\n  n &lt;- length(x)\n  sum_x &lt;- sum(x)\n  c &lt;- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\n\nx1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\n\nbench::mark(optimize(ll_poisson1(x1), c(0, 100), maximum = TRUE))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 optimize(ll_poisson1(x1), c(0, 100… 12.1µs 12.8µs    74803.    12.8KB     29.9\n\nbench::mark(optimize(ll_poisson2(x1), c(0, 100), maximum = TRUE))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 optimize(ll_poisson2(x1), c(0, 100… 6.48µs 6.85µs   137840.        0B     27.6\n\nx &lt;- rpois(1e3, 100L)\nbench::mark(optimize(ll_poisson1(x), c(0, 100), maximum = TRUE))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                           &lt;bch&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 optimize(ll_poisson1(x), c(0, 100),… 377µs  398µs     2503.     189KB     10.4\n\nbench::mark(optimize(ll_poisson2(x), c(0, 100), maximum = TRUE))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 optimize(ll_poisson2(x), c(0, 100)… 25.3µs 27.7µs    35376.    7.86KB     10.6\n\n\nAnswer: ll_poisson2() is nearly twice as fast with x1 and nearly 10 times as fast when the length of x is 100.\nNotes: consulting AR Solutions was needed to understand how to benchmark the two functions.\nAR Solutions:\nA benchmark on x1 reveals a performance improvement of factor 2 for ll_poisson2() over ll_poisson1()\nAs the redundant calculations within ll_poisson1() become more expensive with growing length of x1, we expect even further relative performance improvements for ll_poisson2(). The following benchmark reveals a relative performance improvement of factor 20 for ll_poisson2() when x1 is of length 100,000.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-7",
    "href": "analysis/advanced-r-2.html#exercises-7",
    "title": "Advanced R (Functional programming)",
    "section": "10.5.1 Exercises",
    "text": "10.5.1 Exercises\n\nWhich of the following commands is equivalent to with(x, f(z))?\n\nx$f(x$z).\nf(x$z).\nx$f(z).\nf(z).\nIt depends.\n\n\nAnswer: (e). depending on the value of x, it could be any of (a) through (d).\nAR Solutions: (e) “It depends” is the correct answer. Usually with() is used with a data frame, so you’d usually expect (b), but if x is a list, it could be any of the options.\n\n\nCompare and contrast the effects of env_bind() vs. attach() for the following code.\n\n\nfuns &lt;- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n\n#&gt; The following objects are masked from package:base:\n#&gt; \n#&gt;     mean, sum\n\nmean &lt;- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean &lt;- function(x) stop(\"Hi!\")\nenv_unbind(globalenv(), names(funs))\n\nAnswer: attach() places the function names in the search path, and the env_bind() code places the function names in the global environment. Both have the effect of masking mean() and sum(), but as the chapter points out, when unbinding, “there’s no guarantee that they haven’t been rebound in the meantime, and you might be deleting an object that someone else created.”\nAR Solutions: attach() adds funs to the search path. Therefore, the provided functions are found before their respective versions from the {base} package. Further, they cannot get accidentally overwritten by similar named functions in the global environment. One annoying downside of using attach() is the possibility to attach the same object multiple times, making it necessary to call detach() equally often.\nIn contrast rlang::env_bind() just adds the functions in fun to the global environment. No further side effects are introduced, and the functions are overwritten when similarly named functions are defined.\nNotes: AR Solutions provides a more complete answer.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-8",
    "href": "analysis/advanced-r-2.html#exercises-8",
    "title": "Advanced R (Functional programming)",
    "section": "11.2.3 Exercises",
    "text": "11.2.3 Exercises\n\nBase R provides a function operator in the form of Vectorize(). What does it do? When might you use it?\n\nAnswer: according to the R documentation, “Vectorize creates a function wrapper that vectorizes the action of its argument FUN.” “The arguments named in the vectorize.args argument to Vectorize are the arguments passed in the ... list to mapply. Only those that are actually passed will be vectorized; default values will not.” and returns “A function with the same arguments as FUN, wrapping a call to mapply.”\nIn other words, it is a function operator that uses mapply() to iterate across the arguments. This is potentially simpler to understand than use of mapply().\nIn the R documentation example, the vectorized rep.int is called for each pair of values:\n\nvrep &lt;- Vectorize(rep.int)\nvrep(1:4, 4:1)\n\n#&gt; [[1]]\n#&gt; [1] 1 1 1 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2 2 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3 3\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 4\n\n\nAR Solutions: In R a lot of functions are “vectorised”. Vectorised has two meanings. First, it means (broadly) that a function inputs a vector or vectors and does something to each element. Secondly, it usually implies that these operations are implemented in a compiled language such as C or Fortran, so that the implementation is very fast.\nHowever, despite what the function’s name implies, Vectorize() is not able to speed up the provided function. It rather changes the input format of the supplied arguments (vectorize.args), so that they can be iterated over.\nVectorize() provides a convenient and concise notation to iterate over multiple arguments but has some major drawbacks that mean you generally shouldn’t use it. See this post for more details.\nNotes: Jim Hester’s article points out that most R functions are already vectorized, including paste()!\n\ncolor &lt;- c(\"blue\", \"red\", \"green\")\nobject &lt;- c(\"ball\", \"hat\", \"coat\")\nname &lt;- c(\"Sally\", \"Hank\", \"Darla\")\n\npaste(\"A\", color, object, \"for\", name)\n\n#&gt; [1] \"A blue ball for Sally\"  \"A red hat for Hank\"     \"A green coat for Darla\"\n\n\nIt also argues against use of Vectorize() because a) the functions it generates are not type stable, b) obfuscates the function code, c) can degrade performance, and d) can’t improve performance.\nHe recommends using existing vectorized functions and either vapply() or map().\n\n\nRead the source code for possibly(). How does it work?\n\n\npossibly\n\n#&gt; function (.f, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     .f &lt;- as_mapper(.f)\n#&gt;     force(otherwise)\n#&gt;     check_bool(quiet)\n#&gt;     function(...) {\n#&gt;         tryCatch(.f(...), error = function(e) {\n#&gt;             if (!quiet) \n#&gt;                 message(\"Error: \", conditionMessage(e))\n#&gt;             otherwise\n#&gt;         })\n#&gt;     }\n#&gt; }\n#&gt; &lt;bytecode: 0x116610438&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\n\nAnswer: possibly() returns a function that uses tryCatch() to return otherwise if the mapper .f errors, unless interrupted, forcing evaluation of otherwise before the mapper is called.\nAR Solutions: possibly() modifies functions to return a specified default value (otherwise) in case of an error and to suppress any error messages (quiet = TRUE).\nWhile reading the source code, we notice that possibly() internally uses purrr::as_mapper(). This enables users to supply not only functions, but also formulas or atomics via the same syntax as known from other functions in the {purrr} package. Besides this, the new default value (otherwise) gets evaluated once to make it (almost) immutable.\nThe main functionality of possibly() is provided by base::tryCatch(). In this part the supplied function (.f) gets wrapped and the error and interrupt handling are specified.\n\n\nRead the source code for safely(). How does it work?\n\n\nsafely\n\n#&gt; function (.f, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     .f &lt;- as_mapper(.f)\n#&gt;     force(otherwise)\n#&gt;     check_bool(quiet)\n#&gt;     function(...) capture_error(.f(...), otherwise, quiet)\n#&gt; }\n#&gt; &lt;bytecode: 0x116144358&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\npurrr:::capture_error\n\n#&gt; function (code, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     tryCatch(list(result = code, error = NULL), error = function(e) {\n#&gt;         if (!quiet) \n#&gt;             message(\"Error: \", conditionMessage(e))\n#&gt;         list(result = otherwise, error = e)\n#&gt;     })\n#&gt; }\n#&gt; &lt;bytecode: 0x1160c9040&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\n\nAnswer: safely() returns a function that uses the internal capture_error() function to store the evaluation of the mapper .f in result, and any error in error.\nAR Solutions: safely() modifies functions to return a list, containing the elements result and error. It works in a similar fashion as possibly() and besides using as_mapper(), safely() also provides the otherwise and quiet arguments. However, in order to provide the result and the error in a consistent way, the tryCatch() part of the implementation returns a list with similar structure for both cases. In the case of successful evaluation error equals NULL and in case of an error result equals otherwise, which is NULL by default.\nAs the tryCatch() part is hidden in the internal purrr:::capture_output() function, we provide it here in addition to safely().\nTake a look at Advanced R or the documentation of safely() to see how you can take advantage of this behaviour, e.g. when fitting many models.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#exercises-9",
    "href": "analysis/advanced-r-2.html#exercises-9",
    "title": "Advanced R (Functional programming)",
    "section": "11.3.1 Exercises",
    "text": "11.3.1 Exercises\n\nWeigh the pros and cons of download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1) versus download.file %&gt;% delay_by(0.1) %&gt;% dot_every(10).\n\nAnswer: in the first version, download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1), delay_by is the outer function, so a delay is added after the dot is written. In the second version, a dot is added after the delay. The first version seems better since the feedback dots aren’t delayed.\nAR Solutions: Both commands will print a dot every 10 downloads and will take the same amount of time to run, so the differences may seem quite subtle.\nIn the first case, first the dot functionality is added to download.file(). Then the delay is added to this already tweaked function. This implies, that the printing of the dot will also be delayed, and the first dot will be printed as soon as the download for the 10th URL starts.\nIn the latter case the delay is added first and the dot-functionality is wrapped around it. This order will print the first dot immediately after the 9th download is finished, then the short delay occurs before the 10th download actually starts.\nNote: the first case seems like the better option.\n\n\nShould you memoise file.download()? Why or why not?\n\nAnswer: download.file() should not be memoised! As mentioned in the chapter, the function is not pure (the output doesn’t depend only on the input), and has side effects (saving a file to disk).\nAR Solutions: Memoising file.download() will only work if the files are immutable, i.e. if the file at a given URL is always the same. There’s no point memoising unless this is true. Even if this is true, however, memoise has to store the results in memory, and large files will potentially take up a lot of memory.\nThis implies that it’s probably not beneficial to memoise file.download() in most cases. The only exception is if you are downloading small files many times, and the file at a given URL is guaranteed not to change.\nNote: AR Solutions offers a reasonable exception case when memoising makes sense.\n\n\nCreate a function operator that reports whenever a file is created or deleted in the working directory, using dir() and setdiff(). What other global function effects might you want to track?\n\n\nwd_changes &lt;- function(f) {\n  function(...) {\n    before &lt;- dir()\n    ret &lt;- withVisible(f(...))\n    after &lt;- dir()\n    removed &lt;- setdiff(before, after)\n    added &lt;- setdiff(after, before)\n    if (length(removed) != 0) cat(\"removed files: \", removed, \"\\n\")\n    if (length(added) != 0) cat(\"added files: \", added, \"\\n\")\n    if (ret$visible) {\n      ret$value\n    } else {\n      invisible(ret$value)\n    }\n  }\n}\n\nAnswer: code above. Other effects you might want to track include changes to the global environment, output, and conditions.\nAR Solutions: We start with a function that reports the difference between two vectors containing file names:\n\ndir_compare &lt;- function(old, new) {\n  if (setequal(old, new)) {\n    return()\n  }\n\n  added &lt;- setdiff(new, old)\n  removed &lt;- setdiff(old, new)\n\n  changes &lt;- c(\n    if (length(added) &gt; 0) paste0(\" * '\", added, \"' was added\"),\n    if (length(removed) &gt; 0) paste0(\" * '\", removed, \"' was removed\")\n  )\n  message(paste(changes, collapse = \"\\n\"))\n}\ndir_compare(c(\"x\", \"y\"), c(\"x\", \"y\"))\n\n#&gt; NULL\n\ndir_compare(c(\"x\", \"y\"), c(\"x\", \"a\"))\n\n#&gt;  * 'a' was added\n#&gt;  * 'y' was removed\n\n\nThen we wrap it up in a function operator\n\ntrack_dir &lt;- function(f) {\n  force(f)\n  function(...) {\n    dir_old &lt;- dir()\n    on.exit(dir_compare(dir_old, dir()), add = TRUE)\n\n    f(...)\n  }\n}\n\nAnd try it out by creating wrappers around file.create() and file.remove():\n\nfile_create &lt;- track_dir(file.create)\nfile_remove &lt;- track_dir(file.remove)\nfile_create(\"delete_me\")\n\n#&gt;  * 'delete_me' was added\n\n\n#&gt; [1] TRUE\n\nfile_remove(\"delete_me\")\n\n#&gt;  * 'delete_me' was removed\n\n\n#&gt; [1] TRUE\n\n\nTo create a more serious version of track_dir() one might provide optionality to set the full.names and recursive arguments of dir() to TRUE. This would enable to also track the creation/deletion of hidden files and files in folders contained in the working directory.\nOther global effects that might be worth tracking include changes regarding:\n\nthe search path and possibly introduced conflicts()\noptions() and par() which modify global settings\nthe path of the working directory\nenvironment variables\n\nNotes: AR Solutions use of multiple functions, messages and on.exit is preferable.\n\n\nWrite a function operator that logs a timestamp and message to a file every time a function is run.\n\n\nlog_call &lt;- function(f, logfile = \"log_call.log\") {\n  name &lt;- deparse(enexpr(f))\n  force(f)\n  force(logfile)\n\n  function(...) {\n    m &lt;- paste0(Sys.time(), \" log_call: \", name)\n    write(m, file = logfile, append = TRUE)\n    f(...)\n  }\n}\n\nAnswer: code above.\nAR Solutions: Our logger() function operator takes a function and a file path as input. One timestamp is written to the file under log_path when we call logger() and another timestamp is written to the same file each time the new function gets called.\n\nappend_line &lt;- function(path, ...) {\n  cat(..., \"\\n\", sep = \"\", file = path, append = TRUE)\n}\n\nlogger &lt;- function(f, log_path) {\n  force(f)\n  force(log_path)\n\n  append_line(log_path, \"created at: \", as.character(Sys.time()))\n  function(...) {\n    append_line(log_path, \"called at: \", as.character(Sys.time()))\n    f(...)\n  }\n}\n\nNote: AR Solutions creates a function append_line() instead of using write(), and adds a “created at:” time, but is otherwise functionally the same. My solution also logs the name of the function called.\n\n\nModify delay_by() so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called g &lt;- delay_by(1, f); g(); Sys.sleep(2); g() there shouldn’t be an extra delay.\n\n\nsleep_if &lt;- function(start, end, delay) {\n  sleep_time &lt;- delay - as.numeric(end - start)\n  if (sleep_time &gt; 0) Sys.sleep(sleep_time)\n}\n\ndelay_by &lt;- function(f, delay) {\n  force(f)\n  force(delay)\n\n  last_called &lt;- NULL\n  function(...) {\n    if (!is.null(last_called)) {\n      sleep_if(last_called, Sys.time(), delay)\n    }\n    on.exit(last_called &lt;&lt;- Sys.time(), add = TRUE)\n\n    f(...)\n  }\n}\n\nf &lt;- function() {\n  0\n}\ng &lt;- delay_by(f, 1)\nh &lt;- delay_by(f, 1)\n\nsystem.time({\n  h()\n  h()\n})\n\n#&gt;    user  system elapsed \n#&gt;   0.001   0.000   1.007\n\nsystem.time({\n  g()\n  Sys.sleep(2)\n  g()\n})\n\n#&gt;    user  system elapsed \n#&gt;   0.005   0.000   2.010\n\n\nAnswer: code above.\nAR Solutions:\nTo ensure that the function created by delay_by() waits that a certain amount of time has passed since its last execution, we incorporate three little changes into our new delay_atleast() as indicated in the corresponding comments below.\n\ndelay_atleast &lt;- function(amount, f) {\n  force(f)\n  force(amount)\n\n  # Store the last time the function was run\n  last_time &lt;- NULL\n\n  # Return modified \"delay-aware\" function\n  function(...) {\n    if (!is.null(last_time)) {\n      wait &lt;- (last_time - Sys.time()) + amount\n      if (wait &gt; 0) {\n        Sys.sleep(wait)\n      }\n    }\n\n    # Update the time after the function has finished\n    on.exit(last_time &lt;&lt;- Sys.time())\n\n    f(...)\n  }\n}\n\nNotes: this was tricky; I had to consult AR Solutions for an answer.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#footnotes",
    "href": "analysis/advanced-r-2.html#footnotes",
    "title": "Advanced R (Functional programming)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTypically it’s not the for loop itself that’s slow, but what you’re doing inside of it. A common culprit of slow loops is modifying a data structure, where each modification generates a copy. See Sections 2.5.1 and 24.6 for more details.↩︎",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html",
    "href": "analysis/advanced-r-4.html",
    "title": "Advanced R (Metaprogramming)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Metaprogramming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions.\nlibrary(lobstr)\nlibrary(rlang)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises",
    "href": "analysis/advanced-r-4.html#exercises",
    "title": "Advanced R (Metaprogramming)",
    "section": "18.2.4 Exercises",
    "text": "18.2.4 Exercises\n\nReconstruct the code represented by the trees below:\n\n\n#&gt; █─f\n#&gt; └─█─g\n#&gt;   └─█─h\n#&gt; █─`+`\n#&gt; ├─█─`+`\n#&gt; │ ├─1\n#&gt; │ └─2\n#&gt; └─3\n#&gt; █─`*`\n#&gt; ├─█─`(`\n#&gt; │ └─█─`+`\n#&gt; │   ├─x\n#&gt; │   └─y\n#&gt; └─z\n\nAnswer: code below.\n\nlobstr::ast(f(g(h())))\n\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h\n\nlobstr::ast(1 + 2 + 3)\n\n#&gt; █─`+` \n#&gt; ├─█─`+` \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─3\n\nlobstr::ast((x + y) * z)\n\n#&gt; █─`*` \n#&gt; ├─█─`(` \n#&gt; │ └─█─`+` \n#&gt; │   ├─x \n#&gt; │   └─y \n#&gt; └─z\n\n\nAR Solutions: Let the source (of the code chunks above) be with you and show you how the ASTs (abstract syntax trees) were produced.\n\nast(f(g(h())))\n\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h\n\nast(1 + 2 + 3)\n\n#&gt; █─`+` \n#&gt; ├─█─`+` \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─3\n\nast((x + y) * z)\n\n#&gt; █─`*` \n#&gt; ├─█─`(` \n#&gt; │ └─█─`+` \n#&gt; │   ├─x \n#&gt; │   └─y \n#&gt; └─z\n\n\n\n\nDraw the following trees by hand and then check your answers with lobstr::ast().\n\n\nf(g(h(i(1, 2, 3))))\nf(1, g(2, h(3, i())))\nf(g(1, 2), h(3, i(4, 5)))\n\nAnswer: code below, expression 1:\n\n#&gt; █─f\n#&gt; └─█─g\n#&gt;   └─█─h\n#&gt;     └─█─i\n#&gt;       └─1\n#&gt;       └─2\n#&gt;       └─3\nlobstr::ast(f(g(h(i(1, 2, 3)))))\n\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h \n#&gt;     └─█─i \n#&gt;       ├─1 \n#&gt;       ├─2 \n#&gt;       └─3\n\n\nExpression 2:\n\n#&gt; █─f\n#&gt; └─1\n#&gt; └─█─g\n#&gt;   └─2\n#&gt;   └─█─h\n#&gt;     └─3\n#&gt;     └─█─i\nlobstr::ast(f(1, g(2, h(3, i()))))\n\n#&gt; █─f \n#&gt; ├─1 \n#&gt; └─█─g \n#&gt;   ├─2 \n#&gt;   └─█─h \n#&gt;     ├─3 \n#&gt;     └─█─i\n\n\nExpression 3:\n\n#&gt; █─f\n#&gt; └─█─g\n#&gt; | └─1\n#&gt; | └─2\n#&gt; └─█─h\n#&gt;   └─3\n#&gt;   └─█─i\n#&gt;     └─4\n#&gt;     └─5\nlobstr::ast(f(g(1, 2), h(3, i(4, 5))))\n\n#&gt; █─f \n#&gt; ├─█─g \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─█─h \n#&gt;   ├─3 \n#&gt;   └─█─i \n#&gt;     ├─4 \n#&gt;     └─5\n\n\nAR Solutions: Let us delegate the drawing to the lobstr package.\n\n\nWhat’s happening with the ASTs below? (Hint: carefully read ?\"^\".)\n\n\nlobstr::ast(`x` + `y`)\n\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─y\n\nlobstr::ast(x ** y) # styler: off\n\n#&gt; █─`^` \n#&gt; ├─x \n#&gt; └─y\n\nlobstr::ast(1 -&gt; x)\n\n#&gt; █─`&lt;-` \n#&gt; ├─x \n#&gt; └─1\n\n\nAnswer: all expressions are changed to their normal forms. In the first expression, the back ticks denoting symbols are not needed. In the third expression, the assignment operator is changed to the standard form. In the second expression, the operator is changed per this note in the R documentation:\n\n** is translated in the parser to ^, but this was undocumented for many years. It appears as an index entry in Becker et al (1988), pointing to the help for Deprecated but is not actually mentioned on that page. Even though it had been deprecated in S for 20 years, it was still accepted in R in 2008.\n\nAR Solutions: ASTs start function calls with the name of the function. This is why the call in the first expression is translated into its prefix form. In the second case, ** is translated by R’s parser into ^. In the last AST, the expression is flipped when R parses it.\n\n\nWhat is special about the AST below? (Hint: re-read Section 6.2.1.)\n\n\nlobstr::ast(function(x = 1, y = 2) {})\n\n#&gt; █─`function` \n#&gt; ├─█─x = 1 \n#&gt; │ └─y = 2 \n#&gt; ├─█─`{` \n#&gt; └─&lt;inline srcref&gt;\n\n\nAnswer: the AST includes two of the three parts of the function, the formals(), x and y, the body(), represented by { and &lt;inline srcref&gt;.\nAR Solutions: The last leaf of the AST is not explicitly specified in the expression. Instead, the srcref attribute, which points to the functions source code, is automatically created by base R.\n\n\nWhat does the call tree of an if statement with multiple else if conditions look like? Why?\n\nAnswer: the call tree shows nested if statements; this is because if-else is a function with three arguments, the cond, the cons.expr and the alt.expr. The alt.expr for each if-else statement is a new call to if.\n\nlobstr::ast(\n  if (v == 1) {\n    print(\"one\")\n  } else if (v == 2) {\n    print(\"two\")\n  } else if (v == 3) {\n    print(\"three\")\n  } else if (v == 4) {\n    print(\"four\")\n  }\n)\n\n#&gt; █─`if` \n#&gt; ├─█─`==` \n#&gt; │ ├─v \n#&gt; │ └─1 \n#&gt; ├─█─`{` \n#&gt; │ └─█─print \n#&gt; │   └─\"one\" \n#&gt; └─█─`if` \n#&gt;   ├─█─`==` \n#&gt;   │ ├─v \n#&gt;   │ └─2 \n#&gt;   ├─█─`{` \n#&gt;   │ └─█─print \n#&gt;   │   └─\"two\" \n#&gt;   └─█─`if` \n#&gt;     ├─█─`==` \n#&gt;     │ ├─v \n#&gt;     │ └─3 \n#&gt;     ├─█─`{` \n#&gt;     │ └─█─print \n#&gt;     │   └─\"three\" \n#&gt;     └─█─`if` \n#&gt;       ├─█─`==` \n#&gt;       │ ├─v \n#&gt;       │ └─4 \n#&gt;       └─█─`{` \n#&gt;         └─█─print \n#&gt;           └─\"four\"\n\n\nAR Solutions: The AST of nested else if statements might look a bit confusing because it contains multiple curly braces. However, we can see that in the else part of the AST just another expression is being evaluated, which happens to be an if statement and so forth.\n\nast(\n  if (FALSE) {\n    1\n  } else if (FALSE) {\n    2\n  } else if (TRUE) {\n    3\n  }\n)\n\n#&gt; █─`if` \n#&gt; ├─FALSE \n#&gt; ├─█─`{` \n#&gt; │ └─1 \n#&gt; └─█─`if` \n#&gt;   ├─FALSE \n#&gt;   ├─█─`{` \n#&gt;   │ └─2 \n#&gt;   └─█─`if` \n#&gt;     ├─TRUE \n#&gt;     └─█─`{` \n#&gt;       └─3\n\n\nWe can see the structure more clearly if we avoid the curly braces:\n\nast(\n  # styler: off\n  if (FALSE) 1\n  else if (FALSE) 2\n  else if (TRUE) 3\n  # styler: on\n)\n\n#&gt; █─`if` \n#&gt; ├─FALSE \n#&gt; ├─1 \n#&gt; └─█─`if` \n#&gt;   ├─FALSE \n#&gt;   ├─2 \n#&gt;   └─█─`if` \n#&gt;     ├─TRUE \n#&gt;     └─3",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-1",
    "href": "analysis/advanced-r-4.html#exercises-1",
    "title": "Advanced R (Metaprogramming)",
    "section": "18.3.5 Exercises",
    "text": "18.3.5 Exercises\n\nWhich two of the six types of atomic vector can’t appear in an expression? Why? Similarly, why can’t you create an expression that contains an atomic vector of length greater than one?\n\nAnswer: raw and some complex numbers can’t appear in an expression, since constructing both requires a function call (raw() and + respectively). Similarly, creating atomic vectors longer than one requires c().\n\nexpr(f(TRUE, 1L, 1.0, \"x\", 1i, raw(1L), 1 + 1i))\n\n#&gt; f(TRUE, 1L, 1, \"x\", 0+1i, raw(1L), 1 + (0+1i))\n\nexpr(c(1, 2))\n\n#&gt; c(1, 2)\n\n\nAR Solutions: There is no way to create raws and complex atomics without using a function call (this is only possible for imaginary scalars like i, 5i etc.). But expressions that include a function are calls. Therefore, both of these vector types cannot appear in an expression.\nSimilarly, it is not possible to create an expression that evaluates to an atomic of length greater than one without using a function (e.g. c()).\nLet’s make this observation concrete via an example:\n\n# Atomic\nis_atomic(expr(1))\n\n#&gt; [1] TRUE\n\n# Not an atomic (although it would evaluate to an atomic)\nis_atomic(expr(c(1, 1)))\n\n#&gt; [1] FALSE\n\nis_call(expr(c(1, 1)))\n\n#&gt; [1] TRUE\n\n\n\n\nWhat happens when you subset a call object to remove the first element? e.g. expr(read.csv(\"foo.csv\", header = TRUE))[-1]. Why?\n\nAnswer: as the result demonstrates, this removes the function call which makes the first argument the new function call in the expression, since the AST structure (call object) is preserved, and the first element of the call object is the function position.\n\nexpr(read.csv(\"foo.csv\", header = TRUE))[-1]\n\n#&gt; \"foo.csv\"(header = TRUE)\n\n\nAR Solutions: When the first element of a call object is removed, the second element moves to the first position, which is the function to call. Therefore, we get \"foo.csv\"(header = TRUE).\n\n\nDescribe the differences between the following call objects.\n\n\nx &lt;- 1:10\ncall2(median, x, na.rm = TRUE)\ncall2(expr(median), x, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\ncall2(expr(median), expr(x), na.rm = TRUE)\n\nAnswer: the objects differ in their use of expr(). When using bare median and x, the object uses the evaluated function and value of x where using expr() prevents evaluation.\n\nmedian\n\n#&gt; function (x, na.rm = FALSE, ...) \n#&gt; UseMethod(\"median\")\n#&gt; &lt;bytecode: 0x105c7c008&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nexpr(median)\n\n#&gt; median\n\nx\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nexpr(x)\n\n#&gt; x\n\n\nAR Solutions: The call objects differ in their first two elements, which are in some cases evaluated before the call is constructed. In the first one, both median() and x are evaluated and inlined into the call. Therefore, we can see in the constructed call that median is a generic and the x argument is 1:10.\n\ncall2(median, x, na.rm = TRUE)\n\n#&gt; (function (x, na.rm = FALSE, ...) \n#&gt; UseMethod(\"median\"))(1:10, na.rm = TRUE)\n\n\nIn the following calls we remain with differing combinations. Once, only x and once only median() gets evaluated.\n\ncall2(expr(median), x, na.rm = TRUE)\n\n#&gt; median(1:10, na.rm = TRUE)\n\ncall2(median, expr(x), na.rm = TRUE)\n\n#&gt; (function (x, na.rm = FALSE, ...) \n#&gt; UseMethod(\"median\"))(x, na.rm = TRUE)\n\n\nIn the final call neither x nor median() is evaluated.\n\ncall2(expr(median), expr(x), na.rm = TRUE)\n\n#&gt; median(x, na.rm = TRUE)\n\n\nNote that all these calls will generate the same result when evaluated. The key difference is when the values bound to the x and median symbols are found.\n\n\nrlang::call_standardise() doesn’t work so well for the following calls. Why? What makes mean() special?\n\n\ncall_standardise(quote(mean(1:10, na.rm = TRUE)))\n\n#&gt; Warning: `call_standardise()` is deprecated as of rlang 0.4.11\n#&gt; This warning is displayed once every 8 hours.\n\n\n#&gt; mean(x = 1:10, na.rm = TRUE)\n\ncall_standardise(quote(mean(n = T, 1:10)))\n\n#&gt; mean(x = 1:10, n = T)\n\ncall_standardise(quote(mean(x = 1:10, , TRUE)))\n\n#&gt; mean(x = 1:10, , TRUE)\n\n\nAnswer: as noted in the book, “If the function uses ... it’s not possible to standardise all arguments.” mean() has a single argument, x, and uses ... for the remaining arguments, although the default S3 method is mean(x, trim = 0, na.rm = FALSE, ...).\nAR Solutions: The reason for this unexpected behaviour is that mean() uses the ... argument and therefore cannot standardise the regarding arguments. Since mean() uses S3 dispatch (i.e. UseMethod()) and the underlying mean.default() method specifies some more arguments, call_standardise() can do much better with a specific S3 method.\n\n\nWhy does this code not make sense?\n\n\nx &lt;- expr(foo(x = 1))\nnames(x) &lt;- c(\"x\", \"y\")\n\nAnswer: as the code below demonstrates, the only symbol (name) in the expression is x. Assigning a name to both components changes x to y but doesn’t change the function call foo.\n\nex &lt;- expr(foo(x = 1))\nnames(ex)\n\n#&gt; [1] \"\"  \"x\"\n\nnames(ex) &lt;- c(\"x\", \"y\")\nex\n\n#&gt; foo(y = 1)\n\n\nAR Solutions: As stated in Advanced R\n\nThe first element of a call is always the function that gets called.\n\nLet’s see what happens when we run the code\n\nx &lt;- expr(foo(x = 1))\nx\n\n#&gt; foo(x = 1)\n\nnames(x) &lt;- c(\"x\", \"\")\nx\n\n#&gt; foo(1)\n\nnames(x) &lt;- c(\"\", \"x\")\nx\n\n#&gt; foo(x = 1)\n\n\nSo, giving the first element a name just adds metadata that R ignores.\n\n\nConstruct the expression if(x &gt; 1) \"a\" else \"b\" using multiple calls to call2(). How does the code structure reflect the structure of the AST?\n\nAnswer: code below. The call2() structure mirrors the AST of the if expression.\n\ncall2(\"if\", call2(\"&gt;\", expr(x), 1), \"a\", \"b\")\n\n#&gt; if (x &gt; 1) \"a\" else \"b\"\n\nlobstr::ast(if (x &gt; 1) \"a\" else \"b\")\n\n#&gt; █─`if` \n#&gt; ├─█─`&gt;` \n#&gt; │ ├─x \n#&gt; │ └─1 \n#&gt; ├─\"a\" \n#&gt; └─\"b\"\n\n\nAR Solutions: Similar to the prefix version we get\n\ncall2(\"if\", call2(\"&gt;\", sym(\"x\"), 1), \"a\", \"b\")\n\n#&gt; if (x &gt; 1) \"a\" else \"b\"\n\n\nWhen we read the AST from left to right, we get the same structure: Function to evaluate, expression, which is another function and is evaluated first, and two constants which will be evaluated next.\n\nast(`if`(x &gt; 1, \"a\", \"b\"))\n\n#&gt; █─`if` \n#&gt; ├─█─`&gt;` \n#&gt; │ ├─x \n#&gt; │ └─1 \n#&gt; ├─\"a\" \n#&gt; └─\"b\"",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-2",
    "href": "analysis/advanced-r-4.html#exercises-2",
    "title": "Advanced R (Metaprogramming)",
    "section": "18.4.4 Exercises",
    "text": "18.4.4 Exercises\n\nR uses parentheses in two slightly different ways as illustrated by these two calls:\n\n\nf((1))\n`(`(1 + 1)\n\nCompare and contrast the two uses by referencing the AST.\nAnswer: R uses parentheses both as a function and as part of a function call. In the first call, the outer parentheses are for f and the inner represent ( with a single parameter. In the second call, equivalent to (1 + 1), the parentheses are for the ( function call.\n\nlobstr::ast(f((1)))\n\n#&gt; █─f \n#&gt; └─█─`(` \n#&gt;   └─1\n\nlobstr::ast(`(`(1 + 1))\n\n#&gt; █─`(` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─1\n\nlobstr::ast((1 + 1))\n\n#&gt; █─`(` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─1\n\n\nAR Solutions: The trick with these examples lies in the fact that ( can be a part of R’s general prefix function syntax but can also represent a call to the ( function.\nSo, in the AST of the first example, we will not see the outer ( since it is prefix function syntax and belongs to f(). In contrast, the inner ( is a function (represented as a symbol in the AST):\n\nast(f((1)))\n\n#&gt; █─f \n#&gt; └─█─`(` \n#&gt;   └─1\n\n\nIn the second example, we can see that the outer ( is a function and the inner ( belongs to its syntax:\n\nast(`(`(1 + 1))\n\n#&gt; █─`(` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─1\n\n\nFor the sake of clarity, let’s also create a third example, where none of the ( is part of another function’s syntax:\n\nast(((1 + 1)))\n\n#&gt; █─`(` \n#&gt; └─█─`(` \n#&gt;   └─█─`+` \n#&gt;     ├─1 \n#&gt;     └─1\n\n\n\n\n= can also be used in two ways. Construct a simple example that shows both uses.\n\nAnswer: = can be used for assignment and also for function parameters.\n\nlobstr::ast(`=`(val, sum(10, na.rm = TRUE)))\n\n#&gt; █─`=` \n#&gt; ├─val \n#&gt; └─█─sum \n#&gt;   ├─10 \n#&gt;   └─na.rm = TRUE\n\n\nAR Solutions: = is used both for assignment, and for naming arguments in function calls:\n\nb = c(c = 1) # styler: off\n\nSo, when we play with ast(), we can directly see that the following is not possible:\n\ntry(ast(b = c(c = 1)))\n\n#&gt; Error in ast(b = c(c = 1)) : unused argument (b = c(c = 1))\n\n\nWe get an error because b = makes R looking for an argument called b. Since x is the only argument of ast(), we get an error.\nThe easiest way around this problem is to wrap this line in {}.\n\nast({b = c(c = 1)})  # styler: off\n\n#&gt; █─`{` \n#&gt; └─█─`=` \n#&gt;   ├─b \n#&gt;   └─█─c \n#&gt;     └─c = 1\n\n\nWhen we ignore the braces and compare the trees, we can see that the first = is used for assignment and the second = is part of the syntax of function calls.\n\n\nDoes -2^2 yield 4 or -4? Why?\n\nAnswer: the result is -4, because ^ has higher precedence than -:\n\n-2^2\n\n#&gt; [1] -4\n\nlobstr::ast(-2^2)\n\n#&gt; █─`-` \n#&gt; └─█─`^` \n#&gt;   ├─2 \n#&gt;   └─2\n\n\nAR Solutions: It yields -4, because ^ has a higher operator precedence than -, which we can verify by looking at the AST (or looking it up under ?\"Syntax\"):\n\n-2^2\n\n#&gt; [1] -4\n\nast(-2^2)\n\n#&gt; █─`-` \n#&gt; └─█─`^` \n#&gt;   ├─2 \n#&gt;   └─2\n\n\n\n\nWhat does !1 + !1 return? Why?\n\nAnswer: FALSE. As the AST demonstrates, the ! operator takes precedence.\n\n!1 + !1\n\n#&gt; [1] FALSE\n\nlobstr::ast(!1 + !1)\n\n#&gt; █─`!` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─█─`!` \n#&gt;     └─1\n\n\nThe result can be demonstrated by evaluating the AST in steps:\n\n!1 # FALSE\n\n#&gt; [1] FALSE\n\n1 + FALSE # 1\n\n#&gt; [1] 1\n\n!1 # FALSE\n\n#&gt; [1] FALSE\n\n\nAR Solutions: The answer is a little surprising:\n\n!1 + !1\n\n#&gt; [1] FALSE\n\n\nTo answer the “why?”, we take a look at the AST:\n\nast(!1 + !1)\n\n#&gt; █─`!` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─█─`!` \n#&gt;     └─1\n\n\nThe right !1 is evaluated first. It evaluates to FALSE, because R coerces every non 0 numeric to TRUE, when a logical operator is applied. The negation of TRUE then equals FALSE.\nNext 1 + FALSE is evaluated to 1, since FALSE is coerced to 0.\nFinally !1 is evaluated to FALSE.\nNote that if ! had a higher precedence, the intermediate result would be FALSE + FALSE, which would evaluate to 0.\n\n\nWhy does x1 &lt;- x2 &lt;- x3 &lt;- 0 work? Describe the two reasons.\n\nAnswer: assignment is right-associative: x1 &lt;- (x2 &lt;- 0) and x1 &lt;- x2 &lt;- 0 are equivalent, and the rightmost assignment operator is evaluated first.\n\nlobstr::ast(x1 &lt;- x2 &lt;- x3 &lt;- 0)\n\n#&gt; █─`&lt;-` \n#&gt; ├─x1 \n#&gt; └─█─`&lt;-` \n#&gt;   ├─x2 \n#&gt;   └─█─`&lt;-` \n#&gt;     ├─x3 \n#&gt;     └─0\n\n\nAR Solutions: One reason is that &lt;- is right-associative, i.e. evaluation takes place from right to left:\n\nx1 &lt;- (x2 &lt;- (x3 &lt;- 0))\n\nThe other reason is that &lt;- invisibly returns the value on the right-hand side.\n\n(x3 &lt;- 0)\n\n#&gt; [1] 0\n\n\nNote: I forgot that &lt;- returns the value invisibly.\n\n\nCompare the ASTs of x + y %+% z and x ^ y %+% z. What have you learned about the precedence of custom infix functions?\n\nAnswer: custom infix functions have higher precedence than + and lower precedence than ^.\n\nlobstr::ast(x + y %+% z)\n\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─█─`%+%` \n#&gt;   ├─y \n#&gt;   └─z\n\nlobstr::ast(x ^ y %+% z) # styler: off\n\n#&gt; █─`%+%` \n#&gt; ├─█─`^` \n#&gt; │ ├─x \n#&gt; │ └─y \n#&gt; └─z\n\n\nAR Solutions: Let’s take a look at the syntax trees:\n\nast(x + y %+% z)\n\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─█─`%+%` \n#&gt;   ├─y \n#&gt;   └─z\n\n\nHere y %+% z will be calculated first and the result will be added to x.\n\nast(x ^ y %+% z) # styler: off\n\n#&gt; █─`%+%` \n#&gt; ├─█─`^` \n#&gt; │ ├─x \n#&gt; │ └─y \n#&gt; └─z\n\n\nHere x ^ y will be calculated first, and the result will be used as first argument to %+%(). We can conclude that custom infix functions have precedence between addition and exponentiation. The exact precedence of infix functions can be looked up under ?\"Syntax\" where we see that it lies directly behind the sequence operator (:) and in front of the multiplication and division operators (* and /).\n\n\nWhat happens if you call parse_expr() with a string that generates multiple expressions? e.g. parse_expr(\"x + 1; y + 1\")\n\nAnswer: parse_expr() throws an error. Use parse_exprs() with strings containing multiple expressions.\n\ntry(parse_expr(\"x + 1; y + 1\"))\n\n#&gt; Error in parse_expr(\"x + 1; y + 1\") : \n#&gt;   `x` must contain exactly 1 expression, not 2.\n\nparse_exprs(\"x + 1; y + 1\")\n\n#&gt; [[1]]\n#&gt; x + 1\n#&gt; \n#&gt; [[2]]\n#&gt; y + 1\n\n\nAR Solutions: In this case parse_expr() notices that more than one expression would have to be generated and throws an error.\n\ntry(parse_expr(\"x + 1; y + 1\"))\n\n#&gt; Error in parse_expr(\"x + 1; y + 1\") : \n#&gt;   `x` must contain exactly 1 expression, not 2.\n\n\n\n\nWhat happens if you attempt to parse an invalid expression? e.g. \"a +\" or \"f())\".\n\nAnswer: parse_expr() throws an error.\n\ntry(parse_expr(\"a +\"))\n\n#&gt; Error in parse(text = x, keep.source = FALSE) : \n#&gt;   &lt;text&gt;:2:0: unexpected end of input\n#&gt; 1: a +\n#&gt;    ^\n\ntry(parse_expr(\"f())\"))\n\n#&gt; Error in parse(text = x, keep.source = FALSE) : \n#&gt;   &lt;text&gt;:1:4: unexpected ')'\n#&gt; 1: f())\n#&gt;        ^\n\n\nAR Solutions: Invalid expressions will lead to an error in the underlying parse() function.\n\ntry(parse_expr(\"a +\"))\n\n#&gt; Error in parse(text = x, keep.source = FALSE) : \n#&gt;   &lt;text&gt;:2:0: unexpected end of input\n#&gt; 1: a +\n#&gt;    ^\n\ntry(parse_expr(\"f())\"))\n\n#&gt; Error in parse(text = x, keep.source = FALSE) : \n#&gt;   &lt;text&gt;:1:4: unexpected ')'\n#&gt; 1: f())\n#&gt;        ^\n\ntry(parse(text = \"a +\"))\n\n#&gt; Error in parse(text = \"a +\") : &lt;text&gt;:2:0: unexpected end of input\n#&gt; 1: a +\n#&gt;    ^\n\ntry(parse(text = \"f())\"))\n\n#&gt; Error in parse(text = \"f())\") : &lt;text&gt;:1:4: unexpected ')'\n#&gt; 1: f())\n#&gt;        ^\n\n\n\n\ndeparse() produces vectors when the input is long. For example, the following call produces a vector of length two:\n\n\nexpr &lt;- expr(g(a + b + c + d + e + f + g + h + i + j + k + l +\n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\ndeparse(expr)\n\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + \"\n#&gt; [2] \"    p + q + r + s + t + u + v + w + x + y + z)\"\n\n\nWhat does expr_text() do instead?\nAnswer: expr_text() adds a newline (\\n) instead.\n\nexpr_text(expr)\n\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + \\n    p + q + r + s + t + u + v + w + x + y + z)\"\n\n\nAR Solutions: expr_text() will paste the results from deparse(expr) together and use a linebreak (\\n) as separator.\n\nexpr &lt;- expr(g(a + b + c + d + e + f + g + h + i + j + k + l + m +\n  n + o + p + q + r + s + t + u + v + w + x + y + z))\ndeparse(expr)\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + \"\n#&gt; [2] \"o + p + q + r + s + t + u + v + w + x + y + z)\"\nexpr_text(expr)\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n\n#&gt; + \\n    o + p + q + r + s + t + u + v + w + x + y + z)\"\n\n\n\npairwise.t.test() assumes that deparse() always returns a length one character vector. Can you construct an input that violates this expectation? What happens?\n\nAnswer: an especially long input for x or g would create a character vector of length two or more. However, starting in R 4.0.0, pairwise.t.test() uses deparse1() which guarantees a string (character of length one), so it is no longer possible to break pairwise.t.test().\n\npairwise.t.test\n\n#&gt; function (x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, \n#&gt;     paired = FALSE, alternative = c(\"two.sided\", \"less\", \"greater\"), \n#&gt;     ...) \n#&gt; {\n#&gt;     if (paired && pool.sd) \n#&gt;         stop(\"pooling of SD is incompatible with paired tests\")\n#&gt;     DNAME &lt;- paste(deparse1(substitute(x)), \"and\", deparse1(substitute(g)))\n#&gt;     g &lt;- factor(g)\n#&gt;     p.adjust.method &lt;- match.arg(p.adjust.method)\n#&gt;     alternative &lt;- match.arg(alternative)\n#&gt;     if (pool.sd) {\n#&gt;         METHOD &lt;- \"t tests with pooled SD\"\n#&gt;         xbar &lt;- tapply(x, g, mean, na.rm = TRUE)\n#&gt;         s &lt;- tapply(x, g, sd, na.rm = TRUE)\n#&gt;         n &lt;- tapply(!is.na(x), g, sum)\n#&gt;         degf &lt;- n - 1\n#&gt;         total.degf &lt;- sum(degf)\n#&gt;         pooled.sd &lt;- sqrt(sum(s^2 * degf)/total.degf)\n#&gt;         compare.levels &lt;- function(i, j) {\n#&gt;             dif &lt;- xbar[i] - xbar[j]\n#&gt;             se.dif &lt;- pooled.sd * sqrt(1/n[i] + 1/n[j])\n#&gt;             t.val &lt;- dif/se.dif\n#&gt;             if (alternative == \"two.sided\") \n#&gt;                 2 * pt(-abs(t.val), total.degf)\n#&gt;             else pt(t.val, total.degf, lower.tail = (alternative == \n#&gt;                 \"less\"))\n#&gt;         }\n#&gt;     }\n#&gt;     else {\n#&gt;         METHOD &lt;- if (paired) \n#&gt;             \"paired t tests\"\n#&gt;         else \"t tests with non-pooled SD\"\n#&gt;         compare.levels &lt;- function(i, j) {\n#&gt;             xi &lt;- x[as.integer(g) == i]\n#&gt;             xj &lt;- x[as.integer(g) == j]\n#&gt;             t.test(xi, xj, paired = paired, alternative = alternative, \n#&gt;                 ...)$p.value\n#&gt;         }\n#&gt;     }\n#&gt;     PVAL &lt;- pairwise.table(compare.levels, levels(g), p.adjust.method)\n#&gt;     ans &lt;- list(method = METHOD, data.name = DNAME, p.value = PVAL, \n#&gt;         p.adjust.method = p.adjust.method)\n#&gt;     class(ans) &lt;- \"pairwise.htest\"\n#&gt;     ans\n#&gt; }\n#&gt; &lt;bytecode: 0x105d29340&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\ndeparse(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))\n\n#&gt; [1] \"c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, \"\n#&gt; [2] \"18)\"\n\npairwise.t.test(1:18, c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))\n\n#&gt; \n#&gt;  Pairwise comparisons using t tests with pooled SD \n#&gt; \n#&gt; data:  1:18 and c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18) \n#&gt; \n#&gt;    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17\n#&gt; 2  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 3  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 4  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 5  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 6  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 7  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 8  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 9  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 10 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 11 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 12 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 13 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 14 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 15 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 16 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 17 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 18 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; \n#&gt; P value adjustment method: holm\n\n\nAR Solutions: The function pairwise.t.test() captures its data arguments (x and g) so it can print the input expressions along the computed p-values. Prior to R 4.0.0 this used to be implemented via deparse(substitute(x)) in combination with paste(). This could lead to unexpected output, if one of the inputs exceeded the default width.cutoff value of 60 characters within deparse(). In this case, the expression would be split into a character vector of length greater 1.\n\n# Output in R version 3.6.2\nd &lt;- 1\npairwise.t.test(2, d + d + d + d + d + d + d + d +\n  d + d + d + d + d + d + d + d + d)\n#&gt;  Pairwise comparisons using t tests with pooled SD\n#&gt;\n#&gt; data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d\n#&gt; + d + d +  2 and     d\n#&gt;\n#&gt; &lt;0 x 0 matrix&gt;\n#&gt;\n#&gt; P value adjustment method: holm\n\nIn R 4.0.0 pairwise.t.test() was updated to use the newly introduced deparse1(), which serves as a wrapper around deparse().\n\ndeparse1() is a simple utility added in R 4.0.0 to ensure a string result (character vector of length one), typically used in name construction, as deparse1(substitute(.)).\n\n\n# Output since R 4.0.0\nd &lt;- 1\npairwise.t.test(2, d + d + d + d + d + d + d + d +\n  d + d + d + d + d + d + d + d + d)\n#&gt;  Pairwise comparisons using t tests with pooled SD\n#&gt;\n#&gt; data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d\n#&gt; + d + d + d\n#&gt;\n#&gt; &lt;0 x 0 matrix&gt;\n#&gt;\n#&gt; P value adjustment method: holm\n\n\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-3",
    "href": "analysis/advanced-r-4.html#exercises-3",
    "title": "Advanced R (Metaprogramming)",
    "section": "18.5.3 Exercises",
    "text": "18.5.3 Exercises\n\nlogical_abbr() returns TRUE for T(1, 2, 3). How could you modify logical_abbr_rec() so that it ignores function calls that use T or F?\n\nAR Solutions: We can apply a similar logic as in the assignment example from Advanced R. We just treat it as a special case handled within a sub function called find_T_call(), which finds T() calls and “bounces them out”. Therefore, we also repeat the expr_type() helper which tells us if we are in the base or in the recursive case.\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \",\n      typeof(x),\n      call. = FALSE\n    )\n  )\n}\n\n\nfind_T_call &lt;- function(x) {\n  if (is_call(x, \"T\")) {\n    x &lt;- as.list(x)[-1]\n    purrr::some(x, logical_abbr_rec)\n  } else {\n    purrr::some(x, logical_abbr_rec)\n  }\n}\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\"),\n\n    # Recursive cases\n    pairlist = purrr::some(x, logical_abbr_rec),\n    call = find_T_call(x)\n  )\n}\nlogical_abbr &lt;- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nNow let’s test our new logical_abbr() function:\n\nlogical_abbr(T(1, 2, 3))\n\n#&gt; [1] FALSE\n\nlogical_abbr(T(T, T(3, 4)))\n\n#&gt; [1] TRUE\n\nlogical_abbr(T(T))\n\n#&gt; [1] TRUE\n\nlogical_abbr(T())\n\n#&gt; [1] FALSE\n\nlogical_abbr()\n\n#&gt; [1] FALSE\n\nlogical_abbr(c(T, T, T))\n\n#&gt; [1] TRUE\n\n\nAnswer: taken from Advanced R solutions, we need to find function calls within the recursive call. The trick is to find and remove the T or F from the list:\n\nfind_tf_call &lt;- function(x) {\n  if (is_call(x, \"T\") || is_call(x, \"F\")) {\n    x &lt;- as.list(x)[-1]\n    purrr::some(x, logical_abbr_rec)\n  } else {\n    purrr::some(x, logical_abbr_rec)\n  }\n}\n\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\"),\n\n    # Recursive cases\n    pairlist = purrr::some(x, logical_abbr_rec),\n    call = find_tf_call(x)\n  )\n}\n\nlogical_abbr &lt;- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nlogical_abbr(T) # TRUE\n\n#&gt; [1] TRUE\n\nlogical_abbr(FALSE) # FALSE\n\n#&gt; [1] FALSE\n\nlogical_abbr(T(1, 2, 3)) # FALSE\n\n#&gt; [1] FALSE\n\nlogical_abbr(F(1, 2, 3)) # FALSE\n\n#&gt; [1] FALSE\n\n\nNote: I was unable to solve this exercise on my own, and needed to consult AR Solutions. The AR Solutions version only implements T, adding F is trivial.\n\n\nlogical_abbr() works with expressions. It currently fails when you give it a function. Why? How could you modify logical_abbr() to make it work? What components of a function will you need to recurse over?\n\n\nlogical_abbr(function(x = TRUE) {\n  g(x + T)\n})\n\nAR Solutions: The function currently fails, because \"closure\" is not handled in switch_expr() within logical_abbr_rec().\n\nf &lt;- function(x = TRUE) {\n  g(x + T)\n}\ntry(logical_abbr(!!f))\n\n#&gt; Error : Don't know how to handle type closure\n\n\nIf we want to make it work, we have to write a function to also iterate over the formals and the body of the input function.\nAnswer: the above example evaluates successfully as TRUE, however, the following fails, presumably because expr_type doesn’t handle closure:\n\ntry(logical_abbr(function(x = TRUE) {\n  g(x)\n}))\n\n#&gt; Error : Don't know how to handle type integer\n\nis_closure(function(x = TRUE) {\n  g(x)\n})\n\n#&gt; [1] TRUE\n\ntypeof(function(x = TRUE) {\n  g(x)\n})\n\n#&gt; [1] \"closure\"\n\n\nNote: I’m not sure why the error says integer instead of closure.\n\n\nModify find_assign to also detect assignment using replacement functions, i.e. names(x) &lt;- y.\n\nAnswer: first compare the AST to normal assignment:\n\nast(x &lt;- y)\n\n#&gt; █─`&lt;-` \n#&gt; ├─x \n#&gt; └─y\n\nast(names(x) &lt;- y)\n\n#&gt; █─`&lt;-` \n#&gt; ├─█─names \n#&gt; │ └─x \n#&gt; └─y\n\n\nAssignment is a call object where the first element is the symbol &lt;-, the second is a call object with the function and the name of the variable, and the third is the value to be assigned. The original code doesn’t detect name(x) &lt;- y:\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign &lt;- function(x) unique(find_assign_rec(enexpr(x)))\n\nfind_assign(a &lt;- b &lt;- c &lt;- 1)\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nfind_assign(names(x) &lt;- y)\n\n#&gt; character(0)\n\n\nTo detect the new pattern, modify find_assign_call to detect when the second element is a call, and return the third:\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else if (is_call(x, \"&lt;-\") && is_call(x[[2]])) {\n    lhs &lt;- as_string(x[[3]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign(a &lt;- b &lt;- c &lt;- 1)\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nfind_assign(names(x) &lt;- y)\n\n#&gt; [1] \"y\"\n\n\nAR Solutions: Let’s see what the AST of such an assignment looks like:\n\nast(names(x) &lt;- x)\n\n#&gt; █─`&lt;-` \n#&gt; ├─█─names \n#&gt; │ └─x \n#&gt; └─x\n\n\nSo, we need to catch the case where the first two elements are both calls. Further the first call is identical to &lt;- and we must return only the second call to see which objects got new values assigned.\nThis is why we add the following block within another else statement in find_assign_call():\n\nif (is_call(x, \"&lt;-\") && is_call(x[[2]])) {\n  lhs &lt;- expr_text(x[[2]])\n  children &lt;- as.list(x)[-1]\n}\n\nLet us finish with the whole code, followed by some tests for our new function:\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nfind_assign &lt;- function(x) unique(find_assign_rec(enexpr(x)))\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    if (is_call(x, \"&lt;-\") && is_call(x[[2]])) {\n      lhs &lt;- expr_text(x[[2]])\n      children &lt;- as.list(x)[-1]\n    } else {\n      lhs &lt;- character()\n      children &lt;- as.list(x)\n    }\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = , symbol = character(),\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\n# Tests functionality\nfind_assign(x &lt;- y)\n\n#&gt; [1] \"x\"\n\nfind_assign(names(x))\n\n#&gt; character(0)\n\nfind_assign(names(x) &lt;- y)\n\n#&gt; [1] \"names(x)\"\n\nfind_assign(names(x(y)) &lt;- y)\n\n#&gt; [1] \"names(x(y))\"\n\nfind_assign(names(x(y)) &lt;- y &lt;- z)\n\n#&gt; [1] \"names(x(y))\" \"y\"\n\n\nNote: using expr_text() instead of as_string() is preferable.\n\n\nWrite a function that extracts all calls to a specified function.\n\nAnswer: this is similar to the previous exercise. Here is a simple version that doesn’t properly walk the tree:\n\nfind_fun_call &lt;- function(x, fun) {\n  if (is_call(x, fun)) expr_text(x) else character()\n}\n\nfind_call_rec &lt;- function(x, fun) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_call_rec),\n    call = find_fun_call(x, fun)\n  )\n}\n\nfind_call_fun &lt;- function(x, fun) find_call_rec(enexpr(x), fun)\n\nfind_call_fun(1:10, \"sum\")\n\n#&gt; character(0)\n\nfind_call_fun(x, \"sum\")\n\n#&gt; character(0)\n\nfind_call_fun(sum(1:10), \"sum\")\n\n#&gt; [1] \"sum(1:10)\"\n\nfind_call_fun(sum(1:10), \"mean\")\n\n#&gt; character(0)\n\nfind_call_fun(sum(1:10) + sum(11:20), \"sum\")\n\n#&gt; character(0)\n\n\nUpdated version:\n\nfind_fun_call &lt;- function(x, fun) {\n  if (is_call(x, fun)) {\n    parents &lt;- expr_text(x)\n    children &lt;- as.list(x)[-1]\n  } else {\n    parents &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(parents, flat_map_chr(children, find_call_rec, fun))\n}\n\nfind_call_fun(1:10, \"sum\")\n\n#&gt; character(0)\n\nfind_call_fun(x, \"sum\")\n\n#&gt; character(0)\n\nfind_call_fun(sum(1:10), \"sum\")\n\n#&gt; [1] \"sum(1:10)\"\n\nfind_call_fun(sum(1:10), \"mean\")\n\n#&gt; character(0)\n\nfind_call_fun(sum(1:10) + sum(11:20), \"sum\")\n\n#&gt; [1] \"sum(1:10)\"  \"sum(11:20)\"\n\nfind_call_fun(sum(sum(1:10), sum(11:20)), \"sum\")\n\n#&gt; [1] \"sum(sum(1:10), sum(11:20))\" \"sum(1:10)\"                 \n#&gt; [3] \"sum(11:20)\"\n\n\nAR Solutions: Here we need to delete the previously added else statement and check for a call (not necessarily &lt;-) within the first if() in find_assign_call(). We save a call when we found one and return it later as part of our character output. Everything else stays the same:\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x)) {\n    lhs &lt;- expr_text(x)\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign(x &lt;- y)\n\n#&gt; [1] \"x &lt;- y\"\n\nfind_assign(names(x(y)) &lt;- y &lt;- z)\n\n#&gt; [1] \"names(x(y)) &lt;- y &lt;- z\" \"names(x(y))\"           \"x(y)\"                 \n#&gt; [4] \"y &lt;- z\"\n\nfind_assign(mean(sum(1:3)))\n\n#&gt; [1] \"mean(sum(1:3))\" \"sum(1:3)\"       \"1:3\"\n\n\nNote: the AR Solutions version detects any function call, not a specific function call.",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-4",
    "href": "analysis/advanced-r-4.html#exercises-4",
    "title": "Advanced R (Metaprogramming)",
    "section": "19.2.2 Exercises",
    "text": "19.2.2 Exercises\n\nFor each function in the following base R code, identify which arguments are quoted and which are evaluated.\n\n\nlibrary(MASS) # nolint: unused_import_linter.\n\nmtcars2 &lt;- subset(mtcars, cyl == 4)\n\nwith(mtcars2, sum(vs))\nsum(mtcars2$am)\n\nrm(mtcars2)\n\nAnswer: using the technique described in the chapter, test arguments outside their functions:\n\nlibrary(MASS) # nolint: unused_import_linter.\ntry(MASS)\n\n#&gt; Error in eval(expr, envir, enclos) : object 'MASS' not found\n\nmtcars2 &lt;- subset(mtcars, cyl == 4)\nmtcars\n\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#&gt; AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#&gt; Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#&gt; Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#&gt; Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#&gt; Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#&gt; Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#&gt; Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\ntry(cyl)\n\n#&gt; Error in eval(expr, envir, enclos) : object 'cyl' not found\n\nwith(mtcars2, sum(vs))\n\n#&gt; [1] 10\n\nmtcars2\n\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\ntry(vs)\n\n#&gt; Error in eval(expr, envir, enclos) : object 'vs' not found\n\nsum(mtcars2$am)\n\n#&gt; [1] 8\n\nmtcars2$am\n\n#&gt;  [1] 1 0 0 1 1 1 0 1 1 1 1\n\nrm(mtcars2)\n\nResults: MASS, cyl, vs are quoted, mtcars, mtcars2 and mtcars2$am are not.\nAR Solutions: For each argument we first follow the advice from Advanced R and execute the argument outside of the respective function. Since MASS, cyl, vs and am are not objects contained in the global environment, their execution raises an “Object not found” error. This way we confirm that the respective function arguments are quoted. For the other arguments, we may inspect the source code (and the documentation) to check if any quoting mechanisms are applied or the arguments are evaluated.\n\nlibrary(MASS) # MASS is quoted # nolint: unused_import_linter.\n\nlibrary() also accepts character vectors and doesn’t quote when character.only is set to TRUE, so library(MASS, character.only = TRUE) would raise an error.\n\nmtcars2 &lt;- subset(mtcars, cyl == 4) # mtcars is evaluated\n# cyl is quoted\nwith(mtcars2, sum(vs)) # mtcars2 is evaluated\n# sum(vs) is quoted\nsum(mtcars2$am) # matcars$am is evaluated\n# am is quoted by $()\n\nWhen we inspect the source code of rm(), we notice that rm() catches its ... argument as an unevaluated call (in this case a pairlist) via match.call(). This call is then converted into a string for further evaluation.\n\nrm(mtcars2) # mtcars2 is quoted\n\n\n\nFor each function in the following tidyverse code, identify which arguments are quoted and which are evaluated.\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_cyl &lt;- mtcars %&gt;%\n  group_by(cyl) %&gt;%\n  summarise(mean = mean(mpg))\n\nggplot(by_cyl, aes(cyl, mean)) +\n  geom_point()\n\nAnswer: library automatically quotes its arguments. cyl, mpg, and mean are all data.frame columns.\n\nQuoted: dplyr, ggplot2, cyl, mpg, mean (in the final ggpot call)\nEvaluated: by_cyl, mtcars\n\nAR Solutions: From the previous exercise we’ve already learned that library() quotes its first argument.\n\nlibrary(dplyr) # dplyr is quoted\nlibrary(ggplot2) # ggplot2 is quoted\n\nIn similar fashion, it becomes clear that cyl is quoted by group_by().\n\nby_cyl &lt;- mtcars %&gt;% # mtcars is evaluated\n  group_by(cyl) %&gt;% # cyl is quoted\n  summarise(mean = mean(mpg)) # mean = mean(mpg) is quoted\n\nTo find out what happens in summarise(), we inspect the source code. Tracing down the S3-dispatch of summarise(), we see that the ... argument is quoted in dplyr:::summarise_cols() which is called in the underlying summarise.data.frame() method.\n\ndplyr::summarise\n\n#&gt; function (.data, ..., .by = NULL, .groups = NULL) \n#&gt; {\n#&gt;     by &lt;- enquo(.by)\n#&gt;     if (!quo_is_null(by) && !is.null(.groups)) {\n#&gt;         abort(\"Can't supply both `.by` and `.groups`.\")\n#&gt;     }\n#&gt;     UseMethod(\"summarise\")\n#&gt; }\n#&gt; &lt;bytecode: 0x1158ea270&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\n\n\ndplyr:::summarise.data.frame\n\n#&gt; function (.data, ..., .by = NULL, .groups = NULL) \n#&gt; {\n#&gt;     by &lt;- compute_by({\n#&gt;         {\n#&gt;             .by\n#&gt;         }\n#&gt;     }, .data, by_arg = \".by\", data_arg = \".data\")\n#&gt;     cols &lt;- summarise_cols(.data, dplyr_quosures(...), by, \"summarise\")\n#&gt;     out &lt;- summarise_build(by, cols)\n#&gt;     if (!cols$all_one) {\n#&gt;         summarise_deprecate_variable_size()\n#&gt;     }\n#&gt;     if (!is_tibble(.data)) {\n#&gt;         out &lt;- as.data.frame(out)\n#&gt;     }\n#&gt;     if (identical(.groups, \"rowwise\")) {\n#&gt;         out &lt;- rowwise_df(out, character())\n#&gt;     }\n#&gt;     out\n#&gt; }\n#&gt; &lt;bytecode: 0x11305c470&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\n\n\ndplyr:::summarise_cols\n#&gt; function (.data, ...)\n#&gt; {\n#&gt;     mask &lt;- DataMask$new(.data, caller_env())\n#&gt;     dots &lt;- enquos(...)\n#&gt;     dots_names &lt;- names(dots)\n#&gt;     auto_named_dots &lt;- names(enquos(..., .named = TRUE))\n#&gt;     cols &lt;- list()\n#&gt;     sizes &lt;- 1L\n#&gt;     chunks &lt;- vector(\"list\", length(dots))\n#&gt;     types &lt;- vector(\"list\", length(dots))\n#&gt;\n#&gt;     ## function definition abbreviated for clarity ##\n#&gt; }\n#&gt; &lt;bytecode: 0x55b540c07ca0&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\nIn the following {ggplot2} expression the cyl- and mean-objects are quoted.\n\nggplot(\n  by_cyl, # by_cyl is evaluated\n  aes(cyl, mean) # aes() is evaluated\n) +\n  # cyl, mean is quoted (via aes)\n  geom_point()\n\nWe can confirm this also by inspecting aes()’s source code.\n\nggplot2::aes\n\n#&gt; function (x, y, ...) \n#&gt; {\n#&gt;     xs &lt;- arg_enquos(\"x\")\n#&gt;     ys &lt;- arg_enquos(\"y\")\n#&gt;     dots &lt;- enquos(...)\n#&gt;     args &lt;- c(xs, ys, dots)\n#&gt;     args &lt;- Filter(Negate(quo_is_missing), args)\n#&gt;     local({\n#&gt;         aes &lt;- function(x, y, ...) NULL\n#&gt;         inject(aes(!!!args))\n#&gt;     })\n#&gt;     aes &lt;- new_aes(args, env = parent.frame())\n#&gt;     rename_aes(aes)\n#&gt; }\n#&gt; &lt;bytecode: 0x115b58680&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-5",
    "href": "analysis/advanced-r-4.html#exercises-5",
    "title": "Advanced R (Metaprogramming)",
    "section": "19.3.6 Exercises",
    "text": "19.3.6 Exercises\n\nHow is expr() implemented? Look at its source code.\n\nAnswer: reviewing the source code:\n\nrlang::expr\n\n#&gt; function (expr) \n#&gt; {\n#&gt;     enexpr(expr)\n#&gt; }\n#&gt; &lt;bytecode: 0x1128a0558&gt;\n#&gt; &lt;environment: namespace:rlang&gt;\n\nrlang::enexpr\n\n#&gt; function (arg) \n#&gt; {\n#&gt;     .Call(ffi_enexpr, substitute(arg), parent.frame())\n#&gt; }\n#&gt; &lt;bytecode: 0x113318bc8&gt;\n#&gt; &lt;environment: namespace:rlang&gt;\n\n\nexpr() simply calls enexpr(), which uses the C++ function ffi_enexpr and uses the base R function substitute().\nAR Solutions: expr() acts as a simple wrapper, which passes its argument to enexpr().\n\n\nCompare and contrast the following two functions. Can you predict the output before running them?\n\n\nf1 &lt;- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 &lt;- function(x, y) {\n  enexprs(x = x, y = y)\n}\nf1(a + b, c + d)\nf2(a + b, c + d)\n\nAnswer: per Advanced R, exprs(x = x, y = y) is shorthand for list(x = expr(x), y = expr(y)), and expr() will capture the argument exactly as provided. enexpr() captures what the caller supplied, with enexprs() returning a list.\nTest the predictions in comments:\n\nf1 &lt;- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 &lt;- function(x, y) {\n  enexprs(x = x, y = y)\n}\n# returns $x x $y y\nf1(a + b, c + d)\n\n#&gt; $x\n#&gt; x\n#&gt; \n#&gt; $y\n#&gt; y\n\n# returns $x a + b $y c + d\nf2(a + b, c + d)\n\n#&gt; $x\n#&gt; a + b\n#&gt; \n#&gt; $y\n#&gt; c + d\n\n\nCorrect!\nAR Solutions: Both functions are able to capture multiple arguments and will return a named list of expressions. f1() will return the arguments defined within the body of f1(). This happens because exprs() captures the expressions as specified by the developer during the definition of f1().\n\nf1(a + b, c + d)\n\n#&gt; $x\n#&gt; x\n#&gt; \n#&gt; $y\n#&gt; y\n\n\nf2() will return the arguments supplied to f2() as specified by the user when the function is called.\n\nf2(a + b, c + d)\n\n#&gt; $x\n#&gt; a + b\n#&gt; \n#&gt; $y\n#&gt; c + d\n\n\n\n\nWhat happens if you try to use enexpr() with an expression (i.e.  enexpr(x + y) ? What happens if enexpr() is passed a missing argument?\n\nAnswer: from the code below, arg must be a symbol, not an expression, and arg must exist.\n\ntry(enexpr(x + y))\n\n#&gt; Error in enexpr(x + y) : `arg` must be a symbol\n\ntry(enexpr(arg = foo))\n\n#&gt; Error in (function (arg)  : object 'foo' not found\n\n\nAR Solutions: In the first case an error is thrown:\n\non_expr &lt;- function(x) {\n  enexpr(expr(x))\n}\ntry(on_expr(x + y))\n\n#&gt; Error in enexpr(expr(x)) : `arg` must be a symbol\n\n\nIn the second case a missing argument is returned:\n\non_missing &lt;- function(x) {\n  enexpr(x)\n}\non_missing()\nis_missing(on_missing())\n\n#&gt; [1] TRUE\n\n\n\n\nHow are exprs(a) and exprs(a = ) different? Think about both the input and the output.\n\nAnswer: as the code below demonstrates, expr(a) creates an unnamed list with a as the first element. exprs(a = ) which creates an named list with an empty first element. Input of the form x = y creates a named list, while the form x creates an unnamed list.\n\nexprs(a)\n\n#&gt; [[1]]\n#&gt; a\n\nexprs(a = )\n\n#&gt; $a\n\nexprs(a = a)\n\n#&gt; $a\n#&gt; a\n\n\nAR Solutions: In exprs(a) the input a is interpreted as a symbol for an unnamed argument. Consequently, the output shows an unnamed list with the first element containing the symbol a.\n\nout1 &lt;- exprs(a)\nstr(out1)\n\n#&gt; List of 1\n#&gt;  $ : symbol a\n\n\nIn exprs(a = ) the first argument is named a, but then no value is provided. This leads to the output of a named list with the first element named a, which contains the missing argument.\n\nout2 &lt;- exprs(a = )\nstr(out2)\n\n#&gt; List of 1\n#&gt;  $ a: symbol\n\nis_missing(out2$a)\n\n#&gt; [1] TRUE\n\n\n\n\nWhat are other differences between exprs() and alist()? Read the documentation for the named arguments of exprs() to find out.\n\nAnswer: exprs() has three named arguments (alist() has none):\n\n.named, which automatically adds names to the list\n.ignore_empty, which selectively ignores empty arguments depending on the setting\n.unquote_names, which treats use of := (which allows names injection) as =\n\nAR Solutions: exprs() provides the additional arguments .named (= FALSE), .ignore_empty (c(\"trailing\", \"none\", \"all\")) and .unquote_names (TRUE). .named allows to ensure that all dots are named. ignore_empty allows to specify how empty arguments should be handled for dots (\"trailing\") or all arguments (\"none\" and \"all\"). Further via .unquote_names one can specify if := should be treated like =. := can be useful as it supports unquoting (!!) on the left-hand side.\n\n\nThe documentation for substitute() says:\n\nSubstitution takes place by examining each component of the parse tree as follows:\n\nIf it is not a bound symbol in env, it is unchanged.\nIf it is a promise object (i.e., a formal argument to a function) the expression slot of the promise replaces the symbol.\nIf it is an ordinary variable, its value is substituted, unless env is .GlobalEnv in which case the symbol is left unchanged.\n\n\nCreate examples that illustrate each of the above cases.\n\nAnswer: reviewing Google results for R bound symbol, R promise object, and chapter 6.5.1, construct the following code:\n\n# ordinary variable in `.GlobalEnv`\nfoo &lt;- \"bar\"\nsubstitute(foo)\n\n#&gt; foo\n\n# ordinary variable not in `.GlobalEnv`\nlocal({\n  foo &lt;- \"bar\"\n  substitute(foo)\n})\n\n#&gt; [1] \"bar\"\n\n# not a bound symbol in `env`\nsubstitute(func)\n\n#&gt; func\n\n# promise object\nlocal({\n  x &lt;- 1:5\n  y &lt;- 1:10\n  substitute(mean(x = y))\n})\n\n#&gt; mean(x = 1:10)\n\n\nIn the promise example, y is substituted, but not x, since x is the formal argument to mean().\nAR Solutions: Let’s create a new environment my_env, which contains no objects. In this case substitute() will just return its first argument (expr):\n\nmy_env &lt;- env()\nsubstitute(x, my_env)\n\n#&gt; x\n\n\nWhen we create a function containing an argument, which is directly returned after substitution, this function just returns the provided expression:\n\nfoo &lt;- function(x) substitute(x)\n\nfoo(x + y * sin(0))\n\n#&gt; x + y * sin(0)\n\n\nIn case substitute() can find (parts of) the expression in env, it will literally substitute. However, unless env is .GlobalEnv.\n\nmy_env$x &lt;- 7\nsubstitute(x, my_env)\n\n#&gt; [1] 7\n\nx &lt;- 7\nsubstitute(x, .GlobalEnv)\n\n#&gt; x",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-6",
    "href": "analysis/advanced-r-4.html#exercises-6",
    "title": "Advanced R (Metaprogramming)",
    "section": "19.4.8 Exercises",
    "text": "19.4.8 Exercises\n\nGiven the following components:\n\n\nxy &lt;- expr(x + y)\nxz &lt;- expr(x + z)\nyz &lt;- expr(y + z)\nabc &lt;- exprs(a, b, c)\n\nUse quasiquotation to construct the following calls:\n\n(x + y) / (y + z)\n-(x + z)^(y + z)\n(x + y) + (y + z) - (x + y)\natan2(x + y, y + z)\nsum(x + y, x + y, y + z)\nsum(a, b, c)\nmean(c(a, b, c), na.rm = TRUE)\nfoo(a = x + y, b = y + z)\n\nAnswer: code below.\n\n# (x + y) / (y + z)\nexpr(!!xy / !!yz)\n\n#&gt; (x + y)/(y + z)\n\n# -(x + z) ^ (y + z)\nexpr(-(!!xz)^!!yz)\n\n#&gt; -(x + z)^(y + z)\n\n# (x + y) + (y + z) - (x + y)\nexpr(((!!xy)) + !!yz - !!xy)\n\n#&gt; (x + y) + (y + z) - (x + y)\n\n# atan2(x + y, y + z)\nexpr(atan2(!!xy, !!yz))\n\n#&gt; atan2(x + y, y + z)\n\n# sum(x + y, x + y, y + z)\nexpr(sum(!!xy, !!xy, !!yz))\n\n#&gt; sum(x + y, x + y, y + z)\n\n# sum(a, b, c)\nexpr(sum(!!!abc))\n\n#&gt; sum(a, b, c)\n\n# mean(c(a, b, c), na.rm = TRUE)\nexpr(mean(c(!!!abc), na.rm = TRUE))\n\n#&gt; mean(c(a, b, c), na.rm = TRUE)\n\n# foo(a = x + y, b = y + z)\nexpr(foo(a = !!xy, b = !!yz))\n\n#&gt; foo(a = x + y, b = y + z)\n\n\nSurprisingly, multiple parentheses are needed to construct (x + y) + (y + z) - (x + y).\nAR Solutions We combine and unquote the given quoted expressions to construct the desired calls like this:\n\nexpr(!!xy / !!yz) # (1)\n\n#&gt; (x + y)/(y + z)\n\nexpr(-(!!xz)^(!!yz)) # (2)\n\n#&gt; -(x + z)^(y + z)\n\nexpr(((!!xy)) + !!yz - !!xy) # (3)\n\n#&gt; (x + y) + (y + z) - (x + y)\n\nexpr(atan2(!!xy, !!yz)) # (4)\n\n#&gt; atan2(x + y, y + z)\n\nexpr(sum(!!xy, !!xy, !!yz)) # (5)\n\n#&gt; sum(x + y, x + y, y + z)\n\nexpr(sum(!!!abc)) # (6)\n\n#&gt; sum(a, b, c)\n\nexpr(mean(c(!!!abc), na.rm = TRUE)) # (7)\n\n#&gt; mean(c(a, b, c), na.rm = TRUE)\n\nexpr(foo(a = !!xy, b = !!yz)) # (8)\n\n#&gt; foo(a = x + y, b = y + z)\n\n\n\n\nThe following two calls print the same, but are actually different:\n\n\n(a &lt;- expr(mean(1:10)))\n\n#&gt; mean(1:10)\n\n(b &lt;- expr(mean(!!(1:10))))\n\n#&gt; mean(1:10)\n\nidentical(a, b)\n\n#&gt; [1] FALSE\n\n\nWhat’s the difference? Which one is more natural?\nAnswer: the key difference is the use of !! for the sequence 1:10. Comparing expr() for both of the arguments supplied to mean, !! changes the expression from a call to : to an integer vector:\n\narga &lt;- expr(1:10)\nargb &lt;- expr(!!(1:10))\narga\n\n#&gt; 1:10\n\nast(!!arga)\n\n#&gt; █─`:` \n#&gt; ├─1 \n#&gt; └─10\n\nargb\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nast(!!argb)\n\n#&gt; &lt;inline integer&gt;\n\n\nUse of !! creates a non-standard AST with an inline integer. The first form is more natural.\nAR Solutions: It’s easiest to see the difference with lobstr::ast():\n\nlobstr::ast(mean(1:10))\n\n#&gt; █─mean \n#&gt; └─█─`:` \n#&gt;   ├─1 \n#&gt;   └─10\n\nlobstr::ast(mean(!!(1:10)))\n\n#&gt; █─mean \n#&gt; └─&lt;inline integer&gt;\n\n\nIn the expression mean(!!(1:10)) the call 1:10 is evaluated to an integer vector, while still being a call object in mean(1:10).\nThe first version (mean(1:10)) seems more natural. It captures lazy evaluation, with a promise that is evaluated when the function is called. The second version (mean(!!(1:10))) inlines a vector directly into a call.",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-7",
    "href": "analysis/advanced-r-4.html#exercises-7",
    "title": "Advanced R (Metaprogramming)",
    "section": "19.6.5 Exercises",
    "text": "19.6.5 Exercises\n\nOne way to implement exec() is shown below. Describe how it works. What are the key ideas?\n\n\nexec &lt;- function(f, ..., .env = caller_env()) {\n  args &lt;- list2(...)\n  do.call(f, args, envir = .env)\n}\n\nAnswer: the implementation is a wrapper to do.call(), which requires a function, list of arguments, and environment (it also has a quote parameter which is set to FALSE by default). list2() is used to convert the function arguments into a list which is compatible with do.call().\nAR Solutions: exec() takes a function (f), its arguments (...) and an environment (.env) as input. This allows to construct a call from f and ... and evaluate this call in the supplied environment. As the ... argument is handled via list2(), exec() supports tidy dots (quasiquotation), which means that arguments and names (on the left-hand side of :=) can be unquoted via !! and !!!.\n\n\nCarefully read the source code for interaction(), expand.grid(), and par(). Compare and contrast the techniques they use for switching between dots and list behaviour.\n\nAnswer: reviewing the source code for each function, all three functions convert dots into a list using list(...). All three also allow passing multiple arguments as well as a list as a single argument.\n\ninteraction\n\n#&gt; function (..., drop = FALSE, sep = \".\", lex.order = FALSE) \n#&gt; {\n#&gt;     args &lt;- list(...)\n#&gt;     narg &lt;- length(args)\n#&gt;     if (narg &lt; 1L) \n#&gt;         stop(\"No factors specified\")\n#&gt;     if (narg == 1L && is.list(args[[1L]])) {\n#&gt;         args &lt;- args[[1L]]\n#&gt;         narg &lt;- length(args)\n#&gt;     }\n#&gt;     for (i in narg:1L) {\n#&gt;         f &lt;- as.factor(args[[i]])[, drop = drop]\n#&gt;         l &lt;- levels(f)\n#&gt;         if1 &lt;- as.integer(f) - 1L\n#&gt;         if (i == narg) {\n#&gt;             ans &lt;- if1\n#&gt;             lvs &lt;- l\n#&gt;         }\n#&gt;         else {\n#&gt;             if (lex.order) {\n#&gt;                 ll &lt;- length(lvs)\n#&gt;                 ans &lt;- ans + ll * if1\n#&gt;                 lvs &lt;- paste(rep(l, each = ll), rep(lvs, length(l)), \n#&gt;                   sep = sep)\n#&gt;             }\n#&gt;             else {\n#&gt;                 ans &lt;- ans * length(l) + if1\n#&gt;                 lvs &lt;- paste(rep(l, length(lvs)), rep(lvs, each = length(l)), \n#&gt;                   sep = sep)\n#&gt;             }\n#&gt;             if (anyDuplicated(lvs)) {\n#&gt;                 ulvs &lt;- unique(lvs)\n#&gt;                 while ((i &lt;- anyDuplicated(flv &lt;- match(lvs, \n#&gt;                   ulvs)))) {\n#&gt;                   lvs &lt;- lvs[-i]\n#&gt;                   ans[ans + 1L == i] &lt;- match(flv[i], flv[1:(i - \n#&gt;                     1)]) - 1L\n#&gt;                   ans[ans + 1L &gt; i] &lt;- ans[ans + 1L &gt; i] - 1L\n#&gt;                 }\n#&gt;                 lvs &lt;- ulvs\n#&gt;             }\n#&gt;             if (drop) {\n#&gt;                 olvs &lt;- lvs\n#&gt;                 lvs &lt;- lvs[sort(unique(ans + 1L))]\n#&gt;                 ans &lt;- match(olvs[ans + 1L], lvs) - 1L\n#&gt;             }\n#&gt;         }\n#&gt;     }\n#&gt;     structure(as.integer(ans + 1L), levels = lvs, class = \"factor\")\n#&gt; }\n#&gt; &lt;bytecode: 0x1122c1090&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nexpand.grid\n\n#&gt; function (..., KEEP.OUT.ATTRS = TRUE, stringsAsFactors = TRUE) \n#&gt; {\n#&gt;     nargs &lt;- length(args &lt;- list(...))\n#&gt;     if (!nargs) \n#&gt;         return(as.data.frame(list()))\n#&gt;     if (nargs == 1L && is.list(a1 &lt;- args[[1L]])) \n#&gt;         nargs &lt;- length(args &lt;- a1)\n#&gt;     if (nargs == 0L) \n#&gt;         return(as.data.frame(list()))\n#&gt;     cargs &lt;- vector(\"list\", nargs)\n#&gt;     iArgs &lt;- seq_len(nargs)\n#&gt;     nmc &lt;- paste0(\"Var\", iArgs)\n#&gt;     nm &lt;- names(args)\n#&gt;     if (is.null(nm)) \n#&gt;         nm &lt;- nmc\n#&gt;     else if (any(ng0 &lt;- nzchar(nm))) \n#&gt;         nmc[ng0] &lt;- nm[ng0]\n#&gt;     names(cargs) &lt;- nmc\n#&gt;     rep.fac &lt;- 1L\n#&gt;     d &lt;- lengths(args)\n#&gt;     if (KEEP.OUT.ATTRS) {\n#&gt;         dn &lt;- vector(\"list\", nargs)\n#&gt;         names(dn) &lt;- nmc\n#&gt;     }\n#&gt;     orep &lt;- prod(d)\n#&gt;     if (orep == 0L) {\n#&gt;         for (i in iArgs) cargs[[i]] &lt;- args[[i]][FALSE]\n#&gt;     }\n#&gt;     else {\n#&gt;         for (i in iArgs) {\n#&gt;             x &lt;- args[[i]]\n#&gt;             if (KEEP.OUT.ATTRS) \n#&gt;                 dn[[i]] &lt;- paste0(nmc[i], \"=\", if (is.numeric(x)) \n#&gt;                   format(x)\n#&gt;                 else x)\n#&gt;             nx &lt;- length(x)\n#&gt;             orep &lt;- orep/nx\n#&gt;             if (stringsAsFactors && is.character(x)) \n#&gt;                 x &lt;- factor(x, levels = unique(x))\n#&gt;             x &lt;- x[rep.int(rep.int(seq_len(nx), rep.int(rep.fac, \n#&gt;                 nx)), orep)]\n#&gt;             cargs[[i]] &lt;- x\n#&gt;             rep.fac &lt;- rep.fac * nx\n#&gt;         }\n#&gt;     }\n#&gt;     if (KEEP.OUT.ATTRS) \n#&gt;         attr(cargs, \"out.attrs\") &lt;- list(dim = d, dimnames = dn)\n#&gt;     rn &lt;- .set_row_names(as.integer(prod(d)))\n#&gt;     structure(cargs, class = \"data.frame\", row.names = rn)\n#&gt; }\n#&gt; &lt;bytecode: 0x1121b5b30&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\npar\n\n#&gt; function (..., no.readonly = FALSE) \n#&gt; {\n#&gt;     .Pars.readonly &lt;- c(\"cin\", \"cra\", \"csi\", \"cxy\", \"din\", \"page\")\n#&gt;     single &lt;- FALSE\n#&gt;     args &lt;- list(...)\n#&gt;     if (!length(args)) \n#&gt;         args &lt;- as.list(if (no.readonly) \n#&gt;             .Pars[-match(.Pars.readonly, .Pars)]\n#&gt;         else .Pars)\n#&gt;     else {\n#&gt;         if (all(unlist(lapply(args, is.character)))) \n#&gt;             args &lt;- as.list(unlist(args))\n#&gt;         if (length(args) == 1) {\n#&gt;             if (is.list(args[[1L]]) || is.null(args[[1L]])) \n#&gt;                 args &lt;- args[[1L]]\n#&gt;             else if (is.null(names(args))) \n#&gt;                 single &lt;- TRUE\n#&gt;         }\n#&gt;     }\n#&gt;     value &lt;- .External2(C_par, args)\n#&gt;     if (single) \n#&gt;         value &lt;- value[[1L]]\n#&gt;     if (!is.null(names(args))) \n#&gt;         invisible(value)\n#&gt;     else value\n#&gt; }\n#&gt; &lt;bytecode: 0x105bcde08&gt;\n#&gt; &lt;environment: namespace:graphics&gt;\n\n\nAR Solutions: All three functions capture the dots via args &lt;- list(...).\ninteraction() computes factor interactions between the captured input factors by iterating over the args. When a list is provided this is detected via length(args) == 1 && is.list(args[[1]]) and one level of the list is stripped through args &lt;- args[[1]]. The rest of the function’s code doesn’t differentiate further between list and dots behaviour.\n\n# styler: off\n# Both calls create the same output\ninteraction(     a = c(\"a\", \"b\", \"c\", \"d\"), b = c(\"e\", \"f\"))  # dots\n\n#&gt; [1] a.e b.f c.e d.f\n#&gt; Levels: a.e b.e c.e d.e a.f b.f c.f d.f\n\ninteraction(list(a = c(\"a\", \"b\", \"c\", \"d\"), b = c(\"e\", \"f\"))) # list\n\n#&gt; [1] a.e b.f c.e d.f\n#&gt; Levels: a.e b.e c.e d.e a.f b.f c.f d.f\n\n# styler: on\n\nexpand.grid() uses the same strategy and also assigns args &lt;- args[[1]] in case of length(args) == 1 && is.list(args[[1]]).\npar() does the most pre-processing to ensure a valid structure of the args argument. When no dots are provided (!length(args)) it creates a list of arguments from an internal character vector (partly depending on its no.readonly argument). Further, given that all elements of args are character vectors (all(unlist(lapply(args, is.character)))), args is turned into a list via as.list(unlist(args)) (this flattens nested lists). Similar to the other functions, one level of args gets stripped via args &lt;- args[[1L]], when args is of length one and its first element is a list.\n\n\nExplain the problem with this definition of set_attr()\n\n\nset_attr &lt;- function(x, ...) {\n  attr &lt;- rlang::list2(...)\n  attributes(x) &lt;- attr\n  x\n}\ntry(set_attr(1:10, x = 10))\n\n#&gt; Error in attributes(x) &lt;- attr : attributes must be named\n\n\nAnswer: attributes(x) &lt;- value requires value to be a named list, which is only generated for list2 calls of the form list2(a = 1, b = 2) - setting .named = TRUE doesn’t help in this case as it generates zero-length names which are not allowed by attributes(). Using dots will only work when each attribute is explicitly named.\n\nset_attr &lt;- function(x, ...) {\n  attr &lt;- rlang::list2(..., .named = TRUE)\n  attributes(x) &lt;- attr\n  x\n}\ntry(set_attr(1:10, x = 10))\n\n#&gt; Error in attributes(x) &lt;- attr : attempt to use zero-length variable name\n\n\nAR Solutions: set_attr() expects an object named x and its attributes, supplied via the dots. Unfortunately, this prohibits us to provide attributes named x as these would collide with the argument name of our object. Even omitting the object’s argument name doesn’t help in this case — as can be seen in the example where the object is consequently treated as an unnamed attribute.\nHowever, we may name the first argument .x, which seems clearer and less likely to invoke errors. In this case 1:10 will get the (named) attribute x = 10 assigned:\n\nset_attr &lt;- function(.x, ...) {\n  attr &lt;- rlang::list2(...)\n\n  attributes(.x) &lt;- attr\n  .x\n}\n\nset_attr(1:10, x = 10)\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n#&gt; attr(,\"x\")\n#&gt; [1] 10",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-8",
    "href": "analysis/advanced-r-4.html#exercises-8",
    "title": "Advanced R (Metaprogramming)",
    "section": "19.7.5 Exercises",
    "text": "19.7.5 Exercises\n\nIn the linear-model example, we could replace the expr() in reduce(summands, ~ expr(!!.x + !!.y)) with call2(): reduce(summands, call2, \"+\"). Compare and contrast the two approaches. Which do you think is easier to read?\n\nAnswer: both approaches add the first and second arguments. The call2() method implicitly passes the arguments, where the formula method explicitly adds them, making it easier to understand.\nAR Solutions:\n\n\nRe-implement the Box-Cox transform defined below using unquoting and new_function():\n\n\nbc &lt;- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x^lambda - 1) / lambda\n  }\n}\n\nbc(0)\n\n#&gt; function(x) log(x)\n#&gt; &lt;environment: 0x114db09d0&gt;\n\nbc(2)\n\n#&gt; function(x) (x^lambda - 1) / lambda\n#&gt; &lt;bytecode: 0x1168dc7f0&gt;\n#&gt; &lt;environment: 0x114e11d20&gt;\n\nbc(0)(2)\n\n#&gt; [1] 0.6931472\n\nbc(2)(2)\n\n#&gt; [1] 1.5\n\n\nAnswer: code below.\n\nbc &lt;- function(lambda) {\n  if (lambda == 0) {\n    func &lt;- expr({\n      log(x)\n    })\n  } else {\n    func &lt;- expr({\n      ((x^!!lambda) - 1) / !!lambda\n    })\n  }\n  new_function(\n    exprs(x = ),\n    func,\n    caller_env()\n  )\n}\n\nbc(0)\n\n#&gt; function (x) \n#&gt; {\n#&gt;     log(x)\n#&gt; }\n\nbc(2)\n\n#&gt; function (x) \n#&gt; {\n#&gt;     ((x^2) - 1)/2\n#&gt; }\n\nbc(0)(2)\n\n#&gt; [1] 0.6931472\n\nbc(2)(2)\n\n#&gt; [1] 1.5\n\n\nAR Solutions: Here new_function() allows us to create a function factory using tidy evaluation.\n\nbc2 &lt;- function(lambda) {\n  lambda &lt;- enexpr(lambda)\n\n  if (!!lambda == 0) { # nolint: if_not_else_linter.\n    new_function(exprs(x = ), expr(log(x)))\n  } else {\n    new_function(exprs(x = ), expr((x^(!!lambda) - 1) / !!lambda))\n  }\n}\n\nbc2(0)\n\n#&gt; function (x) \n#&gt; log(x)\n#&gt; &lt;environment: 0x1069fabd0&gt;\n\nbc2(2)\n\n#&gt; function (x) \n#&gt; (x^2 - 1)/2\n#&gt; &lt;environment: 0x1118fefd0&gt;\n\nbc2(2)(2)\n\n#&gt; [1] 1.5\n\n\nNote: I prefer the base R approach to new_function().\n\n\nRe-implement the simple compose() defined below using quasiquotation and new_function():\n\n\ncompose &lt;- function(f, g) {\n  function(...) f(g(...))\n}\n\ncompose(sum, as.integer)\n\n#&gt; function(...) f(g(...))\n#&gt; &lt;environment: 0x112694cd8&gt;\n\ncompose(sum, as.integer)(1:10)\n\n#&gt; [1] 55\n\n\nAnswer: (non-working) code below.\n\ncompose &lt;- function(f, g) {\n  new_function(\n    expr(...),\n    expr({\n      (!!f)((!!g)(...))\n    }),\n    caller_env()\n  )\n}\n\ncompose(sum, as.integer)\ncompose(sum, as.integer)(1:10)\n\nAR Solutions: The implementation is fairly straightforward, even though a lot of parentheses are required:\n\ncompose2 &lt;- function(f, g) {\n  f &lt;- enexpr(f)\n  g &lt;- enexpr(g)\n\n  new_function(exprs(... = ), expr((!!f)((!!g)(...))))\n}\n\ncompose(sin, cos)\n\n#&gt; function(...) f(g(...))\n#&gt; &lt;bytecode: 0x1143a7ed0&gt;\n#&gt; &lt;environment: 0x115b11ff0&gt;\n\ncompose(sin, cos)(pi)\n\n#&gt; [1] -0.841471\n\ncompose2(sin, cos)\n\n#&gt; function (...) \n#&gt; sin(cos(...))\n#&gt; &lt;environment: 0x1150e8350&gt;\n\ncompose2(sin, cos)(pi)\n\n#&gt; [1] -0.841471",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#exercises-9",
    "href": "analysis/advanced-r-4.html#exercises-9",
    "title": "Advanced R (Metaprogramming)",
    "section": "20.2.4 Exercises",
    "text": "20.2.4 Exercises\n\nCarefully read the documentation for source(). What environment does it use by default? What if you supply local = TRUE? How do you provide a custom environment?\n\nAnswer: by default, source() uses the global environment, and uses the calling environment with local = TRUE, and doesn’t support other options; to provide a custom environment, you must use sys.source().\nAR Solutions: By default, source() uses the global environment (local = FALSE). A specific evaluation environment may be chosen, by passing it explicitly to the local argument. To use current environment (i.e. the calling environment of source()) set local = TRUE.\n\n# Create a temporary, sourceable R script that prints x\ntmp_file &lt;- tempfile()\nwriteLines(\"print(x)\", tmp_file)\n\n# Set `x` globally\nx &lt;- \"global environment\"\nenv2 &lt;- env(x = \"specified environment\")\n\nlocate_evaluation &lt;- function(file, local) {\n  x &lt;- \"local environment\"\n  source(file, local = local)\n}\n\n# Where will source() evaluate the code?\nlocate_evaluation(tmp_file, local = FALSE) # default\n\n#&gt; [1] \"global environment\"\n\nlocate_evaluation(tmp_file, local = env2)\n\n#&gt; [1] \"specified environment\"\n\nlocate_evaluation(tmp_file, local = TRUE)\n\n#&gt; [1] \"local environment\"\n\n\n\n\nPredict the results of the following lines of code:\n\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n\nAnswer: all of these should return 4, since the innermost expression is evaluated first.\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\n\n#&gt; [1] 4\n\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n\n#&gt; [1] 4\n\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n\n#&gt; eval(expr(eval(expr(eval(expr(2 + 2))))))\n\n\nIncorrect: let’s explore how these are evaluated:\n\nexpr(2 + 2)\n\n#&gt; 2 + 2\n\neval(expr(2 + 2))\n\n#&gt; [1] 4\n\nexpr(eval(expr(2 + 2)))\n\n#&gt; eval(expr(2 + 2))\n\neval(expr(eval(expr(2 + 2))))\n\n#&gt; [1] 4\n\nexpr(eval(expr(eval(expr(2 + 2)))))\n\n#&gt; eval(expr(eval(expr(2 + 2))))\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\n\n#&gt; [1] 4\n\n\nWhen expr() is on the outside, the expression isn’t evaluated, when eval() is on the outside the answer ‘collapses’ to 4.\nAR Solutions: Let’s look at a quote from the first edition of Advanced R:\n\n“expr() and eval() are opposites. […] each eval() peels off one layer of expr()’s”.\n\nIn general, eval(expr(x)) evaluates to x. Therefore, (1) evaluates to \\(2 + 2 = 4\\). Adding another eval() doesn’t have impact here. So, also (2) evaluates to 4. However, when wrapping (1) into expr() the whole expression will be quoted.\n\neval(expr(eval(expr(eval(expr(2 + 2)))))) # (1)\n\n#&gt; [1] 4\n\neval(eval(expr(eval(expr(eval(expr(2 + 2))))))) # (2)\n\n#&gt; [1] 4\n\nexpr(eval(expr(eval(expr(eval(expr(2 + 2))))))) # (3)\n\n#&gt; eval(expr(eval(expr(eval(expr(2 + 2))))))\n\n\n\n\nFill in the function bodies below to re-implement get() using sym() and eval(), andassign() using sym(), expr(), and eval(). Don’t worry about the multiple ways of choosing an environment that get() and assign() support; assume that the user supplies it explicitly.\n\n\n# name is a string\nget2 &lt;- function(name, env) {}\nassign2 &lt;- function(name, value, env) {}\n\nAnswer: code below.\n\nget2 &lt;- function(name, env) {\n  eval(sym(name), envir = env)\n}\nassign2 &lt;- function(name, value, env) {\n  s &lt;- sym(name)\n  eval(expr(!!s &lt;- !!value), envir = env)\n}\n\ntest &lt;- 1234\nget2(\"test\", caller_env())\n\n#&gt; [1] 1234\n\nassign2(\"test\", 2345, caller_env())\ntest\n\n#&gt; [1] 1234\n\n\nAR Solutions: We reimplement these two functions using tidy evaluation. We turn the string name into a symbol, then evaluate it:\n\nget2 &lt;- function(name, env = caller_env()) {\n  name_sym &lt;- sym(name)\n  eval(name_sym, env)\n}\n\nx &lt;- 1\nget2(\"x\")\n\n#&gt; [1] 1\n\n\nTo build the correct expression for the value assignment, we unquote using !!.\n\nassign2 &lt;- function(name, value, env = caller_env()) {\n  name_sym &lt;- sym(name)\n  assign_expr &lt;- expr(!!name_sym &lt;- !!value)\n  eval(assign_expr, env)\n}\n\nassign2(\"x\", 4)\nx\n\n#&gt; [1] 4\n\n\nNote: I had to review AR Solutions to discover the need to unquote using !!.\n\n\nModify source2() so it returns the result of every expression, not just the last one. Can you eliminate the for loop?\n\nAnswer: code below.\n\nmy_source2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  invisible(lapply(exprs, eval, env))\n}\n\nAR Solutions: The code for source2() was given in Advanced R as:\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  res &lt;- NULL\n  for (i in seq_along(exprs)) {\n    res &lt;- eval(exprs[[i]], env)\n  }\n\n  invisible(res)\n}\n\nIn order to highlight the modifications in our new source2() function, we’ve preserved the differing code from the former source2() in a comment.\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  # res &lt;- NULL\n  # for (i in seq_along(exprs)) {\n  #   res[[i]] &lt;- eval(exprs[[i]], env)\n  # }\n\n  res &lt;- purrr::map(exprs, eval, env)\n\n  invisible(res)\n}\n\nLet’s create a file and test source2(). Keep in mind that &lt;- returns invisibly.\n\ntmp_file &lt;- tempfile()\nwriteLines(\n  \"x &lt;- 1\n       x\n       y &lt;- 2\n       y  # some comment\",\n  tmp_file\n)\n\n(source2(tmp_file))\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 2\n\n\nNote: validate my_source2() returns the same results:\n\n(my_source2(tmp_file))\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 2\n\n\n\n\nWe can make base::local() slightly easier to understand by spreading out over multiple lines:\n\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  eval(call, envir = parent.frame())\n}\n\nExplain how local() works in words. (Hint: you might want to print(call) to help understand what substitute() is doing, and read the documentation to remind yourself what environment new.env() will inherit from.)\nAnswer: adding print(call) shows that substitute() creates a call to evaluate the expression passed to local3() in new.env(), which inherits the environment from the caller. So:\nlocal() works by evaluating an expression in a new child environment.\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  print(call)\n  eval(call, envir = parent.frame())\n}\n\nlocal3(test &lt;- 4567)\n\n#&gt; eval(quote(test &lt;- 4567), new.env())\n\n\nAR Solutions: Let’s follow the advice and add print(call) inside of local3():\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  print(call)\n  eval(call, envir = parent.frame())\n}\n\nThe first line generates a call to eval(), because substitute() operates in the current evaluation argument. However, this doesn’t matter here, as both, expr and envir are promises and therefore “the expression slots of the promises replace the symbols”, from ?substitute.\n\nlocal3({\n  x &lt;- 10\n  x * 2\n})\n\n#&gt; eval(quote({\n#&gt;     x &lt;- 10\n#&gt;     x * 2\n#&gt; }), new.env())\n\n\n#&gt; [1] 20\n\n\nNext, call will be evaluated in the caller environment (aka the parent frame). Given that call contains another call eval() why does this matter? The answer is subtle: this outer environment determines where the bindings for eval, quote, and new.env are found.\n\neval(quote({\n  x &lt;- 10\n  x * 2\n}), new.env())\n\n#&gt; [1] 20\n\nexists(\"x\")\n\n#&gt; [1] TRUE",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html",
    "href": "analysis/r-training-log.html",
    "title": "R Training Log",
    "section": "",
    "text": "Original notes on learning R and RStudio. An updated reading list of R books and other recommended resources is available in R Books.",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html#r-for-data-science",
    "href": "analysis/r-training-log.html#r-for-data-science",
    "title": "R Training Log",
    "section": "R for Data Science",
    "text": "R for Data Science\nSelected highlights from the book:\n\nPatterns and models\n7.6 Patterns and models covers models and residuals, here showing how to reveal the expected relationship between cut and price:\n\nlibrary(modelr)\n\nmod &lt;- lm(log(price) ~ log(carat), data = diamonds)\n\ndiamonds2 &lt;- diamonds %&gt;%\n  add_residuals(mod) %&gt;%\n  mutate(resid = exp(resid))\n\nggplot(data = diamonds2) +\n  geom_point(mapping = aes(x = carat, y = resid)) +\n  theme_quo()\n\n\n\n\n\n\n\nggplot(data = diamonds2) +\n  geom_boxplot(mapping = aes(x = cut, y = resid)) +\n  theme_quo()\n\n\n\n\n\n\n\n\n\n\nNon-Tidy Data\nHadley advocates for “tidy” data, but there are times when data is usefully non-tidy.\n\n\nGraphics: Learning more\nFrom 28.8 Learning more:\n“The absolute best place to learn more is the ggplot2 book: ggplot2: Elegant graphics for data analysis. It goes into much more depth about the underlying theory, and has many more examples of how to combine the individual pieces to solve practical problems. Unfortunately, the book is not available online for free, although you can find the source code at https://github.com/hadley/ggplot2-book.\nAnother great resource is the ggplot2 extensions gallery https://exts.ggplot2.tidyverse.org/gallery/. This site lists many of the packages that extend ggplot2 with new geoms and scales. It’s a great place to start if you’re trying to do something that seems hard with ggplot2.”\n\n\nR Markdown Websites\nFrom 29.8 Websites:\n“With a little additional infrastructure you can use R Markdown to generate a complete website:\n\nPut your .Rmd files in a single directory. index.Rmd will become the home page.\nAdd a YAML file named _site.yml provides the navigation for the site. For example:\n\nname: \"my-website\"\nnavbar:\n  title: \"My Website\"\n  left:\n    - text: \"Home\"\n      href: index.html\n    - text: \"Viridis Colors\"\n      href: 1-example.html\n    - text: \"Terrain Colors\"\n      href: 3-inline.html\nExecute rmarkdown::render_site() to build _site, a directory of files ready to deploy as a standalone static website, or if you use an RStudio Project for your website directory. RStudio will add a Build tab to the IDE that you can use to build and preview your site.\nRead more at https://bookdown.org/yihui/rmarkdown/rmarkdown-site.html.”\n\n\nR Notebook Advice\nHadley has some good suggestions for R Notebooks in 30 R Markdown workflow.",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html#r-packages",
    "href": "analysis/r-training-log.html#r-packages",
    "title": "R Training Log",
    "section": "R Packages",
    "text": "R Packages\nNotes from the book. I’ve started writing all code in the package structure described in the book and used by Hadley and the tidyverse. Doing so makes it easier to write tests, documentation, track dependencies, and provides convenient continuous integration through R CMD check.\n\nSystem Setup\nChapter 3 has good coverage of setting up a system for R development, I’ve incorporated what I learned from this into my “R Setup Log”.\n\n\nNaming Things\nPackage names are pretty restricted, but Hadley has some good recommendation on naming them, including the “available” package, which I’ve started using.\n\n\nRStudio\nThere are some helpful tips in the RStudio section, including 2 key shortcuts to remember:\n\ncontrol-. to “Go to file/function”\nalt-shift-k for the keyboard shortcut quick reference\nnot a shortcut, but use proj_sitrep() to query active projects and working directory\n\n\n\nWriting Better Code\nChapter 6, The Package Within, highlights some sub-optimal R code and shows how to clean it up. It never occurred to me to use a left join to clean up data, and I’ve already started using the technique.\n\n\nR and Homebrew\n7.4 Code Style includes a footnote that references my favorite open source project, Homebrew:\n\nThe Robot Pedantry, Human Empathy blog post by Mike McQuaid does an excellent job summarizing the benefit of automating tasks like code re-styling.\n\nI’ve contributed to homebrew, but I’ve only recently realized how advanced a project it truly is - “advanced” DevOps concepts like trunk-based development and pedantic continuous integration checks just make sense to me, thanks to my experiences contributing. And, I’ve been the recipient of a “You Rock!” from Mike, which felt great, and still does now, even after learning it was partially automated.\n\n\nPackage Conventions\nFrom 7.6 Respect the R landscape:\nAvoid using any of the following:\nlibrary()\nrequire()\nsource()\noptions()\npar()\nsetwd()\nSys.setenv()\nSys.setlocale()\nset.seed()\nInstead, manage dependencies through roxygen2 and the DESCRIPTION file. Use withr when you need to modify state.",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html#wikipedia",
    "href": "analysis/r-training-log.html#wikipedia",
    "title": "R Training Log",
    "section": "Wikipedia",
    "text": "Wikipedia\nA fun demo taken from the Wikipedia article on R:\n\n\n\nMandelbrot set\n\n\n\nlocal({\n  # install.packages(\"caTools\")  # install external package\n  # library(caTools)             # external package providing write.gif function\n  # note: the code in the text of the Wikipedia article doesn't match the code\n  #       used to generate the image in the article,\n  # https://commons.wikimedia.org/wiki/File:Mandelbrot_Creation_Animation.gif\n  #       the colors here have been changed to match the image.\n  jet.colors &lt;- colorRampPalette(c(\n    \"#00007F\", \"blue\", \"#007FFF\", \"cyan\", \"#7FFF7F\",\n    \"yellow\", \"#FF7F00\", \"red\", \"#7F0000\"\n  ))\n  dx &lt;- 1500 # define width\n  dy &lt;- 1400 # define height\n  C &lt;- complex(\n    real = rep(seq(-2.2, 1.0, length.out = dx), each = dy),\n    imag = rep(seq(-1.2, 1.2, length.out = dy), dx)\n  )\n  C &lt;- matrix(C, dy, dx) # reshape as square matrix of complex numbers\n  Z &lt;- 0 # initialize Z to zero\n  X &lt;- array(0, c(dy, dx, 20)) # initialize output 3D array\n  for (k in 1:20) { # loop with 20 iterations\n    Z &lt;- Z^2 + C # the central difference equation\n    X[, , k] &lt;- exp(-abs(Z)) # capture results\n  }\n  write.gif(X, \"rendered/mandelbrot.gif\", col = jet.colors, delay = 100)\n})\n\nWarning in complex(real = rep(seq(-2.2, 1, length.out = dx), each = dy), :\npartial argument match of 'imag' to 'imaginary'",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html",
    "href": "analysis/ggplot2-3.html",
    "title": "ggplot2 (Scales)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Scales” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(jbplot)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#notes",
    "href": "analysis/ggplot2-3.html#notes",
    "title": "ggplot2 (Scales)",
    "section": "Notes",
    "text": "Notes\nThe goal of label_date_short() is to automatically construct short labels that are sufficient to uniquely identify the dates:\n\nggplot(economics, aes(date, psavert)) +\n  geom_line(na.rm = TRUE) +\n  labs(x = NULL, y = NULL) +\n  scale_x_date(limits = as.Date(c(\"2004-01-01\", \"2005-01-01\")), labels = scales::label_date_short())\n\n\n\n\n\n\n\n\nLet’s create a plot with rotated labels!\n\nggplot(mpg, aes(manufacturer, hwy)) +\n  geom_boxplot() +\n  guides(x = guide_axis(angle = 90))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#missing-values",
    "href": "analysis/ggplot2-3.html#missing-values",
    "title": "ggplot2 (Scales)",
    "section": "Missing values",
    "text": "Missing values\nAll continuous colour scales have an na.value parameter that controls what colour is used for missing values (including values outside the range of the scale limits). By default it is set to grey, which will stand out when you use a colourful scale. If you use a black and white scale, you might want to set it to something else to make it more obvious. You can set na.value = NA to make missing values invisible, or choose a specific colour if you prefer:\n\ndf &lt;- data.frame(x = 1, y = 1:5, z = c(1, 3, 2, NA, 5))\nbase &lt;- ggplot(df, aes(x, y)) +\n  geom_tile(aes(fill = z), linewidth = 5) +\n  labs(x = NULL, y = NULL) +\n  scale_x_continuous(labels = NULL)\nbase\n\n\n\n\n\n\n\nbase + scale_fill_gradient(na.value = NA)\n\n\n\n\n\n\n\nbase + scale_fill_gradient(na.value = \"yellow\")",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#limits-breaks-and-labels",
    "href": "analysis/ggplot2-3.html#limits-breaks-and-labels",
    "title": "ggplot2 (Scales)",
    "section": "Limits, breaks, and labels",
    "text": "Limits, breaks, and labels\nScale limits for discrete colour scales can be set using the limits argument to the scale argument, or by using the lims() helper function. This can be important when the same variable is represented in different plots, and you want to ensure that the colours are consistent across plots. To demonstrate this I’ll extend the example from Section 10.1.1. Colour represents the fuel type, which can be regular, ethanol, diesel, premium or compressed natural gas.\n\nmpg_99 &lt;- mpg %&gt;% filter(year == 1999)\nmpg_08 &lt;- mpg %&gt;% filter(year == 2008)\nbase_99 &lt;- ggplot(mpg_99, aes(displ, hwy, colour = fl)) +\n  geom_point()\nbase_08 &lt;- ggplot(mpg_08, aes(displ, hwy, colour = fl)) +\n  geom_point()\nbase_99\n\n\n\n\n\n\n\nbase_08\n\n\n\n\n\n\n\n\nEach plot makes sense on its own, but visual comparison between the two is difficult. The axis limits are different, and because only regular, premium and diesel fuels are represented in the 1998 data the colours are mapped inconsistently. To ensure a consistent mapping for the colour aesthetic, we can use lims() to manually set the limits. As discussed in Section 10.1.1 it takes name-value pairs as input, where the name specifies the aesthetic and the value specifies the limits:\n\nbase_99 + lims(colour = c(\"c\", \"d\", \"e\", \"p\", \"r\"))\n\n\n\n\n\n\n\nbase_08 + lims(colour = c(\"c\", \"d\", \"e\", \"p\", \"r\"))\n\n\n\n\n\n\n\n\nThe nice thing about lims() is that we can set the limits for multiple aesthetics at once. To ensure that x, y, and colour all use consistent limits we can do this:\n\nbase_99 +\n  lims(\n    x = c(1, 7),\n    y = c(10, 45),\n    colour = c(\"c\", \"d\", \"e\", \"p\", \"r\")\n  )\n\n\n\n\n\n\n\nbase_08 +\n  lims(\n    x = c(1, 7),\n    y = c(10, 45),\n    colour = c(\"c\", \"d\", \"e\", \"p\", \"r\")\n  )\n\n\n\n\n\n\n\n\nThere are two potential limitations to these plots. First, while setting the scale limits does ensure that colours are mapped identically in both plots, it also means that the plot for the 1999 data displays labels for all five fuel types, despite the fact that ethanol and compressed natural gas fuels were not in use at that time. We can address this by manually setting the scale breaks, ensuring that only those fuel types that appear in the data are shown in the legend. The second limitation is that the labels are not particularly helpful, which we can address by specifying them manually. When setting multiple properties of a single scale, it can be more useful to customise using the arguments to the scale function rather than using the lims() helper function:\n\nbase_99 +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    breaks = c(\"d\", \"p\", \"r\"),\n    labels = c(\"diesel\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\n\nHowever, there is nothing stopping you from using lims() to control the position aesthetic limits, while using scale_colour_discrete() to exercise more fine-grained control over the colour aesthetic:\n\nbase_99 +\n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    breaks = c(\"d\", \"p\", \"r\"),\n    labels = c(\"diesel\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\nbase_08 +\n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    labels = c(\"compressed\", \"diesel\", \"ethanol\", \"premium\", \"regular\")\n  )",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#legends",
    "href": "analysis/ggplot2-3.html#legends",
    "title": "ggplot2 (Scales)",
    "section": "Legends",
    "text": "Legends\n\noverride.aes is useful when you want the elements in the legend display differently to the geoms in the plot. This is often required when you’ve used transparency or size to deal with moderate overplotting and also used colour in the plot.\n\n\nbase &lt;- ggplot(mpg, aes(displ, hwy, colour = drv)) +\n  geom_point(size = 4, alpha = 0.2, stroke = 0)\n\nbase + guides(colour = guide_legend())\n\n\n\n\n\n\n\nbase + guides(colour = guide_legend(override.aes = list(alpha = 1)))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#binned-colour",
    "href": "analysis/ggplot2-3.html#binned-colour",
    "title": "ggplot2 (Scales)",
    "section": "Binned colour scales",
    "text": "Binned colour scales\nColour scales also come in binned versions. The default scale is scale_fill_binned() which in turn defaults to scale_fill_steps(). As with the binned position scales discussed in Section 10.4 these scales have an n.breaks argument that controls the number of discrete colour categories created by the scale. Counterintuitively—because the human visual system is very good at detecting edges—this can sometimes make a continuous colour gradient easier to perceive:\n\nerupt + scale_fill_binned()\n\n\n\n\n\n\n\nerupt + scale_fill_steps()\n\n\n\n\n\n\n\nerupt + scale_fill_steps(n.breaks = 8)\n\n\n\n\n\n\n\n\nThe viridis palettes can be used in the same way, by calling the palette generating functions directly when specifying the colours argument to scale_fill_stepsn():\n\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::viridis(9))\n\n\n\n\n\n\n\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::magma(9))\n\n\n\n\n\n\n\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::inferno(9))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#size",
    "href": "analysis/ggplot2-3.html#size",
    "title": "ggplot2 (Scales)",
    "section": "Size",
    "text": "Size\nThe size aesthetic is typically used to scale points and text. The default scale for size aesthetics is scale_size() in which a linear increase in the variable is mapped onto a linear increase in the area (not the radius) of the geom. Scaling as a function of area is a sensible default as human perception of size is more closely mimicked by area scaling than by radius scaling. By default the smallest value in the data (more precisely in the scale limits) is mapped to a size of 1 and the largest is mapped to a size of 6. The range argument allows you to scale the size of the geoms:\n\nbase &lt;- ggplot(mpg, aes(displ, hwy, size = cyl)) +\n  geom_point()\nbase\n\n\n\n\n\n\n\nbase + scale_size(range = c(1, 2))\n\n\n\n\n\n\n\n\nLet’s draw a scale model of the planets!\n\nplanets &lt;- data.frame(\n  name = c(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"),\n  type = c(rep(\"Inner\", 4), rep(\"Outer\", 4)),\n  position = 1:8,\n  radius = c(2440, 6052, 6378, 3390, 71400, 60330, 25559, 24764),\n  stringsAsFactors = FALSE\n)\nplanets$name &lt;- with(planets, factor(name, name))\n\nggplot(planets, aes(1, name, size = radius)) +\n  geom_point() +\n  scale_x_continuous(breaks = NULL) +\n  scale_radius(limits = c(0, NA), range = c(0, 15)) +\n  labs(x = NULL, y = NULL, size = \"Radius\", title = \"The planets of the solar system\") +\n  theme_quo(y = FALSE, x = FALSE)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#manual-scales",
    "href": "analysis/ggplot2-3.html#manual-scales",
    "title": "ggplot2 (Scales)",
    "section": "Manual scales",
    "text": "Manual scales\nLet’s create a plot with manual scales:\n\nhuron &lt;- data.frame(year = 1875:1972, level = as.numeric(LakeHuron))\n\nggplot(huron, aes(year)) +\n  geom_line(aes(y = level + 5, colour = \"above\")) +\n  geom_line(aes(y = level - 5, colour = \"below\")) +\n  scale_colour_manual(\"Direction\",\n    values = c(above = \"red\", below = \"blue\")\n  ) +\n  labs(x = NULL, y = NULL)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#identity-scales",
    "href": "analysis/ggplot2-3.html#identity-scales",
    "title": "ggplot2 (Scales)",
    "section": "Identity scales",
    "text": "Identity scales\nLet’s plot all the R colors!\n\nggplot(luv_colours, aes(u, v)) +\n  geom_point(aes(colour = col), size = 3) +\n  scale_color_identity() +\n  coord_equal() +\n  labs(x = NULL, y = NULL)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-5.html",
    "href": "analysis/ggplot2-5.html",
    "title": "ggplot2 (Extending)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Extending” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(ggplot2)\nlibrary(wesanderson)\nlibrary(scales)\nlibrary(maps)\nlibrary(dplyr)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Extending)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-5.html#exercises",
    "href": "analysis/ggplot2-5.html#exercises",
    "title": "ggplot2 (Extending)",
    "section": "19.2.1 Exercises",
    "text": "19.2.1 Exercises\n\nCreate an object that represents a pink histogram with 100 bins.\n\nAnswer: pink_hist applied to the price of diamonds.\n\npink_hist &lt;- geom_histogram(bins = 100, fill = \"pink\")\n\nggplot(diamonds, aes(price)) +\n  pink_hist\n\n\n\n\n\n\n\n\nGG Solutions:\n\npink_hist_ggs &lt;- geom_histogram(\n  color = \"pink\",\n  bins = 100\n)\n\nNote: I think the intent here is to set fill, not color.\n\n\nCreate an object that represents a fill scale with the Blues ColorBrewer palette.\n\nAnswer: blues applied to a geom_bar() example:\n\nblues &lt;- scale_fill_brewer(palette = \"Blues\")\n\nggplot(mpg, aes(class, fill = drv)) +\n  geom_bar() +\n  theme_classic() +\n  blues\n\n\n\n\n\n\n\n\nGG Solutions:\n\nfill_blues &lt;- scale_fill_distiller(\n  palette = \"Blues\"\n)\n\nNote that the documentation states:\n\nThe distiller scales extend brewer scales by smoothly interpolating 7 colours from any palette to a continuous scale.\n\n\n\nRead the source code for theme_grey(). What are its arguments? How does it work?\n\nAnswer: theme_grey() has 4 arguments: base_size, base_family, base_line_size, and base_rect_size. It specifies a complete theme object, t, and uses the %+replace% function to modify an internal global, ggplot_global$theme_all_null using t.\n\ntheme_grey\n\n#&gt; function (base_size = 11, base_family = \"\", base_line_size = base_size/22, \n#&gt;     base_rect_size = base_size/22) \n#&gt; {\n#&gt;     half_line &lt;- base_size/2\n#&gt;     t &lt;- theme(line = element_line(colour = \"black\", linewidth = base_line_size, \n#&gt;         linetype = 1, lineend = \"butt\"), rect = element_rect(fill = \"white\", \n#&gt;         colour = \"black\", linewidth = base_rect_size, linetype = 1), \n#&gt;         text = element_text(family = base_family, face = \"plain\", \n#&gt;             colour = \"black\", size = base_size, lineheight = 0.9, \n#&gt;             hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), \n#&gt;             debug = FALSE), axis.line = element_blank(), axis.line.x = NULL, \n#&gt;         axis.line.y = NULL, axis.text = element_text(size = rel(0.8), \n#&gt;             colour = \"grey30\"), axis.text.x = element_text(margin = margin(t = 0.8 * \n#&gt;             half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * \n#&gt;             half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * \n#&gt;             half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * \n#&gt;             half_line/2), hjust = 0), axis.ticks = element_line(colour = \"grey20\"), \n#&gt;         axis.ticks.length = unit(half_line/2, \"pt\"), axis.ticks.length.x = NULL, \n#&gt;         axis.ticks.length.x.top = NULL, axis.ticks.length.x.bottom = NULL, \n#&gt;         axis.ticks.length.y = NULL, axis.ticks.length.y.left = NULL, \n#&gt;         axis.ticks.length.y.right = NULL, axis.title.x = element_text(margin = margin(t = half_line/2), \n#&gt;             vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line/2), \n#&gt;             vjust = 0), axis.title.y = element_text(angle = 90, \n#&gt;             margin = margin(r = half_line/2), vjust = 1), axis.title.y.right = element_text(angle = -90, \n#&gt;             margin = margin(l = half_line/2), vjust = 0), legend.background = element_rect(colour = NA), \n#&gt;         legend.spacing = unit(2 * half_line, \"pt\"), legend.spacing.x = NULL, \n#&gt;         legend.spacing.y = NULL, legend.margin = margin(half_line, \n#&gt;             half_line, half_line, half_line), legend.key = element_rect(fill = \"grey95\", \n#&gt;             colour = NA), legend.key.size = unit(1.2, \"lines\"), \n#&gt;         legend.key.height = NULL, legend.key.width = NULL, legend.text = element_text(size = rel(0.8)), \n#&gt;         legend.text.align = NULL, legend.title = element_text(hjust = 0), \n#&gt;         legend.title.align = NULL, legend.position = \"right\", \n#&gt;         legend.direction = NULL, legend.justification = \"center\", \n#&gt;         legend.box = NULL, legend.box.margin = margin(0, 0, 0, \n#&gt;             0, \"cm\"), legend.box.background = element_blank(), \n#&gt;         legend.box.spacing = unit(2 * half_line, \"pt\"), panel.background = element_rect(fill = \"grey92\", \n#&gt;             colour = NA), panel.border = element_blank(), panel.grid = element_line(colour = \"white\"), \n#&gt;         panel.grid.minor = element_line(linewidth = rel(0.5)), \n#&gt;         panel.spacing = unit(half_line, \"pt\"), panel.spacing.x = NULL, \n#&gt;         panel.spacing.y = NULL, panel.ontop = FALSE, strip.background = element_rect(fill = \"grey85\", \n#&gt;             colour = NA), strip.clip = \"inherit\", strip.text = element_text(colour = \"grey10\", \n#&gt;             size = rel(0.8), margin = margin(0.8 * half_line, \n#&gt;                 0.8 * half_line, 0.8 * half_line, 0.8 * half_line)), \n#&gt;         strip.text.x = NULL, strip.text.y = element_text(angle = -90), \n#&gt;         strip.text.y.left = element_text(angle = 90), strip.placement = \"inside\", \n#&gt;         strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(half_line/2, \n#&gt;             \"pt\"), strip.switch.pad.wrap = unit(half_line/2, \n#&gt;             \"pt\"), plot.background = element_rect(colour = \"white\"), \n#&gt;         plot.title = element_text(size = rel(1.2), hjust = 0, \n#&gt;             vjust = 1, margin = margin(b = half_line)), plot.title.position = \"panel\", \n#&gt;         plot.subtitle = element_text(hjust = 0, vjust = 1, margin = margin(b = half_line)), \n#&gt;         plot.caption = element_text(size = rel(0.8), hjust = 1, \n#&gt;             vjust = 1, margin = margin(t = half_line)), plot.caption.position = \"panel\", \n#&gt;         plot.tag = element_text(size = rel(1.2), hjust = 0.5, \n#&gt;             vjust = 0.5), plot.tag.position = \"topleft\", plot.margin = margin(half_line, \n#&gt;             half_line, half_line, half_line), complete = TRUE)\n#&gt;     ggplot_global$theme_all_null %+replace% t\n#&gt; }\n#&gt; &lt;bytecode: 0x10e7e2418&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n\nGG Solutions:\n\nIts arguments include base_size, base_family, base_line_size, and base_rect_size\nAccording to the help file, theme_gray() is the signature ggplot2 theme with a grey background and white gridlines and is designed to put the data forward yet make comparisons easy.\n\n\n\nCreate scale_colour_wesanderson(). It should have a parameter to pick the palette from the wesanderson package, and create either a continuous or discrete scale.\n\nAnswer: to construct this function, it is helpful to review the code for scale_color_brewer():\n\nscale_color_brewer\n\n#&gt; function (..., type = \"seq\", palette = 1, direction = 1, aesthetics = \"colour\") \n#&gt; {\n#&gt;     discrete_scale(aesthetics, \"brewer\", brewer_pal(type, palette, \n#&gt;         direction), ...)\n#&gt; }\n#&gt; &lt;bytecode: 0x10fc7d530&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n\nThe function is a wrapper for discrete_scale() and calls scales::brewer_pal(), which is a function factory:\n\nscales::brewer_pal\n\n#&gt; function (type = \"seq\", palette = 1, direction = 1) \n#&gt; {\n#&gt;     pal &lt;- pal_name(palette, type)\n#&gt;     force(direction)\n#&gt;     function(n) {\n#&gt;         if (n &lt; 3) {\n#&gt;             pal &lt;- suppressWarnings(RColorBrewer::brewer.pal(n, \n#&gt;                 pal))\n#&gt;         }\n#&gt;         else {\n#&gt;             pal &lt;- RColorBrewer::brewer.pal(n, pal)\n#&gt;         }\n#&gt;         pal &lt;- pal[seq_len(n)]\n#&gt;         if (direction == -1) {\n#&gt;             pal &lt;- rev(pal)\n#&gt;         }\n#&gt;         pal\n#&gt;     }\n#&gt; }\n#&gt; &lt;bytecode: 0x107ef3810&gt;\n#&gt; &lt;environment: namespace:scales&gt;\n\n\nFirst we construct a discrete scale, using Darjeeling1 as the default:\n\nwesanderson_pal &lt;- function(name, type) {\n  function(n) {\n    wes_palette(name, n, type)\n  }\n}\n\nscale_color_wesanderson_d &lt;- function(..., name = \"Darjeeling1\", type = \"discrete\",\n                                      aesthetics = \"colour\") {\n  discrete_scale(aesthetics, \"wesanderson_d\", wesanderson_pal(name, type), ...)\n}\n\nNote that these functions are limited by the number of colors in each wesanderson palette (4-7), which will generate an error if more colors are requested. The wesanderson_pal function could be revised to auto-enable continuous or scale_color_wesanderson_d() can be called with type = \"continuous\".\nFor a continuous scale, it is helpful to review the code of scale_color_viridis_c():\n\nscale_color_viridis_c\n\n#&gt; function (..., alpha = 1, begin = 0, end = 1, direction = 1, \n#&gt;     option = \"D\", values = NULL, space = \"Lab\", na.value = \"grey50\", \n#&gt;     guide = \"colourbar\", aesthetics = \"colour\") \n#&gt; {\n#&gt;     continuous_scale(aesthetics, \"viridis_c\", gradient_n_pal(viridis_pal(alpha, \n#&gt;         begin, end, direction, option)(6), values, space), na.value = na.value, \n#&gt;         guide = guide, ...)\n#&gt; }\n#&gt; &lt;bytecode: 0x11e49fe08&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n\nWe can add a continuous scale based using Zissou1 as the default:\n\nscale_color_wesanderson_c &lt;- function(...,\n                                      name = \"Zissou1\",\n                                      type = \"continuous\",\n                                      values = NULL,\n                                      space = \"Lab\",\n                                      na.value = \"grey50\",\n                                      guide = \"colourbar\",\n                                      aesthetics = \"colour\") {\n  continuous_scale(\n    aesthetics, \"wesanderson_c\",\n    gradient_n_pal(wesanderson_pal(name, type)(length(wes_palettes[[name]])), values, space),\n    na.value = na.value, guide = guide, ...\n  )\n}\n\nscale_colour_wesanderson_d() applied to an mpg plot:\n\nggplot(mpg, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  scale_color_wesanderson_d()\n\n\n\n\n\n\n\n\nscale_colour_wesanderson_c() applied to an mpg plot:\n\nggplot(mpg, aes(displ, hwy, color = cyl)) +\n  geom_point() +\n  scale_color_wesanderson_c()\n\n\n\n\n\n\n\n\nNotes: while the exercise calls for a single function, this breaks the normal conventions for ggplot2. Such a function could be written by combining scale_colour_wesanderson_d() and scale_colour_wesanderson_c().\nGG Solutions:\n\nscale_colour_wesanderson &lt;- function(palette = \"BottleRocket1\", ...) {\n  scale_color_manual(values = wesanderson::wes_palette(palette), ...)\n}\n# Working example\nggplot(mtcars, aes(wt, disp, color = factor(gear))) +\n  geom_point() +\n  scale_colour_wesanderson()",
    "crumbs": [
      "Changelog",
      "ggplot2 (Extending)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-5.html#exercises-1",
    "href": "analysis/ggplot2-5.html#exercises-1",
    "title": "ggplot2 (Extending)",
    "section": "19.3.4 Exercises",
    "text": "19.3.4 Exercises\n\nTo make the best use of space, many examples in this book hide the axes labels and legend. I’ve just copied-and-pasted the same code into multiple places, but it would make more sense to create a reusable function. What would that function look like?\n\nAnswer: hide_ll() does this, demonstrated with an mpg plot.\n\nhide_ll &lt;- function() {\n  list(\n    labs(x = NULL, y = NULL),\n    theme(legend.position = \"none\")\n  )\n}\n\nggplot(mpg, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  hide_ll()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nremove_labels &lt;- theme(\n  legend.position = \"none\",\n  axis.title.x = element_blank(),\n  axis.title.y = element_blank()\n)\n# Working Example\nggplot(mtcars, aes(wt, disp, color = factor(gear))) +\n  geom_point() +\n  remove_labels\n\n\n\n\n\n\n\n\nNote: the GG Solutions answer is more verbose, but uses only a single function call (theme).\n\n\nExtend the borders() function to also add coord_quickmap() to the plot.\n\nAnswer: borders_quickmap() implemented and demonstrated using a borders() example. In this case, the function passes all ... variables to borders() and none to coord_quickmap() which avoids the complexity of handling arguments for both functions.\n\nborders_quickmap &lt;- function(...) {\n  list(\n    borders(...),\n    coord_quickmap()\n  )\n}\n\nus.cities |&gt;\n  filter(capital == 2, !(country.etc %in% c(\"AK\", \"HI\"))) |&gt;\n  ggplot(aes(long, lat)) +\n  geom_point() +\n  borders_quickmap(\"state\") +\n  theme_void()\n\n\n\n\n\n\n\n\nNote: because of the complexities, it’s unlikely I’d ever implement something like Additional arguments - there are minimal gains compared to calling two functions with separate lists of parameters.\nGG Solutions: Not sure.\n\n\nLook through your own code. What combinations of geoms or scales do you use all the time? How could you extract the pattern into a reusable function?\n\nAnswer: a common pattern I use is geom_smooth with lm and y ~ x. An implementation of this using robust linear modeling from MASS is demonstrated below:\n\ngeom_rlm &lt;- function(mapping = NULL, data = NULL, stat = \"smooth\", position = \"identity\", ...,\n                     method = MASS::rlm, formula = y ~ x, se = TRUE,\n                     na.rm = FALSE,\n                     orientation = NA,\n                     show.legend = NA, inherit.aes = TRUE) {\n  geom_smooth(\n    mapping = mapping, data = data, stat = stat, position = position, ...,\n    method = method, formula = formula, se = se, na.rm = na.rm, orientation = orientation,\n    show.legend = show.legend, inherit.aes = TRUE\n  )\n}\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_rlm()\n\n\n\n\n\n\n\n\nGG Solutions: no answer.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Extending)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-5.html#exercises-2",
    "href": "analysis/ggplot2-5.html#exercises-2",
    "title": "ggplot2 (Extending)",
    "section": "19.4.2 Exercises",
    "text": "19.4.2 Exercises\n\nCreate a distribution() function specially designed for visualising continuous distributions. Allow the user to supply a dataset and the name of a variable to visualise. Let them choose between histograms, frequency polygons, and density plots. What other arguments might you want to include?\n\nAnswer: code below. In this case, it is useful to include binwidth and bins, used in creating both histograms and frequency polygons, and na.rm, used in all three. Defaults to histogram.\n\ndistribution &lt;- function(data, var, type = \"histogram\", binwidth = NULL, bins = NULL,\n                         na.rm = FALSE) {\n  gg &lt;- ggplot(data, aes({{ var }}))\n\n  if (type == \"histogram\") {\n    gg &lt;- gg + geom_histogram(binwidth = binwidth, bins = bins, na.rm = na.rm)\n  } else if (type == \"freqpoly\") {\n    gg &lt;- gg + geom_freqpoly(binwidth = binwidth, bins = bins, na.rm = na.rm)\n  } else if (type == \"density\") {\n    gg &lt;- gg + geom_density(na.rm = na.rm)\n  } else {\n    stop(\"`type` must be histogram, freqpoly, or density\")\n  }\n  gg\n}\n\ndistribution(diamonds, price, binwidth = 100)\n\n\n\n\n\n\n\ndistribution(diamonds, price, type = \"freqpoly\", binwidth = 100)\n\n\n\n\n\n\n\ndistribution(diamonds, price, type = \"density\")\n\n\n\n\n\n\n\n\n\n\nWhat additional arguments should pcp() take? What are the downsides of how ... is used in the current code?\n\nAnswer: it would be useful to add arguments for the order of the variables, and a scale adjustment for value, drawing from examples on Wikipedia. Using ... for geom_line() prevents other unnamed parameters from being passed to other functions, like ggplot().",
    "crumbs": [
      "Changelog",
      "ggplot2 (Extending)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-5.html#exercises-3",
    "href": "analysis/ggplot2-5.html#exercises-3",
    "title": "ggplot2 (Extending)",
    "section": "19.5.1 Exercises",
    "text": "19.5.1 Exercises\n\nHow could you add a geom_point() layer to each element of the following list?\n\n\nplots &lt;- list(\n  ggplot(mpg, aes(displ, hwy)),\n  ggplot(diamonds, aes(carat, price)),\n  ggplot(faithfuld, aes(waiting, eruptions, size = density))\n)\n\nAnswer: easily done with lapply()`:\n\nlapply(plots, function(g) g + geom_point())\n\n#&gt; [[1]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[2]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[3]]\n\n\n\n\n\n\n\n\n\n\n\nWhat does the following function do? What’s a better name for it?\n\n\nmystery &lt;- function(...) {\n  Reduce(`+`, list(...), accumulate = TRUE)\n}\n\nmystery(\n  ggplot(mpg, aes(displ, hwy)) +\n    geom_point(),\n  geom_smooth(),\n  xlab(NULL),\n  ylab(NULL)\n)\n\n#&gt; [[1]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[2]]\n\n\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[3]]\n\n\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[4]]\n\n\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nAnswer: a better name would be ‘add layer and print’.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Extending)"
    ]
  },
  {
    "objectID": "analysis/r-books.html",
    "href": "analysis/r-books.html",
    "title": "R Books",
    "section": "",
    "text": "An actively maintained and curated list of R Books and other recommended resources from my reading list.",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#libraries",
    "href": "analysis/r-books.html#libraries",
    "title": "R Books",
    "section": "Libraries",
    "text": "Libraries\nLibraries used in this notebook.\n\nlibrary(palmerpenguins)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(cranlogs)\nlibrary(dplyr)",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#getting-started",
    "href": "analysis/r-books.html#getting-started",
    "title": "R Books",
    "section": "Getting Started",
    "text": "Getting Started\nBooks and resources I recommend for learning R.\n\nR for Data Science\nR for Data Science (2e) - Second Edition of Hadley Wickham’s introductory book on R and exploratory data analysis. The book contains example code and exercises in most chapters. I used the first edition as my primary source when I was first learning R, and still recommend the book for beginners who want to learn R. The book teaches the basics of using tidyverse R1 for exploratory data analysis and visualization. A companion book provides suggested solutions to the exercises.\nSample visualization from the first chapter:\n\n# visualization from https://r4ds.hadley.nz/data-visualize#first-steps\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\", shape = \"Species\"\n  ) +\n  scale_color_colorblind()\n\n\n\n\n\n\n\n\n\n\nResources\nIn addition to R for Data Science, I recommend the following resources for new R users:\n\nThe R Graph Gallery - library of charts made with R and ggplot2\nPackages for writing better code:\n\nrenv - for package version management by project\nstyler - for consistent formatting of R code\nlintr - for avoiding common mistakes\n\nStyle guides for writing better code:\n\ntidyverse style guide - implemented by styler\nGoogle’s R Style Guide - a fork of the tidyverse guide\n\n\nrdev, my personalized collection of R development tools, includes all three of these packages and more, along with my own style guide and R environment setup instructions.",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#additional-reading",
    "href": "analysis/r-books.html#additional-reading",
    "title": "R Books",
    "section": "Additional Reading",
    "text": "Additional Reading\nBooks I read to improve my knowledge of R.\n\nR Packages (2e) - the second edition of Hadley Wickham’s book on writing R packages, which I used to build rdev\nAdvanced R - the second edition of Hadley’s book on R programming, which explains the R language (the first edition uses more base R than the second edition)\nAdvanced R Solutions - solutions to exercises from Advanced R\nggplot2: Elegant Graphics for Data Analysis (3e) - the third edition of Hadley’s book on his implementation of Leland Wilkinson’s Grammar of Graphics\nSolutions to ggplot2: Elegant Graphics for Data Analysis - solutions to exercises from ggplot2\n\nMy own notes and solutions to the Advanced R and ggplot2 exercises are available on this site.\n\nraps-with-r\nBuilding reproducible analytical pipelines with R - the stated goal of the book is to improve the reproducibility of data analysis. I don’t recommend this book. Section 1 is a reasonably good introduction to git and GitHub, but introduces trunk-based development without covering linear commit history. Section 2 provides some good advice, but much that I disagree with, including inline use of knitr::knit_child to automate creation of sections (which break the notebook workflow) and fusen to create packages from .Rmd files, which I found to create extra work with no clear benefits over using and/or extending the standard package layout like vertical or my own layout from rdev. (Interestingly, the author of vertical is also switching to Quarto for reproducible research and analysis) I also found the code examples to be inconsistent and a bit clunky.\nChapter 12 gives recommendations on testing: unit testing with some basic examples, assertive programming, Test-Driven Development (TDD), and test coverage. It suggests three packages for R assertions: assertthat, chk, and checkmate. Both chk and checkmate are designed to check function arguments; of the two, checkmate appears to be more robust and built to address the downside of R being a dynamically typed language.\nFor data validation, I currently use stopifnot(), although I may switch to either assertr or validate, which are both popular packages. I validate function arguments using manual checks, but checkmate looks appealing as a way to write more succinct code. Total downloads for the assertr, validate, chk, and checkmate packages for the last month are listed below:\n\ncran_downloads(\n  packages = c(\"assertr\", \"validate\", \"chk\", \"checkmate\"),\n  when = \"last-month\"\n) |&gt;\n  group_by(package) |&gt;\n  summarize(downloads = sum(count), as_of = max(date))\n\n# A tibble: 4 × 3\n  package   downloads as_of     \n  &lt;chr&gt;         &lt;dbl&gt; &lt;date&gt;    \n1 assertr        1609 2023-12-30\n2 checkmate    244133 2023-12-30\n3 chk           11199 2023-12-30\n4 validate       1426 2023-12-30\n\n\n2023-12-29 Update: I’ve started using checkmate to check function arguments and have found that validate is better overall at data validation.\nChapter 13 introduces targets, “a Make-like pipeline tool for statistics and data science in R.” Conceptually, targets is very similar to an R Notebook, but like Make, will skip components that are up to date, and can run targets in parallel to speed up builds. targets can also render R Markdown documents using the tarchetypes package. I found the example target pipeline in the book convoluted and didn’t attempt to follow it. The targets manual explains that it implements two kinds of literate programming:\n\n\nA literate programming source document (or Quarto project) that renders inside an individual target. Here, you define a special kind of target that runs a lightweight R Markdown report which depends on upstream targets.\nTarget Markdown, an overarching system in which one or more Quarto or R Markdown files write the _targets.R file and encapsulate the pipeline.\n\n\nOf these two types, the second is a better fit with my preferred workflow: including multiple self-contained notebooks in a single repository. From the appendix, the design of Target Markdown supports both interactive development using notebooks and running a pipeline non-interactively when rendering the final document. For my work, targets doesn’t offer significant advantages over using R Markdown and Quarto - the only slowdown I typically encounter is when building a site with many notebooks, which the Quarto freeze option handles by only re-rendering documents when the source file changes. (I’m not performing the large, complex computations that targets is designed for)\nChapter 14 covers Docker, and asserts that it is necessary for reproducibility. While using Docker ensures a stable operating system environment, I think the book overstates the case for reproducibility, citing a single example where the operating system changed the results of an analysis because the scripts relied on OS file ordering. Much like use of targets, Docker would be most useful for projects with complex development environments shared across teams, but much of the benefits can be achieved using other approaches, like using OS-independent code. The chapter also encourages using a “frozen” development environment that is updated on a fixed schedule to minimize the impact of frequent updates. This is exactly the opposite of the modern DevOps approach - the issues created by small, frequent updates are smaller and easier to address than the more complex problems created by large upgrades. I always start development by updating packages to the latest production release - while this sometimes introduces issues, they are typically easy to fix, and prioritizing maintenance first improves quality and security.\nAn alternate approach to using Docker is to leverage GitHub Actions, which provides on-demand virtual machines that can be used to consistently test, build, and deploy code. The Tidyverse community provides a library of GitHub Actions for R, which I’ve customized for rdev. In fact, chapter 15 covers use of GitHub Actions using r-lib and presents them as a potential alternative for Docker.\nOverall, I do follow the book’s core recommendations for reproducibility:\n\nUse version control extensively\nUse trunk-based development\nAdopt functional programming and DRY\nUse R Markdown which embeds analysis code and code output directly into the written report\nUse renv to manage dependencies\nPackage all R code and publish using GitHub Pages\nWrite unit tests using testthat\nUse assertions to validate function arguments and imported data\nCheck test coverage using covr\nUse automated builds (but using Quarto instead of targets)\n\nI would consider use of targets and Docker for larger, more complex, or long-lived projects, but I found that fusen offered no clear benefits and wouldn’t recommend its use. I think the biggest lesson I took from the book was to follow DRY a bit more strictly than I currently do, and use more functions, tests, and assertions in my analysis code.\nThe book does reference some interesting reading I’ve added to my list:\n\nJohn M. Chambers. “Object-Oriented Programming, Functional Programming and R.” Statist. Sci. 29 (2) 167 - 180, May 2014. https://doi.org/10.1214/13-STS452\nTrunk-Based Development And Branch By Abstraction\n\nWhile reading the book, I discovered some interesting additional resources:\n\nVertical, a “an R-based structured workflow for creating and sharing research assets in the form of an extended R package”, which I plan to review and compare to rdev\nFour ways to write assertion checks in R - an article on four methods for writing assertions in R:\n\nUse stopifnot() from base R\nUse the assertthat package (last updated March 2019)\nUse the assertive package (last updated July 2020)\nUse the assertr package for data assertions, which works especially well for assertion checks against data frames used in data analysis\n\nI also revisited the validate package, a data validation rules engine, which includes the Data Validation Cookbook (in Future Reading)",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#future-reading",
    "href": "analysis/r-books.html#future-reading",
    "title": "R Books",
    "section": "Future Reading",
    "text": "Future Reading\nR books on my reading list.\n\nThe R Manuals - a re-styled version of the original R manuals, published using Quarto (starting with Writing R Extensions)\nR Markdown: The Definitive Guide - written by the author of knitr\nR Markdown Cookbook - the follow-up to The Definitive Guide\nThe Data Validation Cookbook - a book on the R validate package\nDiscovering Statistics Using R - recommended to me as an introduction to statistics using R",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#r-dialects",
    "href": "analysis/r-books.html#r-dialects",
    "title": "R Books",
    "section": "R Dialects",
    "text": "R Dialects\nAn explanatory note on the R dialects of base R and tidyverse R.\nThe R programming language is over 30 years old and has a large number of packages (R libraries) that extend R. Unlike python (a general purpose language), R was designed specifically for analysis, visualization, and statistical modeling, which is why I chose R for data analysis: it has built-in support for data structures like data frames (implemented in python using pandas), vectors, packages for just about any statistical tool you’d need, and of course, ggplot2. In fairness, python is more popular, more robust, and a better tool for some tasks, like data acquisition and machine learning (which were not priorities for my use).\nLike many human languages, R has developed two distinct dialects: base R and tidyverse R. Base R consists of the packages included in the R distribution (base, compiler, datasets, graphics, grDevices, grid, methods, parallel, splines, stats, stats4, tcltk, tools, utils), and the Tidyverse is a collection of packages that implement a domain-specific language for data analysis, originally created by Hadley Wickham.\nIn my experience, tidyverse R is better for data analysis, where base R is better for writing packages - tidyverse functions are closer to natural language, but have many more dependencies. Comparing two popular tools for data manipulation, dplyr (tidyverse R) and data.table (base R) shows these differences.\nThis code snippet is from a short analysis of survey responses using dplyr:\nsurvey_results &lt;- survey_import |&gt;\n  mutate(across(Q1:Q7, ~ case_when(\n    .x == \"strongly disagree\" ~ 1,\n    .x == \"disagree\" ~ 2,\n    .x == \"neither agree nor disagree\" ~ 3,\n    .x == \"agree\" ~ 4,\n    .x == \"strongly agree\" ~ 5\n  ))) |&gt;\n  mutate(Q8 = as.numeric(Q8 == \"Yes\")) |&gt;\n  arrange(end_date)\nThe code is reasonably easy to understand, even if you’re not familiar with R.\nThe same code written in data.table isn’t as clear:\nlikert_5 &lt;- c(\n  \"strongly disagree\", \"disagree\", \"neither agree nor disagree\",\n  \"agree\", \"strongly agree\"\n)\nq_likert &lt;- paste0(\"Q\", 1:7)\nq_yesno &lt;- \"Q8\"\n\nsurvey_results &lt;- copy(survey_import)\nsurvey_results &lt;- survey_results[\n  , (q_likert) := lapply(.SD, \\(x) as.numeric(factor(x, levels = likert_5))),\n  .SDcols = q_likert\n][\n  , (q_yesno) := lapply(.SD, \\(x) as.numeric(x == \"Yes\")),\n  .SDcols = q_yesno\n][\n  order(end_date)\n]\nWhile it may be harder to read, data.table has some clear advantages: it is quite fast, especially with very large datasets, and has no dependencies other than base R, where dplyr has many.\nThese tradeoffs are why I tend to use tidyverse R for analysis and base R for functions (most tidyverse expressions have functional equivalents in base R). Code used in data analysis should be clear and easy to read, which tidyverse R excels at. Packaged functions provide documentation and the source code isn’t typically read, but many dependencies can be problematic; R CMD check will raise a NOTE if there are too many imports.",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#footnotes",
    "href": "analysis/r-books.html#footnotes",
    "title": "R Books",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFor a detailed explanation of “tidyverse R”, see R Dialects↩︎",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "MIT License",
    "section": "",
    "text": "MIT License\nCopyright (c) 2020 rtraining authors\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "analysis/using-Rcpp.html",
    "href": "analysis/using-Rcpp.html",
    "title": "Using Rcpp",
    "section": "",
    "text": "Notes on using Rcpp to implement Poker-Hand-Evaluator in the cards package.\n# no libraries",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/using-Rcpp.html#add-headers",
    "href": "analysis/using-Rcpp.html#add-headers",
    "title": "Using Rcpp",
    "section": "Add Headers",
    "text": "Add Headers\nTo start the first implementation, I added the headers from cpp_example.cc:\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n#include &lt;phevaluator/phevaluator.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n\n//' Evaluate a poker hand using PH Evaluator\n//'\n//' Evaluate the rank category of a five card poker hand using\n//'   [PH Evaluator](https://github.com/HenryRLee/PokerHandEvaluator).\n//'\n//' Implemented following\n//'   [`cpp_example.cc`](https://github.com/HenryRLee/PokerHandEvaluator/blob/master/cpp/examples/cpp_example.cc)\n//'   and [RcppAnnoy](https://github.com/eddelbuettel/rcppannoy).\n//'\n//' Currently implemented as a stub function that always returns \"poker_hand\".\n//'\n//' @param hand a hand of cards (an integer vector of length 5).\n//' @return string hand rank.\n//' @export\n// [[Rcpp::export]]\nString eval_hand_phe(IntegerVector hand) {\n  // phevaluator::Rank rank = phevaluator::EvaluateCards(hand[0], hand[1], hand[2], hand[3], hand[4]);\n  // return rank.describeCategory();\n  return \"poker_hand\";\n}\nTo get the updated code to compile, I had to add src/Makevars, which I copied from RcppAnnoy, and also added the cpp/include directory from PH Evaluator to inst/.\nsrc/Makevars:\nPKG_CPPFLAGS = -I../inst/include/\nWhile this code compiled, to get the commented code working, I’d need to add the code from cpp/src. Just dumping the files from PH Evaluator into src/ didn’t work, but the rxylib Makevars file offered a clue: adapt the Makefile from PH Evaluator to the R Makevars format to properly build the library objects. Put another way, follow how rxylib translated xlib/Makefile.am to Makevars. The Stack Overflow question referenced in rxylib provided additional details on the Makevars file format.",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/using-Rcpp.html#follow-up",
    "href": "analysis/using-Rcpp.html#follow-up",
    "title": "Using Rcpp",
    "section": "Follow-up",
    "text": "Follow-up\nI did some additional research, and there doesn’t seem to be a simple way to change R to compile using filename.cc.o instead of filename.o, as it goes against the intent of the R developers, as described in this Stack Overflow article:\n\nThe clear recommendation on r-devel (please check the archives) is that you should avoid Makefile logic if you can. IIRC this echoed in the Writing R Extension manual.\n\nSo, it seems the right answer is to rename the files to avoid this conflict. Additionally, after reading a tidyverse blog post on New CRAN requirements for packages with C and C++, I learned that the R C++ standard was now C++17, so I technically did not need that line in the Makevars file, but I decided to keep it as it was an upstream requirement.\nI also discovered an example package that explained how to put code in a subdirectory of src/, which I plan to use for the second version using Rcpp Modules.\nI later added a script to copy (or update) the PH Evaluator source and header files to the cards package, to automate future updates if needed.\nAfter reading through the Creating R Packages chapter of Writing R Extensions and evaluating my options, I am inclined to use a simple approach to creating a “phevaluator” package, copying the necessary files into src/ (with a shell script for reproducibility), use a minimal Makevars file, and use Rcpp Modules to expose the C++ classes and methods in PH Evaluator, following the approach used by the RcppStudent R package.",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html",
    "href": "analysis/ggplot2-4.html",
    "title": "ggplot2 (Grammar)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Grammar” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(MASS) # nolint: unused_import_linter. Used for \"rlm\".\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(jbplot)\nlibrary(ggthemes)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises",
    "href": "analysis/ggplot2-4.html#exercises",
    "title": "ggplot2 (Grammar)",
    "section": "13.5 Exercises",
    "text": "13.5 Exercises\n\nOne of the best ways to get a handle on how the grammar works is to apply it to the analysis of existing graphics. For each of the graphics listed below, write down the components of the graphic. Don’t worry if you don’t know what the corresponding functions in ggplot2 are called (or if they even exist!), instead focussing on recording the key elements of a plot so you could communicate it to someone else.\n\nAnswer: use the components from 13.4 to describe each plot: data, aesthetics (aes), stat, geom, scale, coordinate system (coord), and faceting\n\n“Napoleon’s march” by Charles John Minard: link\n\nAnswer: the plot describes Napolean’s 1812 campaign. Larger version at: Wikipedia\n\ndata: the size, location and date of the army’s travel, along with temperature\naes: x, y mapped to location over time, with width representing size\nstat: no transformation\ngeom: line\nscale: scales are used for location and temperature\ncoord: Cartesian / map projection\nfacet: no faceting\n\n\n\n“Where the Heat and the Thunder Hit Their Shots”, by Jeremy White, Joe Ward, and Matthew Ericson at The New York Times. link\n\nAnswer: a plot of basketball shots and points scored.\n\ndata: number of attempts and points scored by location\naes: x, y mapped to location, size mapped to attempts, color to points scored\nstat: no transformation (possibly points per attempt)\ngeom: hex tiles\nscale: continuous scales mapped to location, size (attempts), and color (points)\ncoord: Cartesian, mapped to the court\nfacet: faceting by team and players\n\n\n\n“London Cycle Hire Journeys”, by James Cheshire. link\n\nAnswer: retrieved from archive.org.\n\ndata: travels of London bicycle rentals\naes: x, y mapped to location, density (alpha) mapped to number of trips in a location\nstat: none\ngeom: line\nscale: location\ncoord: Cartesian / map projection\nfacet: none\n\n\n\nThe Pew Research Center’s favorite data visualizations of 2014: link\n\nAnswer: multiple plots, described individually.\nPolitical Shifts\n\ndata: responses to political values questions\naes: height showing volume of responses, between consistently liberal and conservative\nstat: histogram\ngeom: area / frequency polygon, with color showing above / below median of the other party\nscale: continuous\ncoord: Cartesian\nfacet: faceting by party by year\n\nNext America\n\ndata: population by age group and gender\naes: binned data by age and gender\nstat: none\ngeom: bar and color by gender, with boomers a distinct color\nscale: continuous\ncoord: Cartesian\nfacet: faceting by year, animated\n\n“Murder Capitals”\n\ndata: murder rate for six cities, with the highest rate shown for each year, national rate\naes: x is time (year) and y is the murder rate\nstat: none\ngeom: bar, line\nscale: city is additionally mapped to year at the top of the plot, and national rate is shown as a line across the bottom\ncoord: Cartesian\nfacet: none\n\nIdeological Placement of News Sources\n\ndata: scores of responses to political values questions mapped to audiences for news sources\naes: x mapped to score for a news source audience\nstat: none\ngeom: point\nscale: a single (x-axis) continuous scale, with labels for each source\ncoord: Cartesian\nfacet: none\n\nRegional Support for Same-Sex Marriage\n\ndata: percentage of population supporting same-sex marriage by region\naes: x mapped to time (year), y mapped to percent support\nstat: none\ngeom: line\nscale: continuous\ncoord: Cartesian\nfacet: faceting by region, national support is an additional layer\n\n\n\n“The Tony’s Have Never Been so Dominated by Women”, by Joanna Kao at FiveThirtyEight: link.\n\nAnswer: a plot of Tony award winners by category.\n\ndata: Tony award categories by year with at least one female winner\naes: categories along the y axis, years along the x axis, colored red if a female won\nstat: none\ngeom: square points with color showing female winners\nscale: discrete categories and years\ncoord: Cartesian\nfacet: none\n\n\n\n“In Climbing Income Ladder, Location Matters” by the Mike Bostock, Shan Carter, Amanda Cox, Matthew Ericson, Josh Keller, Alicia Parlapiano, Kevin Quealy and Josh Williams at the New York Times: link\n\nAnswer: not visible due to paywall, unable to retrieve the graphic.\n\n\n“Dissecting a Trailer: The Parts of the Film That Make the Cut”, by Shan Carter, Amanda Cox, and Mike Bostock at the New York Times: link\n\nAnswer: multiple plots showing the sequencing of movie trailers.\n\ndata: scenes in a trailer mapped to when they occurred in the full film\naes: x axis showing the timestamp of a trailer scene, y axis and color showing when the scene occurred, including scenes not in the final film\nstat: none\ngeom: square points (with width per scene), connected by lines\nscale: continuous duration (seconds)\ncoord: Cartesian\nfacet: faceting by trailer (all plots are mapped to the same scale)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises-1",
    "href": "analysis/ggplot2-4.html#exercises-1",
    "title": "ggplot2 (Grammar)",
    "section": "14.3.1 Exercises",
    "text": "14.3.1 Exercises\n\nThe first two arguments to ggplot are data and mapping. The first two arguments to all layer functions are mapping and data. Why does the order of the arguments differ? (Hint: think about what you set most commonly.)\n\nAnswer: most plots use common data for all layers, where the aesthetics are more likely to vary.\nGG Solutions:\n\nCommonly, you first set the data in ggplot() and then set aesthetics inside your layer functions, like geom_point(), geom_boxplot(), or geom_histogram().\n\n\n\nThe following code uses dplyr to generate some summary statistics about each class of car.\n\n\nclass &lt;- mpg %&gt;%\n  group_by(class) %&gt;%\n  summarise(n = n(), hwy = mean(hwy))\n\nUse the data to recreate this plot:\nAnswer: with some help from the source code to get the measurements right, here is the solution:\n\nggplot(mpg, aes(class, hwy)) +\n  geom_point() +\n  geom_jitter(width = 0.25) +\n  geom_point(data = class, color = \"red\", size = 5) +\n  geom_text(aes(y = 10, label = paste0(\"n = \", n)), data = class, size = 3)\n\n\n\n\n\n\n\n\nGG Solutions:\n\nmpg %&gt;%\n  ggplot(aes(class, hwy)) +\n  geom_jitter(width = 0.15, height = 0.35) +\n  geom_point(\n    data = class, aes(class, hwy),\n    color = \"red\",\n    size = 6\n  ) +\n  geom_text(data = class, aes(y = 10, x = class, label = paste0(\"n = \", n)))\n\n\n\n\n\n\n\n\n\nI plotted 3 different layers: jittered points, red point for the summary measure, mean, and text for the sample size (n).",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises-2",
    "href": "analysis/ggplot2-4.html#exercises-2",
    "title": "ggplot2 (Grammar)",
    "section": "14.4.3 Exercises",
    "text": "14.4.3 Exercises\n\nSimplify the following plot specifications:\n\n\nggplot(mpg) +\n  geom_point(aes(mpg$displ, mpg$hwy))\n\nggplot() +\n  geom_point(mapping = aes(y = hwy, x = cty), data = mpg) +\n  geom_smooth(data = mpg, mapping = aes(cty, hwy))\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(log(brainwt), log(bodywt)), data = msleep)\n\nAnswer:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"loess\", formula = y ~ x)\n\n\n\n\n\n\n\nggplot(msleep, aes(log(brainwt), log(bodywt))) +\n  geom_point(na.rm = TRUE)\n\n\n\n\n\n\n\n\nGG Solutions offers a similar solution for the first two and a strange solution for the third (since the diamonds data is never used in the third plot):\n\nggplot(mpg) +\n  geom_point(aes(displ, hwy))\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  geom_smooth()\n\nmsleep_processed &lt;- msleep %&gt;%\n  mutate(\n    brainwt_log = log(brainwt),\n    bodywt_log = log(bodywt)\n  )\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(brainwt_log, bodywt_log),\n    data = msleep_processed\n  )\n\nNote: I prefer my answer to GG Solutions.\n\n\nWhat does the following code do? Does it work? Does it make sense? Why/why not?\n\n\nggplot(mpg) +\n  geom_point(aes(class, cty)) +\n  geom_boxplot(aes(trans, hwy))\n\nAnswer: it does work, but does not make sense, and should be done as separate plots so that the variables comparisons are visible:\n\nggplot(mpg, aes(class, cty)) +\n  geom_point() +\n  coord_flip()\n\n\n\n\n\n\n\nggplot(mpg, aes(trans, hwy)) +\n  geom_boxplot() +\n  coord_flip()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nIt plots points of class vs cty and then a boxplot of trans vs hwy. It doesn’t make sense to plot layers with different x and y variables.\n\n\n\nWhat happens if you try to use a continuous variable on the x axis in one layer, and a categorical variable in another layer? What happens if you do it in the opposite order?\n\nAnswer: let’s experiment!\nThis code throws an error, Error: Discrete value supplied to continuous scale\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_point(aes(drv, hwy), color = \"red\")\n\nReversing the order works, but draws a strange plot:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(drv, hwy), color = \"red\") +\n  geom_point()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nNot sure",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises-3",
    "href": "analysis/ggplot2-4.html#exercises-3",
    "title": "ggplot2 (Grammar)",
    "section": "14.5.1 Exercises",
    "text": "14.5.1 Exercises\n\nDownload and print out the ggplot2 cheatsheet from rstudio so you have a handy visual reference for all the geoms.\n\nAnswer: cheatsheets have moved to posit (as the company rebranded).\n\n\nLook at the documentation for the graphical primitive geoms. Which aesthetics do they use? How can you summarise them in a compact form?\n\nAnswer: from 14.5, the primitives are:\n\ngeom_blank(): no aesthetics, “draw nothing”\ngeom_point(): x, y, alpha, color, fill, group, shape, size, stroke, “draw points”\ngeom_path(): x, y, alpha, color, group, linetype, linewidth, “connect observations”\ngeom_ribbon(): x or y, ymin or xmin, ymax or xmax, alpha, color, fill, group, linetype, linewidth, “draw an area along a line”\ngeom_segment(): x, y, xend, yend, alpha, color, group, linetype, linewidth, “connect two points”\ngeom_rect(): x, y, alpha, color, fill, group, height, linetype, linewidth, width, “draw rectangles”\ngeom_polygon(): x, y, alpha, color, fill, group, linetype, linewidth, subgroup, “draw polygons”\ngeom_text(): x, y, label, alpha, angle, color, family, fontface, group, hjust, lineheight, size, vjust, “draw text”\n\n\n\nWhat’s the best way to master an unfamiliar geom? List three resources to help you get started.\n\nAnswer:\n\nR Documentation for ggplot2, either built-in or online\nPosit cheatsheets\nThe R Graph Gallery\n\n\n\nFor each of the plots below, identify the geom used to draw it.\n\nAnswer: in the order they appear in the Exercises:\n\ngeom_violin\ngeom_point (actually uses geom_count)\ngeom_hex\ngeom_point (actually uses geom_jitter)\ngeom_area\ngeom_path\n\nNote: verifying my answers against the source code, I got two wrong, although the underlying geom is geom_point.\nGG Solutions:\nStarting from top left, clockwise direction:\n\ngeom_violin(), geom_point(), geom_point(), geom_path(), geom_area(), geom_hex().\n\nNote: GG Solutions makes the same mistakes I did.\n\n\nFor each of the following problems, suggest a useful geom:\n\nDisplay how a variable has changed over time.\nShow the detailed distribution of a single variable.\nFocus attention on the overall trend in a large dataset.\nDraw a map.\nLabel outlying points.\n\n\nAnswers below:\n\nDisplay how a variable has changed over time: geom_line, with time on the x axis, or geom_path to show changes in two dimensions over time.\nShow the detailed distribution of a single variable: one of the distribution plots, geom_histogram and geom_dotplot are good choices.\nFocus attention on the overall trend in a large dataset: geom_smooth.\nDraw a map: geom_map or its successor, geom_sf.\nLabel outlying points: geom_text or geom_label.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises-4",
    "href": "analysis/ggplot2-4.html#exercises-4",
    "title": "ggplot2 (Grammar)",
    "section": "14.6.2 Exercises",
    "text": "14.6.2 Exercises\n\nThe code below creates a similar dataset to stat_smooth(). Use the appropriate geoms to mimic the default geom_smooth() display.\n\n\nmod &lt;- loess(hwy ~ displ, data = mpg)\nsmoothed &lt;- data.frame(displ = seq(1.6, 7, length.out = 50))\npred &lt;- predict(mod, newdata = smoothed, se = TRUE)\nsmoothed$hwy &lt;- pred$fit\nsmoothed$hwy_lwr &lt;- pred$fit - 1.96 * pred$se.fit\nsmoothed$hwy_upr &lt;- pred$fit + 1.96 * pred$se.fit\n\nAnswer: the exercise is to replicate geom_smooth using the smoothed data frame, which includes a line and a ribbon:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"loess\", formula = y ~ x)\n\n\n\n\n\n\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_line(data = smoothed, color = \"blue\", linewidth = 1) +\n  geom_ribbon(mapping = aes(ymin = hwy_lwr, ymax = hwy_upr), data = smoothed, alpha = 0.2)\n\n\n\n\n\n\n\n\nA perfect match!\nGG Solutions:\n\nsmoothed %&gt;%\n  ggplot(aes(displ, hwy)) +\n  geom_line(color = \"dodgerblue1\") +\n  geom_ribbon(aes(ymin = hwy_lwr, ymax = hwy_upr), alpha = 0.4)\n\n\n\n\n\n\n\n\n\n\nWhat stats were used to create the following plots?\n\nAnswer: in the order they appear in the Exercises:\n\nstat_ecdf\nstat_qq\nstat_density\n\nConfirmed correct by reviewing the source code.\nGG Solutions: From left to right,\nstat_ecdf(), stat_qq(), stat_function()\n\n\nRead the help for stat_sum() then use geom_count() to create a plot that shows the proportion of cars that have each combination of drv and trans.\n\nAnswer: in addition, facet by year.\n\nggplot(mpg, aes(drv, trans)) +\n  geom_count(aes(size = after_stat(prop), group = 1)) +\n  scale_size(labels = scales::label_percent()) +\n  facet_wrap(vars(year)) +\n  labs(title = \"Combinations of drive train and transmissions\", x = NULL, y = NULL) +\n  labs(size = \"% of cars\") +\n  theme_quo()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nmpg %&gt;%\n  ggplot(aes(drv, trans)) +\n  geom_count(aes(size = after_stat(prop), group = 1))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises-5",
    "href": "analysis/ggplot2-4.html#exercises-5",
    "title": "ggplot2 (Grammar)",
    "section": "14.7.1 Exercises",
    "text": "14.7.1 Exercises\n\nWhen might you use position_nudge()? Read the documentation.\n\nAnswer: as the documentation states, “Nudging is built in to geom_text() because it’s so useful for moving labels a small distance from what they’re labelling.”\nGG Solutions: According to the help page, position_nudge() is generally useful for adjusting the position of items on discrete scales by a small amount. Nudging is built in to geom_text() because it’s so useful for moving labels a small distance from what they’re labelling.\n\n\nMany position adjustments can only be used with a few geoms. For example, you can’t stack boxplots or errors bars. Why not? What properties must a geom possess in order to be stackable? What properties must it possess to be dodgeable?\n\nAnswer: reading the docs, position_stack() requires that geoms have a position (points, lines, text) or a dimension (bar, area). Boxplots and error bars can’t be stacked since they don’t have a position or area. A geom must have a width in order to be dodgeable, which can be set with position_dodge(width = ...).\nGG Solutions: Not sure\n\n\nWhy might you use geom_jitter() instead of geom_count()? What are the advantages and disadvantages of each technique?\n\nAnswer: geom_jitter() preserves the size and number of points but not position, and geom_count() preserves the position but not number or size. geom_jitter() can be a better choice when there are few overlapping points.\nGG Solutions: geom_jitter() adds a small amount of random variation to the location of each point. It is useful for looking at all the overplotted points. On the other hand, geom_count() counts the number of overlapping observations at each location. It is useful for understanding the number of points in a location.\n\n\nWhen might you use a stacked area plot? What are the advantages and disadvantages compared to a line plot?\n\nAnswer: a stacked area plot is a good way to show the relationship of related variables, showing how parts of a whole change over time, for example, plotting the phases of incident response (mean time to detect, mean time to resolve). It is very similar to a line plot, and makes relative values (proportions) easier to compare and absolute values harder to compare.\nGG Solutions: Stacked area plot seems useful when you want to portray an area whereas a line plot seems useful when you just need a line.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#setting-color-with-limits",
    "href": "analysis/ggplot2-4.html#setting-color-with-limits",
    "title": "ggplot2 (Grammar)",
    "section": "Setting color with limits",
    "text": "Setting color with limits\nLet’s create a pair of plots controlling color with limits (from 11.3.5)! First, we’ll just plot both independently:\n\ngg_99 &lt;- mpg |&gt;\n  filter(year == 1999) |&gt;\n  ggplot(aes(displ, hwy, color = fl)) +\n  geom_point()\n\ngg_08 &lt;- mpg |&gt;\n  filter(year == 2008) |&gt;\n  ggplot(aes(displ, hwy, color = fl)) +\n  geom_point()\n\ngg_99\n\n\n\n\n\n\n\ngg_08\n\n\n\n\n\n\n\n\nNow, let’s replot using limits:\n\ngg_99 +\n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    breaks = c(\"d\", \"p\", \"r\"),\n    labels = c(\"diesel\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\ngg_08 +\n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    labels = c(\"compressed\", \"diesel\", \"ethanol\", \"premium\", \"regular\")\n  )",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#key-glyphs",
    "href": "analysis/ggplot2-4.html#key-glyphs",
    "title": "ggplot2 (Grammar)",
    "section": "Key glyphs",
    "text": "Key glyphs\nLet’s use a key glyph! (draw_key_timeseries())\n\nggplot(economics, aes(date, psavert, color = \"Personal\\nSavings\\nRate\")) +\n  geom_line(key_glyph = \"timeseries\") +\n  labs(x = NULL, y = NULL, color = NULL) +\n  theme_quo()",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#polar-coordinates",
    "href": "analysis/ggplot2-4.html#polar-coordinates",
    "title": "ggplot2 (Grammar)",
    "section": "Polar coordinates",
    "text": "Polar coordinates\nLet’s draw a spiral with polar coordinates!\n\ndata.frame(x = c(1, 200), y = c(200, 1)) |&gt;\n  ggplot(aes(x, y)) +\n  geom_line() +\n  coord_polar()\n\n\n\n\n\n\n\n\nWe can use polar coordinates to draw a pie chart:\n\nggplot(mtcars, aes(factor(1), fill = factor(cyl))) +\n  geom_bar(width = 1) +\n  scale_x_discrete(NULL, expand = c(0, 0)) +\n  scale_y_continuous(NULL, expand = c(0, 0)) +\n  coord_polar(theta = \"y\") +\n  labs(title = \"Number of cylinders\", fill = NULL) +\n  theme_void()",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#facet-grid",
    "href": "analysis/ggplot2-4.html#facet-grid",
    "title": "ggplot2 (Grammar)",
    "section": "Facet grid",
    "text": "Facet grid\nLet’s draw a facet grid!\n\nmpg |&gt;\n  filter(cyl != 5) |&gt;\n  ggplot(aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"rlm\", formula = y ~ x) +\n  facet_grid(drv ~ cyl) +\n  labs(x = NULL, y = NULL)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#free-scales",
    "href": "analysis/ggplot2-4.html#free-scales",
    "title": "ggplot2 (Grammar)",
    "section": "Free scales",
    "text": "Free scales\nFree scales are useful when faceting across different variables over the same time period:\n\nggplot(economics_long, aes(date, value)) +\n  geom_line() +\n  facet_wrap(~variable, scales = \"free_y\", ncol = 1)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#facet-space",
    "href": "analysis/ggplot2-4.html#facet-space",
    "title": "ggplot2 (Grammar)",
    "section": "Facet space",
    "text": "Facet space\nfacet_grid() has an additional parameter called space, which takes the same values as scales. When space is “free”, each column (or row) will have width (or height) proportional to the range of the scale for that column (or row). This makes the scaling equal across the whole plot: 1 cm on each panel maps to the same range of data. (This is somewhat analogous to the ‘sliced’ axis limits of lattice.) For example, if panel a had range 2 and panel b had range 4, one-third of the space would be given to a, and two-thirds to b. This is most useful for categorical scales, where we can assign space proportionally based on the number of levels in each facet, as illustrated below.\n\nmpg2 &lt;- subset(mpg, cyl != 5 & drv %in% c(\"4\", \"f\") & class != \"2seater\")\nmpg2$model &lt;- reorder(mpg2$model, mpg2$cty)\nmpg2$manufacturer &lt;- reorder(mpg2$manufacturer, -mpg2$cty)\n\nggplot(mpg2, aes(cty, model)) +\n  geom_point() +\n  facet_grid(manufacturer ~ ., scales = \"free\", space = \"free\") +\n  labs(x = NULL, y = NULL) +\n  theme(strip.text.y = element_text(angle = 0))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#grouping-and-faceting",
    "href": "analysis/ggplot2-4.html#grouping-and-faceting",
    "title": "ggplot2 (Grammar)",
    "section": "Grouping and faceting",
    "text": "Grouping and faceting\nLet’s combine grouping and faceting!\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(data = select(mpg, -drv), color = \"grey75\") +\n  geom_point(aes(color = drv)) +\n  facet_wrap(~drv)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises-6",
    "href": "analysis/ggplot2-4.html#exercises-6",
    "title": "ggplot2 (Grammar)",
    "section": "17.7 Exercises",
    "text": "17.7 Exercises\n\nDiamonds: display the distribution of price conditional on cut and carat. Try faceting by cut and grouping by carat. Try faceting by carat and grouping by cut. Which do you prefer?\n\nAnswer: faceting by caret requires discretizing, here we use cut_number():\n\nggplot(diamonds, aes(price, group = carat, color = carat)) +\n  geom_histogram(bins = 100) +\n  scale_color_viridis_c() +\n  facet_wrap(~cut)\n\n\n\n\n\n\n\ndiamonds |&gt;\n  mutate(carat_n = cut_number(carat, 6)) |&gt;\n  ggplot(aes(price, group = cut, fill = cut)) +\n  geom_histogram(bins = 100) +\n  scale_color_viridis_d() +\n  facet_wrap(~carat_n)\n\n\n\n\n\n\n\n\nFaceting by cut seems preferable, since it provides an insight not provided by faceting by carat: there are more large carat diamonds with a Fair cut.\nGG Solutions: takes a different approach, and concludes: “It makes more sense to facet by cut because its a discrete variable. Faceting by carat, a continuous variable, makes too many facets and renders the plot unreadable!”\n\n\nDiamonds: compare the relationship between price and carat for each colour. What makes it hard to compare the groups? Is grouping better or faceting? If you use faceting, what annotation might you add to make it easier to see the differences between panels?\n\nAnswer: comparing is hard because of overlap between groups and overplotting. Overall, grouping seems easier to read than faceting. Adding a reference line (in this case, a robust linear regression) makes it easier to see differences across faceting panels.\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(color = color)) +\n  geom_smooth(method = \"rlm\", formula = y ~ x, se = FALSE) +\n  coord_cartesian(ylim = c(0, max(diamonds$price)))\n\n\n\n\n\n\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(color = color)) +\n  geom_smooth(data = select(diamonds, -color), method = \"rlm\", formula = y ~ x, se = FALSE) +\n  coord_cartesian(ylim = c(0, max(diamonds$price))) +\n  facet_wrap(~color)\n\n\n\n\n\n\n\n\nGG Solutions:\n\ndiamonds %&gt;%\n  ggplot(aes(carat, price)) +\n  geom_point(aes(color = color))\n\n\n\n\n\n\n\ndiamonds %&gt;%\n  ggplot(aes(carat, price)) +\n  geom_point(aes(color = color)) +\n  facet_wrap(~color)\n\n\n\n\n\n\n\n\n\nI think its better to use grouping to compare the different colors. The panels all have the same shape, so it’s hard to compare the groups across facets. If I use faceting, I’d add that the plot is facetted by diamond colour, from D (best) to J (worst).\n\n\n\nWhy is facet_wrap() generally more useful than facet_grid()?\n\nAnswer: when faceting by a single variable, facet_wrap() is easier to use as it wraps the facets to fit the plot space automatically. facet_grid() is generally more useful only when faceting with two variables.\nGG Solutions: I think facet_wrap() is more useful than facet_grid() because the former function is useful if you have a single variable with many levels and want to arrange the plots in a more space efficient manner. In data analysis, its extremely common to have a single variable with many levels that the analyst wants to arrange the for easy comparison. Although facet_grid() works on single variables, facet_wrap() involves less typing when you have a single variable.\n\n\nRecreate the following plot. It facets mpg2 by class, overlaying a smooth curve fit to the full dataset.\n\nAnswer: plot below.\n\nggplot(mpg2, aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(data = select(mpg2, -class), method = \"loess\", formula = y ~ x, se = FALSE) +\n  facet_wrap(~class)\n\n\n\n\n\n\n\n\nComparing to the source code, the answer is correct!\nGG Solutions:\n\nmpg2 %&gt;%\n  ggplot(aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(data = mpg2 %&gt;% select(-class), se = FALSE, method = \"loess\") +\n  facet_wrap(~class)\n\n#&gt; `geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises-7",
    "href": "analysis/ggplot2-4.html#exercises-7",
    "title": "ggplot2 (Grammar)",
    "section": "18.2.1 Exercises",
    "text": "18.2.1 Exercises\n\nTry out all the themes in ggthemes. Which do you like the best?\n\nAnswer: the “interesting” themes are displayed below. From the top four, I’d pick theme_solarized_2(), although theme_fivethirtyeight() is a close runner-up.\n\nbase &lt;- ggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = factor(cyl))) +\n  geom_smooth(method = \"loess\", formula = y ~ x) +\n  labs(\n    title = \"Fuel economy declines as engine size increases\",\n    subtitle = \"1999-2008\",\n    caption = \"Data from https://fueleconomy.gov/\",\n    x = \"Displacement (liters)\",\n    y = \"Miles per gallon (highway)\",\n    color = \"Cylinders\"\n  )\n\nbase\n\n\n\n\n\n\n\nbase + theme_calc()\n\n\n\n\n\n\n\nbase + theme_fivethirtyeight()\n\n\n\n\n\n\n\nbase + theme_hc()\n\n\n\n\n\n\n\nbase + theme_solarized_2()\n\n\n\n\n\n\n\n\n\n\nWhat aspects of the default theme do you like? What don’t you like?\nWhat would you change?\n\nAnswer: my personal theme, theme_quo() uses a white background with light gray gridlines (based on theme_minimal()), bold titles, captions left-adjusted, and a better font, Lato.\n\nbase +\n  theme_quo()\n\n\n\n\n\n\n\n\n\n\nLook at the plots in your favourite scientific journal. What theme do they most resemble? What are the main differences?\n\nAnswer: the plots from this paper on Safety Science most closely resemble theme_classic(), with few differences, the most notable being the position of the legend in Figures 4, 5, 8, and 9.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#exercises-8",
    "href": "analysis/ggplot2-4.html#exercises-8",
    "title": "ggplot2 (Grammar)",
    "section": "18.4.6 Exercises",
    "text": "18.4.6 Exercises\n\nCreate the ugliest plot possible! (Contributed by Andrew D. Steen, University of Tennessee - Knoxville)\n\nAnswer: using the same base, alter colors and theme settings, must still be legible:\n\nbase +\n  geom_smooth(method = \"loess\", formula = y ~ x, color = \"orange\", fill = \"limegreen\") +\n  theme_grey(base_family = \"Comic Sans MS\") +\n  theme(\n    plot.background = element_rect(fill = \"skyblue\", color = \"purple\"),\n    plot.title = element_text(face = \"bold\", hjust = 1, color = \"red\"),\n    plot.subtitle = element_text(color = \"yellow\"),\n    plot.caption = element_text(hjust = 0.5, color = \"blue\"),\n    plot.margin = margin(50, 50, 50, 50),\n    axis.line = element_line(color = \"maroon\", linetype = \"dotdash\"),\n    axis.text = element_text(color = \"hotpink\"),\n    axis.title = element_text(color = \"green\"),\n    legend.background = element_rect(fill = \"lemonchiffon\", color = \"gray50\"),\n    legend.key = element_rect(fill = \"pink\", color = \"black\"),\n    legend.text = element_text(color = \"purple\"),\n    legend.title = element_text(color = \"deeppink\"),\n    panel.background = element_rect(fill = \"lavender\"),\n    panel.grid = element_line(linetype = \"twodash\")\n  ) +\n  scale_color_excel()\n\n\n\n\n\n\n\n\n\n\ntheme_dark() makes the inside of the plot dark, but not the outside. Change the plot background to black, and then update the text settings so you can still read the labels.\n\nAnswer:\n\nbase +\n  theme_dark() +\n  theme(\n    plot.background = element_rect(fill = \"black\"),\n    legend.background = element_rect(fill = \"black\"),\n    text = element_text(color = \"gray50\")\n  )\n\n\n\n\n\n\n\n\n\n\nMake an elegant theme that uses “linen” as the background colour and a serif font for the text.\n\nAnswer:\n\nbase +\n  theme_minimal(base_family = \"Georgia\") +\n  theme(\n    plot.background = element_rect(fill = \"linen\"),\n    panel.grid.major = element_line(color = \"gray85\"),\n    panel.grid.minor = element_line(color = \"gray90\")\n  )\n\n\n\n\n\n\n\n\n\n\nSystematically explore the effects of hjust when you have a multiline title. Why doesn’t vjust do anything?\n\nAnswer: with multiline titles, hjust affects both lines in the same way, between left justified (0), centered (0.5), and right justified (1). vjust does slightly alter the vertical justification, but not significantly since two lines are just within the vertical margins.\n\nmulti &lt;- base +\n  labs(title = \"Fuel economy declines as engine size increases\\n1999-2008\", subtitle = NULL)\n\nmulti + theme(plot.title = element_text(hjust = 0))\n\n\n\n\n\n\n\nmulti + theme(plot.title = element_text(hjust = 0.25))\n\n\n\n\n\n\n\nmulti + theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\nmulti + theme(plot.title = element_text(hjust = 1))\n\n\n\n\n\n\n\nmulti + theme(plot.title = element_text(hjust = 1, vjust = 0))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html",
    "href": "analysis/ggplot2-2.html",
    "title": "ggplot2 (Layers)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Layers” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(babynames)\nlibrary(jbplot)\nlibrary(modelr)\nlibrary(maps) # nolint: unused_import_linter. maps is required by map_data().\nlibrary(sf)\nlibrary(USAboundaries)\nlibrary(USAboundariesData) # nolint: unused_import_linter. Needed by USAboundaries.\nlibrary(ggraph)\nlibrary(tidygraph)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#exercises",
    "href": "analysis/ggplot2-2.html#exercises",
    "title": "ggplot2 (Layers)",
    "section": "3.1.1 Exercises",
    "text": "3.1.1 Exercises\n\nWhat geoms would you use to draw each of the following named plots?\n\nScatterplot\nLine chart\nHistogram\nBar chart\nPie chart\n\n\nAnswer:\n\nScatterplot: geom_point()\nLine chart: geom_line()\nHistogram: geom_histogram()\nBar chart: geom_bar()\nPie chart: there is no native geom for a pie chart, but, as the R Graph Gallery demonstrates, it is possible to create a pie chart using geom_bar() and coord_polar()\n\nGG Solutions:\n\nScatterplot: geom_point()\nLine chart: geom_line()\nHistogram: geom_histogram()\nBar chart: geom_bar()\nPie chart: ggplot2 does not have a geom to draw pie charts. One workaround, according to the R Graph Gallery is to build a stacked bar chart with one bar only using the geom_bar() function and then make it circular with coord_polar()\n\n\n\nWhat’s the difference between geom_path() and geom_polygon()? What’s the difference between geom_path() and geom_line()?\n\nAnswer: geom_path() connects observations with a line in the order they appear in the data, geom_line() connects them in order along the x axis, and geom_polygon() connects the start and end points of geom_path() and fills in the plot.\nGG Solutions:\n\ngeom_polygon draws the same graph (lines) as geom_path, but it fills these lines with color\ngeom_line() connects points from left to right, whereas geom_path() connects points in the order they appear in the data\n\n\n\nWhat low-level geoms are used to draw geom_smooth()? What about geom_boxplot() and geom_violin()?\n\nAnswer: reviewing the source code:\ngeom_smooth() uses:\n\ngeom_path() by way of geom_line()\ngeom_area() by way of geom_ribbon()\n\ngeom_boxplot() uses:\n\ngeom_point()\ngeom_path() by way of geom_segment() and geom_crossbar()\ngeom_polygon() by way of geom_crossbar()\n\ngeom_violin() uses:\n\ngeom_path()\ngeom_polygon()\n\nGG Solutions:\n(kangnade)\n\ngeom_point(), geom_path(), and geom_area() are used to draw geom_smooth()\ngeom_rect(), geom_line(), geom_point() are used for geom_boxplot()\ngeom_area() and geom_path() are used for geom_violin()\n\nNote: GG Solutions answers appear to be incorrect guesses.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#exercises-1",
    "href": "analysis/ggplot2-2.html#exercises-1",
    "title": "ggplot2 (Layers)",
    "section": "4.5 Exercises",
    "text": "4.5 Exercises\nGG Solutions offers no answers for this section.\n\nDraw a boxplot of hwy for each value of cyl, without turning cyl into a factor. What extra aesthetic do you need to set?\n\nAnswer: the group aesthetic is required.\n\nggplot(mpg, aes(cyl, hwy, group = cyl)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\nModify the following plot so that you get one boxplot per integer value of displ.\n\n\nggplot(mpg, aes(displ, cty)) +\n  geom_boxplot()\n\nAnswer: grouping by the floor of displacement works, but is arranged strangely. Mutating displacement first is a better solution:\n\nggplot(mpg, aes(displ, cty, group = floor(displ))) +\n  geom_boxplot()\n\n\n\n\n\n\n\nmpg |&gt;\n  mutate(displ = floor(displ)) |&gt;\n  ggplot(aes(displ, cty, group = displ)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\nWhen illustrating the difference between mapping continuous and discrete colours to a line, the discrete example needed aes(group = 1). Why? What happens if that is omitted? What’s the difference between aes(group = 1) and aes(group = 2)? Why?\n\nAnswer: using the example from the book, omitting the group aesthetic generates an error:\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\nThere is no difference between aes(group = 1) and aes(group = 2), presumably because both methods put all observations into a single group.\n\ndf &lt;- data.frame(x = 1:3, y = 1:3, colour = c(1, 3, 5))\n\nggplot(df, aes(x, y, colour = factor(colour))) +\n  geom_line(aes(group = 1), linewidth = 2) +\n  geom_point(size = 5)\n\n\n\n\n\n\n\nggplot(df, aes(x, y, colour = factor(colour))) +\n  geom_line(aes(group = 2), linewidth = 2) +\n  geom_point(size = 5)\n\n\n\n\n\n\n\n\n\n\nHow many bars are in each of the following plots? (Hint: try adding an outline around each bar with colour = \"white\")\n\n\nggplot(mpg, aes(drv)) +\n  geom_bar()\nggplot(mpg, aes(drv, fill = hwy, group = hwy)) +\n  geom_bar()\n\nmpg2 &lt;- mpg %&gt;%\n  arrange(hwy) %&gt;%\n  mutate(id = seq_along(hwy))\nggplot(mpg2, aes(drv, fill = hwy, group = id)) +\n  geom_bar()\n\nAnswer: in the first plot, there are three bars. In the second, there is one bar for each unique value for hwy in each column. In the third, there is one bar for each observation of hwy.\n\nggplot(mpg, aes(drv)) +\n  geom_bar(color = \"white\")\n\n\n\n\n\n\n\nggplot(mpg, aes(drv, fill = hwy, group = hwy)) +\n  geom_bar(color = \"white\")\n\n\n\n\n\n\n\nmpg |&gt;\n  arrange(hwy) |&gt;\n  mutate(id = seq_along(hwy)) |&gt;\n  ggplot(aes(drv, fill = hwy, group = id)) +\n  geom_bar(color = \"white\")\n\n\n\n\n\n\n\n\n\n\nInstall the babynames package. It contains data about the popularity of babynames in the US. Run the following code and fix the resulting graph. Why does this graph make me unhappy?\n\n\nhadley &lt;- filter(babynames, name == \"Hadley\")\nggplot(hadley, aes(year, n)) +\n  geom_line()\n\nAnswer: the popularity of “Hadley” is sadly declining.\n\nbabynames |&gt;\n  filter(name == \"Hadley\") |&gt;\n  ggplot(aes(year, n, group = sex, color = sex)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\nBonus: a comparison of the popularity of my name (John) and Hadley:\n\nbabynames |&gt;\n  filter(name %in% c(\"Hadley\", \"John\")) |&gt;\n  ggplot(aes(year, prop, color = interaction(name, sex, sep = \", \", lex.order = TRUE))) +\n  geom_line() +\n  scale_y_log10() +\n  scale_color_viridis_d() +\n  labs(x = \"\", y = \"\", color = \"Name, Sex\") +\n  labs(title = \"Relative popularity of the names Hadley and John\") +\n  theme_quo()\n\n\n\n\n\n\n\n\nNote: group is redundant for geom_line() when using color.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#exercises-2",
    "href": "analysis/ggplot2-2.html#exercises-2",
    "title": "ggplot2 (Layers)",
    "section": "5.4.1 Exercises",
    "text": "5.4.1 Exercises\n\nWhat binwidth tells you the most interesting story about the distribution of carat?\n\nAnswer: as answered in 2.6.6 Exercises:\nAnswer: using trial and error, binwidth = 0.01 reveals that carat weight is skewed towards round numbers (1, 1.25, 1.5, 2, etc.). Using the smaller binwidth = 0.005 doesn’t improve the pattern, and makes it harder to see.\n\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.01)\n\n\n\n\n\n\n\n\nGG Solutions:\n\nHighly subjective answer, but I would go with 0.2 since it gives you the right amount of information about the distribution of carat: right-skewed.\n\n\n\nDraw a histogram of price. What interesting patterns do you see?\n\nAnswer: price has a multi-modal distribution with a gap. Looking at the underlying data, there are no prices between $1454 and $1546\n\nggplot(diamonds, aes(price)) +\n  geom_histogram(binwidth = 50)\n\n\n\n\n\n\n\ndiamonds |&gt;\n  filter(price &gt;= 1454, price &lt;= 1546)\n\n#&gt; # A tibble: 24 × 10\n#&gt;    carat cut       color clarity depth table price     x     y     z\n#&gt;    &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  0.5  Very Good D     SI1      61.6    56  1454  5.09  5.11  3.14\n#&gt;  2  0.52 Ideal     I     VVS1     60.1    56  1454  5.24  5.27  3.16\n#&gt;  3  0.54 Ideal     H     VS1      61.2    55  1454  5.25  5.31  3.23\n#&gt;  4  0.51 Premium   G     VS2      61.2    60  1546  5.17  5.12  3.15\n#&gt;  5  0.51 Ideal     G     VS2      62.9    54  1546  5.12  5.08  3.21\n#&gt;  6  0.51 Premium   G     VS2      62.4    57  1546  5.11  5.09  3.18\n#&gt;  7  0.51 Premium   G     VS2      62.7    58  1546  5.12  5.09  3.2 \n#&gt;  8  0.51 Premium   G     VS2      62.2    57  1546  5.15  5.1   3.19\n#&gt;  9  0.51 Ideal     G     VS2      62.7    57  1546  5.12  5.05  3.19\n#&gt; 10  0.51 Premium   G     VS2      62.9    58  1546  5.11  5.06  3.2 \n#&gt; # ℹ 14 more rows\n\n\nGG Solutions:\n\nIt’s skewed to the right and has a long tail. Also, there is a small peak around 5000 and a huge peak around 0.\n\n\n\nHow does the distribution of price vary with clarity?\n\nAnswer: a boxplot of price by clarity shows that diamonds with better clarity aren’t necessarily more expensive.\nHowever, as noted in my R Training Log and as answered in 2.6.6 Exercises:\n\n7.6 Patterns and models covers models and residuals, here showing how to reveal the expected relationship between cut and price:\n\nWe can remove the relationship between carats and price, and redo the boxplot, which shows the expected relationship:\n\nggplot(diamonds, aes(clarity, price)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n# remove carat weight as a confounding variable\ndiamonds |&gt;\n  add_residuals(lm(log(price) ~ log(carat), data = diamonds)) |&gt;\n  mutate(resid = exp(resid)) |&gt;\n  ggplot(aes(clarity, resid)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThe range of prices is similar across clarity and the median and IQR vary greatly with clarity.\n\n\n\nOverlay a frequency polygon and density plot of depth. What computed variable do you need to map to y to make the two plots comparable? (You can either modify geom_freqpoly() or geom_density().)\n\nAnswer: you need to either divide or multiply y by the total number of observations, nrow(diamonds) using after_stat().\n\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(aes(y = after_stat(count) / nrow(diamonds)), binwidth = 1) +\n  geom_density() +\n  labs(y = \"\")\n\n\n\n\n\n\n\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(binwidth = 1) +\n  geom_density(aes(y = after_stat(density) * nrow(diamonds))) +\n  labs(y = \"\")\n\n\n\n\n\n\n\n\nNotes: from the documentation for after_stat():\n\nMost aesthetics are mapped from variables found in the data. Sometimes, however, you want to delay the mapping until later in the rendering process. ggplot2 has three stages of the data that you can map aesthetics from. The default is to map at the beginning, using the layer data provided by the user. The second stage is after the data has been transformed by the layer stat. The third and last stage is after the data has been transformed and mapped by the plot scales. The most common example of mapping from stat transformed data is the height of bars in geom_histogram(): the height does not come from a variable in the underlying data, but is instead mapped to the count computed by stat_bin(). An example of mapping from scaled data could be to use a desaturated version of the stroke colour for fill. If you want to map directly from the layer data you should not do anything special. In order to map from stat transformed data you should use the after_stat() function to flag that evaluation of the aesthetic mapping should be postponed until after stat transformation. Similarly, you should use after_scale() to flag evaluation of mapping for after data has been scaled. If you want to map the same aesthetic multiple times, e.g. map x to a data column for the stat, but remap it for the geom, you can use the stage() function to collect multiple mappings.\n\nGG Solutions answer not included here.\nNote: after reading the Generated Variables section, there is an easier solution:\n\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(aes(y = after_stat(density)), binwidth = 1) +\n  geom_density() +\n  labs(y = \"\")\n\n\n\n\n\n\n\n\n\nBonus: overlay a PDF and ECDF on a histogram.\n\nggplot(diamonds, aes(price)) +\n  geom_histogram(aes(y = after_stat(ncount)), binwidth = 50, fill = \"gray\") +\n  stat_ecdf() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n\n\n\n\n\n\n\nggplot(diamonds, aes(price)) +\n  geom_histogram(binwidth = 50, fill = \"gray\") +\n  # nolint next: line_length_linter.\n  # see https://stackoverflow.com/questions/27611438/density-curve-overlay-on-histogram-where-vertical-axis-is-frequency-aka-count\n  geom_density(aes(y = after_stat(density * nrow(diamonds) * 50))) +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n\n\n\n\n\n\n\nggplot(diamonds, aes(price)) +\n  geom_histogram(aes(y = after_stat(ncount)), binwidth = 50, fill = \"gray\") +\n  # TODO: the factor of 0.62 was determined by trial and error, find underlying formula\n  #       the maximum density / the maximum count of the previous plot = 930.57 / 1503 = 0.62\n  #       but that doesn't work here\n  geom_density(aes(y = after_stat(ndensity * 0.62))) +\n  stat_ecdf() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#bonus",
    "href": "analysis/ggplot2-2.html#bonus",
    "title": "ggplot2 (Layers)",
    "section": "Bonus",
    "text": "Bonus\nThere are no exercises, so let’s draw a map of Minnesota using polygon maps!\n\nmap_data(\"county\", \"minnesota\") |&gt;\n  select(lon = long, lat, group) |&gt;\n  ggplot(aes(lon, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"grey50\") +\n  coord_quickmap() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n\n\n\n\n\n\n\n\nPolygon maps are superseded by simple features maps, so let’s draw it again, adding Minneapolis, in red:\n\nus_counties(resolution = \"high\", states = \"MN\") |&gt;\n  ggplot() +\n  geom_sf(fill = \"white\") +\n  geom_sf(data = filter(us_cities(states = \"MN\"), city == \"Minneapolis\"), color = \"red\") +\n  coord_sf() +\n  theme_quo()\n\n\n\n\n\n\n\n\nSide note: although it creates files in /usr/local, which causes Homebrew to complain, rig, The R Installation Manager, supports multiple versions of R, and supports installation of binary packages, which is substantially faster and requires fewer local dependencies.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#notes",
    "href": "analysis/ggplot2-2.html#notes",
    "title": "ggplot2 (Layers)",
    "section": "Notes",
    "text": "Notes\nWhile ggplot2 has limited support for maps, it has no direct support for networks and graphs. ggraph offers some interesting visualizations that are useful for understanding social networks, especially this one, which shows how friendships among high school boys changed from 1957 to 1958:\n\nhighschool |&gt;\n  as_tbl_graph(directed = FALSE) |&gt;\n  ggraph(layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point() +\n  facet_edges(~year)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#notes-1",
    "href": "analysis/ggplot2-2.html#notes-1",
    "title": "ggplot2 (Layers)",
    "section": "Notes",
    "text": "Notes\nAn important distinction on axis labels:\n\nThere are two ways to remove the axis label. Setting labs(x = \"\") omits the label but still allocates space; setting labs(x = NULL) removes the label and its space.\n\nConsider adopting showtext for non-standard fonts, with caveats for using it in R Markdown.\nOne of the most useful alignments is “inward”. It aligns text towards the middle of the plot, which ensures that labels remain within the plot limits:\n\ndf &lt;- data.frame(\n  x = c(1, 1, 2, 2, 1.5),\n  y = c(1, 2, 1, 2, 1.5),\n  text = c(\n    \"bottom-left\", \"top-left\",\n    \"bottom-right\", \"top-right\", \"center\"\n  ), stringsAsFactors = FALSE\n)\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text))\n\n\n\n\n\n\n\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text), vjust = \"inward\", hjust = \"inward\")\n\n\n\n\n\n\n\n\n\nThe font size is controlled by the size aesthetic. Unlike most tools, ggplot2 specifies the size in millimeters (mm), rather than the usual points (pts). The reason for this choice is that it makes it the units for font sizes consistent with how other sizes are specified in ggplot2. (There are 72.27 pts in a inch, so to convert from points to mm, just multiply by 72.27 / 25.4).\n\nLet’s assign blame to unemployment!\n\npresidential &lt;- subset(presidential, start &gt; economics$date[1] & start &lt; max(economics$date))\n\nggplot(economics) +\n  geom_rect(\n    aes(xmin = start, xmax = end, fill = party),\n    ymin = -Inf, ymax = Inf, alpha = 0.25,\n    data = presidential\n  ) +\n  geom_vline(\n    aes(xintercept = as.numeric(start)),\n    data = presidential,\n    colour = \"grey50\", alpha = 0.5\n  ) +\n  geom_text(\n    # themes only affect the non-data components of the plot, see:\n    #   https://github.com/tidyverse/ggplot2/issues/1859\n    aes(x = start, y = 0.0005, label = name, family = \"Lato\"),\n    data = presidential,\n    size = 3, vjust = 0, hjust = 0, nudge_x = 75\n  ) +\n  geom_line(aes(date, unemploy / pop)) +\n  scale_fill_manual(values = c(\"blue\", \"red\")) +\n  scale_y_continuous(labels = scales::percent, limits = c(0, NA)) +\n  scale_x_date(breaks = presidential$start, date_labels = \"%Y\") +\n  guides(fill = \"none\") +\n  labs(title = \"Unemployment rate by presidential term\", x = NULL, y = NULL) +\n  theme_quo(minor.y = FALSE, x = FALSE)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html",
    "href": "analysis/ggplot2-1.html",
    "title": "ggplot2 (Getting started)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Getting started” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(modelr)\nlibrary(jbplot)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html#exercises",
    "href": "analysis/ggplot2-1.html#exercises",
    "title": "ggplot2 (Getting started)",
    "section": "2.2.1 Exercises",
    "text": "2.2.1 Exercises\n\nList five functions that you could use to get more information about the mpg dataset.\n\nAnswer:\nFive common base R functions I use to interrogate dataframes are:\n\nsummary()\nhist()\nplot()\nlm()\nView()\n\nGG Solutions:\n\nhelp(mpg): Documentation of dataset\ndim(mpg): Dimensions of dataset\nsummary(mpg): Summary measures of dataset\nstr(mpg): Display of the internal structure of dataset\nglimpse(mpg): dplyr version of str(mpg)\n\n\n\nHow can you find out what other datasets are included with ggplot2?\n\nAnswer: use data(package = \"ggplot2\"), which returns the following:\nData sets in package ‘ggplot2’:\n\ndiamonds                      Prices of over 50,000 round cut diamonds\neconomics                     US economic time series\neconomics_long                US economic time series\nfaithfuld                     2d density estimate of Old Faithful data\nluv_colours                   'colors()' in Luv space\nmidwest                       Midwest demographics\nmpg                           Fuel economy data from 1999 to 2008 for 38 popular models of\n                              cars\nmsleep                        An updated and expanded version of the mammals sleep dataset\npresidential                  Terms of 12 presidents from Eisenhower to Trump\nseals                         Vector field of seal movements\ntxhousing                     Housing sales in TX\nGG Solutions:\ndata(package = \"ggplot2\") loads the available data sets in ggplot2. Alternatively,if you have internet access, go to https://ggplot2.tidyverse.org/reference/index.html#section-data\n\n\nApart from the US, most countries use fuel consumption (fuel consumed over fixed distance) rather than fuel economy (distance travelled with fixed amount of fuel). How could you convert cty and hwy into the European standard of l/100km?\n\nAnswer: to convert miles/gallon to liters/100km, we use the formula:\n\\(\\frac{1}{miles/gallon} \\times \\frac{3.78541}{1.609344 \\div 100} = l/100km\\)\n\nmpg_l100km &lt;- function(x) {\n  (1 / x) * 3.78541 / (1.609344 / 100)\n}\n\nmpg |&gt;\n  mutate(cty = mpg_l100km(cty), hwy = mpg_l100km(hwy))\n\n#&gt; # A tibble: 234 × 11\n#&gt;    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n#&gt;    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt;  1 audi         a4           1.8  1999     4 auto… f      13.1  8.11 p     comp…\n#&gt;  2 audi         a4           1.8  1999     4 manu… f      11.2  8.11 p     comp…\n#&gt;  3 audi         a4           2    2008     4 manu… f      11.8  7.59 p     comp…\n#&gt;  4 audi         a4           2    2008     4 auto… f      11.2  7.84 p     comp…\n#&gt;  5 audi         a4           2.8  1999     6 auto… f      14.7  9.05 p     comp…\n#&gt;  6 audi         a4           2.8  1999     6 manu… f      13.1  9.05 p     comp…\n#&gt;  7 audi         a4           3.1  2008     6 auto… f      13.1  8.71 p     comp…\n#&gt;  8 audi         a4 quattro   1.8  1999     4 manu… 4      13.1  9.05 p     comp…\n#&gt;  9 audi         a4 quattro   1.8  1999     4 auto… 4      14.7  9.41 p     comp…\n#&gt; 10 audi         a4 quattro   2    2008     4 manu… 4      11.8  8.40 p     comp…\n#&gt; # ℹ 224 more rows\n\n\nGG Solutions:\n\nAccording to asknumbers, you divide 235.214583 by the mpg values in cty and hwy to convert them into the European standard of l/100km.\nFunction to convert into European standard (Rademaker, 2016):\n\n\nmpgTol100km &lt;- function(milespergallon) {\n  GalloLiter &lt;- 3.785411784\n  MileKilometer &lt;- 1.609344\n\n  l100km &lt;- (100 * GalloLiter) / (milespergallon * MileKilometer)\n  l100km\n}\n\n\n\nWhich manufacturer has the most models in this dataset? Which model has the most variations? Does your answer change if you remove the redundant specification of drive train (e.g. “pathfinder 4wd”, “a4 quattro”) from the model name?\n\nAnswer: we can generate a dataframe with manufacturers, models, and variations using:\n\nmpg_summary &lt;- mpg |&gt;\n  count(manufacturer, model) |&gt;\n  rename(variations = n)\n\nmpg_summary\n\n#&gt; # A tibble: 38 × 3\n#&gt;    manufacturer model              variations\n#&gt;    &lt;chr&gt;        &lt;chr&gt;                   &lt;int&gt;\n#&gt;  1 audi         a4                          7\n#&gt;  2 audi         a4 quattro                  8\n#&gt;  3 audi         a6 quattro                  3\n#&gt;  4 chevrolet    c1500 suburban 2wd          5\n#&gt;  5 chevrolet    corvette                    5\n#&gt;  6 chevrolet    k1500 tahoe 4wd             4\n#&gt;  7 chevrolet    malibu                      5\n#&gt;  8 dodge        caravan 2wd                11\n#&gt;  9 dodge        dakota pickup 4wd           9\n#&gt; 10 dodge        durango 4wd                 7\n#&gt; # ℹ 28 more rows\n\n\nThe model with the most variations is the Dodge Caravan 2wd.\n\nmpg_summary |&gt;\n  arrange(variations) |&gt;\n  tail(1)\n\n#&gt; # A tibble: 1 × 3\n#&gt;   manufacturer model       variations\n#&gt;   &lt;chr&gt;        &lt;chr&gt;            &lt;int&gt;\n#&gt; 1 dodge        caravan 2wd         11\n\n\nThe manufacturer with the most models is Toyota.\n\nmpg_summary |&gt;\n  count(manufacturer) |&gt;\n  arrange(n) |&gt;\n  tail(1)\n\n#&gt; # A tibble: 1 × 2\n#&gt;   manufacturer     n\n#&gt;   &lt;chr&gt;        &lt;int&gt;\n#&gt; 1 toyota           6\n\n\nIf we first remove the redundant drive train from the summary, we get:\n\nmpg_summary2 &lt;- mpg |&gt;\n  mutate(model = gsub(\" (quattro)|(2wd)|(4wd)|(awd)$\", \"\", model)) |&gt;\n  count(manufacturer, model) |&gt;\n  rename(variations = n)\n\nmpg_summary2\n\n#&gt; # A tibble: 37 × 3\n#&gt;    manufacturer model              variations\n#&gt;    &lt;chr&gt;        &lt;chr&gt;                   &lt;int&gt;\n#&gt;  1 audi         \"a4\"                       15\n#&gt;  2 audi         \"a6\"                        3\n#&gt;  3 chevrolet    \"c1500 suburban \"           5\n#&gt;  4 chevrolet    \"corvette\"                  5\n#&gt;  5 chevrolet    \"k1500 tahoe \"              4\n#&gt;  6 chevrolet    \"malibu\"                    5\n#&gt;  7 dodge        \"caravan \"                 11\n#&gt;  8 dodge        \"dakota pickup \"            9\n#&gt;  9 dodge        \"durango \"                  7\n#&gt; 10 dodge        \"ram 1500 pickup \"         10\n#&gt; # ℹ 27 more rows\n\n\nThe model with the most variations has changed to the Audi A4.\n\nmpg_summary2 |&gt;\n  arrange(variations) |&gt;\n  tail(1)\n\n#&gt; # A tibble: 1 × 3\n#&gt;   manufacturer model variations\n#&gt;   &lt;chr&gt;        &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 audi         a4            15\n\n\nThe manufacturer with the most models is still Toyota.\n\nmpg_summary2 |&gt;\n  count(manufacturer) |&gt;\n  arrange(n) |&gt;\n  tail(1)\n\n#&gt; # A tibble: 1 × 2\n#&gt;   manufacturer     n\n#&gt;   &lt;chr&gt;        &lt;int&gt;\n#&gt; 1 toyota           6\n\n\nGG Solutions:\nNot included here because I believe the answer to question 4 in 2.2 Exercises is incorrect, as it counts variants by manufacturer, not models by manufacturer.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html#exercises-1",
    "href": "analysis/ggplot2-1.html#exercises-1",
    "title": "ggplot2 (Getting started)",
    "section": "2.3.1 Exercises",
    "text": "2.3.1 Exercises\n\nHow would you describe the relationship between cty and hwy? Do you have any concerns about drawing conclusions from that plot?\n\nAnswer: we can explore the relationship using a scatterplot:\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThere is a strong correlation between cty and hwy, which is expected since these are both measures of fuel efficiency of the same car.\nGG Solutions:\n\nThe plot shows a strongly linear relationship, which tells me that cty and hwy are highly correlated variables. The only concern I have is that the points seem to be overlapping.\nThere is not much insight to be gained except that cars which are fuel efficient on a highway are also fuel efficient in cities. This relationship is probably a function of speed (Rademaker, 2016)\n\n\n\nWhat does ggplot(mpg, aes(model, manufacturer)) + geom_point() show? Is it useful? How could you modify the data to make it more informative?\n\nAnswer: this plot shows each model as a point for each manufacturer, which is not particularly useful, although it does allow for a quick count of models by manufacturer. A bar chart showing count of models by manufacturer would be more useful.\n\nggplot(mpg, aes(model, manufacturer)) +\n  geom_point()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThe plot shows the manufacturer of each model. Its not very readable since there are too many models and this clutters up the x-axis with too many ticks! I would just plot 20 or so models so that the graph is more readable. See below:\n\n\nmpg %&gt;%\n  head(25) %&gt;%\n  ggplot(aes(model, manufacturer)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nA possible alternative would be to look total number of observations for each manufacturer-model combination using geom_bar(). (Rademaker, 2016)\n\n\ndf &lt;- mpg %&gt;%\n  transmute(\"man_mod\" = paste(manufacturer, model, sep = \" \")) # nolint: keyword_quote_linter.\nggplot(df, aes(man_mod)) +\n  geom_bar() +\n  coord_flip()\n\n\n\n\n\n\n\n\nNote: I prefer my solution for this exercise.\n\n\nDescribe the data, aesthetic mappings and layers used for each of the following plots. You’ll need to guess a little because you haven’t seen all the datasets and functions yet, but use your common sense! See if you can predict what the plot will look like before running the code.\n\nggplot(mpg, aes(cty, hwy)) + geom_point()\nggplot(diamonds, aes(carat, price)) + geom_point()\nggplot(economics, aes(date, unemploy)) + geom_line()\nggplot(mpg, aes(cty)) + geom_histogram()\n\n\nAnswer:\n\nggplot(mpg, aes(cty, hwy)) + geom_point() - scatterplot of city mpg against highway mpg\nggplot(diamonds, aes(carat, price)) + geom_point() - scatterplot of diamond weight in carats against price\nggplot(economics, aes(date, unemploy)) + geom_line() - a line plot showing the unemployment rate over time\nggplot(mpg, aes(cty)) + geom_histogram() - a histogram of city mpg\n\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(economics, aes(date, unemploy)) +\n  geom_line()\n\n\n\n\n\n\n\nggplot(mpg, aes(cty)) +\n  geom_histogram()\n\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nIn general, my guesses are correct (given my existing experience with ggplot), except for the economics plot, which appears to show the number of unemployed people instead of an employment rate.\nGG Solutions: (Rademaker, 2016)\n\nggplot(mpg, aes(cty, hwy)) + geom_point()\n\n\nData: mpg\nAesthetic: highway miles per gallon is mapped to y position and city miles per gallon is mapped to x position.\nLayer: points\n\n\nggplot(diamonds, aes(carat, price)) + geom_point()\n\n\nData: diamonds\nAesthetic: price in US dollars is mapped to y position, weight of the diamond is mapped to x position.\nLayer: points\n\n\nggplot(economics, aes(date, unemploy)) + geom_line()\n\n\nData: economics\nAesthetic: median duration of unemployment, in weeks, is mapped to y position and month of data collection is mapped to x position.\nLayer: line",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html#exercises-2",
    "href": "analysis/ggplot2-1.html#exercises-2",
    "title": "ggplot2 (Getting started)",
    "section": "2.4.1 Exercises",
    "text": "2.4.1 Exercises\n\nExperiment with the colour, shape and size aesthetics. What happens when you map them to continuous values? What about categorical values? What happens when you use more than one aesthetic in a plot?\n\nAnswer: observations based on the plots below:\n\nUsing a continuous variable with shape generates an error\nUsing a categorical variable with shape for more than 6 values generates a warning\nUsing a continuous variable with size works well\nUsing a categorical variable with size generates a warning\nUsing a continuous variable with color creates a gradient\nUsing a categorical variable with color creates a discrete mapping\nMultiple aesthetics can overload the plot\n\n\n# continuous\nggplot(mpg, aes(displ, hwy, color = cyl)) +\n  geom_point()\n\n\n\n\n\n\n\n# categorical\nggplot(mpg, aes(displ, hwy, color = drv)) +\n  geom_point()\n\n\n\n\n\n\n\n# multiple\nmpg |&gt;\n  mutate(year = as.factor(year)) |&gt;\n  ggplot(aes(displ, hwy, color = drv, size = cyl, shape = year)) +\n  geom_point()\n\n\n\n\n\n\n\n\nGG Solutions offers a similar and less complete answer.\n\n\nWhat happens if you map a continuous variable to shape? Why? What happens if you map trans to shape? Why?\n\nAnswer: As noted above, using a continuous variable with shape generates an error, because plots must have discrete shapes. Using a categorical variable with shape for more than 6 values (like trans) generates a warning, since (as the error notes) many different shapes can be hard to distinguish on a plot.\nGG Solutions presents a similar answer.\n\n\nHow is drive train related to fuel economy? How is drive train related to engine size and class?\n\nAnswer: The plots below show that:\n\nFront wheel drive is correlated with higher fuel economy\nFront wheel drive is correlated with smaller displacement, rear wheel drive is correlated with larger displacement, and four wheel drive is not correlated with displacement\nSome classes only have a single drive train:\n\nTwo seaters only have rear wheel drive\nMinivans only have front wheel drive\nPickups only have four wheel drive\n\n\n\nggplot(mpg, aes(hwy, drv)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(mpg, aes(displ, drv)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(mpg, aes(class, drv)) +\n  geom_point()\n\n\n\n\n\n\n\n\nGG Solutions presents a similar answer using bar charts, and compares engine size and class together in a single plot.\nNote: GG Solutions does not explore the relationship between drive train and class.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html#exercises-3",
    "href": "analysis/ggplot2-1.html#exercises-3",
    "title": "ggplot2 (Getting started)",
    "section": "2.5.1 Exercises",
    "text": "2.5.1 Exercises\n\nWhat happens if you try to facet by a continuous variable like hwy? What about cyl? What’s the key difference?\n\nAnswer: faceting on a continuous variable creates a facet for each unique value in the data frame, which holds true for both hwy and cyl. The key difference is that cyl has fewer unique values, making the plot more readable and useful.\n\nggplot(mpg, aes(displ, cty)) +\n  geom_point() +\n  facet_wrap(vars(hwy))\n\n\n\n\n\n\n\nggplot(mpg, aes(displ, cty)) +\n  geom_point() +\n  facet_wrap(vars(cyl))\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThe key difference is hwy is a continuous variable that has 27 unique values, so you get 27 different subsets. However, cly is a categorical variable and has 4 unique values, so cyl only has 4 different subsets. It is less cluttered when you try to facet.\n(Rademaker, 2016) Faceting by a continuous variable works but becomes hard to read and interpret when the variable that we facet by has too many levels.\n\n\n\nUse faceting to explore the 3-way relationship between fuel economy, engine size, and number of cylinders. How does faceting by number of cylinders change your assessment of the relationship between engine size and fuel economy?\n\nAnswer: engines with fewer cylinders have a stronger relationship between displacement and fuel economy (where larger engines have poorer fuel economy), strongest with 4 cylinders, unclear with 5 (due to limited data), weaker with 6, and no apparent relationship with 8.\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", formula = y ~ x) +\n  facet_wrap(vars(cyl))\n\n\n\n\n\n\n\n\nGG Solutions:\n\nWhen I initially plot engine size and fuel economy, I see an overall decreasing linear relationship. Upon faceting, I see that the decreasing relationship is mostly seen in the 4 cylinder subset. In the other cylinder subsets, we see a flat relationship - as engine displacement increases, fuel economy remains constant.\n\n\n\nRead the documentation for facet_wrap(). What arguments can you use to control how many rows and columns appear in the output?\n\nAnswer: use nrow and ncol.\nGG Solutions:\n\nI can use the arguments nrow, ncol to control how many rows and columns appear in the output.\n\n\n\nWhat does the scales argument to facet_wrap() do? When might you use it?\n\nAnswer: the scales argument determines whether scales are fixed (the default) or free on one or both dimensions. Using scales = \"free\" is helpful when comparing relationships when scale is less important, as shown in this reworked example of exercise 2, which focuses on the smoothed plot:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", formula = y ~ x) +\n  facet_wrap(vars(cyl), scales = \"free\")\n\n\n\n\n\n\n\n\nGG Solutions:\n\nIt allows users to decide whether scales should be fixed. I would use it whenever different subsets of the data are on vastly different scales.\n(Rademaker, 2016) If we want to compare across facets, scales = \"fixed\" is more appropriate. If our focus is on individual patterns within each facet, setting scales = \"free\" might be more appropriate.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html#exercises-4",
    "href": "analysis/ggplot2-1.html#exercises-4",
    "title": "ggplot2 (Getting started)",
    "section": "2.6.6 Exercises",
    "text": "2.6.6 Exercises\n\nWhat’s the problem with the plot created by ggplot(mpg, aes(cty, hwy)) + geom_point()? Which of the geoms described above is most effective at remedying the problem?\n\nAnswer: as noted in GG Solutions, the problem is overplotting, which geom_jitter fixes:\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  geom_jitter()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThe problem is overplotting.\n\nSolution 1. Use geom_jitter to add random noise to the data and avoid overplotting.\nSolution 2. (Rademaker, 2016) Set opacity with alpha\n\n\nOne challenge with ggplot(mpg, aes(class, hwy)) + geom_boxplot() is that the ordering of class is alphabetical, which is not terribly useful. How could you change the factor levels to be more informative?\nRather than reordering the factor by hand, you can do it automatically based on the data: ggplot(mpg, aes(reorder(class, hwy), hwy)) + geom_boxplot(). What does reorder() do? Read the documentation.\n\nAnswer: as noted in the exercise, ordering of class by hwy is more informative. reorder() reorders levels based on the second, numeric value, by default using the mean.\n\nggplot(mpg, aes(class, hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nggplot(mpg, aes(reorder(class, hwy), hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nGG Solutions takes a similar approach but instead uses mutate(class = factor(class), class = fct_reorder(class, hwy)).\n\n\nExplore the distribution of the carat variable in the diamonds dataset. What binwidth reveals the most interesting patterns?\n\nAnswer: using trial and error, binwidth = 0.01 reveals that carat weight is skewed towards round numbers (1, 1.25, 1.5, 2, etc.). Using the smaller binwidth = 0.005 doesn’t improve the pattern, and makes it harder to see.\n\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.1)\n\n\n\n\n\n\n\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.01)\n\n\n\n\n\n\n\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.005)\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThis is a subjective answer, but binwidth of 0.2 or 0.3 reveals that the distribution of carat is heavily skewed to the right. This means that most diamonds carats are between 0 and 1.\n\n\n\nExplore the distribution of the price variable in the diamonds data. How does the distribution vary by cut?\n\nAnswer: a boxplot of price by cut shows that better cuts aren’t necessarily more expensive.\nHowever, as noted in my R Training Log:\n\n7.6 Patterns and models covers models and residuals, here showing how to reveal the expected relationship between cut and price:\n\nWe can remove the relationship between carats and price, and redo the boxplot:\n\nggplot(diamonds, aes(cut, price)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n# remove carat weight as a confounding variable\nmod &lt;- lm(log(price) ~ log(carat), data = diamonds)\n\ndiamonds2 &lt;- diamonds |&gt;\n  add_residuals(mod) |&gt;\n  mutate(resid = exp(resid))\n\nggplot(data = diamonds2) +\n  geom_boxplot(mapping = aes(x = cut, y = resid))\n\n\n\n\n\n\n\n\nGG Solutions uses both a boxplot and a frequency polygon to compare cuts, and concludes:\n\n(Rademaker, 2016) Fair quality diamonds are more expensive then others. Possible reason is they are bigger.\n\n\n\nYou now know (at least) three ways to compare the distributions of subgroups: geom_violin(), geom_freqpoly() and the colour aesthetic, or geom_histogram() and faceting. What are the strengths and weaknesses of each approach? What other approaches could you try?\n\nAnswer: Violin plots convey the most information but require an understanding of probability density. Frequency polygons allow for direct comparison on the same plot - in contrast, faceted histograms provide a better visualization of each variable, but make comparison more difficult. Other approaches include comparing boxplots, multiple density plots, or side-by-side histograms - a bar plot showing multiple variables for each bin.\nGG Solutions:\n\nAccording to the book, geom_violin() shows a compact representation of the “density” of the distribution, highlighting the areas where more points are found. Its weakness is that violin plots rely on the calculation of a density estimate, which is hard to interpret.\nAccording to the book, geom_freqploy() bins the data, then counts the number of observations in each bin using lines. One possible weakness is that you have to select the width of the bins yourself by experimentation.\nAccording to the book, geom_histogram() and faceting makes it easier to see the distribution of each group, but makes comparisons between groups a little harder.\n\n\n\nRead the documentation for geom_bar(). What does the weight aesthetic do?\n\nAnswer: for geom_bar(), the weight aesthetic changes the height of the bar from the number of cases in each group to the sum of the weights.\nGG Solutions:\n\nThe weight aesthetic converts the number of cases to a weight and makes the height of the bar proportional to the sum of the weights. See below:\n\n\ng &lt;- ggplot(mpg, aes(class))\n# Number of cars in each class:\ng + geom_bar()\n\n\n\n\n\n\n\n# Total engine displacement of each class\ng + geom_bar(aes(weight = displ))\n\n\n\n\n\n\n\n\n\n\nUsing the techniques already discussed in this chapter, come up with three ways to visualise a 2d categorical distribution. Try them out by visualising the distribution of model and manufacturer, trans and class, and cyl and trans.\n\nAnswer: three ways to visualize categorical distributions:\n\nBar charts\nA scatterplot using alpha\nA scatterplot using size\n\n\nmpg[c(\"manufacturer\", \"model\")] |&gt;\n  unique() |&gt;\n  ggplot(aes(manufacturer)) +\n  geom_bar(color = \"black\", fill = \"white\", width = 0.8) +\n  coord_flip() +\n  scale_x_discrete(limits = rev) +\n  labs(x = \"\", y = \"models\") +\n  theme_quo()\n\n\n\n\n\n\n\nmpg |&gt;\n  ggplot(aes(trans, class)) +\n  geom_point(alpha = 0.1) +\n  scale_y_discrete(limits = rev) +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n\n\n\n\n\n\n\nmpg |&gt;\n  count(trans, cyl) |&gt;\n  ggplot(aes(cyl, trans, size = n)) +\n  geom_point() +\n  scale_y_discrete(limits = rev) +\n  labs(x = \"cylinders\", y = \"\", size = \"count\") +\n  theme_quo(minor.x = FALSE)\n\n\n\n\n\n\n\n\nGG Solutions does not provide an answer.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/FaultTree.html",
    "href": "analysis/FaultTree.html",
    "title": "FaultTree.widget Test",
    "section": "",
    "text": "Notebook for testing FaultTree.widget rendering fixes.\n\nExample\nThe fault tree below is centered in-frame when viewed in RStudio, but is partially off-frame when viewed in a browser, and completely off-frame if the browser window is wide enough. This is true for both html_notebook and html_document.\n\nlibrary(FaultTree)\nlibrary(FaultTree.widget)\n\n# nolint start\ntree1 &lt;- ftree.make(type = \"priority\", reversible_cond = TRUE, name = \"Site power loss\")\ntree1 &lt;- addLogic(tree1, at = 1, type = \"or\", name = \"neither emergency\", name2 = \"generator operable\")\ntree1 &lt;- addLogic(tree1, at = 2, type = \"and\", name = \"Independent failure\", name2 = \"of generators\")\ntree1 &lt;- addLatent(tree1, at = 3, mttf = 5, mttr = 12 / 8760, inspect = 1 / 26, name = \"e-gen set fails\")\ntree1 &lt;- addLatent(tree1, at = 3, mttf = 5, mttr = 12 / 8760, inspect = 1 / 26, name = \"e-gen set fails\")\ntree1 &lt;- addLogic(tree1, at = 2, type = \"inhibit\", name = \"Common cause\", name2 = \"failure of generators\")\ntree1 &lt;- addProbability(tree1, at = 6, prob = .05, name = \"Common cause\", name2 = \"beta factor\")\ntree1 &lt;- addLatent(tree1, at = 6, mttf = 5, mttr = 12 / 8760, inspect = 1 / 26, name = \"e-gen set fails\")\ntree1 &lt;- addDemand(tree1, at = 1, mttf = 1.0, name = \"External power\", name2 = \"interruption\")\n# nolint end\n\ntree1 &lt;- ftree.calc(tree1)\n\nftree2widget(tree1, height = 500, width = 800)\n\n\n\n\n\nCheck rendering without height and width specified:\n\nftree2widget(tree1)\n\n\n\n\n\n\n\nSolution\nA partial fix is to change the line in inst/htmlwidgets/ftree_widget1.js and inst/htmlwidgets/ftree_widget2.js\nfrom (which sets the position based on the width of the browser window):\nvar width_initial = $(window).width()/2-60;\nto (which sets the position based on the width of the div containing the widget):\nvar width_initial = $(\"div\").width()/2-60;\nThen the fault tree will position itself within view, but not always centered. A complete fix would render the fault tree centered within the widget.\nOther approaches tested:\n// var width_initial = $('div:contains(\"htmlwidget\")').width()/2-60;\n// var width_initial = $(\"div\").filter(function(){ return this.children.length === 0; }).width()/2-60;",
    "crumbs": [
      "Changelog",
      "FaultTree.widget Test"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html",
    "href": "analysis/advanced-r-3.html",
    "title": "Advanced R (Object-oriented programming)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Object-oriented programming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions.\nlibrary(sloop)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(R6)\nlibrary(methods)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises",
    "href": "analysis/advanced-r-3.html#exercises",
    "title": "Advanced R (Object-oriented programming)",
    "section": "13.2.1 Exercises",
    "text": "13.2.1 Exercises\n\nDescribe the difference between t.test() and t.data.frame(). When is each function called?\n\n\nftype(t.test)\n\n#&gt; [1] \"S3\"      \"generic\"\n\nftype(t.data.frame)\n\n#&gt; [1] \"S3\"     \"method\"\n\ns3_dispatch(t.test(formula()))\n\n#&gt; =&gt; t.test.formula\n#&gt;  * t.test.default\n\ns3_dispatch(t(data.frame()))\n\n#&gt; =&gt; t.data.frame\n#&gt; -&gt; t.default\n\n\nAnswer: As noted by sloop::ftype() and the docs, t.test() is a S3 generic, and t.data.frame() is an S3 method for t() (transpose). t.data.frame() is called as a method when calling t(x) when x is a data.frame. t.test() calls either t.test.default or t.test.formula.\nAR Solutions: Because of S3’s generic.class() naming scheme, both functions may initially look similar, while they are in fact unrelated.\n\nt.test() is a generic function that performs a t-test.\nt.data.frame() is a method that gets called by the generic t() to transpose data frame input.\n\nDue to R’s S3 dispatch rules, t.test() would also get called when t() is applied to an object of class test\n\n\nMake a list of commonly used base R functions that contain . in their name but are not S3 methods.\n\n\nftype(as.character)\n\n#&gt; [1] \"primitive\" \"generic\"\n\nftype(as.data.frame)\n\n#&gt; [1] \"S3\"      \"generic\"\n\nftype(data.frame)\n\n#&gt; [1] \"function\"\n\nftype(eval.parent)\n\n#&gt; [1] \"function\"\n\nftype(file.path)\n\n#&gt; [1] \"internal\"\n\nftype(file.copy)\n\n#&gt; [1] \"internal\"\n\nftype(is.null)\n\n#&gt; [1] \"primitive\"\n\nftype(is.data.frame)\n\n#&gt; [1] \"function\"\n\nftype(Sys.localeconv)\n\n#&gt; [1] \"internal\"\n\nftype(Sys.time)\n\n#&gt; [1] \"internal\"\n\n\nAnswer:\n\nAll of the as. functions\ndata.frame\nAll of the file. functions\nAll of the is. functions\nAll of the Sys. functions\n\nAR Solutions: In recent years “snake_case”-style has become increasingly common when naming functions and variables in R. But many functions in base R will continue to be “point.separated”, which is why some inconsistency in your R code most likely cannot be avoided. (install.packages(), read.csv(), list.files(), download.file(), data.frame(), as.character(), Sys.Date(), all.equal(), do.call(), on.exit())\n\n\nWhat does the as.data.frame.data.frame() method do? Why is it confusing? How could you avoid this confusion in your own code?\n\n\ns3_dispatch(as.data.frame(data.frame()))\n\n#&gt; =&gt; as.data.frame.data.frame\n#&gt;  * as.data.frame.default\n\n\nAnswer: as.data.frame.data.frame() is the method used to coerce a data.frame to a data.frame. This is confusing because the class contains a period (as does the function call); avoiding periods improves readability: as_dataframe.dataframe makes the generic and method clear.\nAR Solutions: The function as.data.frame.data.frame() implements the data.frame() method for the as.data.frame() generic, which coerces objects to data frames.\nThe name is confusing, because it does not clearly communicate the type of the function, which could be a regular function, a generic or a method. Even if we assume a method, the amount of .’s makes it difficult to separate the generic- and the class-part of the name. Is it the data.frame.data.frame() method for the as() generic? Is it the frame.data.frame() method for the as.data() generic?\nWe could avoid this confusion by applying a different naming convention (e.g. “snake_case”) for our class and function names.\n\n\nDescribe the difference in behaviour in these two calls.\n\n\nset.seed(1014)\nsome_days &lt;- as.Date(\"2017-01-31\") + sample(10, 5)\nmean(some_days)\n\n#&gt; [1] \"2017-02-06\"\n\nmean(unclass(some_days))\n\n#&gt; [1] 17203.4\n\ns3_dispatch(mean(some_days))\n\n#&gt; =&gt; mean.Date\n#&gt;  * mean.default\n\ns3_dispatch(mean(unclass(some_days)))\n\n#&gt;    mean.double\n#&gt;    mean.numeric\n#&gt; =&gt; mean.default\n\n\nAnswer: the first call calculates the mean using mean.Date(), and so returns a date. using unclass() changes the date to its underlying value (double) which calculates the mean using mean.default().\nAR Solutions: mean() is a generic function, which will select the appropriate method based on the class of the input. some_days has the class Date and mean.Date(some_days) will be used to calculate the mean date of some_days.\nAfter unclass() has removed the class attribute from some_date, the default method is chosen. mean.default(unclass(some_days)) then calculates the mean of the underlying double.\n\n\nWhat class of object does the following code return? What base type is it built on? What attributes does it use?\n\n\nx &lt;- ecdf(rpois(100, 10))\nx\n\n#&gt; Empirical CDF \n#&gt; Call: ecdf(rpois(100, 10))\n#&gt;  x[1:18] =      2,      3,      4,  ...,     18,     19\n\nstr(x)\n\n#&gt; function (v)  \n#&gt;  - attr(*, \"class\")= chr [1:3] \"ecdf\" \"stepfun\" \"function\"\n#&gt;  - attr(*, \"call\")= language ecdf(rpois(100, 10))\n\n\nAnswer: the code returns an object of class ecdf, which is build on the stepfun object, and the function base type. It additionally includes the call attribute.\nAR Solutions: It returns an object of the class ecdf (empirical cumulative distribution function) with the superclasses stepfun and function. The ecdf object is built on the base type closure (a function). The expression, which was used to create it (rpois(100, 10)), is stored in the call attribute.\n\ntypeof(x)\n\n#&gt; [1] \"closure\"\n\n\n\n\nWhat class of object does the following code return? What base type is it built on? What attributes does it use?\n\n\nx &lt;- table(rpois(100, 5))\nx\n\n#&gt; \n#&gt;  1  2  3  4  5  6  7  8  9 10 \n#&gt;  7  5 18 14 15 15 14  4  5  3\n\nstr(x)\n\n#&gt;  'table' int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3\n#&gt;  - attr(*, \"dimnames\")=List of 1\n#&gt;   ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n\nstr(unclass(x))\n\n#&gt;  int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3\n#&gt;  - attr(*, \"dimnames\")=List of 1\n#&gt;   ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n\n\nAnswer: per the docs, the code returns an object of class table, which is built on array, which uses the dimnames attribute in combination with a vector.\nAR Solutions: This code returns a table object, which is built upon the integer type. The attribute dimnames is used to name the elements of the integer vector.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-1",
    "href": "analysis/advanced-r-3.html#exercises-1",
    "title": "Advanced R (Object-oriented programming)",
    "section": "13.3.4 Exercises",
    "text": "13.3.4 Exercises\n\nWrite a constructor for data.frame objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?\n\n\ndput(data.frame())\n\n#&gt; structure(list(), names = character(0), row.names = integer(0), class = \"data.frame\")\n\ndput(data.frame(a = 1:2, b = 3:4))\n\n#&gt; structure(list(a = 1:2, b = 3:4), class = \"data.frame\", row.names = c(NA, \n#&gt; -2L))\n\nunclass(data.frame(a = 1:2, b = 3:4))\n\n#&gt; $a\n#&gt; [1] 1 2\n#&gt; \n#&gt; $b\n#&gt; [1] 3 4\n#&gt; \n#&gt; attr(,\"row.names\")\n#&gt; [1] 1 2\n\n\nAnswer: code below. The data frame is built on the list base type, and includes the names, row.names, and class attributes. This implementation requires values to be a list, names to be a character, and row.names to be an integer.\n\nnew_data.frame &lt;- function(values = list(),\n                           names = character(length(values)),\n                           row.names = integer(length(values))) {\n  stopifnot(\n    is.list(values),\n    is.character(names),\n    is.integer(row.names)\n  )\n  structure(values, names = names, row.names = row.names, class = \"data.frame\")\n}\n\nnew_data.frame()\n\n#&gt; data frame with 0 columns and 0 rows\n\nnew_data.frame(list(1:3, 4:6, 7:9))\n\n#&gt;        \n#&gt; 0 1 4 7\n#&gt; 0 2 5 8\n#&gt; 0 3 6 9\n\nnew_data.frame(list(1:3, 4:6, 7:9), names = c(\"a\", \"b\", \"c\"), row.names = 1:3)\n\n#&gt;   a b c\n#&gt; 1 1 4 7\n#&gt; 2 2 5 8\n#&gt; 3 3 6 9\n\n\nAR Solutions: Data frames are built on named lists of vectors, which all have the same length. Besides the class and the column names (names), the row.names are their only further attribute. This must be a character vector with the same length as the other vectors.\nWe need to provide the number of rows as an input to make it possible to create data frames with 0 columns but multiple rows.\nThis leads to the following constructor:\n\nnew_data.frame &lt;- function(x, n, row.names = NULL) {\n  # Check if the underlying object is a list\n  stopifnot(is.list(x))\n\n  # Check all inputs are the same length\n  # (This check also allows that x has length 0)\n  stopifnot(all(lengths(x) == n))\n\n  if (is.null(row.names)) {\n    # Use special row names helper from base R\n    row.names &lt;- .set_row_names(n)\n  } else {\n    # Otherwise check that they're a character vector with the\n    # correct length\n    stopifnot(is.character(row.names), length(row.names) == n)\n  }\n\n  structure(\n    x,\n    class = \"data.frame\",\n    row.names = row.names\n  )\n}\n\n# Test\nx &lt;- list(a = 1, b = 2)\nnew_data.frame(x, n = 1)\n\n#&gt;   a b\n#&gt; 1 1 2\n\nnew_data.frame(x, n = 1, row.names = \"l1\")\n\n#&gt;    a b\n#&gt; l1 1 2\n\n# Create a data frame with 0 columns and 2 rows\nnew_data.frame(list(), n = 2)\n\n#&gt; data frame with 0 columns and 2 rows\n\n\nNote: AR Solutions approach also validates that all inputs are same length, and supports creation of dataframes with 0 columns but multiple rows.\n\n\nEnhance my factor() helper to have better behaviour when one or more values is not found in levels. What does base::factor() do in this situation?\n\n\nnew_factor &lt;- function(x = integer(), levels = character()) {\n  stopifnot(\n    is.integer(x),\n    is.character(levels)\n  )\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nAnswer: the fix is to update validate_factor() to allow NA values, since the helper already fills in NA when values is not found in levels. This matches the behavior of base::factor().\n\nvalidate_factor &lt;- function(x) {\n  values &lt;- unclass(x)\n  levels &lt;- attr(x, \"levels\")\n\n  if (!all(is.na(values) | values &gt; 0)) {\n    stop(\n      \"All non-missing `x` values must be greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) &lt; max(values, na.rm = TRUE)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nmy_factor &lt;- function(x = character(), levels = unique(x)) {\n  ind &lt;- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nfactor(c(\"a\", \"a\", \"b\"), levels = \"a\")\n\n#&gt; [1] a    a    &lt;NA&gt;\n#&gt; Levels: a\n\nmy_factor(c(\"a\", \"a\", \"b\"), levels = \"a\")\n\n#&gt; [1] a    a    &lt;NA&gt;\n#&gt; Levels: a\n\n\nAR Solutions: base::factor() converts these values (silently) into NAs.\nThe factor() helper including the constructor (new_factor()) and its validator (validate_factor()) were given in Advanced R. However, as the goal of this question is to throw an early error within the helper, we only repeat the code for the helper:\nTo improve the factor() helper we choose to return an informative error message instead.\n\nfactor2 &lt;- function(x, levels = unique(x)) {\n  new_levels &lt;- match(x, levels)\n\n  # Error if levels don't include all values\n  missing &lt;- unique(setdiff(x, levels))\n  if (length(missing) &gt; 0) {\n    stop(\n      \"The following values do not occur in the levels of x: \",\n      paste0(\"'\", missing, \"'\", collapse = \", \"), \".\",\n      call. = FALSE\n    )\n  }\n\n  validate_factor(new_factor(new_levels, levels))\n}\n\n# Test\ntry(factor2(c(\"a\", \"b\", \"c\"), levels = c(\"a\", \"b\")))\n\n#&gt; Error : The following values do not occur in the levels of x: 'c'.\n\n\n\n\nCarefully read the source code of factor(). What does it do that my constructor does not?\n\n\nfactor(c(\"a\", \"a\", \"b\", \"c\"), labels = c(\"alpha\", \"beta\", \"beta\"))\n\n#&gt; [1] alpha alpha beta  beta \n#&gt; Levels: alpha beta\n\nclass(factor(1:10, ordered = TRUE))\n\n#&gt; [1] \"ordered\" \"factor\"\n\n\nAnswer: the base implementation:\n\nsets the value to character(0) if the value is null\nretains value names\nallows an upper bound on the number of levels, nmax\ncoerces the value to character\nprovides a method for excluding values from levels, exclude\nprovides labels for remapping factors\nadds an “ordered” class if the value is ordered (ordered = TRUE)\n\nNote: labels are an interesting and unexpected feature of factor()\n\nfactor\n\n#&gt; function (x = character(), levels, labels = levels, exclude = NA, \n#&gt;     ordered = is.ordered(x), nmax = NA) \n#&gt; {\n#&gt;     if (is.null(x)) \n#&gt;         x &lt;- character()\n#&gt;     nx &lt;- names(x)\n#&gt;     if (missing(levels)) {\n#&gt;         y &lt;- unique(x, nmax = nmax)\n#&gt;         ind &lt;- order(y)\n#&gt;         levels &lt;- unique(as.character(y)[ind])\n#&gt;     }\n#&gt;     force(ordered)\n#&gt;     if (!is.character(x)) \n#&gt;         x &lt;- as.character(x)\n#&gt;     levels &lt;- levels[is.na(match(levels, exclude))]\n#&gt;     f &lt;- match(x, levels)\n#&gt;     if (!is.null(nx)) \n#&gt;         names(f) &lt;- nx\n#&gt;     if (missing(labels)) {\n#&gt;         levels(f) &lt;- as.character(levels)\n#&gt;     }\n#&gt;     else {\n#&gt;         nlab &lt;- length(labels)\n#&gt;         if (nlab == length(levels)) {\n#&gt;             nlevs &lt;- unique(xlevs &lt;- as.character(labels))\n#&gt;             at &lt;- attributes(f)\n#&gt;             at$levels &lt;- nlevs\n#&gt;             f &lt;- match(xlevs, nlevs)[f]\n#&gt;             attributes(f) &lt;- at\n#&gt;         }\n#&gt;         else if (nlab == 1L) \n#&gt;             levels(f) &lt;- paste0(labels, seq_along(levels))\n#&gt;         else stop(gettextf(\"invalid 'labels'; length %d should be 1 or %d\", \n#&gt;             nlab, length(levels)), domain = NA)\n#&gt;     }\n#&gt;     class(f) &lt;- c(if (ordered) \"ordered\", \"factor\")\n#&gt;     f\n#&gt; }\n#&gt; &lt;bytecode: 0x157406908&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\nAR Solutions: The original implementation (base::factor()) allows more flexible input for x. It coerces x to character or replaces it with character(0) (in case of NULL). It also ensures that the levels are unique. This is achieved by setting them via base::levels&lt;-, which fails when duplicate values are supplied.\nNote: I missed the fact that base::levels&lt;- fails when duplicate values are supplied.\n\n\nFactors have an optional “contrasts” attribute. Read the help for C(), and briefly describe the purpose of the attribute. What type should it have? Rewrite the new_factor() constructor to include this attribute.\n\nAnswer: per the “contrast {stats}” documentation, contrast matrices are used in fitting analysis of variance and regression models, so the attribute should be a matrix.\n\nnew_factor &lt;- function(x = integer(), levels = character(), contr = matrix()) {\n  stopifnot(is.integer(x), is.character(levels), is.matrix(contr))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contr\n  )\n}\n\nAR Solutions: When factor variables (representing nominal or ordinal information) are used in statistical models, they are typically encoded as dummy variables and by default each level is compared with the first factor level. However, many different encodings (“contrasts”) are possible, see Contrast.\nWithin R’s formula interface you can wrap a factor in stats::C() and specify the contrast of your choice. Alternatively, you can set the contrasts attribute of your factor variable, which accepts matrix input. (See ?contr.helmert or similar for details.)\nOur updated new_factor() constructor gets a contrasts argument, which accepts a numeric matrix or NULL (default).\n\n# Updated new_factor() constructor\nnew_factor &lt;- function(x = integer(),\n                       levels = character(),\n                       contrasts = NULL) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  if (!is.null(constrasts)) {\n    stopifnot(is.matrix(contrasts) && is.numeric(contrasts)) # nolint: conjunct_test_linter.\n  }\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contrasts\n  )\n}\n\n\n\nRead the documentation for utils::as.roman(). How would you write a constructor for this class? Does it need a validator? What might a helper do?\n\n\ndput(as.roman(3899))\n\n#&gt; structure(3899L, class = \"roman\")\n\nnew_roman &lt;- function(x = integer()) {\n  stopifnot(is.integer(x))\n\n  structure(\n    x,\n    class = \"roman\"\n  )\n}\n\nnew_roman(2022L)\n\n#&gt; [1] MMXXII\n\n\nAnswer: the structure of the class “roman” is simple, an integer with a defined class. A simple constructor would take an integer and return an object of class “roman” as above. A validator is probably not needed, but could validate that the integer is within the supported range of integers (1-3899). A helper might coerce the number to be an integer using as.integer().\nAR Solutions: This function transforms numeric input into Roman numbers. It is built on the integer type, which results in the following constructor.\n\nnew_roman &lt;- function(x = integer()) {\n  stopifnot(is.integer(x))\n  structure(x, class = \"roman\")\n}\n\nThe documentation tells us, that only values between 1 and 3899 are uniquely represented, which we then include in our validation function.\n\nvalidate_roman &lt;- function(x) {\n  values &lt;- unclass(x)\n\n  if (any(values &lt; 1 | values &gt; 3899)) {\n    stop(\n      \"Roman numbers must fall between 1 and 3899.\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nFor convenience, we allow the user to also pass real values to a helper function.\n\nroman &lt;- function(x = integer()) {\n  x &lt;- as.integer(x)\n\n  validate_roman(new_roman(x))\n}\n\n# Test\nroman(c(1, 753, 2019))\n\n#&gt; [1] I       DCCLIII MMXIX\n\ntry(roman(0))\n\n#&gt; Error : Roman numbers must fall between 1 and 3899.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-2",
    "href": "analysis/advanced-r-3.html#exercises-2",
    "title": "Advanced R (Object-oriented programming)",
    "section": "13.4.4 Exercises",
    "text": "13.4.4 Exercises\n\nRead the source code for t() and t.test() and confirm that t.test() is an S3 generic and not an S3 method. What happens if you create an object with class test and call t() with it? Why?\n\n\nx &lt;- structure(1:10, class = \"test\")\nt(x)\n\n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#&gt; [1,]    1    2    3    4    5    6    7    8    9    10\n#&gt; attr(,\"class\")\n#&gt; [1] \"test\"\n\n\nAnswer: both t() and t.test() simply call UseMethod(), and are S3 generics.\n\nt\n\n#&gt; function (x) \n#&gt; UseMethod(\"t\")\n#&gt; &lt;bytecode: 0x132ecb330&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nt.test\n\n#&gt; function (x, ...) \n#&gt; UseMethod(\"t.test\")\n#&gt; &lt;bytecode: 0x1271e5f78&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\n\nCreating an object with class test and calling t() uses the default method since t.test() is not a registered method for t(), as this code shows:\n\nmethods(\"t\")\n\n#&gt; [1] t.data.frame  t.default     t.ts*         t.vctrs_sclr* t.vctrs_vctr*\n#&gt; see '?methods' for accessing help and source code\n\ns3_dispatch(t(x))\n\n#&gt; =&gt; t.test\n#&gt;  * t.default\n\n\nAR Solutions: We can see that t.test() is a generic because it calls UseMethod().\n\n# or simply call\nftype(t.test)\n\n#&gt; [1] \"S3\"      \"generic\"\n\n\nInterestingly, R also provides helpers, which list functions that look like methods, but in fact are not:\n\ntools::nonS3methods(\"stats\")\n\n#&gt; [1] \"anova.lmlist\"        \"expand.model.frame\"  \"fitted.values\"      \n#&gt; [4] \"influence.measures\"  \"lag.plot\"            \"t.test\"             \n#&gt; [7] \"plot.spec.phase\"     \"plot.spec.coherency\"\n\n\nWhen we create an object with class test, t() dispatches to the t.default() method. This happens, because UseMethod() simply searches for functions named paste0(\"generic\", \".\", c(class(x), \"default\")).\nHowever, in older versions of R (pre R 4.0.0; when Advanced R was written) this behaviour was slightly different. Instead of dispatching to the t.default() method, the t.test() generic was erroneously treated as a method of t() which then dispatched to t.test.default() or (when defined) to t.test.test().\n\n\nWhat generics does the table class have methods for?\n\nAnswer: s3_methods_class() answers this question:\n\ns3_methods_class(\"table\")\n\n#&gt; # A tibble: 11 × 4\n#&gt;    generic       class visible source             \n#&gt;    &lt;chr&gt;         &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n#&gt;  1 [             table TRUE    base               \n#&gt;  2 aperm         table TRUE    base               \n#&gt;  3 as_tibble     table FALSE   registered S3method\n#&gt;  4 as.data.frame table TRUE    base               \n#&gt;  5 Axis          table FALSE   registered S3method\n#&gt;  6 lines         table FALSE   registered S3method\n#&gt;  7 plot          table FALSE   registered S3method\n#&gt;  8 points        table FALSE   registered S3method\n#&gt;  9 print         table TRUE    base               \n#&gt; 10 summary       table TRUE    base               \n#&gt; 11 tail          table FALSE   registered S3method\n\n\nAR Solutions: This is a simple application of sloop::s3_methods_class().\nInterestingly, the table class has a number of methods designed to help plotting with base graphics.\n\nx &lt;- rpois(100, 5)\nplot(table(x))\n\n\n\n\n\n\n\n\n\n\nWhat generics does the ecdf class have methods for?\n\nAnswer:\n\ns3_methods_class(\"ecdf\")\n\n#&gt; # A tibble: 4 × 4\n#&gt;   generic  class visible source             \n#&gt;   &lt;chr&gt;    &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 plot     ecdf  TRUE    stats              \n#&gt; 2 print    ecdf  FALSE   registered S3method\n#&gt; 3 quantile ecdf  FALSE   registered S3method\n#&gt; 4 summary  ecdf  FALSE   registered S3method\n\n\nAR Solutions: We use the same approach as above.\nThe methods are primarily designed for display (plot(), print(), summary()), but you can also extract quantiles with quantile().\n\n\nWhich base generic has the greatest number of defined methods?\n\nAnswer: using code from 6.2.5, identify generics and count defined methods:\n\n# from 6.2.5 exercises, this code makes a list of all functions in the base package\nfuns &lt;- Filter(is.function, mget(ls(\"package:base\", all.names = TRUE), inherits = TRUE))\n\nget_method_count &lt;- function(fname) {\n  data.frame(\n    name = fname,\n    # this code should work but doesn't:\n    # method_count = nrow(s3_methods_generic(fname))\n    method_count = length(methods(fname))\n  )\n}\n\nmap_dfr(names(funs), get_method_count) |&gt;\n  arrange(desc(method_count))\n\n#&gt;                                    name method_count\n#&gt; 1                                 print          276\n#&gt; 2                                format          124\n#&gt; 3                                     [           49\n#&gt; 4                               summary           39\n#&gt; 5                          as.character           32\n#&gt; 6                         as.data.frame           32\n#&gt; 7                                  plot           30\n#&gt; 8                                    [[           22\n#&gt; 9                                   [&lt;-           18\n#&gt; 10                                  $&lt;-           18\n#&gt; 11                                    $           17\n#&gt; 12                                 file           17\n#&gt; 13                                 [[&lt;-           15\n#&gt; 14                              as.list           15\n#&gt; 15                                    c           15\n#&gt; 16                            all.equal           12\n#&gt; 17                                xtfrm           11\n#&gt; 18                                  rep           10\n#&gt; 19                               unique           10\n#&gt; 20                           duplicated            9\n#&gt; 21                              as.Date            8\n#&gt; 22                            as.matrix            8\n#&gt; 23                           as.POSIXlt            7\n#&gt; 24                             length&lt;-            7\n#&gt; 25                                 mean            7\n#&gt; 26                              names&lt;-            7\n#&gt; 27                                  row            7\n#&gt; 28                        anyDuplicated            6\n#&gt; 29                           as.POSIXct            6\n#&gt; 30                                 diff            6\n#&gt; 31                               length            6\n#&gt; 32                                write            6\n#&gt; 33                                anyNA            5\n#&gt; 34                     conditionMessage            5\n#&gt; 35                                is.na            5\n#&gt; 36                              is.na&lt;-            5\n#&gt; 37                               labels            5\n#&gt; 38                                names            5\n#&gt; 39                                    t            5\n#&gt; 40                                    -            4\n#&gt; 41                                    +            4\n#&gt; 42                            as.double            4\n#&gt; 43                            as.vector            4\n#&gt; 44                                close            4\n#&gt; 45                                  cut            4\n#&gt; 46                                 open            4\n#&gt; 47                                split            4\n#&gt; 48                               subset            4\n#&gt; 49                                    !            3\n#&gt; 50                                    &            3\n#&gt; 51                                    |            3\n#&gt; 52                           as.logical            3\n#&gt; 53                                cbind            3\n#&gt; 54                           dimnames&lt;-            3\n#&gt; 55                           is.numeric            3\n#&gt; 56                                kappa            3\n#&gt; 57                               levels            3\n#&gt; 58                             levels&lt;-            3\n#&gt; 59                                   ls            3\n#&gt; 60                                match            3\n#&gt; 61                                merge            3\n#&gt; 62                               pretty            3\n#&gt; 63                          row.names&lt;-            3\n#&gt; 64                                  seq            3\n#&gt; 65                                 sort            3\n#&gt; 66                            transform            3\n#&gt; 67                                    *            2\n#&gt; 68                                    /            2\n#&gt; 69                                aperm            2\n#&gt; 70                           as.integer            2\n#&gt; 71                             as.table            2\n#&gt; 72                               body&lt;-            2\n#&gt; 73                                   by            2\n#&gt; 74                                dim&lt;-            2\n#&gt; 75                             dimnames            2\n#&gt; 76                                  dir            2\n#&gt; 77                                 drop            2\n#&gt; 78                           droplevels            2\n#&gt; 79             getDLLRegisteredRoutines            2\n#&gt; 80                            intersect            2\n#&gt; 81                            is.finite            2\n#&gt; 82                          is.infinite            2\n#&gt; 83                               is.nan            2\n#&gt; 84                               julian            2\n#&gt; 85                              library            2\n#&gt; 86                                 list            2\n#&gt; 87                                  max            2\n#&gt; 88                                  min            2\n#&gt; 89                               months            2\n#&gt; 90                                   qr            2\n#&gt; 91                             quarters            2\n#&gt; 92                                range            2\n#&gt; 93                                rbind            2\n#&gt; 94                                  rev            2\n#&gt; 95                                round            2\n#&gt; 96                            row.names            2\n#&gt; 97                               rowsum            2\n#&gt; 98                              setdiff            2\n#&gt; 99                             setequal            2\n#&gt; 100                               solve            2\n#&gt; 101                             split&lt;-            2\n#&gt; 102                              system            2\n#&gt; 103                               trunc            2\n#&gt; 104                               union            2\n#&gt; 105                              unlist            2\n#&gt; 106                            weekdays            2\n#&gt; 107                               which            2\n#&gt; 108                              within            2\n#&gt; 109                                  !=            1\n#&gt; 110                                 %/%            1\n#&gt; 111                                  %%            1\n#&gt; 112                                   ^            1\n#&gt; 113                                   &lt;            1\n#&gt; 114                                  &lt;=            1\n#&gt; 115                                  ==            1\n#&gt; 116                                   &gt;            1\n#&gt; 117                                  &gt;=            1\n#&gt; 118                            as.array            1\n#&gt; 119                      as.environment            1\n#&gt; 120                       as.expression            1\n#&gt; 121                         as.function            1\n#&gt; 122                             as.null            1\n#&gt; 123                           as.single            1\n#&gt; 124                                attr            1\n#&gt; 125                                chol            1\n#&gt; 126                     chooseOpsMethod            1\n#&gt; 127                       conditionCall            1\n#&gt; 128                         determinant            1\n#&gt; 129                                 dim            1\n#&gt; 130                                dump            1\n#&gt; 131                                eval            1\n#&gt; 132                              factor            1\n#&gt; 133                               flush            1\n#&gt; 134                                  gc            1\n#&gt; 135                         interaction            1\n#&gt; 136                         isSymmetric            1\n#&gt; 137                           kronecker            1\n#&gt; 138                             lengths            1\n#&gt; 139                       library.dynam            1\n#&gt; 140                               mtfrm            1\n#&gt; 141                         nameOfClass            1\n#&gt; 142                               order            1\n#&gt; 143                                pmax            1\n#&gt; 144                                pmin            1\n#&gt; 145                              remove            1\n#&gt; 146                              sample            1\n#&gt; 147                                save            1\n#&gt; 148                               scale            1\n#&gt; 149                                seek            1\n#&gt; 150                            sequence            1\n#&gt; 151                                sink            1\n#&gt; 152                                 sum            1\n#&gt; 153                            toString            1\n#&gt; 154                            truncate            1\n#&gt; 155                               units            1\n#&gt; 156                             units&lt;-            1\n#&gt; 157                                 url            1\n#&gt; 158                                with            1\n#&gt; 159                              -.Date            0\n#&gt; 160                            -.POSIXt            0\n#&gt; 161                                   :            0\n#&gt; 162                                  ::            0\n#&gt; 163                                 :::            0\n#&gt; 164                           !.hexmode            0\n#&gt; 165                           !.octmode            0\n#&gt; 166                        .__H__.cbind            0\n#&gt; 167                        .__H__.rbind            0\n#&gt; 168                              ...elt            0\n#&gt; 169                           ...length            0\n#&gt; 170                            ...names            0\n#&gt; 171                      ..getNamespace            0\n#&gt; 172                      .amatch_bounds            0\n#&gt; 173                       .amatch_costs            0\n#&gt; 174                            .bincode            0\n#&gt; 175                                  .C            0\n#&gt; 176                        .cache_class            0\n#&gt; 177                               .Call            0\n#&gt; 178                      .Call.graphics            0\n#&gt; 179                       .check_tzones            0\n#&gt; 180                             .class2            0\n#&gt; 181                                .col            0\n#&gt; 182                           .colMeans            0\n#&gt; 183                            .colSums            0\n#&gt; 184                               .Date            0\n#&gt; 185             .decode_numeric_version            0\n#&gt; 186                            .Defunct            0\n#&gt; 187                        .deparseOpts            0\n#&gt; 188                         .Deprecated            0\n#&gt; 189                             .detach            0\n#&gt; 190                           .difftime            0\n#&gt; 191                         .doSortWrap            0\n#&gt; 192                            .doTrace            0\n#&gt; 193                             .doWrap            0\n#&gt; 194                            .dynLibs            0\n#&gt; 195             .encode_numeric_version            0\n#&gt; 196              .expand_R_libs_env_var            0\n#&gt; 197                           .External            0\n#&gt; 198                  .External.graphics            0\n#&gt; 199                          .External2            0\n#&gt; 200                          .First.sys            0\n#&gt; 201                       .format.zeros            0\n#&gt; 202                    .formula2varlist            0\n#&gt; 203                            .Fortran            0\n#&gt; 204                       .getNamespace            0\n#&gt; 205                   .getNamespaceInfo            0\n#&gt; 206                .getRequiredPackages            0\n#&gt; 207               .getRequiredPackages2            0\n#&gt; 208                                 .gt            0\n#&gt; 209                                .gtn            0\n#&gt; 210                  .handleSimpleError            0\n#&gt; 211                           .Internal            0\n#&gt; 212                .isMethodsDispatchOn            0\n#&gt; 213                             .isOpen            0\n#&gt; 214                          .kappa_tri            0\n#&gt; 215                          .kronecker            0\n#&gt; 216                           .libPaths            0\n#&gt; 217               .make_numeric_version            0\n#&gt; 218                        .makeMessage            0\n#&gt; 219                             .mapply            0\n#&gt; 220                          .maskedMsg            0\n#&gt; 221                 .mergeExportMethods            0\n#&gt; 222                 .mergeImportMethods            0\n#&gt; 223                  .NotYetImplemented            0\n#&gt; 224                         .NotYetUsed            0\n#&gt; 225                  .OptRequireMethods            0\n#&gt; 226                           .packages            0\n#&gt; 227              .packageStartupMessage            0\n#&gt; 228                            .POSIXct            0\n#&gt; 229                            .POSIXlt            0\n#&gt; 230                             .pretty            0\n#&gt; 231                          .Primitive            0\n#&gt; 232                          .primTrace            0\n#&gt; 233                        .primUntrace            0\n#&gt; 234                              .rmpkg            0\n#&gt; 235                                .row            0\n#&gt; 236                     .row_names_info            0\n#&gt; 237                           .rowMeans            0\n#&gt; 238                       .rowNamesDF&lt;-            0\n#&gt; 239                            .rowSums            0\n#&gt; 240                           .S3method            0\n#&gt; 241                             .Script            0\n#&gt; 242                      .set_row_names            0\n#&gt; 243                .signalSimpleWarning            0\n#&gt; 244                   .standard_regexps            0\n#&gt; 245                             .subset            0\n#&gt; 246                            .subset2            0\n#&gt; 247                      .TAOCP1997init            0\n#&gt; 248                          .traceback            0\n#&gt; 249                 .tryResumeInterrupt            0\n#&gt; 250                       .valid.factor            0\n#&gt; 251                                   (            0\n#&gt; 252                              [.AsIs            0\n#&gt; 253                        [.data.frame            0\n#&gt; 254                              [.Date            0\n#&gt; 255                          [.difftime            0\n#&gt; 256                             [.Dlist            0\n#&gt; 257                       [.DLLInfoList            0\n#&gt; 258                            [.factor            0\n#&gt; 259                           [.hexmode            0\n#&gt; 260                            [.listof            0\n#&gt; 261                           [.noquote            0\n#&gt; 262                   [.numeric_version            0\n#&gt; 263                           [.octmode            0\n#&gt; 264                           [.POSIXct            0\n#&gt; 265                           [.POSIXlt            0\n#&gt; 266                       [.simple.list            0\n#&gt; 267                             [.table            0\n#&gt; 268                          [.warnings            0\n#&gt; 269                       [[.data.frame            0\n#&gt; 270                             [[.Date            0\n#&gt; 271                           [[.factor            0\n#&gt; 272                  [[.numeric_version            0\n#&gt; 273                          [[.POSIXct            0\n#&gt; 274                          [[.POSIXlt            0\n#&gt; 275                     [[&lt;-.data.frame            0\n#&gt; 276                         [[&lt;-.factor            0\n#&gt; 277                [[&lt;-.numeric_version            0\n#&gt; 278                        [[&lt;-.POSIXlt            0\n#&gt; 279                      [&lt;-.data.frame            0\n#&gt; 280                            [&lt;-.Date            0\n#&gt; 281                        [&lt;-.difftime            0\n#&gt; 282                          [&lt;-.factor            0\n#&gt; 283                 [&lt;-.numeric_version            0\n#&gt; 284                         [&lt;-.POSIXct            0\n#&gt; 285                         [&lt;-.POSIXlt            0\n#&gt; 286                                   {            0\n#&gt; 287                                   @            0\n#&gt; 288                                 @&lt;-            0\n#&gt; 289                          *.difftime            0\n#&gt; 290                          /.difftime            0\n#&gt; 291                           &.hexmode            0\n#&gt; 292                           &.octmode            0\n#&gt; 293                                  &&            0\n#&gt; 294                                 %*%            0\n#&gt; 295                                %in%            0\n#&gt; 296                                 %o%            0\n#&gt; 297                                 %x%            0\n#&gt; 298                              +.Date            0\n#&gt; 299                            +.POSIXt            0\n#&gt; 300                                  &lt;-            0\n#&gt; 301                                 &lt;&lt;-            0\n#&gt; 302                                   =            0\n#&gt; 303                           |.hexmode            0\n#&gt; 304                           |.octmode            0\n#&gt; 305                                  ||            0\n#&gt; 306                                   ~            0\n#&gt; 307                           $.DLLInfo            0\n#&gt; 308                   $.package_version            0\n#&gt; 309                      $&lt;-.data.frame            0\n#&gt; 310                         $&lt;-.POSIXlt            0\n#&gt; 311                          abbreviate            0\n#&gt; 312                                 abs            0\n#&gt; 313                                acos            0\n#&gt; 314                               acosh            0\n#&gt; 315               activeBindingFunction            0\n#&gt; 316                               addNA            0\n#&gt; 317                     addTaskCallback            0\n#&gt; 318                               agrep            0\n#&gt; 319                              agrepl            0\n#&gt; 320                               alist            0\n#&gt; 321                                 all            0\n#&gt; 322                 all.equal.character            0\n#&gt; 323                   all.equal.default            0\n#&gt; 324               all.equal.environment            0\n#&gt; 325               all.equal.envRefClass            0\n#&gt; 326                    all.equal.factor            0\n#&gt; 327                   all.equal.formula            0\n#&gt; 328                  all.equal.function            0\n#&gt; 329                  all.equal.language            0\n#&gt; 330                      all.equal.list            0\n#&gt; 331                   all.equal.numeric            0\n#&gt; 332                    all.equal.POSIXt            0\n#&gt; 333                       all.equal.raw            0\n#&gt; 334                           all.names            0\n#&gt; 335                            all.vars            0\n#&gt; 336                     allowInterrupts            0\n#&gt; 337                                 any            0\n#&gt; 338                 anyDuplicated.array            0\n#&gt; 339            anyDuplicated.data.frame            0\n#&gt; 340               anyDuplicated.default            0\n#&gt; 341                anyDuplicated.matrix            0\n#&gt; 342                    anyNA.data.frame            0\n#&gt; 343               anyNA.numeric_version            0\n#&gt; 344                       anyNA.POSIXlt            0\n#&gt; 345                       aperm.default            0\n#&gt; 346                         aperm.table            0\n#&gt; 347                              append            0\n#&gt; 348                               apply            0\n#&gt; 349                                 Arg            0\n#&gt; 350                                args            0\n#&gt; 351                               array            0\n#&gt; 352                            array2DF            0\n#&gt; 353                            arrayInd            0\n#&gt; 354                    as.array.default            0\n#&gt; 355                             as.call            0\n#&gt; 356              as.character.condition            0\n#&gt; 357                   as.character.Date            0\n#&gt; 358                as.character.default            0\n#&gt; 359                  as.character.error            0\n#&gt; 360                 as.character.factor            0\n#&gt; 361                as.character.hexmode            0\n#&gt; 362        as.character.numeric_version            0\n#&gt; 363                as.character.octmode            0\n#&gt; 364                 as.character.POSIXt            0\n#&gt; 365                 as.character.srcref            0\n#&gt; 366                          as.complex            0\n#&gt; 367                 as.data.frame.array            0\n#&gt; 368                  as.data.frame.AsIs            0\n#&gt; 369             as.data.frame.character            0\n#&gt; 370               as.data.frame.complex            0\n#&gt; 371            as.data.frame.data.frame            0\n#&gt; 372                  as.data.frame.Date            0\n#&gt; 373               as.data.frame.default            0\n#&gt; 374              as.data.frame.difftime            0\n#&gt; 375                as.data.frame.factor            0\n#&gt; 376               as.data.frame.integer            0\n#&gt; 377                  as.data.frame.list            0\n#&gt; 378               as.data.frame.logical            0\n#&gt; 379                as.data.frame.matrix            0\n#&gt; 380          as.data.frame.model.matrix            0\n#&gt; 381               as.data.frame.noquote            0\n#&gt; 382               as.data.frame.numeric            0\n#&gt; 383       as.data.frame.numeric_version            0\n#&gt; 384               as.data.frame.ordered            0\n#&gt; 385               as.data.frame.POSIXct            0\n#&gt; 386               as.data.frame.POSIXlt            0\n#&gt; 387                   as.data.frame.raw            0\n#&gt; 388                 as.data.frame.table            0\n#&gt; 389                    as.data.frame.ts            0\n#&gt; 390                as.data.frame.vector            0\n#&gt; 391                   as.Date.character            0\n#&gt; 392                     as.Date.default            0\n#&gt; 393                      as.Date.factor            0\n#&gt; 394                     as.Date.numeric            0\n#&gt; 395                     as.Date.POSIXct            0\n#&gt; 396                     as.Date.POSIXlt            0\n#&gt; 397                         as.difftime            0\n#&gt; 398                  as.double.difftime            0\n#&gt; 399                   as.double.POSIXlt            0\n#&gt; 400               as.expression.default            0\n#&gt; 401                           as.factor            0\n#&gt; 402                 as.function.default            0\n#&gt; 403                          as.hexmode            0\n#&gt; 404                  as.list.data.frame            0\n#&gt; 405                        as.list.Date            0\n#&gt; 406                     as.list.default            0\n#&gt; 407                    as.list.difftime            0\n#&gt; 408                 as.list.environment            0\n#&gt; 409                      as.list.factor            0\n#&gt; 410                    as.list.function            0\n#&gt; 411             as.list.numeric_version            0\n#&gt; 412                     as.list.POSIXct            0\n#&gt; 413                     as.list.POSIXlt            0\n#&gt; 414                   as.logical.factor            0\n#&gt; 415                as.matrix.data.frame            0\n#&gt; 416                   as.matrix.default            0\n#&gt; 417                   as.matrix.noquote            0\n#&gt; 418                   as.matrix.POSIXlt            0\n#&gt; 419                             as.name            0\n#&gt; 420                     as.null.default            0\n#&gt; 421                          as.numeric            0\n#&gt; 422                  as.numeric_version            0\n#&gt; 423                          as.octmode            0\n#&gt; 424                          as.ordered            0\n#&gt; 425                  as.package_version            0\n#&gt; 426                         as.pairlist            0\n#&gt; 427                     as.POSIXct.Date            0\n#&gt; 428                  as.POSIXct.default            0\n#&gt; 429                  as.POSIXct.numeric            0\n#&gt; 430                  as.POSIXct.POSIXlt            0\n#&gt; 431                as.POSIXlt.character            0\n#&gt; 432                     as.POSIXlt.Date            0\n#&gt; 433                  as.POSIXlt.default            0\n#&gt; 434                   as.POSIXlt.factor            0\n#&gt; 435                  as.POSIXlt.numeric            0\n#&gt; 436                  as.POSIXlt.POSIXct            0\n#&gt; 437                               as.qr            0\n#&gt; 438                              as.raw            0\n#&gt; 439                   as.single.default            0\n#&gt; 440                           as.symbol            0\n#&gt; 441                    as.table.default            0\n#&gt; 442                as.vector.data.frame            0\n#&gt; 443                    as.vector.factor            0\n#&gt; 444                   as.vector.POSIXlt            0\n#&gt; 445                                asin            0\n#&gt; 446                               asinh            0\n#&gt; 447                         asNamespace            0\n#&gt; 448                              asplit            0\n#&gt; 449                                asS3            0\n#&gt; 450                                asS4            0\n#&gt; 451                              assign            0\n#&gt; 452                                atan            0\n#&gt; 453                               atan2            0\n#&gt; 454                               atanh            0\n#&gt; 455                              attach            0\n#&gt; 456                     attachNamespace            0\n#&gt; 457                      attr.all.equal            0\n#&gt; 458                              attr&lt;-            0\n#&gt; 459                          attributes            0\n#&gt; 460                        attributes&lt;-            0\n#&gt; 461                            autoload            0\n#&gt; 462                          autoloader            0\n#&gt; 463                           backsolve            0\n#&gt; 464                      balancePOSIXlt            0\n#&gt; 465                             baseenv            0\n#&gt; 466                            basename            0\n#&gt; 467                             besselI            0\n#&gt; 468                             besselJ            0\n#&gt; 469                             besselK            0\n#&gt; 470                             besselY            0\n#&gt; 471                                beta            0\n#&gt; 472                     bindingIsActive            0\n#&gt; 473                     bindingIsLocked            0\n#&gt; 474                      bindtextdomain            0\n#&gt; 475                             bitwAnd            0\n#&gt; 476                             bitwNot            0\n#&gt; 477                              bitwOr            0\n#&gt; 478                          bitwShiftL            0\n#&gt; 479                          bitwShiftR            0\n#&gt; 480                             bitwXor            0\n#&gt; 481                                body            0\n#&gt; 482                              bquote            0\n#&gt; 483                               break            0\n#&gt; 484                             browser            0\n#&gt; 485                    browserCondition            0\n#&gt; 486                     browserSetDebug            0\n#&gt; 487                         browserText            0\n#&gt; 488                            builtins            0\n#&gt; 489                       by.data.frame            0\n#&gt; 490                          by.default            0\n#&gt; 491                              bzfile            0\n#&gt; 492                              c.Date            0\n#&gt; 493                          c.difftime            0\n#&gt; 494                            c.factor            0\n#&gt; 495                           c.noquote            0\n#&gt; 496                   c.numeric_version            0\n#&gt; 497                           c.POSIXct            0\n#&gt; 498                           c.POSIXlt            0\n#&gt; 499                          c.warnings            0\n#&gt; 500                                call            0\n#&gt; 501                              callCC            0\n#&gt; 502                        capabilities            0\n#&gt; 503                            casefold            0\n#&gt; 504                                 cat            0\n#&gt; 505                    cbind.data.frame            0\n#&gt; 506                             ceiling            0\n#&gt; 507                         char.expand            0\n#&gt; 508                           character            0\n#&gt; 509                           charmatch            0\n#&gt; 510                           charToRaw            0\n#&gt; 511                              chartr            0\n#&gt; 512                             chkDots            0\n#&gt; 513                        chol.default            0\n#&gt; 514                            chol2inv            0\n#&gt; 515                              choose            0\n#&gt; 516             chooseOpsMethod.default            0\n#&gt; 517                               class            0\n#&gt; 518                             class&lt;-            0\n#&gt; 519                       clearPushBack            0\n#&gt; 520                    close.connection            0\n#&gt; 521                       close.srcfile            0\n#&gt; 522                  close.srcfilealias            0\n#&gt; 523                 closeAllConnections            0\n#&gt; 524                                 col            0\n#&gt; 525                            colMeans            0\n#&gt; 526                            colnames            0\n#&gt; 527                          colnames&lt;-            0\n#&gt; 528                             colSums            0\n#&gt; 529                         commandArgs            0\n#&gt; 530                             comment            0\n#&gt; 531                           comment&lt;-            0\n#&gt; 532                             complex            0\n#&gt; 533                     computeRestarts            0\n#&gt; 534             conditionCall.condition            0\n#&gt; 535          conditionMessage.condition            0\n#&gt; 536                       conflictRules            0\n#&gt; 537                           conflicts            0\n#&gt; 538                                Conj            0\n#&gt; 539                        contributors            0\n#&gt; 540                                 cos            0\n#&gt; 541                                cosh            0\n#&gt; 542                               cospi            0\n#&gt; 543                           crossprod            0\n#&gt; 544                         Cstack_info            0\n#&gt; 545                              cummax            0\n#&gt; 546                              cummin            0\n#&gt; 547                             cumprod            0\n#&gt; 548                              cumsum            0\n#&gt; 549                      curlGetHeaders            0\n#&gt; 550                            cut.Date            0\n#&gt; 551                         cut.default            0\n#&gt; 552                          cut.POSIXt            0\n#&gt; 553                          data.class            0\n#&gt; 554                          data.frame            0\n#&gt; 555                         data.matrix            0\n#&gt; 556                                date            0\n#&gt; 557                               debug            0\n#&gt; 558                      debuggingState            0\n#&gt; 559                           debugonce            0\n#&gt; 560            default.stringsAsFactors            0\n#&gt; 561                       delayedAssign            0\n#&gt; 562                             deparse            0\n#&gt; 563                            deparse1            0\n#&gt; 564                                 det            0\n#&gt; 565                              detach            0\n#&gt; 566                  determinant.matrix            0\n#&gt; 567                                dget            0\n#&gt; 568                                diag            0\n#&gt; 569                              diag&lt;-            0\n#&gt; 570                           diff.Date            0\n#&gt; 571                        diff.default            0\n#&gt; 572                       diff.difftime            0\n#&gt; 573                         diff.POSIXt            0\n#&gt; 574                            difftime            0\n#&gt; 575                             digamma            0\n#&gt; 576                      dim.data.frame            0\n#&gt; 577                 dimnames.data.frame            0\n#&gt; 578               dimnames&lt;-.data.frame            0\n#&gt; 579                          dir.create            0\n#&gt; 580                          dir.exists            0\n#&gt; 581                             dirname            0\n#&gt; 582                             do.call            0\n#&gt; 583                           dontCheck            0\n#&gt; 584                              double            0\n#&gt; 585                                dput            0\n#&gt; 586                              dQuote            0\n#&gt; 587               droplevels.data.frame            0\n#&gt; 588                   droplevels.factor            0\n#&gt; 589                    duplicated.array            0\n#&gt; 590               duplicated.data.frame            0\n#&gt; 591                  duplicated.default            0\n#&gt; 592                   duplicated.matrix            0\n#&gt; 593          duplicated.numeric_version            0\n#&gt; 594                  duplicated.POSIXlt            0\n#&gt; 595                 duplicated.warnings            0\n#&gt; 596                            dyn.load            0\n#&gt; 597                          dyn.unload            0\n#&gt; 598                              dynGet            0\n#&gt; 599                              eapply            0\n#&gt; 600                               eigen            0\n#&gt; 601                            emptyenv            0\n#&gt; 602                          enc2native            0\n#&gt; 603                            enc2utf8            0\n#&gt; 604                        encodeString            0\n#&gt; 605                            Encoding            0\n#&gt; 606                          Encoding&lt;-            0\n#&gt; 607                            endsWith            0\n#&gt; 608                             enquote            0\n#&gt; 609                         env.profile            0\n#&gt; 610                         environment            0\n#&gt; 611                       environment&lt;-            0\n#&gt; 612                 environmentIsLocked            0\n#&gt; 613                     environmentName            0\n#&gt; 614                      errorCondition            0\n#&gt; 615                         eval.parent            0\n#&gt; 616                               evalq            0\n#&gt; 617                              exists            0\n#&gt; 618                                 exp            0\n#&gt; 619                         expand.grid            0\n#&gt; 620                               expm1            0\n#&gt; 621                          expression            0\n#&gt; 622                      extSoftVersion            0\n#&gt; 623                           factorial            0\n#&gt; 624                                fifo            0\n#&gt; 625                         file.access            0\n#&gt; 626                         file.append            0\n#&gt; 627                         file.choose            0\n#&gt; 628                           file.copy            0\n#&gt; 629                         file.create            0\n#&gt; 630                         file.exists            0\n#&gt; 631                           file.info            0\n#&gt; 632                           file.link            0\n#&gt; 633                           file.mode            0\n#&gt; 634                          file.mtime            0\n#&gt; 635                           file.path            0\n#&gt; 636                         file.remove            0\n#&gt; 637                         file.rename            0\n#&gt; 638                           file.show            0\n#&gt; 639                           file.size            0\n#&gt; 640                        file.symlink            0\n#&gt; 641                              Filter            0\n#&gt; 642                                Find            0\n#&gt; 643                        find.package            0\n#&gt; 644                        findInterval            0\n#&gt; 645                      findPackageEnv            0\n#&gt; 646                         findRestart            0\n#&gt; 647                               floor            0\n#&gt; 648                    flush.connection            0\n#&gt; 649                                 for            0\n#&gt; 650                               force            0\n#&gt; 651                        forceAndCall            0\n#&gt; 652                             formals            0\n#&gt; 653                           formals&lt;-            0\n#&gt; 654                         format.AsIs            0\n#&gt; 655                   format.data.frame            0\n#&gt; 656                         format.Date            0\n#&gt; 657                      format.default            0\n#&gt; 658                     format.difftime            0\n#&gt; 659                       format.factor            0\n#&gt; 660                      format.hexmode            0\n#&gt; 661                         format.info            0\n#&gt; 662                   format.libraryIQR            0\n#&gt; 663              format.numeric_version            0\n#&gt; 664                      format.octmode            0\n#&gt; 665                  format.packageInfo            0\n#&gt; 666                      format.POSIXct            0\n#&gt; 667                      format.POSIXlt            0\n#&gt; 668                         format.pval            0\n#&gt; 669               format.summaryDefault            0\n#&gt; 670                             formatC            0\n#&gt; 671                            formatDL            0\n#&gt; 672                        forwardsolve            0\n#&gt; 673                            function            0\n#&gt; 674                               gamma            0\n#&gt; 675                             gc.time            0\n#&gt; 676                              gcinfo            0\n#&gt; 677                           gctorture            0\n#&gt; 678                          gctorture2            0\n#&gt; 679                                 get            0\n#&gt; 680                                get0            0\n#&gt; 681                   getAllConnections            0\n#&gt; 682                       getCallingDLL            0\n#&gt; 683                      getCallingDLLe            0\n#&gt; 684                       getConnection            0\n#&gt; 685  getDLLRegisteredRoutines.character            0\n#&gt; 686    getDLLRegisteredRoutines.DLLInfo            0\n#&gt; 687                          getElement            0\n#&gt; 688                       geterrmessage            0\n#&gt; 689                    getExportedValue            0\n#&gt; 690                             getHook            0\n#&gt; 691                       getLoadedDLLs            0\n#&gt; 692                        getNamespace            0\n#&gt; 693                 getNamespaceExports            0\n#&gt; 694                 getNamespaceImports            0\n#&gt; 695                    getNamespaceInfo            0\n#&gt; 696                    getNamespaceName            0\n#&gt; 697                   getNamespaceUsers            0\n#&gt; 698                 getNamespaceVersion            0\n#&gt; 699                 getNativeSymbolInfo            0\n#&gt; 700                           getOption            0\n#&gt; 701                         getRversion            0\n#&gt; 702                         getSrcLines            0\n#&gt; 703                getTaskCallbackNames            0\n#&gt; 704                             gettext            0\n#&gt; 705                            gettextf            0\n#&gt; 706                               getwd            0\n#&gt; 707                                  gl            0\n#&gt; 708               globalCallingHandlers            0\n#&gt; 709                           globalenv            0\n#&gt; 710                            gregexec            0\n#&gt; 711                            gregexpr            0\n#&gt; 712                                grep            0\n#&gt; 713                               grepl            0\n#&gt; 714                             grepRaw            0\n#&gt; 715                            grouping            0\n#&gt; 716                                gsub            0\n#&gt; 717                               gzcon            0\n#&gt; 718                              gzfile            0\n#&gt; 719                                   I            0\n#&gt; 720                               iconv            0\n#&gt; 721                           iconvlist            0\n#&gt; 722                       icuGetCollate            0\n#&gt; 723                       icuSetCollate            0\n#&gt; 724                           identical            0\n#&gt; 725                            identity            0\n#&gt; 726                                  if            0\n#&gt; 727                              ifelse            0\n#&gt; 728                                  Im            0\n#&gt; 729                       importIntoEnv            0\n#&gt; 730                             infoRDS            0\n#&gt; 731                            inherits            0\n#&gt; 732                             integer            0\n#&gt; 733                         interactive            0\n#&gt; 734                           intToBits            0\n#&gt; 735                           intToUtf8            0\n#&gt; 736                         inverse.rle            0\n#&gt; 737                           invisible            0\n#&gt; 738                       invokeRestart            0\n#&gt; 739          invokeRestartInteractively            0\n#&gt; 740                            is.array            0\n#&gt; 741                           is.atomic            0\n#&gt; 742                             is.call            0\n#&gt; 743                        is.character            0\n#&gt; 744                          is.complex            0\n#&gt; 745                       is.data.frame            0\n#&gt; 746                           is.double            0\n#&gt; 747                          is.element            0\n#&gt; 748                      is.environment            0\n#&gt; 749                       is.expression            0\n#&gt; 750                           is.factor            0\n#&gt; 751                   is.finite.POSIXlt            0\n#&gt; 752                         is.function            0\n#&gt; 753                 is.infinite.POSIXlt            0\n#&gt; 754                          is.integer            0\n#&gt; 755                         is.language            0\n#&gt; 756                             is.list            0\n#&gt; 757                           is.loaded            0\n#&gt; 758                          is.logical            0\n#&gt; 759                           is.matrix            0\n#&gt; 760                    is.na.data.frame            0\n#&gt; 761               is.na.numeric_version            0\n#&gt; 762                       is.na.POSIXlt            0\n#&gt; 763                     is.na&lt;-.default            0\n#&gt; 764                      is.na&lt;-.factor            0\n#&gt; 765             is.na&lt;-.numeric_version            0\n#&gt; 766                             is.name            0\n#&gt; 767                      is.nan.POSIXlt            0\n#&gt; 768                             is.null            0\n#&gt; 769                  is.numeric_version            0\n#&gt; 770                     is.numeric.Date            0\n#&gt; 771                 is.numeric.difftime            0\n#&gt; 772                   is.numeric.POSIXt            0\n#&gt; 773                           is.object            0\n#&gt; 774                          is.ordered            0\n#&gt; 775                  is.package_version            0\n#&gt; 776                         is.pairlist            0\n#&gt; 777                        is.primitive            0\n#&gt; 778                               is.qr            0\n#&gt; 779                                is.R            0\n#&gt; 780                              is.raw            0\n#&gt; 781                        is.recursive            0\n#&gt; 782                           is.single            0\n#&gt; 783                           is.symbol            0\n#&gt; 784                            is.table            0\n#&gt; 785                         is.unsorted            0\n#&gt; 786                           is.vector            0\n#&gt; 787                                 isa            0\n#&gt; 788                              isatty            0\n#&gt; 789                     isBaseNamespace            0\n#&gt; 790                          isdebugged            0\n#&gt; 791                             isFALSE            0\n#&gt; 792                        isIncomplete            0\n#&gt; 793                         isNamespace            0\n#&gt; 794                   isNamespaceLoaded            0\n#&gt; 795                             ISOdate            0\n#&gt; 796                         ISOdatetime            0\n#&gt; 797                              isOpen            0\n#&gt; 798                           isRestart            0\n#&gt; 799                                isS4            0\n#&gt; 800                          isSeekable            0\n#&gt; 801                  isSymmetric.matrix            0\n#&gt; 802                              isTRUE            0\n#&gt; 803                              jitter            0\n#&gt; 804                         julian.Date            0\n#&gt; 805                       julian.POSIXt            0\n#&gt; 806                       kappa.default            0\n#&gt; 807                            kappa.lm            0\n#&gt; 808                            kappa.qr            0\n#&gt; 809                           l10n_info            0\n#&gt; 810                          La_library            0\n#&gt; 811                          La_version            0\n#&gt; 812                              La.svd            0\n#&gt; 813                      labels.default            0\n#&gt; 814                              lapply            0\n#&gt; 815                            lazyLoad            0\n#&gt; 816                      lazyLoadDBexec            0\n#&gt; 817                     lazyLoadDBfetch            0\n#&gt; 818                               lbeta            0\n#&gt; 819                             lchoose            0\n#&gt; 820                      length.POSIXlt            0\n#&gt; 821                       length&lt;-.Date            0\n#&gt; 822                   length&lt;-.difftime            0\n#&gt; 823                     length&lt;-.factor            0\n#&gt; 824                    length&lt;-.POSIXct            0\n#&gt; 825                    length&lt;-.POSIXlt            0\n#&gt; 826                      levels.default            0\n#&gt; 827                     levels&lt;-.factor            0\n#&gt; 828                          lfactorial            0\n#&gt; 829                              lgamma            0\n#&gt; 830                      libcurlVersion            0\n#&gt; 831                library.dynam.unload            0\n#&gt; 832                             licence            0\n#&gt; 833                             license            0\n#&gt; 834                           list.dirs            0\n#&gt; 835                          list.files            0\n#&gt; 836                             list2DF            0\n#&gt; 837                            list2env            0\n#&gt; 838                                load            0\n#&gt; 839                    loadedNamespaces            0\n#&gt; 840                loadingNamespaceInfo            0\n#&gt; 841                       loadNamespace            0\n#&gt; 842                               local            0\n#&gt; 843                         lockBinding            0\n#&gt; 844                     lockEnvironment            0\n#&gt; 845                                 log            0\n#&gt; 846                               log10            0\n#&gt; 847                               log1p            0\n#&gt; 848                                log2            0\n#&gt; 849                                logb            0\n#&gt; 850                             logical            0\n#&gt; 851                           lower.tri            0\n#&gt; 852                          make.names            0\n#&gt; 853                         make.unique            0\n#&gt; 854                   makeActiveBinding            0\n#&gt; 855                                 Map            0\n#&gt; 856                              mapply            0\n#&gt; 857                        margin.table            0\n#&gt; 858                          marginSums            0\n#&gt; 859                          mat.or.vec            0\n#&gt; 860                           match.arg            0\n#&gt; 861                          match.call            0\n#&gt; 862                           match.fun            0\n#&gt; 863                     Math.data.frame            0\n#&gt; 864                           Math.Date            0\n#&gt; 865                       Math.difftime            0\n#&gt; 866                         Math.factor            0\n#&gt; 867                         Math.POSIXt            0\n#&gt; 868                              matrix            0\n#&gt; 869                             max.col            0\n#&gt; 870                           mean.Date            0\n#&gt; 871                        mean.default            0\n#&gt; 872                       mean.difftime            0\n#&gt; 873                        mean.POSIXct            0\n#&gt; 874                        mean.POSIXlt            0\n#&gt; 875                        mem.maxNSize            0\n#&gt; 876                        mem.maxVSize            0\n#&gt; 877                         memCompress            0\n#&gt; 878                       memDecompress            0\n#&gt; 879                      memory.profile            0\n#&gt; 880                    merge.data.frame            0\n#&gt; 881                       merge.default            0\n#&gt; 882                             message            0\n#&gt; 883                                mget            0\n#&gt; 884                             missing            0\n#&gt; 885                                 Mod            0\n#&gt; 886                                mode            0\n#&gt; 887                              mode&lt;-            0\n#&gt; 888                         months.Date            0\n#&gt; 889                       months.POSIXt            0\n#&gt; 890                    mostattributes&lt;-            0\n#&gt; 891                       mtfrm.default            0\n#&gt; 892                 nameOfClass.default            0\n#&gt; 893                       names.POSIXlt            0\n#&gt; 894                     names&lt;-.POSIXlt            0\n#&gt; 895                     namespaceExport            0\n#&gt; 896                     namespaceImport            0\n#&gt; 897              namespaceImportClasses            0\n#&gt; 898                 namespaceImportFrom            0\n#&gt; 899              namespaceImportMethods            0\n#&gt; 900                               nargs            0\n#&gt; 901                               nchar            0\n#&gt; 902                                ncol            0\n#&gt; 903                                NCOL            0\n#&gt; 904                              Negate            0\n#&gt; 905                             new.env            0\n#&gt; 906                                next            0\n#&gt; 907                          NextMethod            0\n#&gt; 908                            ngettext            0\n#&gt; 909                             nlevels            0\n#&gt; 910                             noquote            0\n#&gt; 911                                norm            0\n#&gt; 912                       normalizePath            0\n#&gt; 913                                nrow            0\n#&gt; 914                                NROW            0\n#&gt; 915                            nullfile            0\n#&gt; 916                             numeric            0\n#&gt; 917                     numeric_version            0\n#&gt; 918                           numToBits            0\n#&gt; 919                           numToInts            0\n#&gt; 920                              nzchar            0\n#&gt; 921                             objects            0\n#&gt; 922                            oldClass            0\n#&gt; 923                          oldClass&lt;-            0\n#&gt; 924                          OlsonNames            0\n#&gt; 925                             on.exit            0\n#&gt; 926                     open.connection            0\n#&gt; 927                        open.srcfile            0\n#&gt; 928                   open.srcfilealias            0\n#&gt; 929                    open.srcfilecopy            0\n#&gt; 930                      Ops.data.frame            0\n#&gt; 931                            Ops.Date            0\n#&gt; 932                        Ops.difftime            0\n#&gt; 933                          Ops.factor            0\n#&gt; 934                 Ops.numeric_version            0\n#&gt; 935                         Ops.ordered            0\n#&gt; 936                          Ops.POSIXt            0\n#&gt; 937                             options            0\n#&gt; 938                             ordered            0\n#&gt; 939                               outer            0\n#&gt; 940                     package_version            0\n#&gt; 941                        packageEvent            0\n#&gt; 942                 packageHasNamespace            0\n#&gt; 943                packageNotFoundError            0\n#&gt; 944               packageStartupMessage            0\n#&gt; 945                            packBits            0\n#&gt; 946                            pairlist            0\n#&gt; 947                          parent.env            0\n#&gt; 948                        parent.env&lt;-            0\n#&gt; 949                        parent.frame            0\n#&gt; 950                               parse            0\n#&gt; 951                  parseNamespaceFile            0\n#&gt; 952                               paste            0\n#&gt; 953                              paste0            0\n#&gt; 954                         path.expand            0\n#&gt; 955                        path.package            0\n#&gt; 956                         pcre_config            0\n#&gt; 957                                pipe            0\n#&gt; 958                              pmatch            0\n#&gt; 959                            pmax.int            0\n#&gt; 960                            pmin.int            0\n#&gt; 961                            polyroot            0\n#&gt; 962                          pos.to.env            0\n#&gt; 963                            Position            0\n#&gt; 964                      pretty.default            0\n#&gt; 965                           prettyNum            0\n#&gt; 966                          print.AsIs            0\n#&gt; 967                            print.by            0\n#&gt; 968                     print.condition            0\n#&gt; 969                    print.connection            0\n#&gt; 970                    print.data.frame            0\n#&gt; 971                          print.Date            0\n#&gt; 972                       print.default            0\n#&gt; 973                      print.difftime            0\n#&gt; 974                         print.Dlist            0\n#&gt; 975                       print.DLLInfo            0\n#&gt; 976                   print.DLLInfoList            0\n#&gt; 977         print.DLLRegisteredRoutines            0\n#&gt; 978                         print.eigen            0\n#&gt; 979                        print.factor            0\n#&gt; 980                      print.function            0\n#&gt; 981                       print.hexmode            0\n#&gt; 982                    print.libraryIQR            0\n#&gt; 983                        print.listof            0\n#&gt; 984             print.NativeRoutineList            0\n#&gt; 985                       print.noquote            0\n#&gt; 986               print.numeric_version            0\n#&gt; 987                       print.octmode            0\n#&gt; 988                   print.packageInfo            0\n#&gt; 989                       print.POSIXct            0\n#&gt; 990                       print.POSIXlt            0\n#&gt; 991                     print.proc_time            0\n#&gt; 992                       print.restart            0\n#&gt; 993                           print.rle            0\n#&gt; 994                   print.simple.list            0\n#&gt; 995                       print.srcfile            0\n#&gt; 996                        print.srcref            0\n#&gt; 997                 print.summary.table            0\n#&gt; 998              print.summary.warnings            0\n#&gt; 999                print.summaryDefault            0\n#&gt; 1000                        print.table            0\n#&gt; 1001                     print.warnings            0\n#&gt; 1002                           prmatrix            0\n#&gt; 1003                          proc.time            0\n#&gt; 1004                               prod            0\n#&gt; 1005                         prop.table            0\n#&gt; 1006                        proportions            0\n#&gt; 1007                    provideDimnames            0\n#&gt; 1008                           psigamma            0\n#&gt; 1009                           pushBack            0\n#&gt; 1010                     pushBackLength            0\n#&gt; 1011                                  q            0\n#&gt; 1012                            qr.coef            0\n#&gt; 1013                         qr.default            0\n#&gt; 1014                          qr.fitted            0\n#&gt; 1015                               qr.Q            0\n#&gt; 1016                             qr.qty            0\n#&gt; 1017                              qr.qy            0\n#&gt; 1018                               qr.R            0\n#&gt; 1019                           qr.resid            0\n#&gt; 1020                           qr.solve            0\n#&gt; 1021                               qr.X            0\n#&gt; 1022                      quarters.Date            0\n#&gt; 1023                    quarters.POSIXt            0\n#&gt; 1024                               quit            0\n#&gt; 1025                              quote            0\n#&gt; 1026                      R_compiled_by            0\n#&gt; 1027                   R_system_version            0\n#&gt; 1028                             R.home            0\n#&gt; 1029                          R.Version            0\n#&gt; 1030                      range.default            0\n#&gt; 1031                               rank            0\n#&gt; 1032                             rapply            0\n#&gt; 1033                                raw            0\n#&gt; 1034                      rawConnection            0\n#&gt; 1035                 rawConnectionValue            0\n#&gt; 1036                           rawShift            0\n#&gt; 1037                          rawToBits            0\n#&gt; 1038                          rawToChar            0\n#&gt; 1039                   rbind.data.frame            0\n#&gt; 1040                              rcond            0\n#&gt; 1041                                 Re            0\n#&gt; 1042                           read.dcf            0\n#&gt; 1043                            readBin            0\n#&gt; 1044                           readChar            0\n#&gt; 1045                           readline            0\n#&gt; 1046                          readLines            0\n#&gt; 1047                            readRDS            0\n#&gt; 1048                       readRenviron            0\n#&gt; 1049                             Recall            0\n#&gt; 1050                             Reduce            0\n#&gt; 1051                      reg.finalizer            0\n#&gt; 1052                            regexec            0\n#&gt; 1053                            regexpr            0\n#&gt; 1054                   registerS3method            0\n#&gt; 1055                  registerS3methods            0\n#&gt; 1056                         regmatches            0\n#&gt; 1057                       regmatches&lt;-            0\n#&gt; 1058                 removeTaskCallback            0\n#&gt; 1059                            rep_len            0\n#&gt; 1060                           rep.Date            0\n#&gt; 1061                       rep.difftime            0\n#&gt; 1062                         rep.factor            0\n#&gt; 1063                            rep.int            0\n#&gt; 1064                rep.numeric_version            0\n#&gt; 1065                        rep.POSIXct            0\n#&gt; 1066                        rep.POSIXlt            0\n#&gt; 1067                             repeat            0\n#&gt; 1068                            replace            0\n#&gt; 1069                          replicate            0\n#&gt; 1070                            require            0\n#&gt; 1071                   requireNamespace            0\n#&gt; 1072                 restartDescription            0\n#&gt; 1073                     restartFormals            0\n#&gt; 1074                         retracemem            0\n#&gt; 1075                             return            0\n#&gt; 1076                        returnValue            0\n#&gt; 1077                        rev.default            0\n#&gt; 1078                                rle            0\n#&gt; 1079                                 rm            0\n#&gt; 1080                            RNGkind            0\n#&gt; 1081                         RNGversion            0\n#&gt; 1082                         round.Date            0\n#&gt; 1083                       round.POSIXt            0\n#&gt; 1084               row.names.data.frame            0\n#&gt; 1085                  row.names.default            0\n#&gt; 1086             row.names&lt;-.data.frame            0\n#&gt; 1087                row.names&lt;-.default            0\n#&gt; 1088                           rowMeans            0\n#&gt; 1089                           rownames            0\n#&gt; 1090                         rownames&lt;-            0\n#&gt; 1091                  rowsum.data.frame            0\n#&gt; 1092                     rowsum.default            0\n#&gt; 1093                            rowSums            0\n#&gt; 1094                         sample.int            0\n#&gt; 1095                             sapply            0\n#&gt; 1096                         save.image            0\n#&gt; 1097                            saveRDS            0\n#&gt; 1098                      scale.default            0\n#&gt; 1099                               scan            0\n#&gt; 1100                             search            0\n#&gt; 1101                        searchpaths            0\n#&gt; 1102                    seek.connection            0\n#&gt; 1103                          seq_along            0\n#&gt; 1104                            seq_len            0\n#&gt; 1105                           seq.Date            0\n#&gt; 1106                        seq.default            0\n#&gt; 1107                            seq.int            0\n#&gt; 1108                         seq.POSIXt            0\n#&gt; 1109                   sequence.default            0\n#&gt; 1110                          serialize            0\n#&gt; 1111                       serverSocket            0\n#&gt; 1112                           set.seed            0\n#&gt; 1113                            setHook            0\n#&gt; 1114                   setNamespaceInfo            0\n#&gt; 1115                setSessionTimeLimit            0\n#&gt; 1116                       setTimeLimit            0\n#&gt; 1117                              setwd            0\n#&gt; 1118                    showConnections            0\n#&gt; 1119                            shQuote            0\n#&gt; 1120                               sign            0\n#&gt; 1121                    signalCondition            0\n#&gt; 1122                             signif            0\n#&gt; 1123                    simpleCondition            0\n#&gt; 1124                        simpleError            0\n#&gt; 1125                      simpleMessage            0\n#&gt; 1126                      simpleWarning            0\n#&gt; 1127                     simplify2array            0\n#&gt; 1128                                sin            0\n#&gt; 1129                             single            0\n#&gt; 1130                               sinh            0\n#&gt; 1131                        sink.number            0\n#&gt; 1132                              sinpi            0\n#&gt; 1133                        slice.index            0\n#&gt; 1134                       socketAccept            0\n#&gt; 1135                   socketConnection            0\n#&gt; 1136                       socketSelect            0\n#&gt; 1137                      socketTimeout            0\n#&gt; 1138                      solve.default            0\n#&gt; 1139                           solve.qr            0\n#&gt; 1140                       sort.default            0\n#&gt; 1141                           sort.int            0\n#&gt; 1142                          sort.list            0\n#&gt; 1143                       sort.POSIXlt            0\n#&gt; 1144                             source            0\n#&gt; 1145                   split.data.frame            0\n#&gt; 1146                         split.Date            0\n#&gt; 1147                      split.default            0\n#&gt; 1148                      split.POSIXct            0\n#&gt; 1149                 split&lt;-.data.frame            0\n#&gt; 1150                    split&lt;-.default            0\n#&gt; 1151                            sprintf            0\n#&gt; 1152                               sqrt            0\n#&gt; 1153                             sQuote            0\n#&gt; 1154                            srcfile            0\n#&gt; 1155                       srcfilealias            0\n#&gt; 1156                        srcfilecopy            0\n#&gt; 1157                             srcref            0\n#&gt; 1158                    standardGeneric            0\n#&gt; 1159                         startsWith            0\n#&gt; 1160                             stderr            0\n#&gt; 1161                              stdin            0\n#&gt; 1162                             stdout            0\n#&gt; 1163                               stop            0\n#&gt; 1164                          stopifnot            0\n#&gt; 1165                       storage.mode            0\n#&gt; 1166                     storage.mode&lt;-            0\n#&gt; 1167                     str2expression            0\n#&gt; 1168                           str2lang            0\n#&gt; 1169                           strftime            0\n#&gt; 1170                           strptime            0\n#&gt; 1171                             strrep            0\n#&gt; 1172                           strsplit            0\n#&gt; 1173                             strtoi            0\n#&gt; 1174                            strtrim            0\n#&gt; 1175                          structure            0\n#&gt; 1176                            strwrap            0\n#&gt; 1177                                sub            0\n#&gt; 1178                  subset.data.frame            0\n#&gt; 1179                     subset.default            0\n#&gt; 1180                      subset.matrix            0\n#&gt; 1181                         substitute            0\n#&gt; 1182                             substr            0\n#&gt; 1183                           substr&lt;-            0\n#&gt; 1184                          substring            0\n#&gt; 1185                        substring&lt;-            0\n#&gt; 1186                 summary.connection            0\n#&gt; 1187                 summary.data.frame            0\n#&gt; 1188                 Summary.data.frame            0\n#&gt; 1189                       summary.Date            0\n#&gt; 1190                       Summary.Date            0\n#&gt; 1191                    summary.default            0\n#&gt; 1192                   Summary.difftime            0\n#&gt; 1193                     summary.factor            0\n#&gt; 1194                     Summary.factor            0\n#&gt; 1195                     summary.matrix            0\n#&gt; 1196            Summary.numeric_version            0\n#&gt; 1197                    Summary.ordered            0\n#&gt; 1198                    summary.POSIXct            0\n#&gt; 1199                    Summary.POSIXct            0\n#&gt; 1200                    summary.POSIXlt            0\n#&gt; 1201                    Summary.POSIXlt            0\n#&gt; 1202                  summary.proc_time            0\n#&gt; 1203                    summary.srcfile            0\n#&gt; 1204                     summary.srcref            0\n#&gt; 1205                      summary.table            0\n#&gt; 1206                   summary.warnings            0\n#&gt; 1207                   suppressMessages            0\n#&gt; 1208     suppressPackageStartupMessages            0\n#&gt; 1209                   suppressWarnings            0\n#&gt; 1210                  suspendInterrupts            0\n#&gt; 1211                                svd            0\n#&gt; 1212                              sweep            0\n#&gt; 1213                             switch            0\n#&gt; 1214                           sys.call            0\n#&gt; 1215                          sys.calls            0\n#&gt; 1216                          Sys.chmod            0\n#&gt; 1217                           Sys.Date            0\n#&gt; 1218                          sys.frame            0\n#&gt; 1219                         sys.frames            0\n#&gt; 1220                       sys.function            0\n#&gt; 1221                         Sys.getenv            0\n#&gt; 1222                      Sys.getlocale            0\n#&gt; 1223                         Sys.getpid            0\n#&gt; 1224                           Sys.glob            0\n#&gt; 1225                           Sys.info            0\n#&gt; 1226                     sys.load.image            0\n#&gt; 1227                     Sys.localeconv            0\n#&gt; 1228                         sys.nframe            0\n#&gt; 1229                        sys.on.exit            0\n#&gt; 1230                         sys.parent            0\n#&gt; 1231                        sys.parents            0\n#&gt; 1232                       Sys.readlink            0\n#&gt; 1233                     sys.save.image            0\n#&gt; 1234                         Sys.setenv            0\n#&gt; 1235                    Sys.setFileTime            0\n#&gt; 1236                    Sys.setLanguage            0\n#&gt; 1237                      Sys.setlocale            0\n#&gt; 1238                          Sys.sleep            0\n#&gt; 1239                         sys.source            0\n#&gt; 1240                         sys.status            0\n#&gt; 1241                           Sys.time            0\n#&gt; 1242                       Sys.timezone            0\n#&gt; 1243                          Sys.umask            0\n#&gt; 1244                       Sys.unsetenv            0\n#&gt; 1245                          Sys.which            0\n#&gt; 1246                        system.file            0\n#&gt; 1247                        system.time            0\n#&gt; 1248                            system2            0\n#&gt; 1249                       t.data.frame            0\n#&gt; 1250                          t.default            0\n#&gt; 1251                              table            0\n#&gt; 1252                           tabulate            0\n#&gt; 1253                                tan            0\n#&gt; 1254                               tanh            0\n#&gt; 1255                              tanpi            0\n#&gt; 1256                             tapply            0\n#&gt; 1257                taskCallbackManager            0\n#&gt; 1258                         tcrossprod            0\n#&gt; 1259                            tempdir            0\n#&gt; 1260                           tempfile            0\n#&gt; 1261                     textConnection            0\n#&gt; 1262                textConnectionValue            0\n#&gt; 1263                            tolower            0\n#&gt; 1264                             topenv            0\n#&gt; 1265                   toString.default            0\n#&gt; 1266                            toupper            0\n#&gt; 1267                              trace            0\n#&gt; 1268                          traceback            0\n#&gt; 1269                           tracemem            0\n#&gt; 1270                       tracingState            0\n#&gt; 1271               transform.data.frame            0\n#&gt; 1272                  transform.default            0\n#&gt; 1273                           trigamma            0\n#&gt; 1274                             trimws            0\n#&gt; 1275                         trunc.Date            0\n#&gt; 1276                       trunc.POSIXt            0\n#&gt; 1277                truncate.connection            0\n#&gt; 1278                                try            0\n#&gt; 1279                           tryCatch            0\n#&gt; 1280                   tryInvokeRestart            0\n#&gt; 1281                             typeof            0\n#&gt; 1282                     unCfillPOSIXlt            0\n#&gt; 1283                            unclass            0\n#&gt; 1284                            undebug            0\n#&gt; 1285                       unique.array            0\n#&gt; 1286                  unique.data.frame            0\n#&gt; 1287                     unique.default            0\n#&gt; 1288                      unique.matrix            0\n#&gt; 1289             unique.numeric_version            0\n#&gt; 1290                     unique.POSIXlt            0\n#&gt; 1291                    unique.warnings            0\n#&gt; 1292                     units.difftime            0\n#&gt; 1293                   units&lt;-.difftime            0\n#&gt; 1294                          unix.time            0\n#&gt; 1295                             unlink            0\n#&gt; 1296                    unloadNamespace            0\n#&gt; 1297                      unlockBinding            0\n#&gt; 1298                             unname            0\n#&gt; 1299                        unserialize            0\n#&gt; 1300                            unsplit            0\n#&gt; 1301                            untrace            0\n#&gt; 1302                         untracemem            0\n#&gt; 1303                                unz            0\n#&gt; 1304                          upper.tri            0\n#&gt; 1305                          UseMethod            0\n#&gt; 1306                          utf8ToInt            0\n#&gt; 1307                           validEnc            0\n#&gt; 1308                          validUTF8            0\n#&gt; 1309                             vapply            0\n#&gt; 1310                             vector            0\n#&gt; 1311                          Vectorize            0\n#&gt; 1312                            warning            0\n#&gt; 1313                   warningCondition            0\n#&gt; 1314                           warnings            0\n#&gt; 1315                      weekdays.Date            0\n#&gt; 1316                    weekdays.POSIXt            0\n#&gt; 1317                          which.max            0\n#&gt; 1318                          which.min            0\n#&gt; 1319                              while            0\n#&gt; 1320                       with.default            0\n#&gt; 1321                      withAutoprint            0\n#&gt; 1322                withCallingHandlers            0\n#&gt; 1323                  within.data.frame            0\n#&gt; 1324                        within.list            0\n#&gt; 1325                       withRestarts            0\n#&gt; 1326                        withVisible            0\n#&gt; 1327                          write.dcf            0\n#&gt; 1328                           writeBin            0\n#&gt; 1329                          writeChar            0\n#&gt; 1330                         writeLines            0\n#&gt; 1331                                xor            0\n#&gt; 1332                 xpdrows.data.frame            0\n#&gt; 1333                         xtfrm.AsIs            0\n#&gt; 1334                   xtfrm.data.frame            0\n#&gt; 1335                         xtfrm.Date            0\n#&gt; 1336                      xtfrm.default            0\n#&gt; 1337                     xtfrm.difftime            0\n#&gt; 1338                       xtfrm.factor            0\n#&gt; 1339              xtfrm.numeric_version            0\n#&gt; 1340                      xtfrm.POSIXct            0\n#&gt; 1341                      xtfrm.POSIXlt            0\n#&gt; 1342                             xzfile            0\n#&gt; 1343                           zapsmall            0\n\n\nThis brute-force code unsurprisingly identifies print() as having the greatest number of methods. A bug in s3_methods_generic() prevents its use (error below).\nError in gsub(paste0(\"^\", generic_esc, \"[.,]\"), \"\", info$method) : \ninvalid regular expression '^([.,]', reason 'Missing ')''\nAR Solutions: A little experimentation (and thinking about the most popular functions) suggests that the print() generic has the most defined methods.\nLet’s verify this programmatically with the tools we have learned in this and the previous chapters.\n\nls(all.names = TRUE, envir = baseenv()) %&gt;%\n  mget(envir = baseenv()) %&gt;%\n  keep(is_function) %&gt;%\n  names() %&gt;%\n  keep(is_s3_generic) %&gt;%\n  map(~ set_names(nrow(s3_methods_generic(.x)), .x)) %&gt;%\n  flatten_int() %&gt;%\n  sort(decreasing = TRUE) %&gt;%\n  head()\n\n#&gt;         print        format             [       summary  as.character \n#&gt;           276           124            48            39            32 \n#&gt; as.data.frame \n#&gt;            32\n\n\n\n\nCarefully read the documentation for UseMethod() and explain why the following code returns the results that it does. What two usual rules of function evaluation does UseMethod() violate?\n\n\ng &lt;- function(x) {\n  x &lt;- 10\n  y &lt;- 10\n  UseMethod(\"g\")\n}\ng.default &lt;- function(x) c(x = x, y = y)\nx &lt;- 1\ny &lt;- 1\ng(x)\n\n#&gt;  x  y \n#&gt;  1 10\n\n\nAnswer: the documentation states in Technical Details:\n\nUseMethod creates a new function call with arguments matched as they came in to the generic. Any local variables defined before the call to UseMethod are retained (unlike S).\n\nSo, UseMethod() creates a new function call where x matches x &lt;- 1 and the local variable y &lt;- 10 is retained. This is passed to g.default(). This violates both lazy evaluation and lexical scoping.\nAR Solutions: Let’s take this step by step. If you call g.default(x) directly you get c(1, 1) as you might expect.\nThe value bound to x comes from the argument, the value from y comes from the global environment.\nBut when we call g(x) we get c(1, 10).\nThis is seemingly inconsistent: why does x come from the value defined inside of g(), and y still come from the global environment? It’s because UseMethod() calls g.default() in a special way so that variables defined inside the generic are available to methods. The exception are arguments supplied to the function: they are passed on as is and cannot be affected by code inside the generic.\n\n\nWhat are the arguments to [? Why is this a hard question to answer?\n\nAnswer: the possible arguments include the x, the object being extracted (or replaced), indices (i, j, ...), name, drop, exact, and value.\nThis is a hard question to answer since [ is an irregular primitive function that can be called in multiple ways, none of which support using all possible arguments.\nAR Solutions: The subsetting operator [ is a primitive and a generic function, which can be confirmed via ftype().\n\nftype(`[`)\n\n#&gt; [1] \"primitive\" \"generic\"\n\n\nFor primitive functions formals([) returns NULL so we need to find another way to determine the functions arguments. One possible way to figure out [’s arguments would be to inspect the underlying C source code, which can be searched for via pryr::show_c_source(.Primitive(\"[\")). When we inspect the arguments of some of [’s methods, we see that the arguments vary with the class of x.\n\nnames(formals(`[.data.frame`))\n\n#&gt; [1] \"x\"    \"i\"    \"j\"    \"drop\"\n\nnames(formals(`[.table`))\n\n#&gt; [1] \"x\"    \"i\"    \"j\"    \"...\"  \"drop\"\n\nnames(formals(`[.Date`))\n\n#&gt; [1] \"x\"    \"...\"  \"drop\"\n\nnames(formals(`[.AsIs`))\n\n#&gt; [1] \"x\"   \"i\"   \"...\"\n\n\nTo finally get a better overview, we have to put in a little more effort and also use s3_methods_generic() again.\n\ns3_methods_generic(\"[\") %&gt;%\n  filter(visible) %&gt;%\n  mutate(\n    method = paste0(\"[.\", class),\n    argnames = purrr::map(method, ~ names(formals(.x))),\n    args = purrr::map(method, ~ formals(.x)),\n    args = purrr::map2(\n      argnames, args,\n      ~ paste(.x, .y, sep = \" = \")\n    ),\n    args = purrr::set_names(args, method)\n  ) %&gt;%\n  pull(args) %&gt;%\n  head()\n\n#&gt; $`[.AsIs`\n#&gt; [1] \"x = \"   \"i = \"   \"... = \"\n#&gt; \n#&gt; $`[.data.frame`\n#&gt; [1] \"x = \"                                              \n#&gt; [2] \"i = \"                                              \n#&gt; [3] \"j = \"                                              \n#&gt; [4] \"drop = if (missing(i)) TRUE else length(cols) == 1\"\n#&gt; \n#&gt; $`[.Date`\n#&gt; [1] \"x = \"        \"... = \"      \"drop = TRUE\"\n#&gt; \n#&gt; $`[.difftime`\n#&gt; [1] \"x = \"        \"... = \"      \"drop = TRUE\"\n#&gt; \n#&gt; $`[.Dlist`\n#&gt; [1] \"x = \"   \"i = \"   \"... = \"\n#&gt; \n#&gt; $`[.DLLInfoList`\n#&gt; [1] \"x = \"   \"... = \"",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-3",
    "href": "analysis/advanced-r-3.html#exercises-3",
    "title": "Advanced R (Object-oriented programming)",
    "section": "13.5.1 Exercises",
    "text": "13.5.1 Exercises\n\nCategorise the objects returned by lm(), factor(), table(), as.Date(), as.POSIXct(), ecdf(), ordered(), I() into the styles described above.\n\nAnswer:\n\nlm(), ecdf(): scalar\nfactor(), as.Date(), as.POSIXct(), ordered: vector\ntable(): data frame\nI(): same as the source object\n\nAR Solutions: We can categorise the return values into the various object styles by observing how the number of observations is calculated: For vector style classes, length(x) represents the number of observations. Record style objects use a list of equal length elements to represent individual components. For data frames and matrices, the observations are represented by the rows. Scalar style objects use a list to represent a single thing.\nThis leads us to:\n\nVector object-style: factor(), table(), as.Date(), as.POSIXct(), ordered()\nRecord object-style: not observed\nData frame object-style: not observed\nScalar object-style: lm(), ecdf()\n\nThe object style of I() depends on the input since this function returns a “copy of the object with class AsIs prepended to the class(es)”.\n\n\nWhat would a constructor function for lm objects, new_lm(), look like? Use ?lm and experimentation to figure out the required fields and their types.\n\nAnswer: the only required field is formula, provided that the variables listed in the formula exist (and are both vectors). formula must be of type “formula”.\n\nmpg &lt;- pull(mtcars, mpg)\nwt &lt;- pull(mtcars, wt)\nlm(mpg ~ wt)\n\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ wt)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)           wt  \n#&gt;      37.285       -5.344\n\n\nAR Solutions: The constructor needs to populate the attributes of an lm object and check their types for correctness. Let’s start by creating a simple lm object and explore its underlying base type and attributes:\n\nmod &lt;- lm(cyl ~ ., data = mtcars)\ntypeof(mod)\n\n#&gt; [1] \"list\"\n\nattributes(mod)\n\n#&gt; $names\n#&gt;  [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n#&gt;  [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n#&gt;  [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n#&gt; \n#&gt; $class\n#&gt; [1] \"lm\"\n\n\nAs mod is built upon a list, we can simply use map(mod, typeof) to find out the base types of its elements. (Additionally, we inspect ?lm, to learn more about the individual attributes.)\n\nmap_chr(mod, typeof)\n\n#&gt;  coefficients     residuals       effects          rank fitted.values \n#&gt;      \"double\"      \"double\"      \"double\"     \"integer\"      \"double\" \n#&gt;        assign            qr   df.residual       xlevels          call \n#&gt;     \"integer\"        \"list\"     \"integer\"        \"list\"    \"language\" \n#&gt;         terms         model \n#&gt;    \"language\"        \"list\"\n\n\nNow we should have enough information to write a constructor for new lm objects.\n\nnew_lm &lt;- function(coefficients, residuals, effects, rank, fitted.values, assign,\n                   qr, df.residual, xlevels, call, terms, model) {\n  stopifnot(\n    is.double(coefficients), is.double(residuals),\n    is.double(effects), is.integer(rank), is.double(fitted.values),\n    is.integer(assign), is.list(qr), is.integer(df.residual),\n    is.list(xlevels), is.language(call), is.language(terms),\n    is.list(model)\n  )\n\n  structure(\n    list(\n      coefficients = coefficients,\n      residuals = residuals,\n      effects = effects,\n      rank = rank,\n      fitted.values = fitted.values,\n      assign = assign,\n      qr = qr,\n      df.residual = df.residual,\n      xlevels = xlevels,\n      call = call,\n      terms = terms,\n      model = model\n    ),\n    class = \"lm\"\n  )\n}",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-4",
    "href": "analysis/advanced-r-3.html#exercises-4",
    "title": "Advanced R (Object-oriented programming)",
    "section": "13.6.3 Exercises",
    "text": "13.6.3 Exercises\n\nHow does [.Date support subclasses? How does it fail to support subclasses?\n\n\n`[.Date`\n\n#&gt; function (x, ..., drop = TRUE) \n#&gt; {\n#&gt;     .Date(NextMethod(\"[\"), oldClass(x))\n#&gt; }\n#&gt; &lt;bytecode: 0x1577c97e0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n`.Date`\n\n#&gt; function (xx, cl = \"Date\") \n#&gt; `class&lt;-`(xx, cl)\n#&gt; &lt;bytecode: 0x1607e8ac8&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\nAnswer: by passing the object’s class to .Date, [.Date avoids the problem of [.secret and can return subclasses of Date. However, the .Date method can return objects that don’t contain the class Date.\nAR Solutions: [.Date calls .Date with the result of calling [ on the parent class, along with oldClass():\n.Date is kind of like a constructor for date classes, although it doesn’t check the input is the correct type:\noldClass() is basically the same as class(), except that it doesn’t return implicit classes, i.e. it’s basically attr(x, \"class\") (looking at the C code that’s exactly what it does, except that it also handles S4 objects).\nAs oldClass() is “basically” class(), we can rewrite [.Date to make the implementation more clear:\n\n`[.Date` &lt;- function(x, ..., drop = TRUE) {\n  out &lt;- NextMethod(\"[\")\n  class(out) &lt;- class(x)\n  out\n}\n\nSo, [.Date ensures that the output has the same class as in the input. But what about other attributes that a subclass might possess? They get lost:\n\nx &lt;- structure(1:4, test = \"test\", class = c(\"myDate\", \"Date\"))\nattributes(x[1])\n\n#&gt; $class\n#&gt; [1] \"myDate\" \"Date\"\n\n\nNote: this is a better explanation of how it fails to support subclasses; it drops non-class attributes.\n\n\nR has two classes for representing date time data, POSIXct and POSIXlt, which both inherit from POSIXt. Which generics have different behaviours for the two classes? Which generics share the same behaviour?\n\nAnswer: if a generic is defined for either class, it must have different behaviors. Generics that aren’t defined for either class must have the same behavior. We can get the list of generics defined for either class using sloop::s3_methods_class(). These generics have different behaviors for the two classes:\n\nct_generics &lt;- s3_methods_class(\"POSIXct\")$generic\nlt_generics &lt;- s3_methods_class(\"POSIXlt\")$generic\ndefined_generics &lt;- union(ct_generics, lt_generics)\ndefined_generics\n\n#&gt;  [1] \"[\"             \"[[\"            \"[&lt;-\"           \"as.data.frame\"\n#&gt;  [5] \"as.Date\"       \"as.list\"       \"as.POSIXlt\"    \"c\"            \n#&gt;  [9] \"format\"        \"length&lt;-\"      \"mean\"          \"print\"        \n#&gt; [13] \"rep\"           \"split\"         \"summary\"       \"Summary\"      \n#&gt; [17] \"weighted.mean\" \"xtfrm\"         \"[[&lt;-\"          \"$&lt;-\"          \n#&gt; [21] \"anyNA\"         \"as.double\"     \"as.matrix\"     \"as.POSIXct\"   \n#&gt; [25] \"as.vector\"     \"duplicated\"    \"is.finite\"     \"is.infinite\"  \n#&gt; [29] \"is.na\"         \"is.nan\"        \"length\"        \"names\"        \n#&gt; [33] \"names&lt;-\"       \"sort\"          \"unique\"\n\n\nWe adapt work from previous exercises to get the list of all generics, and identify S3 generics that aren’t defined for either class, which must have the same behavior:\n\ns3_generic_funs &lt;- Filter(is_s3_generic, names(funs))\nunion(setdiff(defined_generics, s3_generic_funs), setdiff(s3_generic_funs, defined_generics))\n\n#&gt;   [1] \"Summary\"                  \"weighted.mean\"           \n#&gt;   [3] \"-\"                        \"!=\"                      \n#&gt;   [5] \"*\"                        \"/\"                       \n#&gt;   [7] \"&\"                        \"%/%\"                     \n#&gt;   [9] \"%%\"                       \"^\"                       \n#&gt;  [11] \"+\"                        \"&lt;\"                       \n#&gt;  [13] \"&lt;=\"                       \"==\"                      \n#&gt;  [15] \"&gt;\"                        \"&gt;=\"                      \n#&gt;  [17] \"|\"                        \"$\"                       \n#&gt;  [19] \"abs\"                      \"acos\"                    \n#&gt;  [21] \"acosh\"                    \"all\"                     \n#&gt;  [23] \"all.equal\"                \"any\"                     \n#&gt;  [25] \"anyDuplicated\"            \"aperm\"                   \n#&gt;  [27] \"Arg\"                      \"as.array\"                \n#&gt;  [29] \"as.call\"                  \"as.character\"            \n#&gt;  [31] \"as.complex\"               \"as.environment\"          \n#&gt;  [33] \"as.expression\"            \"as.function\"             \n#&gt;  [35] \"as.integer\"               \"as.logical\"              \n#&gt;  [37] \"as.null\"                  \"as.numeric\"              \n#&gt;  [39] \"as.raw\"                   \"as.single\"               \n#&gt;  [41] \"as.table\"                 \"asin\"                    \n#&gt;  [43] \"asinh\"                    \"atan\"                    \n#&gt;  [45] \"atanh\"                    \"by\"                      \n#&gt;  [47] \"cbind\"                    \"ceiling\"                 \n#&gt;  [49] \"chol\"                     \"chooseOpsMethod\"         \n#&gt;  [51] \"close\"                    \"conditionCall\"           \n#&gt;  [53] \"conditionMessage\"         \"Conj\"                    \n#&gt;  [55] \"cos\"                      \"cosh\"                    \n#&gt;  [57] \"cospi\"                    \"cummax\"                  \n#&gt;  [59] \"cummin\"                   \"cumprod\"                 \n#&gt;  [61] \"cumsum\"                   \"cut\"                     \n#&gt;  [63] \"determinant\"              \"diff\"                    \n#&gt;  [65] \"digamma\"                  \"dim\"                     \n#&gt;  [67] \"dim&lt;-\"                    \"dimnames\"                \n#&gt;  [69] \"dimnames&lt;-\"               \"droplevels\"              \n#&gt;  [71] \"exp\"                      \"expm1\"                   \n#&gt;  [73] \"floor\"                    \"flush\"                   \n#&gt;  [75] \"gamma\"                    \"getDLLRegisteredRoutines\"\n#&gt;  [77] \"Im\"                       \"is.array\"                \n#&gt;  [79] \"is.matrix\"                \"is.na&lt;-\"                 \n#&gt;  [81] \"is.numeric\"               \"isSymmetric\"             \n#&gt;  [83] \"julian\"                   \"kappa\"                   \n#&gt;  [85] \"labels\"                   \"levels\"                  \n#&gt;  [87] \"levels&lt;-\"                 \"lgamma\"                  \n#&gt;  [89] \"log\"                      \"log10\"                   \n#&gt;  [91] \"log1p\"                    \"log2\"                    \n#&gt;  [93] \"max\"                      \"merge\"                   \n#&gt;  [95] \"min\"                      \"Mod\"                     \n#&gt;  [97] \"months\"                   \"mtfrm\"                   \n#&gt;  [99] \"nameOfClass\"              \"open\"                    \n#&gt; [101] \"plot\"                     \"pretty\"                  \n#&gt; [103] \"prod\"                     \"qr\"                      \n#&gt; [105] \"quarters\"                 \"range\"                   \n#&gt; [107] \"rbind\"                    \"Re\"                      \n#&gt; [109] \"rev\"                      \"round\"                   \n#&gt; [111] \"row.names\"                \"row.names&lt;-\"             \n#&gt; [113] \"rowsum\"                   \"scale\"                   \n#&gt; [115] \"seek\"                     \"seq\"                     \n#&gt; [117] \"seq.int\"                  \"sequence\"                \n#&gt; [119] \"sign\"                     \"signif\"                  \n#&gt; [121] \"sin\"                      \"sinh\"                    \n#&gt; [123] \"sinpi\"                    \"solve\"                   \n#&gt; [125] \"split&lt;-\"                  \"sqrt\"                    \n#&gt; [127] \"subset\"                   \"sum\"                     \n#&gt; [129] \"t\"                        \"tan\"                     \n#&gt; [131] \"tanh\"                     \"tanpi\"                   \n#&gt; [133] \"toString\"                 \"transform\"               \n#&gt; [135] \"trigamma\"                 \"trunc\"                   \n#&gt; [137] \"truncate\"                 \"units\"                   \n#&gt; [139] \"units&lt;-\"                  \"unlist\"                  \n#&gt; [141] \"weekdays\"                 \"with\"                    \n#&gt; [143] \"within\"\n\n\nNote: this code doesn’t quite work, since Summary is a generic according to isGeneric and is not according to is_s3_generic, and weighted.mean is a non-base S3 generic.\nAR Solutions: To answer this question, we have to get the respective generics\n\ngenerics_t &lt;- s3_methods_class(\"POSIXt\")$generic\ngenerics_ct &lt;- s3_methods_class(\"POSIXct\")$generic\ngenerics_lt &lt;- s3_methods_class(\"POSIXlt\")$generic\n\nThe generics in generics_t with a method for the superclass POSIXt potentially share the same behaviour for both subclasses. However, if a generic has a specific method for one of the subclasses, it has to be subtracted:\n\n# These generics provide subclass-specific methods\nunion(generics_ct, generics_lt)\n\n#&gt;  [1] \"[\"             \"[[\"            \"[&lt;-\"           \"as.data.frame\"\n#&gt;  [5] \"as.Date\"       \"as.list\"       \"as.POSIXlt\"    \"c\"            \n#&gt;  [9] \"format\"        \"length&lt;-\"      \"mean\"          \"print\"        \n#&gt; [13] \"rep\"           \"split\"         \"summary\"       \"Summary\"      \n#&gt; [17] \"weighted.mean\" \"xtfrm\"         \"[[&lt;-\"          \"$&lt;-\"          \n#&gt; [21] \"anyNA\"         \"as.double\"     \"as.matrix\"     \"as.POSIXct\"   \n#&gt; [25] \"as.vector\"     \"duplicated\"    \"is.finite\"     \"is.infinite\"  \n#&gt; [29] \"is.na\"         \"is.nan\"        \"length\"        \"names\"        \n#&gt; [33] \"names&lt;-\"       \"sort\"          \"unique\"\n\n# These generics share (inherited) methods for both subclasses\nsetdiff(generics_t, union(generics_ct, generics_lt))\n\n#&gt;  [1] \"-\"            \"+\"            \"all.equal\"    \"as.character\" \"Axis\"        \n#&gt;  [6] \"cut\"          \"diff\"         \"hist\"         \"is.numeric\"   \"julian\"      \n#&gt; [11] \"Math\"         \"months\"       \"Ops\"          \"pretty\"       \"quantile\"    \n#&gt; [16] \"quarters\"     \"round\"        \"seq\"          \"str\"          \"trunc\"       \n#&gt; [21] \"weekdays\"\n\n\nNote: again, advanced R gives a better answer to this question, by comparing to the generics supported by the parent class.\n\n\nWhat do you expect this code to return? What does it actually return? Why?\n\n\ngeneric2 &lt;- function(x) UseMethod(\"generic2\")\ngeneric2.a1 &lt;- function(x) \"a1\"\ngeneric2.a2 &lt;- function(x) \"a2\"\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  NextMethod()\n}\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n\n#&gt; [1] \"a2\"\n\n\nAnswer: I’d expect this code to return \"a2\" with a class of c(\"a1\", \"a2\"). It actually returns “a2” with a class of character. This is because when generic2.b calls NextMethod(), generic2.a2 is called which returns a bare \"a2\", dropping the class assigned by generic2.b.\n\nclass(generic2(structure(list(), class = c(\"b\", \"a2\"))))\n\n#&gt; [1] \"character\"\n\n\nAR Solutions: When we execute the code above, this is what is happening:\n\nwe pass an object of classes b and a2 to generic2(), which prompts R to look for a methodgeneric2.b()\nthe method generic2.b() then changes the class to a1 and calls NextMethod()\nOne would think that this will lead R to call generic2.a1(), but in fact, as mentioned in Advanced R, NextMethod() &gt; doesn’t actually work with the class attribute of the object, but instead uses a special global variable (.Class) to keep track of which method to call next.\nThis is why generic2.a2() is called instead.\n\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n\n#&gt; [1] \"a2\"\n\n\nLet’s just double check the statement above and evaluate .Class explicitly within the generic2.b() method.\n\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  print(.Class)\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n\n#&gt; [1] \"b\"  \"a2\"\n\n\n#&gt; [1] \"a2\"",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-5",
    "href": "analysis/advanced-r-3.html#exercises-5",
    "title": "Advanced R (Object-oriented programming)",
    "section": "13.7.5 Exercises",
    "text": "13.7.5 Exercises\n\nExplain the differences in dispatch below:\n\n\nlength.integer &lt;- function(x) 10\n\nx1 &lt;- 1:5\nclass(x1)\n\n#&gt; [1] \"integer\"\n\ns3_dispatch(length(x1))\n\n#&gt;  * length.integer\n#&gt;    length.numeric\n#&gt;    length.default\n#&gt; =&gt; length (internal)\n\nx2 &lt;- structure(x1, class = \"integer\")\nclass(x2)\n\n#&gt; [1] \"integer\"\n\ns3_dispatch(length(x2))\n\n#&gt; =&gt; length.integer\n#&gt;    length.default\n#&gt;  * length (internal)\n\n\nAnswer: x1 dispatches using implicit class, which is c(\"integer\", \"numeric\"). x2 has an explicit class, so it is dispatched to length.integer.\n\ns3_class(x1)\n\n#&gt; [1] \"integer\" \"numeric\"\n\ns3_class(x2)\n\n#&gt; [1] \"integer\"\n\n\nAR Solutions: class() returns integer in both cases. However, while the class of x1 is created implicitly and inherits from the numeric class, the class of x2 is set explicitly. This is important because length() is an internal generic and internal generics only dispatch to methods when the class attribute has been set, i.e. internal generics do not use implicit classes.\nAn object has no explicit class if attr(x, \"class\") returns NULL:\n\nattr(x1, \"class\")\n\n#&gt; NULL\n\nattr(x2, \"class\")\n\n#&gt; [1] \"integer\"\n\n\nTo see the relevant classes for the S3 dispatch, one can use sloop::s3_class():\n\ns3_class(x1) # implicit\n\n#&gt; [1] \"integer\" \"numeric\"\n\ns3_class(x2) # explicit\n\n#&gt; [1] \"integer\"\n\n\nFor a better understanding of s3_dipatch()’s output we quote from ?s3_dispatch: - =&gt; method exists and is found by UseMethod(). - -&gt; method exists and is used by NextMethod(). - * method exists but is not used. - Nothing (and greyed out in console): method does not exist.\nNote: AR Solutions includes an additional important detail, that “internal generics only dispatch to methods when the class attribute has been set”, which explains why the internal generic is used for x1.\n\n\nWhat classes have a method for the Math group generic in base R? Read the source code. How do the methods work?\n\nAnswer: four base classes have a method for Math: data.frame, Date, difftime, factor, and POSIXt.\n\ns3_methods_generic(\"Math\") |&gt;\n  filter(source == \"base\")\n\n#&gt; # A tibble: 5 × 4\n#&gt;   generic class      visible source\n#&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt; \n#&gt; 1 Math    data.frame TRUE    base  \n#&gt; 2 Math    Date       TRUE    base  \n#&gt; 3 Math    difftime   TRUE    base  \n#&gt; 4 Math    factor     TRUE    base  \n#&gt; 5 Math    POSIXt     TRUE    base\n\n\n\nMath.data.frame\n\n#&gt; function (x, ...) \n#&gt; {\n#&gt;     mode.ok &lt;- vapply(x, function(x) is.numeric(x) || is.logical(x) || \n#&gt;         is.complex(x), NA)\n#&gt;     if (all(mode.ok)) {\n#&gt;         x[] &lt;- lapply(X = x, FUN = .Generic, ...)\n#&gt;         return(x)\n#&gt;     }\n#&gt;     else {\n#&gt;         vnames &lt;- names(x)\n#&gt;         if (is.null(vnames)) \n#&gt;             vnames &lt;- seq_along(x)\n#&gt;         stop(\"non-numeric-alike variable(s) in data frame: \", \n#&gt;             paste(vnames[!mode.ok], collapse = \", \"))\n#&gt;     }\n#&gt; }\n#&gt; &lt;bytecode: 0x161599760&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nMath.Date\n\n#&gt; function (x, ...) \n#&gt; stop(gettextf(\"%s not defined for \\\"Date\\\" objects\", .Generic), \n#&gt;     domain = NA)\n#&gt; &lt;bytecode: 0x16159e8c0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nMath.difftime\n\n#&gt; function (x, ...) \n#&gt; {\n#&gt;     switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , \n#&gt;         round = , signif = {\n#&gt;             units &lt;- attr(x, \"units\")\n#&gt;             .difftime(NextMethod(), units)\n#&gt;         }, stop(gettextf(\"'%s' not defined for \\\"difftime\\\" objects\", \n#&gt;             .Generic), domain = NA))\n#&gt; }\n#&gt; &lt;bytecode: 0x16159de78&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nMath.factor\n\n#&gt; function (x, ...) \n#&gt; stop(gettextf(\"%s not meaningful for factors\", sQuote(.Generic)))\n#&gt; &lt;bytecode: 0x1615a3078&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nMath.POSIXt\n\n#&gt; function (x, ...) \n#&gt; {\n#&gt;     stop(gettextf(\"'%s' not defined for \\\"POSIXt\\\" objects\", \n#&gt;         .Generic), domain = NA)\n#&gt; }\n#&gt; &lt;bytecode: 0x1615a2588&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\n\nMath.data.frame performs math if all columns (variables) are either numeric, logical or complex, and errors if any are not\nMath.difftime performs only certain math functions: abs, sign, floor, ceiling, trunc, round, and signif, and errors for other functions\nMath.Date, Math.factor, and Math.POSIXt always error\n\nAR Solutions: : The following functions belong to this group (see ?Math):\n\nabs, sign, sqrt, floor, ceiling, trunc, round, signif\nexp, log, expm1, log1p, cos, sin, tan, cospi, sinpi, tanpi, acos, asin, atan, cosh, sinh, tanh, acosh, asinh, atanh\nlgamma, gamma, digamma, trigamma\ncumsum, cumprod, cummax, cummin\n\nThe following classes have a method for this group generic:\n\ns3_methods_generic(\"Math\")\n\n#&gt; # A tibble: 8 × 4\n#&gt;   generic class      visible source             \n#&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 Math    data.frame TRUE    base               \n#&gt; 2 Math    Date       TRUE    base               \n#&gt; 3 Math    difftime   TRUE    base               \n#&gt; 4 Math    factor     TRUE    base               \n#&gt; 5 Math    POSIXt     TRUE    base               \n#&gt; 6 Math    quosure    FALSE   registered S3method\n#&gt; 7 Math    vctrs_sclr FALSE   registered S3method\n#&gt; 8 Math    vctrs_vctr FALSE   registered S3method\n\n\nTo explain the basic idea, we just overwrite the data frame method:\n\nMath.data.frame &lt;- function(x) \"hello\"\n\nNow all functions from the math generic group, will return \"hello\"\n\nabs(mtcars)\n\n#&gt; [1] \"hello\"\n\nexp(mtcars)\n\n#&gt; [1] \"hello\"\n\nlgamma(mtcars)\n\n#&gt; [1] \"hello\"\n\n\nOf course, different functions should perform different calculations. Here .Generic comes into play, which provides us with the calling generic as a string\n\nMath.data.frame &lt;- function(x, ...) {\n  .Generic\n}\nabs(mtcars)\n\n#&gt; [1] \"abs\"\n\nexp(mtcars)\n\n#&gt; [1] \"exp\"\n\nlgamma(mtcars)\n\n#&gt; [1] \"lgamma\"\n\nrm(Math.data.frame)\n\nThe original source code of Math.data.frame() is a good example on how to invoke the string returned by .Generic into a specific method. Math.factor() is a good example of a method, which is simply defined for better error messages.\nNote: I prefer my answer to the AR Solutions answer.\n\n\nMath.difftime() is more complicated than I described. Why?\n\nAnswer: the explanation in the text omits the fact that Math.difftime() first checks that the math function being called.\nAR Solutions: Math.difftime() also excludes cases apart from abs, sign, floor, ceiling, trunc, round and signif and needs to return a fitting error message.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-6",
    "href": "analysis/advanced-r-3.html#exercises-6",
    "title": "Advanced R (Object-oriented programming)",
    "section": "14.2.6 Exercises",
    "text": "14.2.6 Exercises\n\nCreate a bank account R6 class that stores a balance and allows you to deposit and withdraw money. Create a subclass that throws an error if you attempt to go into overdraft. Create another subclass that allows you to go into overdraft, but charges you a fee.\n\nAnswer: Account stores a balance as an integer value of cents, and prints in dollars (to avoid problems with floating point math).\n\nAccount &lt;- R6Class(\"Account\", list(\n  balance = 0L,\n  initialize = function(balance = 0L) {\n    stopifnot(is.integer(balance), length(balance) == 1)\n    self$balance &lt;- balance\n  },\n  print = function(...) {\n    cat(\"Account: \\n\")\n    cat(\"  Balance: $\", format(self$balance / 100, nsmall = 2), \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  deposit = function(value) {\n    stopifnot(is.integer(value), length(value) == 1)\n    self$balance &lt;- self$balance + value\n    invisible(self)\n  },\n  withdraw = function(value) {\n    stopifnot(is.integer(value), length(value) == 1)\n    self$balance &lt;- self$balance - value\n    invisible(self)\n  }\n))\n\nAccountOverdraft &lt;- R6Class(\"AccountOverdraft\",\n  inherit = Account,\n  public = list(\n    withdraw = function(value) {\n      stopifnot(value &lt;= self$balance)\n      super$withdraw(value)\n    }\n  )\n)\n\nAccountOverdraftFee &lt;- R6Class(\"AccountOverdraftFee\",\n  inherit = Account,\n  public = list(\n    withdraw = function(value) {\n      if (value &gt; self$balance) value &lt;- value + 500L\n      super$withdraw(value)\n    }\n  )\n)\n\ntry(Account$new(1.5))\n\n#&gt; Error in initialize(...) : is.integer(balance) is not TRUE\n\na &lt;- Account$new(100L)\na$deposit(100L)\na$withdraw(250L)\na\n\n#&gt; Account: \n#&gt;   Balance: $-0.50\n\na2 &lt;- AccountOverdraft$new(200L)\ntry(a2$withdraw(250L))\n\n#&gt; Error in a2$withdraw(250L) : value &lt;= self$balance is not TRUE\n\na2$withdraw(150L)\na2\n\n#&gt; Account: \n#&gt;   Balance: $0.50\n\na3 &lt;- AccountOverdraftFee$new(200L)\na3$withdraw(250L)\na3\n\n#&gt; Account: \n#&gt;   Balance: $-5.50\n\n\nAR Solutions: BankAccount is a similar, simpler approach:\n\nBankAccount &lt;- R6Class(\n  classname = \"BankAccount\",\n  public = list(\n    balance = 0,\n    deposit = function(dep = 0) {\n      self$balance &lt;- self$balance + dep\n      invisible(self)\n    },\n    withdraw = function(draw) {\n      self$balance &lt;- self$balance - draw\n      invisible(self)\n    }\n  )\n)\n\nBankAccountStrict &lt;- R6Class(\n  classname = \"BankAccountStrict\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(draw = 0) {\n      if (self$balance - draw &lt; 0) {\n        stop(\"Your `withdraw` must be smaller \",\n          \"than your `balance`.\",\n          call. = FALSE\n        )\n      }\n      super$withdraw(draw = draw)\n    }\n  )\n)\n\nBankAccountCharging &lt;- R6Class(\n  classname = \"BankAccountCharging\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(draw = 0) {\n      if (self$balance - draw &lt; 0) {\n        draw &lt;- draw + 1\n      }\n      super$withdraw(draw = draw)\n    }\n  )\n)\n\nNote: my object name, AccountOverdraftFee is misleading, since it is not a subclass of AccountOverdraft - the R Solutions naming convention is clearer.\n\n\nCreate an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with $draw(n), and return all cards to the deck and reshuffle with $reshuffle(). Use the following code to make a vector of cards.\n\n\nsuit &lt;- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue &lt;- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards &lt;- paste0(rep(value, 4), suit)\n\nAnswer: Cards shuffles the deck using sample(). The draw() function prints the cards drawn and moves them into play.\n\nCards &lt;- R6Class(\"Cards\", list(\n  deck = sample(cards, 52),\n  play = NULL,\n  print = function(...) {\n    cat(\"Cards: \\n\")\n    cat(\"  Deck:\", self$deck, \"\\n\", sep = \" \")\n    cat(\"  Play:\", self$play, \"\\n\", sep = \" \")\n    invisible(self)\n  },\n  draw = function(n = 1L) {\n    stopifnot(is.integer(n), length(n) == 1, n &gt; 0, n &lt;= length(self$deck))\n    d &lt;- head(self$deck, n)\n    self$play &lt;- c(self$play, d)\n    self$deck &lt;- tail(self$deck, -n)\n    invisible(self)\n  },\n  reshuffle = function() {\n    self$deck &lt;- sample(cards, 52)\n    self$play &lt;- NULL\n    invisible(self)\n  }\n))\n\nd &lt;- Cards$new()\nd\n\n#&gt; Cards: \n#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play:\n\ntry(d$draw(1.5))\n\n#&gt; Error in d$draw(1.5) : is.integer(n) is not TRUE\n\ntry(d$draw(0L))\n\n#&gt; Error in d$draw(0L) : n &gt; 0 is not TRUE\n\ntry(d$draw(53L))\n\n#&gt; Error in d$draw(53L) : n &lt;= length(self$deck) is not TRUE\n\nd$draw(13L)\nd\n\n#&gt; Cards: \n#&gt;   Deck: 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠\n\nd$draw(13L)\nd\n\n#&gt; Cards: \n#&gt;   Deck: 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠\n\nd$reshuffle()\nd\n\n#&gt; Cards: \n#&gt;   Deck: K♠ Q♠ 9♠ 4♠ 5♣ 7♥ 10♥ 6♠ A♥ K♣ 8♦ 5♠ 6♣ J♠ J♦ 7♦ 2♠ 6♥ 2♦ 2♣ 10♣ A♣ 4♦ A♠ 8♠ J♥ K♥ 4♣ Q♥ 9♣ 9♥ 3♦ 6♦ 3♠ 8♣ 5♦ A♦ Q♦ 7♠ 3♣ 3♥ 4♥ 7♣ 5♥ J♣ 9♦ 2♥ 10♦ Q♣ 8♥ K♦ 10♠ \n#&gt;   Play:\n\n\nAR Solutions: Our new ShuffledDeck class will use sample() and positive integer subsetting to implement the reshuffling and drawing functionality. We also add a check, so you cannot draw more cards than there are left in the deck.\n\nShuffledDeck &lt;- R6Class(\n  classname = \"ShuffledDeck\",\n  public = list(\n    deck = NULL,\n    initialize = function(deck = cards) {\n      self$deck &lt;- sample(deck)\n    },\n    reshuffle = function() {\n      self$deck &lt;- sample(cards)\n      invisible(self)\n    },\n    n = function() {\n      length(self$deck)\n    },\n    draw = function(n = 1) {\n      if (n &gt; self$n()) {\n        stop(\"Only \", self$n(), \" cards remaining.\", call. = FALSE)\n      }\n\n      output &lt;- self$deck[seq_len(n)]\n      self$deck &lt;- self$deck[-seq_len(n)]\n      output\n    }\n  )\n)\n\nNotes: it seems simpler to set deck directly instead of using an initialize function, although sample(cards) is cleaner. self$n() is a useful function, and the choice of removing and returning cards with draw() is probably a better design. I prefer my approach using head() and tail() over R Solutions use of seq_len().\nBug: per 14.4.3 setting fields directly fixes the order when the class is defined. This results in a bug: Cards has the same starting shuffle for each new object, but ShuffledDeck does not:\n\nCards$new()\n\n#&gt; Cards: \n#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play:\n\nCards$new()\n\n#&gt; Cards: \n#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play:\n\nShuffledDeck$new()$draw(52)\n\n#&gt;  [1] \"K♥\"  \"4♠\"  \"7♥\"  \"9♠\"  \"9♥\"  \"6♥\"  \"Q♦\"  \"4♦\"  \"9♦\"  \"J♦\"  \"A♠\"  \"10♠\"\n#&gt; [13] \"4♥\"  \"K♣\"  \"8♥\"  \"3♠\"  \"8♣\"  \"3♣\"  \"A♦\"  \"6♣\"  \"K♠\"  \"J♠\"  \"3♥\"  \"2♥\" \n#&gt; [25] \"3♦\"  \"5♥\"  \"J♥\"  \"J♣\"  \"2♠\"  \"7♠\"  \"A♥\"  \"5♠\"  \"Q♥\"  \"Q♣\"  \"6♦\"  \"7♦\" \n#&gt; [37] \"10♥\" \"5♣\"  \"5♦\"  \"6♠\"  \"4♣\"  \"2♦\"  \"9♣\"  \"10♣\" \"2♣\"  \"7♣\"  \"K♦\"  \"A♣\" \n#&gt; [49] \"10♦\" \"8♠\"  \"8♦\"  \"Q♠\"\n\nShuffledDeck$new()$draw(52)\n\n#&gt;  [1] \"8♣\"  \"6♠\"  \"3♠\"  \"4♥\"  \"J♥\"  \"Q♣\"  \"J♣\"  \"8♦\"  \"5♦\"  \"K♠\"  \"10♣\" \"K♣\" \n#&gt; [13] \"2♦\"  \"Q♥\"  \"A♦\"  \"9♠\"  \"7♦\"  \"3♥\"  \"7♣\"  \"9♦\"  \"A♥\"  \"J♠\"  \"8♥\"  \"A♣\" \n#&gt; [25] \"8♠\"  \"7♠\"  \"K♥\"  \"5♥\"  \"2♣\"  \"2♥\"  \"5♠\"  \"10♠\" \"3♦\"  \"4♣\"  \"A♠\"  \"Q♠\" \n#&gt; [37] \"9♥\"  \"9♣\"  \"6♥\"  \"10♥\" \"K♦\"  \"7♥\"  \"2♠\"  \"Q♦\"  \"3♣\"  \"10♦\" \"4♠\"  \"6♣\" \n#&gt; [49] \"4♦\"  \"5♣\"  \"6♦\"  \"J♦\"\n\n\n\n\nWhy can’t you model a bank account or a deck of cards with an S3 class?\n\nAnswer: because S3 classes are copied-on-modify, they lack state. R6 classes are stateful since they are modified in-place. Both bank accounts and a deck of cards are stateful objects.\nAR Solutions: Because S3 classes obey R’s usual semantics of copy-on-modify: every time you deposit money into your bank account or draw a card from the deck, you’d get a new copy of the object.\nIt is possible to combine S3 classes with an environment (which is how R6 works), but it is ill-advised to create an object that looks like a regular R object but has reference semantics.\n\n\nCreate an R6 class that allows you to get and set the current time zone. You can access the current time zone with Sys.timezone() and set it with Sys.setenv(TZ = \"newtimezone\"). When setting the time zone, make sure the new time zone is in the list provided by OlsonNames().\n\nAnswer: TimeZone is initialized with the current time zone, stored as tz in the object.\n\norig_tz &lt;- Sys.timezone()\n\nTimeZone &lt;- R6Class(\"TimeZone\", list(\n  tz = Sys.timezone(),\n  get = function() {\n    cat(\"Current time zone: \", self$tz, \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  set = function(tz) {\n    stopifnot(tz %in% OlsonNames())\n    Sys.setenv(TZ = tz)\n    self$tz &lt;- tz\n    cat(\"Set time zone: \", self$tz, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\ntz &lt;- TimeZone$new()\ntz$get()\n\n#&gt; Current time zone: America/Chicago\n\ndate()\n\n#&gt; [1] \"Mon Dec  4 15:10:24 2023\"\n\ntz$set(\"America/New_York\")\n\n#&gt; Set time zone: America/New_York\n\ndate()\n\n#&gt; [1] \"Mon Dec  4 16:10:24 2023\"\n\nSys.setenv(TZ = orig_tz)\n\nBug: like Cards, TimeZone should set tz in initialize().\nAR Solutions: To create an R6 class that allows us to get and set the time zone, we provide the respective functions as public methods to the R6 class.\n\nTimezone &lt;- R6Class(\n  classname = \"Timezone\",\n  public = list(\n    get = function() {\n      Sys.timezone()\n    },\n    set = function(value) {\n      stopifnot(value %in% OlsonNames())\n      old &lt;- self$get()\n      Sys.setenv(TZ = value)\n      invisible(old)\n    }\n  )\n)\n\n(When setting, we return the old value invisibly because this makes it easy to restore the previous value.)\n\n\nCreate an R6 class that manages the current working directory. It should have $get() and $set() methods.\n\nAnswer: similar to TimeZone, WorkingDirectory initializes wd to getwd().\n\norig_wd &lt;- getwd()\n\nWorkingDirectory &lt;- R6Class(\"WorkingDirectory\", list(\n  wd = getwd(),\n  get = function() {\n    cat(\"Current directory: \", self$wd, \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  set = function(dir) {\n    self$wd &lt;- setwd(dir)\n    cat(\"Set directory: \", self$wd, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\nwd &lt;- WorkingDirectory$new()\nwd$get()\n\n#&gt; Current directory: /Users/agamemnon/GitHub/rtraining/analysis\n\nwd$set(\"assets\")\n\n#&gt; Set directory: /Users/agamemnon/GitHub/rtraining/analysis\n\nlist.files()\n\n#&gt; [1] \"extra.css\"       \"recursive-1.png\" \"recursive-2.png\"\n\nsetwd(orig_wd)\n\nAR Solutions: Take a look at the following implementation, which is quite minimalistic:\n\nWorkingDirectory &lt;- R6Class(\n  classname = \"WorkingDirectory\",\n  public = list(\n    get = function() {\n      getwd()\n    },\n    set = function(value) {\n      setwd(value)\n    }\n  )\n)\n\nBug: like Cards, WorkingDirectory should set wd in initialize(). Also, as AR Solutions notes in a comment:\n\nYou should never do get = getwd() etc because in packages, that inlines the function definition at package build time, creating a subtle dependency that will cause bugs that are extremely difficult to track down\n\n\n\nWhy can’t you model the time zone or current working directory with an S3 class?\n\nAnswer: per exercise 3, time zone and current working directory are both stateful.\nAR Solutions: Because S3 classes are not suitable for modelling a state that changes over time. S3 methods should (almost) always return the same result when called with the same inputs.\n\n\nWhat base type are R6 objects built on top of? What attributes do they have?\n\nAnswer: R6n objects are built on environments, and have a class attribute with an S3 hierarchy including the base R6 class, per 14.2.5.\n\ntypeof(tz)\n\n#&gt; [1] \"environment\"\n\nattributes(tz)\n\n#&gt; $class\n#&gt; [1] \"TimeZone\" \"R6\"\n\n\nAR Solutions: R6 objects are built on top of environments. They have a class attribute, which is a character vector containing the class name, the name of any super classes (if existent) and the string \"R6\" as the last element.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-7",
    "href": "analysis/advanced-r-3.html#exercises-7",
    "title": "Advanced R (Object-oriented programming)",
    "section": "14.3.3 Exercises",
    "text": "14.3.3 Exercises\n\nCreate a bank account class that prevents you from directly setting the account balance, but you can still withdraw from and deposit to. Throw an error if you attempt to go into overdraft.\n\nAnswer: SecureAccount uses a private internal balance exposed through an active function.\n\nSecureAccount &lt;- R6Class(\"SecureAccount\",\n  private = list(\n    .balance = 0L\n  ),\n  public = list(\n    deposit = function(value) {\n      stopifnot(is.integer(value), length(value) == 1)\n      private$.balance &lt;- private$.balance + value\n      invisible(self)\n    },\n    withdraw = function(value) {\n      stopifnot(is.integer(value), length(value) == 1, value &lt;= private$.balance)\n      private$.balance &lt;- private$.balance - value\n      invisible(self)\n    }\n  ),\n  active = list(\n    balance = function(value) {\n      if (missing(value)) {\n        private$.balance\n      } else {\n        stop(\"`$balance` is read only\", call. = FALSE)\n      }\n    }\n  )\n)\n\nsa &lt;- SecureAccount$new()\nsa$deposit(10L)\nsa$withdraw(5L)\ntry(sa$withdraw(20L))\n\n#&gt; Error in sa$withdraw(20L) : value &lt;= private$.balance is not TRUE\n\ntry(sa$balance &lt;- 100L)\n\n#&gt; Error : `$balance` is read only\n\nsa$balance\n\n#&gt; [1] 5\n\n\nAR Solutions: To fulfill this requirement, we make balance a private field. The user has to use the $deposit() and $withdraw() methods which have access to the balance field.\n\nBankAccountStrict2 &lt;- R6Class(\n  classname = \"BankAccountStrict2\",\n  public = list(\n    deposit = function(dep = 0) {\n      private$balance &lt;- private$balance + dep\n      invisible(self)\n    },\n    withdraw = function(draw = 0) {\n      if (private$balance - draw &lt; 0) {\n        stop(\n          \"Your `withdraw` must be smaller \",\n          \"than your `balance`.\",\n          call. = FALSE\n        )\n      }\n      private$balance &lt;- private$balance - draw\n      invisible(self)\n    }\n  ),\n  private = list(\n    balance = 0\n  )\n)\n\n\n\nCreate a class with a write-only $password field. It should have $check_password(password) method that returns TRUE or FALSE, but there should be no way to view the complete password.\n\nAnswer: Login implements a write-only $password field using an active function. check_password() will error if a password hasn’t been set. In real life, this should be implemented with a secure password hashing function, like bcrypt or scrypt.\n\nLogin &lt;- R6Class(\"Login\",\n  private = list(\n    .password = NULL\n  ),\n  public = list(\n    check_password = function(password) {\n      stopifnot(is.character(password), length(password) == 1)\n      if (is.null(private$.password)) stop(\"Error: password not set\")\n      password == private$.password\n    }\n  ),\n  active = list(\n    password = function(value) {\n      if (missing(value)) {\n        stop(\"`$password` is write only\", call. = FALSE)\n      } else {\n        stopifnot(is.character(value), length(value) == 1)\n        private$.password &lt;- value\n        invisible(self)\n      }\n    }\n  )\n)\n\nl &lt;- Login$new()\ntry(l$check_password(\"Password1\"))\n\n#&gt; Error in l$check_password(\"Password1\") : Error: password not set\n\nl$password &lt;- \"Password1\"\nl$check_password(\"Password1\")\n\n#&gt; [1] TRUE\n\nl$check_password(\"Password2\")\n\n#&gt; [1] FALSE\n\ntry(l$password)\n\n#&gt; Error : `$password` is write only\n\n\nAR Solutions: To protect the password from changes and direct access, the password will be a private field. Further, our Password will get its own print method which hides the password.\n\nPassword &lt;- R6Class(\n  classname = \"Password\",\n  public = list(\n    print = function(...) {\n      cat(\"&lt;Password&gt;: ********\\n\")\n      invisible(self)\n    },\n    set = function(value) {\n      private$password &lt;- value\n    },\n    check = function(password) {\n      identical(password, private$password)\n    }\n  ),\n  private = list(\n    password = NULL\n  )\n)\n\nLet’s create one instance of our new class and confirm that the password is neither accessible nor visible, but still check-able.\n\nmy_pw &lt;- Password$new()\nmy_pw$set(\"snuffles\")\nmy_pw$password\n\n#&gt; NULL\n\nmy_pw\n\n#&gt; &lt;Password&gt;: ********\n\nmy_pw$check(\"snuggles\")\n\n#&gt; [1] FALSE\n\nmy_pw$check(\"snuffles\")\n\n#&gt; [1] TRUE\n\n\nNote: the AR Solutions class properly masks the password when calling print(), but mine does not:\n\nl\n\n#&gt; &lt;Login&gt;\n#&gt;   Public:\n#&gt;     check_password: function (password) \n#&gt;     clone: function (deep = FALSE) \n#&gt;     password: active binding\n#&gt;   Private:\n#&gt;     .password: Password1\n\n\n\n\nExtend the Rando class with another active binding that allows you to access the previous random value. Ensure that active binding is the only way to access the value.\n\nAnswer: the updated Rando class sets a private value when random is run that is accessible only through previous, initially set to NA.\n\nRando &lt;- R6::R6Class(\"Rando\",\n  private = list(\n    .previous = NA\n  ),\n  active = list(\n    random = function(value) {\n      if (missing(value)) {\n        private$.previous &lt;- runif(1)\n        private$.previous\n      } else {\n        stop(\"Can't set `$random`\", call. = FALSE)\n      }\n    },\n    previous = function(value) {\n      if (missing(value)) {\n        private$.previous\n      } else {\n        stop(\"Can't set `$previous`\", call. = FALSE)\n      }\n    }\n  )\n)\nx &lt;- Rando$new()\n\nx$previous\n\n#&gt; [1] NA\n\nx$random\n\n#&gt; [1] 0.9643438\n\nx$previous\n\n#&gt; [1] 0.9643438\n\nx$random\n\n#&gt; [1] 0.1186832\n\nx$previous\n\n#&gt; [1] 0.1186832\n\n\nAR Solutions: To access the previous random value from an instance, we add a private $last_random field to our class, and we modify $random() to write to this field, whenever it is called. To access the $last_random field we provide $previous().\n\nRando &lt;- R6::R6Class(\n  classname = \"Rando\",\n  private = list(\n    last_random = NULL\n  ),\n  active = list(\n    random = function(value) {\n      if (missing(value)) {\n        private$last_random &lt;- runif(1)\n        private$last_random\n      } else {\n        stop(\"Can't set `$random`.\", call. = FALSE)\n      }\n    },\n    previous = function(value) {\n      if (missing(value)) {\n        private$last_random\n      }\n    }\n  )\n)\n\n\n\nCan subclasses access private fields/methods from their parent? Perform an experiment to find out.\n\nAnswer: LoginEvil shows that subclasses can access private fields from their parent.\n\nLoginEvil &lt;- R6Class(\"LoginEvil\",\n  inherit = Login,\n  public = list(\n    steal_password = function() {\n      cat(\"The password is: \", private$.password, \"\\n\", sep = \"\")\n    }\n  )\n)\n\nevil &lt;- LoginEvil$new()\nevil$password &lt;- \"SuperSecretPassword\"\nevil$steal_password()\n\n#&gt; The password is: SuperSecretPassword\n\n\nAR Solutions: To find out if private fields/methods can be accessed from subclasses, we first create a class A with a private field foo and a private method bar(). Afterwards, an instance of a subclass B is created and calls the foobar() methods, which tries to access the foo field and the bar() method from its superclass A.\n\nA &lt;- R6Class(\n  classname = \"A\",\n  private = list(\n    field = \"foo\",\n    method = function() {\n      \"bar\"\n    }\n  )\n)\nB &lt;- R6Class(\n  classname = \"B\",\n  inherit = A,\n  public = list(\n    test = function() {\n      cat(\"Field:  \", super$field, \"\\n\", sep = \"\")\n      cat(\"Method: \", super$method(), \"\\n\", sep = \"\")\n    }\n  )\n)\nB$new()$test()\n\n#&gt; Field:  \n#&gt; Method: bar\n\n\nWe conclude that subclasses can access private methods from their superclasses, but not private fields.\nNote: as I discovered, private fields are not accessible through super$, but are accessible through private$.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-8",
    "href": "analysis/advanced-r-3.html#exercises-8",
    "title": "Advanced R (Object-oriented programming)",
    "section": "14.4.4 Exercises",
    "text": "14.4.4 Exercises\n\nCreate a class that allows you to write a line to a specified file. You should open a connection to the file in $initialize(), append a line using cat() in $append_line(), and close the connection in $finalize().\n\nAnswer: WriteFile implemented below.\n\nWriteFile &lt;- R6Class(\"WriteFile\", list(\n  wfile = NULL,\n  initialize = function(filename) {\n    self$wfile &lt;- file(filename, \"a\")\n  },\n  append_line = function(line) {\n    cat(line, file = self$wfile)\n  },\n  finalize = function() {\n    close(self$wfile)\n  }\n))\n\ntmp &lt;- tempfile()\nwf &lt;- WriteFile$new(tmp)\nwf$append_line(\"The quick brown fox jumps over the lazy dog.\\n\")\nreadLines(tmp)\n\n#&gt; [1] \"The quick brown fox jumps over the lazy dog.\"\n\n\nAR Solutions: Our FileWriter class will create a connection to a file at initialization. Therefore, we open a connection to a user specified file during the initialisation. Note that we need to set open = \"a\" in file() to open connection for appending text. Otherwise, cat() would only work when applied to files, but not with connections as explicitly asked for in the exercise. Further, we add the append_line() method and a close() statement as finalizer.\n\nFileWriter &lt;- R6::R6Class(\n  classname = \"FileWriter\",\n  public = list(\n    con = NULL,\n    initialize = function(filename) {\n      self$con &lt;- file(filename, open = \"a\")\n    },\n    finalize = function() {\n      close(self$con)\n    },\n    append_line = function(x) {\n      cat(x, \"\\n\", sep = \"\", file = self$con)\n    }\n  )\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-9",
    "href": "analysis/advanced-r-3.html#exercises-9",
    "title": "Advanced R (Object-oriented programming)",
    "section": "15.2.1 Exercises",
    "text": "15.2.1 Exercises\n\nlubridate::period() returns an S4 class. What slots does it have? What class is each slot? What accessors does it provide?\n\nAnswer: the S4 class, Period, has 6 slots: .Data, year, month, day, hour, and minute, all numeric. I couldn’t figure out how to get the accessors.\n\np &lt;- lubridate::period()\nis(p)\n\n#&gt; [1] \"Period\"   \"Timespan\" \"numeric\"  \"vector\"\n\nvapply(slotNames(p), function(x) class(slot(p, x)), character(1))\n\n#&gt;     .Data      year     month       day      hour    minute \n#&gt; \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\"\n\n\nAR Solutions: Objects of the S4 Period class have six slots named year, month, day, hour, minute, and .Data (which contains the number of seconds). All slots are of type double. Most fields can be retrieved by an identically named accessor (e.g. lubridate::year() will return the field), use second() to get the .Data slot.\nAs a short example, we create a period of 1 second, 2 minutes, 3 hours, 4 days and 5 weeks.\n\nexample_12345 &lt;- lubridate::period(\n  c(1, 2, 3, 4, 5),\n  c(\"second\", \"minute\", \"hour\", \"day\", \"week\")\n)\n\nThis should add up to a period of 39 days, 3 hours, 2 minutes and 1 second.\n\nexample_12345\n\n#&gt; [1] \"39d 3H 2M 1S\"\n\n\nWhen we inspect example_12345, we see the fields and infer that the seconds are stored in the .Data field.\n\nstr(example_12345)\n\n#&gt; Formal class 'Period' [package \"lubridate\"] with 6 slots\n#&gt;   ..@ .Data : num 1\n#&gt;   ..@ year  : num 0\n#&gt;   ..@ month : num 0\n#&gt;   ..@ day   : num 39\n#&gt;   ..@ hour  : num 3\n#&gt;   ..@ minute: num 2\n\n\nNotes: it is easier to just use getClass to enumerate slots and slot classes:\n\ngetClass(is(lubridate::period()))\n\n#&gt; Class \"Period\" [package \"lubridate\"]\n#&gt; \n#&gt; Slots:\n#&gt;                                                       \n#&gt; Name:    .Data    year   month     day    hour  minute\n#&gt; Class: numeric numeric numeric numeric numeric numeric\n#&gt; \n#&gt; Extends: \n#&gt; Class \"Timespan\", directly\n#&gt; Class \"numeric\", from data part\n#&gt; Class \"vector\", by class \"numeric\", distance 2\n\n\nMethods defined for a particular class can be listed using showMethods(), and S4 methods can be listed using .S4methods():\n\n.S4methods(\"Period\")\n\n#&gt; no methods found\n\n\nPeriod has no S4 methods, only regular functions.\n\n\nWhat other ways can you find help for a method? Read ?\"?\" and summarise the details.\n\nAnswer: there are three ways to get help for a method:\n\n?function provides the function documentation\nmethods?function provides the overall documentation methods for the function\nmethods?function(signature) provides the documentation for a specific method\n\nAR Solutions: Besides adding ? in front of a function call (i.e. ?method()), we may find:\n\ngeneral documentation for a generic via ?genericName\ngeneral documentation for the methods of a generic via methods?genericName\ndocumentation for a specific method via ClassName?methodName.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-10",
    "href": "analysis/advanced-r-3.html#exercises-10",
    "title": "Advanced R (Object-oriented programming)",
    "section": "15.3.6 Exercises",
    "text": "15.3.6 Exercises\n\nExtend the Person class with fields to match utils::person(). Think about what slots you will need, what class each slot should have, and what you’ll need to check in your validity method.\n\nAnswer: the Person class uses the fields from utils::person(), excluding deprecated fields. Per the docs, family must be a string (length 1), others can be vectors (but this is not enforced).\n\nsetClass(\"Person\",\n  slots = c(\n    given = \"character\",\n    family = \"character\",\n    email = \"character\",\n    role = \"character\",\n    comment = \"character\"\n  ),\n  prototype = list(\n    given = NA_character_,\n    family = NA_character_,\n    email = NA_character_,\n    role = NA_character_,\n    comment = NA_character_\n  )\n)\n\nsetValidity(\"Person\", function(object) {\n  # regex from https://www.nicebread.de/validating-email-adresses-in-r/\n  regex &lt;- \"\\\\&lt;[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\&gt;\"\n\n  if (length(object@family) &gt; 1) {\n    \"@family must be a string (length 1)\"\n  } else if (!is.na(object@email) & !grepl(regex, object@email, ignore.case = TRUE)) {\n    \"invalid @email\"\n  } else {\n    TRUE\n  }\n}) |&gt;\n  invisible()\n\nPerson &lt;- function(given = NA_character_, family = NA_character_,\n                   email = NA_character_, role = NA_character_, comment = NA_character_) {\n  given &lt;- as.character(given)\n  family &lt;- as.character(family)\n  email &lt;- as.character(email)\n  role &lt;- as.character(role)\n  comment &lt;- as.character(comment)\n\n  new(\"Person\", given = given, family = family, email = email, role = role, comment = comment)\n}\n\nPerson(\"John\", \"Benninghoff\", email = \"john@example.com\", comment = 51)\n\n#&gt; An object of class \"Person\"\n#&gt; Slot \"given\":\n#&gt; [1] \"John\"\n#&gt; \n#&gt; Slot \"family\":\n#&gt; [1] \"Benninghoff\"\n#&gt; \n#&gt; Slot \"email\":\n#&gt; [1] \"john@example.com\"\n#&gt; \n#&gt; Slot \"role\":\n#&gt; [1] NA\n#&gt; \n#&gt; Slot \"comment\":\n#&gt; [1] \"51\"\n\ntry(Person(\"John\", c(\"Three\", \"Last\", \"Names\")))\n\n#&gt; Error in validObject(.Object) : \n#&gt;   invalid class \"Person\" object: @family must be a string (length 1)\n\ntry(Person(\"John\", email = \"invalid@local\"))\n\n#&gt; Error in validObject(.Object) : \n#&gt;   invalid class \"Person\" object: invalid @email\n\n\nAR Solutions: The Person class from Advanced R contains the slots name and age. The person class from the {utils} package contains the slots given (vector of given names), family, role, email and comment (see ?utils::person).\nAll slots from utils::person() besides role must be of type character and length 1. The entries in the role slot must match one of the following abbreviations “aut”, “com”, “cph”, “cre”, “ctb”, “ctr”, “dtc”, “fnd”, “rev”, “ths”, “trl”. Therefore, role might be of different length than the other slots and we’ll add a corresponding constraint within the validator.\n\n# Definition of the Person class\nsetClass(\"Person\",\n  slots = c(\n    age = \"numeric\",\n    given = \"character\",\n    family = \"character\",\n    role = \"character\",\n    email = \"character\",\n    comment = \"character\"\n  ),\n  prototype = list(\n    age = NA_real_,\n    given = NA_character_,\n    family = NA_character_,\n    role = NA_character_,\n    email = NA_character_,\n    comment = NA_character_\n  )\n)\n# Helper to create instances of the Person class\nPerson &lt;- function(given, family,\n                   age = NA_real_,\n                   role = NA_character_,\n                   email = NA_character_,\n                   comment = NA_character_) {\n  age &lt;- as.double(age)\n  new(\"Person\",\n    age = age,\n    given = given,\n    family = family,\n    role = role,\n    email = email,\n    comment = comment\n  )\n}\n# Validator to ensure that each slot is of length one\nsetValidity(\"Person\", function(object) { # nolint: cyclocomp_linter.\n  invalids &lt;- character(0)\n  if (length(object@age) != 1 ||\n    length(object@given) != 1 ||\n    length(object@family) != 1 ||\n    length(object@email) != 1 ||\n    length(object@comment) != 1) {\n    invalids &lt;- paste0(\n      \"@name, @age, @given, @family, @email, \",\n      \"@comment must be of length 1\"\n    )\n  }\n\n  known_roles &lt;- c(\n    NA_character_, \"aut\", \"com\", \"cph\", \"cre\", \"ctb\",\n    \"ctr\", \"dtc\", \"fnd\", \"rev\", \"ths\", \"trl\"\n  )\n\n  if (!all(object@role %in% known_roles)) {\n    paste(\n      \"@role(s) must be one of\",\n      paste(known_roles, collapse = \", \") # nolint: paste_linter.\n    )\n  }\n\n  if (length(invalids)) {\n    return(invalids)\n  }\n  TRUE\n}) |&gt;\n  invisible()\n\nNotes: while I missed including age, our implementations are similar except for validations.\n\n\nWhat happens if you define a new S4 class that doesn’t have any slots? (Hint: read about virtual classes in ?setClass.)\n\nAnswer: defining a new class with no slots makes it a virtual class, which can’t be used to create new objects, but can be used to define a class union.\n\nsetClass(\"Virtual\")\ntry(new(\"Virtual\"))\n\n#&gt; Error in new(\"Virtual\") : \n#&gt;   trying to generate an object from a virtual class (\"Virtual\")\n\nsetClassUnion(\"Virtual\", \"Person\")\ngetClass(\"Virtual\")\n\n#&gt; Extended class definition ( \"ClassUnionRepresentation\" )\n#&gt; Virtual Class \"Virtual\" [in \".GlobalEnv\"]\n#&gt; \n#&gt; No Slots, prototype of class \"Person\"\n#&gt; \n#&gt; Known Subclasses: \"Person\"\n\n\nAR Solutions: It depends on the other arguments. If we inherit from another class, we get the same slots. But something interesting happens if we don’t inherit from an existing class. We get a virtual class. A virtual class can’t be instantiated:\n\nsetClass(\"Human\")\ntry(new(\"Human\"))\n\n#&gt; Error in new(\"Human\") : \n#&gt;   trying to generate an object from a virtual class (\"Human\")\n\n\nBut can be inherited from:\n\nsetClass(\"Programmer\", contains = \"Human\")\n\n\n\nImagine you were going to reimplement factors, dates, and data frames in S4. Sketch out the setClass() calls that you would use to define the classes. Think about appropriate slots and prototype.\n\nAnswer: sketch below. Default values would be set in initialize().\n\nsetClass(\"Factor\",\n  slots = list(\n    x = \"character\",\n    levels = \"character\",\n    labels = \"character\",\n    exclude = \"character\",\n    ordered = \"logical\",\n    nmax = \"integer\"\n  ),\n  prototype = list(\n    x = character(0),\n    levels = character(0),\n    labels = character(0),\n    exclude = NA_character_,\n    ordered = FALSE,\n    nmax = NA_integer_\n  )\n)\n\nsetClass(\"S4Date\",\n  slots = list(\n    days = \"integer\"\n  ),\n  prototype = list(\n    days = 0L\n  )\n)\n\nsetClass(\"DataFrame\",\n  slots = list(\n    data = \"matrix\",\n    col_names = \"character\",\n    row_names = \"character\"\n  ),\n  prototype = list(\n    data = matrix(nrow = 0, ncol = 0),\n    col_names = NULL,\n    row_names = NULL\n  )\n)\n\nAR Solutions: For all these classes we need one slot for the data and one slot per attribute. Keep in mind, that inheritance matters for ordered factors and dates. For data frames, special checks like equal lengths of the underlying list’s elements should be done within a validator.\nFor simplicity we don’t introduce an explicit subclass for ordered factors. Instead, we introduce ordered as a slot.\n\nsetClass(\"Factor\",\n  slots = c(\n    data = \"integer\",\n    levels = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = list(\n    data = integer(),\n    levels = character(),\n    ordered = FALSE\n  )\n)\nnew(\"Factor\", data = c(1L, 2L), levels = letters[1:3])\n\n#&gt; An object of class \"Factor\"\n#&gt; Slot \"data\":\n#&gt; [1] 1 2\n#&gt; \n#&gt; Slot \"levels\":\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; Slot \"ordered\":\n#&gt; [1] FALSE\n\n\nThe Date2 class stores its dates as integers, similarly to base R which uses doubles. Dates don’t have any other attributes.\n\nsetClass(\"Date2\",\n  slots = list(\n    data = \"integer\"\n  ),\n  prototype = list(\n    data = integer()\n  )\n)\n\nnew(\"Date2\", data = 1L)\n\n#&gt; An object of class \"Date2\"\n#&gt; Slot \"data\":\n#&gt; [1] 1\n\n\nOur DataFrame class consists of a list and a slot for row.names. Most of the logic (e.g. checking that all elements of the list are a vector, and that they all have the same length) would need to be part of a validator.\n\nsetClass(\"DataFrame\",\n  slots = c(\n    data = \"list\",\n    row.names = \"character\"\n  ),\n  prototype = list(\n    data = list(),\n    row.names = character(0)\n  )\n)\n\nnew(\"DataFrame\", data = list(a = 1, b = 2))\n\n#&gt; An object of class \"DataFrame\"\n#&gt; Slot \"data\":\n#&gt; $a\n#&gt; [1] 1\n#&gt; \n#&gt; $b\n#&gt; [1] 2\n#&gt; \n#&gt; \n#&gt; Slot \"row.names\":\n#&gt; character(0)\n\n\nNotes:\n\nA key insight from AR Solutions is that the objects need one slot for data and one for each attribute\nMy implementation of Factor is wrong, where the AR Solutions answer is clearly right\nThe implementations of the new Date object are similar; the prototype for AR Solutions is better\nThe AR Solutions DataFrame omits column names (names), where mine does not; using a list for the data in DataFrame is a better choice, but harder to implement\n\n\nattributes(data.frame())\n\n#&gt; $names\n#&gt; character(0)\n#&gt; \n#&gt; $row.names\n#&gt; integer(0)\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-11",
    "href": "analysis/advanced-r-3.html#exercises-11",
    "title": "Advanced R (Object-oriented programming)",
    "section": "15.4.5 Exercises",
    "text": "15.4.5 Exercises\n\nAdd age() accessors for the Person class.\n\nAnswer: the code below adds age accessors to Advanced R Person.\n\nsetClass(\"Person\",\n  slots = c(\n    name = \"character\",\n    age = \"numeric\"\n  ),\n  prototype = list(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\njohn &lt;- new(\"Person\", name = \"John Smith\")\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\")) |&gt;\n  invisible()\nsetMethod(\"age\", \"Person\", function(x) x@age)\n\nage(john)\n\n#&gt; [1] NA\n\nsetGeneric(\"age&lt;-\", function(x, value) standardGeneric(\"age&lt;-\")) |&gt;\n  invisible()\nsetMethod(\"age&lt;-\", \"Person\", function(x, value) {\n  x@age &lt;- value\n  validObject(x)\n  x\n})\n\nage(john) &lt;- 51\nage(john)\n\n#&gt; [1] 51\n\n\nAR Solutions: We implement the accessors via an age() generic, with a method for the Person class and a corresponding replacement function age&lt;-:\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\n\n#&gt; [1] \"age\"\n\nsetMethod(\"age\", \"Person\", function(x) x@age)\n\nsetGeneric(\"age&lt;-\", function(x, value) standardGeneric(\"age&lt;-\"))\n\n#&gt; [1] \"age&lt;-\"\n\nsetMethod(\"age&lt;-\", \"Person\", function(x, value) {\n  x@age &lt;- value\n  validObject(x)\n  x\n})\n\n\n\nIn the definition of the generic, why is it necessary to repeat the name of the generic twice?\n\nAnswer: according to the R docs, setGeneric(name) specifies an existing function. When creating a new generic, the form setGeneric(name, def) is used, where def is standardGeneric(name).\nAR Solutions: Within setGeneric() the name (1st argument) is needed as the name of the generic. Then, the name also explicitly incorporates method dispatch via standardGeneric() within the generic’s body (def parameter of setGeneric()). This behaviour is similar to UseMethod() in S3.\n\n\nWhy does the show() method defined in Section 15.4.3 use is(object)[[1]]? (Hint: try printing the employee subclass.)\n\nAnswer: is(object) returns a vector for a subclass, with the current class first.\n\nsetClass(\"Employee\",\n  contains = \"Person\",\n  slots = c(\n    boss = \"Person\"\n  ),\n  prototype = list(\n    boss = new(\"Person\")\n  )\n)\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(is(object)[[1]], \"\\n\",\n    \"  Name: \", object@name, \"\\n\",\n    \"  Age:  \", object@age, \"\\n\",\n    sep = \"\"\n  )\n})\n\njohn\n\n#&gt; Person\n#&gt;   Name: John Smith\n#&gt;   Age:  51\n\njane &lt;- new(\"Employee\", name = \"Jane Doe\")\nis(jane)\n\n#&gt; [1] \"Employee\" \"Person\"\n\njane\n\n#&gt; Employee\n#&gt;   Name: Jane Doe\n#&gt;   Age:  NA\n\n\nAR Solutions: is(object) returns the class of the object. is(object) also contains the superclass, for subclasses like Employee. In order to always return the most specific class (the subclass), show() returns the first element of is(object).\n\n\nWhat happens if you define a method with different argument names to the generic?\n\nAnswer: this should cause method dispatch to fail, but I don’t know of a way to test.\nAR Solutions: It depends. We first create the object hadley of class Person:\n\n.Person &lt;- setClass(\n  \"Person\",\n  slots = c(name = \"character\", age = \"numeric\")\n)\nhadley &lt;- .Person(name = \"Hadley\")\nhadley\n\n#&gt; Person\n#&gt;   Name: Hadley\n#&gt;   Age:\n\n\nNow let’s see which arguments can be supplied to the show() generic.\n\nformals(\"show\")\n\n#&gt; $object\n\n\nUsually, we would use this argument when defining a new method.\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(object@name, \"creates hard exercises\")\n})\n\nhadley\n\n#&gt; Hadley creates hard exercises\n\n\nWhen we supply another name as a first element of our method (e.g. x instead of object), this element will be matched to the correct object argument and we receive a warning. Our method will work, though:\n\nsetMethod(\"show\", \"Person\", function(x) {\n  cat(x@name, \"creates hard exercises\")\n})\n\n#&gt; Warning: For function 'show', signature 'Person': argument in method definition\n#&gt; changed from (x) to (object)\n\nhadley\n\n#&gt; Hadley creates hard exercises\n\n\nIf we add more arguments to our method than our generic can handle, we will get an error.\n\ntry(\n  setMethod(\"show\", \"Person\", function(x, y) {\n    cat(x@name, \"is\", x@age, \"years old\")\n  })\n)\n\n#&gt; Error in conformMethod(signature, mnames, fnames, f, fdef, definition) : \n#&gt;   in method for 'show' with signature 'object=\"Person\"': formal arguments (object = \"Person\") omitted in the method definition cannot be in the signature\n\n\nIf we do this with arguments added to the correctly written object argument, we will receive an informative error message. It states that we could add other argument names for generics, which can take the ... argument.\n\ntry(\n  setMethod(\"show\", \"Person\", function(object, y) {\n    cat(object@name, \"is\", object@age, \"years old\")\n  })\n)\n\n#&gt; Error in rematchDefinition(definition, fdef, mnames, fnames, signature) : \n#&gt;   methods can add arguments to the generic 'show' only if '...' is an argument to the generic",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-12",
    "href": "analysis/advanced-r-3.html#exercises-12",
    "title": "Advanced R (Object-oriented programming)",
    "section": "15.5.5 Exercises",
    "text": "15.5.5 Exercises\n\nDraw the method graph for f(sweat_smile, kissing_cat)\n\nAnswer: skipped.\nAR Solutions: Look at the graph and repeat after me: “I will keep my class structure simple and use multiple inheritance sparingly”.\n\n\nDraw the method graph for f(smiley, wink, kissing_smiling_eyes)\n\nAnswer: skipped.\nAR Solutions: We see that the method graph below looks simpler than the one above. Relatively speaking, multiple dispatch seems to introduce less complexity than multiple inheritance. Use it with care, though!\n\n\nTake the last example which shows multiple dispatch over two classes that use multiple inheritance. What happens if you define a method for all terminal classes? Why does method dispatch not save us much work here?\n\nAnswer: since all terminal nodes are equidistant from the classes, the method is ambiguous. This is true at the first level as well. The only way to avoid ambiguity is to avoid method dispatch altogether and define a method at the root node.\nAR Solutions: We will introduce ambiguity, since one class has distance 2 to all terminal nodes and the other four have distance 1 to two terminal nodes each. To resolve this ambiguity we have to define five more methods, one per class combination.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#exercises-13",
    "href": "analysis/advanced-r-3.html#exercises-13",
    "title": "Advanced R (Object-oriented programming)",
    "section": "15.6.3 Exercises",
    "text": "15.6.3 Exercises\n\nWhat would a full setOldClass() definition look like for an ordered factor (i.e. add slots and prototype the definition above)?\n\nAnswer: building on the AR Solutions example and the factor example in 15.6.1, the following S4 object behaves like the ordered() version:\n\nsetClass(\"Ordered\",\n  contains = \"integer\",\n  slots = c(\n    levels = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = structure(\n    integer(),\n    levels = character(),\n    ordered = TRUE\n  )\n)\nsetOldClass(\"ordered\", S4Class = \"Ordered\")\n\no &lt;- new(\"Ordered\", 1:4, levels = letters[1:4])\no\n\n#&gt; An object of class \"Ordered\"\n#&gt; [1] 1 2 3 4\n#&gt; Slot \"levels\":\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n#&gt; \n#&gt; Slot \"ordered\":\n#&gt; [1] TRUE\n\nstr(ordered(c(\"a\", \"b\", \"c\", \"d\")))\n\n#&gt;  Ord.factor w/ 4 levels \"a\"&lt;\"b\"&lt;\"c\"&lt;\"d\": 1 2 3 4\n\n\nAR Solutions: The purpose of setOldClass() lies in registering an S3 class as a “formally defined class”, so that it can be used within the S4 object-oriented programming system. When using it, we may provide the argument S4Class, which will inherit the slots and their default values (prototype) to the registered class.\nLet’s build an S4 OrderedFactor on top of the S3 factor in such a way.\n\nsetOldClass(\"factor\") # use build-in definition for brevity\nOrderedFactor &lt;- setClass(\n  \"OrderedFactor\",\n  contains = \"factor\", # inherit from registered S3 class\n  slots = c(\n    levels = \"character\",\n    ordered = \"logical\" # add logical order slot\n  ),\n  prototype = structure(\n    integer(),\n    levels = character(),\n    ordered = logical() # add default value\n  )\n)\n\nWe can now register the (S3) ordered-class, while providing an “S4 template”. We can also use the S4-class to create new object directly.\n\nsetOldClass(\"ordered\", S4Class = \"OrderedFactor\")\nx &lt;- OrderedFactor(\n  c(1L, 2L, 2L),\n  levels = c(\"a\", \"b\", \"c\"),\n  ordered = TRUE\n)\nstr(x)\n\n#&gt; Formal class 'OrderedFactor' [package \".GlobalEnv\"] with 4 slots\n#&gt;   ..@ .Data   : int [1:3] 1 2 2\n#&gt;   ..@ levels  : chr [1:3] \"a\" \"b\" \"c\"\n#&gt;   ..@ ordered : logi TRUE\n#&gt;   ..@ .S3Class: chr \"factor\"\n\n\nNotes: while my class Ordered looks similar to the AR Solutions version, it does not include the S3 class:\n\nstr(o)\n\n#&gt; Formal class 'Ordered' [package \".GlobalEnv\"] with 3 slots\n#&gt;   ..@ .Data  : int [1:4] 1 2 3 4\n#&gt;   ..@ levels : chr [1:4] \"a\" \"b\" \"c\" \"d\"\n#&gt;   ..@ ordered: logi TRUE\n\n\n\n\nDefine a length method for the Person class.\n\nAnswer: since Person is a vector class, its length is the length() of any of its fields (we use Person2 here due to prevent conflicts with the already defined Person class):\n\nsetClass(\"Person2\",\n  slots = c(\n    name = \"character\",\n    age = \"numeric\"\n  ),\n  prototype = list(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\nsetGeneric(\"length\") |&gt;\n  invisible()\nsetMethod(\"length\", \"Person2\", function(x) length(x@name))\n\npeople &lt;- new(\"Person2\", name = c(\"John Smith\", \"Jane Doe\"), age = c(NA_real_, NA_real_))\npeople\n\n#&gt; An object of class \"Person2\"\n#&gt; Slot \"name\":\n#&gt; [1] \"John Smith\" \"Jane Doe\"  \n#&gt; \n#&gt; Slot \"age\":\n#&gt; [1] NA NA\n\nlength(people)\n\n#&gt; [1] 2\n\n\nAR Solutions: We keep things simple and will just return \"180cm\" when the length() method is called on a Person object. The method can be defined either as an S3 or S4 method.\n\nlength.Person &lt;- function(x) \"180cm\" # S3\nsetMethod(\"length\", \"Person\", function(x) \"180cm\") # S4",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html",
    "href": "analysis/r-setup-log.html",
    "title": "R Setup Log",
    "section": "",
    "text": "My notes on my personal R setup. I started my R journey in September 2020 after SIRACon 2020. Important: this historical setup is outdated and differs from my current approach, which is documented in rdev.\n# no libraries",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#r-variants",
    "href": "analysis/r-setup-log.html#r-variants",
    "title": "R Setup Log",
    "section": "R Variants",
    "text": "R Variants\nTL;DR: just use homebrew.\nI don’t recommend installing the cask variant of r because it creates problems with brew doctor:\n\nbrew info --cask r\n\n==&gt; r: 4.3.2\nhttps://www.r-project.org/\nNot installed\nFrom: https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/r/r.rb\n==&gt; Name\nR\n==&gt; Description\nEnvironment for statistical computing and graphics\n==&gt; Artifacts\nR-4.3.2-arm64.pkg (Pkg)\n==&gt; Analytics\ninstall: 762 (30 days), 2,484 (90 days), 6,499 (365 days)\n\n\nI tried “installing all the things” with homebrew-r-srf but didn’t like how the uninstall doesn’t clean up, and frankly, I haven’t found a need for more than the capabilities included with homebrew R:\n\ncapabilities()\n\n       jpeg         png        tiff       tcltk         X11        aqua \n       TRUE        TRUE        TRUE        TRUE        TRUE        TRUE \n   http/ftp     sockets      libxml        fifo      cledit       iconv \n       TRUE        TRUE       FALSE        TRUE       FALSE        TRUE \n        NLS       Rprof     profmem       cairo         ICU long.double \n       TRUE        TRUE        TRUE        TRUE        TRUE       FALSE \n    libcurl \n       TRUE \n\n\nCurrently, this is everything except the X11 dependencies, which aren’t really needed:\n?capabilities\n\nNote to macOS users\nCapabilities “jpeg”, “png” and “tiff” refer to the X11-based versions of these devices. If capabilities(“aqua”) is true, then these devices with type = “quartz” will be available, and out-of-the-box will be the default type. Thus for example the tiff device will be available if capabilities(“aqua”) || capabilities(“tiff”) if the defaults are unchanged.\n\nAs an active contributor to Homebrew, I strongly recommend using it for any/all software; their quality control is excellent.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#development-environment",
    "href": "analysis/r-setup-log.html#development-environment",
    "title": "R Setup Log",
    "section": "Development Environment",
    "text": "Development Environment\nWell, obviously, I use RStudio. There are other IDEs available, and it’s also possible to develop using the command line, but RStudio provides a pleasant, integrated experience for R development, and actively supports the R community. I don’t typically use the built-in Git client, instead using the GitHub Desktop client and git command-line tool.\nbrew install github\nI also occasionally use vim (mainly for shell scripts) and atom (mainly for vanilla .md files using markdown-preview-enhanced).",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#packages",
    "href": "analysis/r-setup-log.html#packages",
    "title": "R Setup Log",
    "section": "Packages",
    "text": "Packages\nManaging packages and environments are a challenge for most modern languages. Thankfully R doesn’t have the same level of challenge as python, or even ruby, managing packages available within a project is a best practice. I use renv for this purpose. (I originally discovered packrat but quickly discovered RStudio is replacing it with renv)\nHere is my package maintenance approach:\n\nBase R Packages\nWith no projects open, I periodically check for updates to the base R packages using the RStudio Packages “Update” function. These are the only packages I install to the base directory /usr/local/Cellar/r/4.0.3_2/lib/R/library. Note: upgrading or reinstalling r through homebrew may ‘downgrade’ the base packages.\n\n\nDevelopment Packages\nThe only other tools I install outside of projects are for supporting development. Originally this was just renv, but now it includes a number of development tools needed to create projects. I use the R site library used by homebrew, currently /usr/local/lib/R/4.0/site-library. I’ve developed a shell script to install development packages that you can find in the tools directory of this repository.\n#!/bin/sh\n# install development packages to site repository\n# thanks to https://blog.sellorm.com/2017/10/21/quick-script-to-install-an-r-package-from-the-command-line/\n# and https://github.com/Homebrew/homebrew-core/blob/master/Formula/r/r.rb\n# designed to work with homebrew: `brew install --formula r && brew install --cask rstudio`\nset -ex # halt script on error, echo on\n\nPREFIX=`brew --prefix`\nRVERSION=`${PREFIX}/bin/Rscript -e 'cat(as.character(getRversion()[1,1:2]))'`\nSITELIB=\"${PREFIX}/lib/R/${RVERSION}/site-library\"\nDEVPKG='c(\"renv\", \"styler\", \"lintr\", \"miniUI\", \"devtools\", \"available\")'\n\nif [ ! -d \"${SITELIB}\" ]\nthen\n    echo \"fatal error: ${SITELIB} does not exist - not using \\`brew install --formula r\\`?\"\n    exit 1\nfi\n\nbrew install libgit2 # required by devtools\n\necho \"install.packages(${DEVPKG}, repos=\\\"https://cran.rstudio.com\\\", lib=\\\"${SITELIB}\\\")\" | R --no-save\n\n\nProject Packages\nAny packages not needed to create projects I install within a project using renv - here are some good intros:\n\nA presentation at rstudio::conf 2020\nThe RStudio Blog post\nAn Introduction to renv\nrenv on GitHub\n\nrenv::init() # to set up renv in the project\nrenv::install(\"rtraining\") # to install a package\nrenv::status() # checks if renv.lock is in sync\nrenv::snapshot() # save libraries in renv.lock\nrenv::restore() # restore libraries from renv.lock - use when first using an existing project\nrenv::clean() # remove extra libraries\nrenv::update() # check for unpdated versions of installed libraries\nIf you’re installing (development) versions of packages from GitHub, you’ll be prompted to set up a personal access token using create_github_token() and adding it to your .Renviron as GITHUB_PAT= using usethis::edit_r_environ(). I had to install the development versions of both styler and lintr due to bugs not yet fixed in the released (CRAN) versions. I did also look at using pak but found it too buggy to use.\nNote: I came across an odd quirk where renv will prompt you to upgrade base R projects, even if they’re not used. I resolved these by just upgrading the base packages with RStudio with no project open.\nI’ve included some comments on useful packages in my R Training Log notebook.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#use-git",
    "href": "analysis/r-setup-log.html#use-git",
    "title": "R Setup Log",
    "section": "Use git!",
    "text": "Use git!\nThis wasn’t really something I learned with R, but use of version control for any kind of code/script is crucial. These days, I keep all scripts and configuration files in some flavor of public or private version control. Mostly that means GitHub, but also private git servers (via ssh) are easy to set up for work that you want to keep off of GitHub.\nI don’t want to get too much into managing code via version control, but I favor trunk-based development with short-lived branches, small commits of working code, and rebase and merge for linear commit history. There’s a lot of good research on this topic from Google’s Dev Ops Research and Assessment team.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#using-rstudio-with-github",
    "href": "analysis/r-setup-log.html#using-rstudio-with-github",
    "title": "R Setup Log",
    "section": "Using RStudio with GitHub",
    "text": "Using RStudio with GitHub\nRStudio has good integration with GitHub. I’ve adopted the convention of “one RStudio Project (.Rproj) per repository” and storing the Rproj file in the repository. That seems to be the norm.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#r-notebooks",
    "href": "analysis/r-setup-log.html#r-notebooks",
    "title": "R Setup Log",
    "section": "R Notebooks",
    "text": "R Notebooks\nR Notebooks are my preferred file format for data analysis, as they allow an easy mixing of text (using pandoc markdown) and R code chunks. This allows me to document what I’m doing as I go, both for reproducibility as well as recording my observations, thoughts and conclusions. It especially lends itself to iterative development:\n\nWrite code\nRun code\nSee results\nUpdate code\n\nThis method of development is not always appropriate, but fits well with exploratory analysis. Once I get to writing functions, I’m starting to adopt the formal structure of packages, testthat, and roxygen2.\nSpecifically, I use html_notebook, which was recommended to me. RStudio handles this differently than html_document:\n\n\n\n\n\n\n\n\nBehavior\nhtml_notebook\nhtml_document\n\n\n\n\nQuick View\nPreview Button\nNo Preview Button\n\n\nSaving Files\nAutomatically knits file on save\nManually knit file\n\n\nRendering Files\nRenders R output as it exists in the IDE on save\nRenders R output by running all R code\n\n\nDefault Options\nIncludes options for readability, hiding and downloading code, and paged tables\nHigher-quality rendering of PNG graphics\n\n\n\nEssentially, R Notebooks are generally faster and more convenient when doing analysis, and html_document R Markdown files offer higher-quality output. This site uses a custom framework to convert html_notebooks to html_documents for publishing (see the next section for details). They are also a convenient way to share analysis with peers - just email the .nb.html file, which will include all of the output, as well as embedding the .Rmd source code for easy editing. This also allows people who don’t have R/RStudio to see the results of an analysis.\nThere are some drawbacks to using R Notebooks:\n\nBecause R Notebooks are render-on-save, you can inadvertently end up with missing or outdated R output from your notebook when saving, if you’ve made updates and haven’t re-run the entire document. My habit is to do the following at the end of a writing session, before committing to git, which ensures a “clean” notebook:\n\nClear the Global Environment\n“Restart R and Clear Output”\n“Run All”\nSave\n\nDebug breakpoints don’t work in R Markdown documents. To fix this, convert R Markdown documents to R Scripts using purl for debugging.\nNot really a drawback, but…Rcpp and rprojroot are erroneously listed in RStudio as required to create R Markdown, which can also cause problems with renv. This is a bug in RStudio, which will be fixed in version 1.4.944.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#publishing-r-notebooks",
    "href": "analysis/r-setup-log.html#publishing-r-notebooks",
    "title": "R Setup Log",
    "section": "Publishing R Notebooks",
    "text": "Publishing R Notebooks\nSince R Notebooks are saved as html files, it’s possible to publish them on GitHub using GitHub pages. GitHub published a tutorial in 2018 on getting RStudio integrated with GitHub, and I started working on that. Quickly I discovered that while the tutorial was helpful, it wasn’t quite the setup I wanted; it published R Markdown through GitHub pages, but wouldn’t directly support the automatically generated html of R Notebooks. After more searching, I was able to get Notebooks working on GitHub, but I used the method described in rstudio/rmarkdown #1020 - checking in the .nb.html into git, and using GitHub Pages so that you can view the rendered HTML instead of just the HTML code.\n\nPublishing with rmarkdown\nAfter using README.md and GitHub pages to publish notebooks, I found I wanted an easier way to publish and navigate across collections of notebooks. Publishing R Notebooks on GitHub pages works fine, but doesn’t offer an easy navigation structure, like pkgdown. I tried using pkgdown to display notebooks, but pkgdown only supports building vignettes, which have a distinctly different look and feel than R Notebooks. The rmarkdown site generator, render_site, allows more flexible building of websites from R Markdown files with a simple navigation bar at the top, but doesn’t support html_notebook files OOB.\nTo work around this, I created a simple framework for converting html_notebook files to html_document and building a _site.yml from a list of notebooks stored in the non-standard notebooks/ directory, initially using a shell script, build_site (stored at the root of this repo). It does the following:\n\nCreates a working directory, .build-site\nBuilds a rmarkdown::render_site() _site.yml file that includes a menu with all notebooks in the notebooks/ directory\nCopies all .Rmd files to .build-site changing their type from html_notebook to html_document\nIncludes some configuration to make html_documents work more like html_notebook\nCalls rmarkdown::render_site() to render the site in the docs/ directory\n\nI typically rebuild a site with the following command, run from the top-level directory of the project:\nrm -rf .build-site && sh build-site && open docs/index.html\nThis approach leverages the docs functionality of GitHub pages, like pkgdown.\n\n\nUpdate on Publishing\nbuild-site has been replaced with build_analysis_site()! At its core, it is functionally the same: builds a pkgdown site, adding an “Analysis” menu with all notebooks in the (renamed) analysis/ directory, then converts and builds the notebooks using rmarkdown, and moves them into the docs/ directory. Since it is now an R Script, it’s more portable and can be more easily bundled with packages. I will be migrating its functionality to rdev shortly, so that it’s usable across multiple analysis projects.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#r-package-layout",
    "href": "analysis/r-setup-log.html#r-package-layout",
    "title": "R Setup Log",
    "section": "R Package Layout",
    "text": "R Package Layout\nHere is my package layout - the table shows the path, whether it’s part of the formal R package definition, and my notes on its use.\n\n\n\nPath\nR\nNotes\n\n\n\n\n.Rbuildignore\nx\nExclude files from package\n\n\n.Rprofile\nx\nUsed by renv and to attach development tools\n\n\n.github\n\nGitHub templates and workflows\n\n\n.gitignore\nx\nI use R and macOS exclusions, and always exclude generated files outside of docs/\n\n\n.lintr\n\nlintr default linters with 100 columns: linters: with_defaults(line_length_linter(100))\n\n\nDESCRIPTION\nx\nuse “Suggests” for development tools, per renv\n\n\nLICENSE\nx\nGenerated with use_mit_license()\n\n\nLICENSE.md\n\nSee above, used by pkgdown\n\n\nNAMESPACE\nx\nGenerated with roxygen2\n\n\nNEWS.md\n\nRelease notes, used by pkgdown\n\n\nREADME.Rmd\nx\nGenerated with use_readme_md()\n\n\nREADME.md\nx\nGenerated with build_readme()\n\n\nR\nx\nAll project functions go here, with roxygen2 comments\n\n\nTODO.md\n\nTo-do list, inspired by renv’s historical TODO.md\n\n\nanalysis\n\nExploratory data analysis in R Notebooks and R Presentations\n\n\nanalysis/data\n\nWhen appropriate, analysis data lives here\n\n\nanalysis/assets\n\nExternal assets (images, other files) included in R Notebooks\n\n\nanalysis/rendered\n\nManually rendered html versions of analysis/ files to be included in docs/, ie .Rpres files, not stored in git\n\n\ndemos\nx\nI don’t use demos, as recommended by R Packages\n\n\ndocs\n\nUsed by pkgdown::build_site() and R Notebooks rendered as html_document using rmarkdown::render_site() via build_analysis_site()\n\n\nexec\nx\nIn theory this is where command line executable scrips reside\n\n\ninst/templates/rmarkdown\nx\nPlanned location for R Markdown Templates\n\n\nman\nx\nGenerated with roxygen2\n\n\npackage.Rproj\n\nI use the same name for the package, .Rproj, directory, and GitHub repo\n\n\npkgdown\n\nI store all pkgdown files here\n\n\npo\nx\nUsed for Internationalization\n\n\nrenv\n\nUsed by renv\n\n\nrenv.lock\n\nThe renv lockfile\n\n\ntests\nx\nTests using testthat\n\n\ntools\nx\nI use tools/ for shell scripts that support development, like setup-r\n\n\nvignettes\nx\nMore typical package articles, used by pkgdown",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#r-workflow",
    "href": "analysis/r-setup-log.html#r-workflow",
    "title": "R Setup Log",
    "section": "R Workflow",
    "text": "R Workflow\nHere is the typical workflow I’m settling into (or at least trying to…I still don’t have TDD down just yet), once a project is created. Projects are either vanilla packages and don’t contain analysis/, like rdev, or “analysis packages” and bundle analysis notebooks as a project, like rtraining.\n\nCheck for updated packages when starting to work, (I created check_renv() for this) and check for errors using local CI checks (ci()).\nWhen creating a new function, write the documentation first, using Roxygen - this helps encourage up-front design and clarifies goals/requirements.\nWrite tests next - both happy path and negative test cases whenever possible. 100% test coverage is overkill, but I try to write a ‘data validity checker’ which also helps define the expected format of the data.\nTDD: run tests, write code that fails tests, fix code, repeat. (Don’t forget to refactor)\nI use trunk-based development, which I learned from Homebrew. I try to keep commits small, related, and implementing changes that don’t break code, merge back to main frequently - before the end of the day - and require linear commit history (ie rebase and merge).\nBefore pushing commits, I run style_all() and ci() to fix any problems locally (just “undo” in GitHub Desktop, fix, and re-commit).\n\nOne thing that annoys me is that by default, devtools just writes new lines to the end of .Rbuildignore, so I wrote sort_rbuildignore().",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "TODO.html",
    "href": "TODO.html",
    "title": "TODO",
    "section": "",
    "text": "Inspired by renv’s historical TODO.md\n\n\n\nAdd R Setup notebook\nAdd problems and solutions to the training log, including how to get around the limitation that you can’t debug R Notebooks. (considered and rejected the knitr-spin.R approach)\nAdd notes on resolving the error message generated by use_package(\"tidyverse\")\nUpdate README.Rmd\nAdd notes from https://r-pkgs.org\nConvert R Setup notebook to a vignette\nUpdate setup notes with current configuration using rig\n\n\n\n\n\nWrite wrapper functions to styler and lintr all files: the package, README.Rmd, and notebooks directory\nWrite a utility/maintenance function to verify: renv::status, renv::clean, and possibly renv::update - see https://github.com/rstudio/renv/blob/master/R/status.R\nWrite a utility function to sort .Rbuildignore\nMigrate utility functions to rdev\nIntegrate build-site and pkgdown using custom navbars\n\nImplement pkgdown\nRename notebooks/ to analysis/, build-site in a subdirectory (docs/analysis)\n\nRefactor site builder as an R function\n\nwrapper for rmarkdown::render_site()\nrun the build in a temporary directory like render_site()\nre-use code from render_site() to create list of R Notebooks\ndynamically build the _site.yml file using yaml with configuration settings passed to the wrapper function\ndynamically build the index.Rmd using DESCRIPTION\nsupport for additional links in the navbar\norder links by Title, not filename\nbetter logic for converting html_notebook to html_document\n\nMigrate site builder to rdev\nReview https://github.com/rstudio/renv/ for ideas to include here\nReview bslib, pkgdown documentation, and bootswatch themes to determine new site look and feel\nEvaluate converting from notebooks to a Quarto website\nReview https://github.com/jimbrig/rtraining/ for ideas to include here\n\n\n\n\n\nImplement site builder for a collection of notebooks leveraging the rmarkdown site generator, render_site\nUpdate DESCRIPTION and use description data in README.Rmd\nSet up GitHub Actions\n\nUse standard R CMD check\nUse lintr\n\nAdd GitHub Action for html/link checking using something like htmlproofer\nRun test coverage\nSwitch to full R CMD check ?\nAutobuild docs/ like pkgdown ?"
  },
  {
    "objectID": "TODO.html#content",
    "href": "TODO.html#content",
    "title": "TODO",
    "section": "",
    "text": "Add R Setup notebook\nAdd problems and solutions to the training log, including how to get around the limitation that you can’t debug R Notebooks. (considered and rejected the knitr-spin.R approach)\nAdd notes on resolving the error message generated by use_package(\"tidyverse\")\nUpdate README.Rmd\nAdd notes from https://r-pkgs.org\nConvert R Setup notebook to a vignette\nUpdate setup notes with current configuration using rig"
  },
  {
    "objectID": "TODO.html#package",
    "href": "TODO.html#package",
    "title": "TODO",
    "section": "",
    "text": "Write wrapper functions to styler and lintr all files: the package, README.Rmd, and notebooks directory\nWrite a utility/maintenance function to verify: renv::status, renv::clean, and possibly renv::update - see https://github.com/rstudio/renv/blob/master/R/status.R\nWrite a utility function to sort .Rbuildignore\nMigrate utility functions to rdev\nIntegrate build-site and pkgdown using custom navbars\n\nImplement pkgdown\nRename notebooks/ to analysis/, build-site in a subdirectory (docs/analysis)\n\nRefactor site builder as an R function\n\nwrapper for rmarkdown::render_site()\nrun the build in a temporary directory like render_site()\nre-use code from render_site() to create list of R Notebooks\ndynamically build the _site.yml file using yaml with configuration settings passed to the wrapper function\ndynamically build the index.Rmd using DESCRIPTION\nsupport for additional links in the navbar\norder links by Title, not filename\nbetter logic for converting html_notebook to html_document\n\nMigrate site builder to rdev\nReview https://github.com/rstudio/renv/ for ideas to include here\nReview bslib, pkgdown documentation, and bootswatch themes to determine new site look and feel\nEvaluate converting from notebooks to a Quarto website\nReview https://github.com/jimbrig/rtraining/ for ideas to include here"
  },
  {
    "objectID": "TODO.html#github",
    "href": "TODO.html#github",
    "title": "TODO",
    "section": "",
    "text": "Implement site builder for a collection of notebooks leveraging the rmarkdown site generator, render_site\nUpdate DESCRIPTION and use description data in README.Rmd\nSet up GitHub Actions\n\nUse standard R CMD check\nUse lintr\n\nAdd GitHub Action for html/link checking using something like htmlproofer\nRun test coverage\nSwitch to full R CMD check ?\nAutobuild docs/ like pkgdown ?"
  }
]