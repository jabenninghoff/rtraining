[
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Changelog",
    "section": "",
    "text": "Added FizzBuzz: My implementation of FizzBuzz in R, using a vector function"
  },
  {
    "objectID": "changelog.html#rtraining-1.3.0",
    "href": "changelog.html#rtraining-1.3.0",
    "title": "Changelog",
    "section": "",
    "text": "Added FizzBuzz: My implementation of FizzBuzz in R, using a vector function"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.12",
    "href": "changelog.html#rtraining-1.2.12",
    "title": "Changelog",
    "section": "rtraining 1.2.12",
    "text": "rtraining 1.2.12\n\nCorrected GitHub language stats"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.11",
    "href": "changelog.html#rtraining-1.2.11",
    "title": "Changelog",
    "section": "rtraining 1.2.11",
    "text": "rtraining 1.2.11\n\nUpdated for R 4.5.0"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.10",
    "href": "changelog.html#rtraining-1.2.10",
    "title": "Changelog",
    "section": "rtraining 1.2.10",
    "text": "rtraining 1.2.10\n\nMinor updates"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.9",
    "href": "changelog.html#rtraining-1.2.9",
    "title": "Changelog",
    "section": "rtraining 1.2.9",
    "text": "rtraining 1.2.9\n\nUpdated R Books: Added “Custom Fonts” section"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.8",
    "href": "changelog.html#rtraining-1.2.8",
    "title": "Changelog",
    "section": "rtraining 1.2.8",
    "text": "rtraining 1.2.8\n\nUpdated R Books: add summaries of What They Forgot to Teach You About R, DevOps for Data Science"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.7",
    "href": "changelog.html#rtraining-1.2.7",
    "title": "Changelog",
    "section": "rtraining 1.2.7",
    "text": "rtraining 1.2.7\n\nMoved Constraints vs Performance to new security analysis package"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.6",
    "href": "changelog.html#rtraining-1.2.6",
    "title": "Changelog",
    "section": "rtraining 1.2.6",
    "text": "rtraining 1.2.6\n\nMinor updates"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.5",
    "href": "changelog.html#rtraining-1.2.5",
    "title": "Changelog",
    "section": "rtraining 1.2.5",
    "text": "rtraining 1.2.5\n\nUpdated Constraints vs Performance: Added “Transparent Donut” section"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.4",
    "href": "changelog.html#rtraining-1.2.4",
    "title": "Changelog",
    "section": "rtraining 1.2.4",
    "text": "rtraining 1.2.4\n\nUpdated Constraints vs Performance: Added “Growth of Controls” section"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.3",
    "href": "changelog.html#rtraining-1.2.3",
    "title": "Changelog",
    "section": "rtraining 1.2.3",
    "text": "rtraining 1.2.3\n\nAdded Constraints vs Performance: Visualizations exploring the use of constraints vs performance improvements in risk management."
  },
  {
    "objectID": "changelog.html#rtraining-1.2.2",
    "href": "changelog.html#rtraining-1.2.2",
    "title": "Changelog",
    "section": "rtraining 1.2.2",
    "text": "rtraining 1.2.2\n\nUpdated for R 4.4.0"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.1",
    "href": "changelog.html#rtraining-1.2.1",
    "title": "Changelog",
    "section": "rtraining 1.2.1",
    "text": "rtraining 1.2.1\n\nAdded Hockey Cards Analysis: A simple Monte Carlo simulation in R, replicating Julia code from a LinkedIn post"
  },
  {
    "objectID": "changelog.html#rtraining-1.2.0",
    "href": "changelog.html#rtraining-1.2.0",
    "title": "Changelog",
    "section": "rtraining 1.2.0",
    "text": "rtraining 1.2.0\n\nAdded Conditional Probability: An exploration of conditional probabilities in R, inspired by a 2015 blog post on the hot hand"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.10",
    "href": "changelog.html#rtraining-1.1.10",
    "title": "Changelog",
    "section": "rtraining 1.1.10",
    "text": "rtraining 1.1.10\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.9",
    "href": "changelog.html#rtraining-1.1.9",
    "title": "Changelog",
    "section": "rtraining 1.1.9",
    "text": "rtraining 1.1.9\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.8",
    "href": "changelog.html#rtraining-1.1.8",
    "title": "Changelog",
    "section": "rtraining 1.1.8",
    "text": "rtraining 1.1.8\n\nUpdated site theme"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.7",
    "href": "changelog.html#rtraining-1.1.7",
    "title": "Changelog",
    "section": "rtraining 1.1.7",
    "text": "rtraining 1.1.7\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.6",
    "href": "changelog.html#rtraining-1.1.6",
    "title": "Changelog",
    "section": "rtraining 1.1.6",
    "text": "rtraining 1.1.6\n\nUsing Rcpp: added link to Corels package, additional follow-up notes"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.5",
    "href": "changelog.html#rtraining-1.1.5",
    "title": "Changelog",
    "section": "rtraining 1.1.5",
    "text": "rtraining 1.1.5\n\nAdded Using Rcpp: Notes on using Rcpp to implement Poker-Hand-Evaluator in the cards package\nUpdated R Books: updated reading list, notes on checkmate and validate"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.4",
    "href": "changelog.html#rtraining-1.1.4",
    "title": "Changelog",
    "section": "rtraining 1.1.4",
    "text": "rtraining 1.1.4\n\nUpdated R Training Log: fixed Wikipedia demo image colors"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.3",
    "href": "changelog.html#rtraining-1.1.3",
    "title": "Changelog",
    "section": "rtraining 1.1.3",
    "text": "rtraining 1.1.3\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.2",
    "href": "changelog.html#rtraining-1.1.2",
    "title": "Changelog",
    "section": "rtraining 1.1.2",
    "text": "rtraining 1.1.2\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.1",
    "href": "changelog.html#rtraining-1.1.1",
    "title": "Changelog",
    "section": "rtraining 1.1.1",
    "text": "rtraining 1.1.1\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-1.1.0",
    "href": "changelog.html#rtraining-1.1.0",
    "title": "Changelog",
    "section": "rtraining 1.1.0",
    "text": "rtraining 1.1.0\n\nAdded R Books: An actively maintained and curated list of R Books and other recommended resources from my reading list"
  },
  {
    "objectID": "changelog.html#rtraining-1.0.0",
    "href": "changelog.html#rtraining-1.0.0",
    "title": "Changelog",
    "section": "rtraining 1.0.0",
    "text": "rtraining 1.0.0\n\nMigrated site to Quarto"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.22",
    "href": "changelog.html#rtraining-0.8.22",
    "title": "Changelog",
    "section": "rtraining 0.8.22",
    "text": "rtraining 0.8.22\n\nUpdated installation instructions in README and templates to use remotes instead of devtools"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.21",
    "href": "changelog.html#rtraining-0.8.21",
    "title": "Changelog",
    "section": "rtraining 0.8.21",
    "text": "rtraining 0.8.21\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.20",
    "href": "changelog.html#rtraining-0.8.20",
    "title": "Changelog",
    "section": "rtraining 0.8.20",
    "text": "rtraining 0.8.20\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.19",
    "href": "changelog.html#rtraining-0.8.19",
    "title": "Changelog",
    "section": "rtraining 0.8.19",
    "text": "rtraining 0.8.19\n\nMaintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.18",
    "href": "changelog.html#rtraining-0.8.18",
    "title": "Changelog",
    "section": "rtraining 0.8.18",
    "text": "rtraining 0.8.18\n\nUpdated Advanced R Workbook (Metaprogramming): add partial solutions for Chapter 20"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.17",
    "href": "changelog.html#rtraining-0.8.17",
    "title": "Changelog",
    "section": "rtraining 0.8.17",
    "text": "rtraining 0.8.17\n\nAdded Advanced R Workbook (Metaprogramming): Workbook for completing quizzes and exercises from the “Object-oriented programming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions\nUpdated Advanced R Workbook (Metaprogramming): add solutions for Chapter 18, 19"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.16",
    "href": "changelog.html#rtraining-0.8.16",
    "title": "Changelog",
    "section": "rtraining 0.8.16",
    "text": "rtraining 0.8.16\n\nMaintenance update"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.15",
    "href": "changelog.html#rtraining-0.8.15",
    "title": "Changelog",
    "section": "rtraining 0.8.15",
    "text": "rtraining 0.8.15\n\nMaintenance update"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.14",
    "href": "changelog.html#rtraining-0.8.14",
    "title": "Changelog",
    "section": "rtraining 0.8.14",
    "text": "rtraining 0.8.14\n\nUpdated Advanced R Workbook (Object-oriented programming): add solutions for Chapter 14, 15"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.13",
    "href": "changelog.html#rtraining-0.8.13",
    "title": "Changelog",
    "section": "rtraining 0.8.13",
    "text": "rtraining 0.8.13\n\nMinor fixes"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.12",
    "href": "changelog.html#rtraining-0.8.12",
    "title": "Changelog",
    "section": "rtraining 0.8.12",
    "text": "rtraining 0.8.12\n\nAdded ggplot2 (Getting started): Workbook for completing quizzes and exercises from the “Getting started” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis\nAdded ggplot2 (Layers): Workbook for completing quizzes and exercises from the “Layers” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis\nAdded ggplot2 (Scales): Workbook for completing quizzes and exercises from the “Scales” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis\nAdded ggplot2 (Grammar): Workbook for completing quizzes and exercises from the “Grammar” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis\nAdded ggplot2 (Extending): Workbook for completing quizzes and exercises from the “Extending” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.11",
    "href": "changelog.html#rtraining-0.8.11",
    "title": "Changelog",
    "section": "rtraining 0.8.11",
    "text": "rtraining 0.8.11\n\nAdded Advanced R Workbook (Object-oriented programming): Workbook for completing quizzes and exercises from the “Object-oriented programming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions\nUpdated Advanced R Workbook (Object-oriented programming): add solutions for Chapter 13"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.10",
    "href": "changelog.html#rtraining-0.8.10",
    "title": "Changelog",
    "section": "rtraining 0.8.10",
    "text": "rtraining 0.8.10\n\nUpdated Advanced R Workbook (Functional programming): add solutions for Chapter 10, 11"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.9",
    "href": "changelog.html#rtraining-0.8.9",
    "title": "Changelog",
    "section": "rtraining 0.8.9",
    "text": "rtraining 0.8.9\n\nUpdated Advanced R Workbook (Functional programming): add solutions for Chapter 9"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.8",
    "href": "changelog.html#rtraining-0.8.8",
    "title": "Changelog",
    "section": "rtraining 0.8.8",
    "text": "rtraining 0.8.8\n\nUpdated Advanced R Workbook (Foundations): add AR Solutions for Chapter 4-8\nAdded Advanced R Workbook (Functional programming): Workbook for completing quizzes and exercises from the “Functional programming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.7",
    "href": "changelog.html#rtraining-0.8.7",
    "title": "Changelog",
    "section": "rtraining 0.8.7",
    "text": "rtraining 0.8.7\n\nUpdated Advanced R Workbook (Foundations): add AR Solutions for Chapter 3"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.6",
    "href": "changelog.html#rtraining-0.8.6",
    "title": "Changelog",
    "section": "rtraining 0.8.6",
    "text": "rtraining 0.8.6\n\nUpdated Advanced R Workbook (Foundations): add AR Solutions for Chapter 2, add workaround for plot rendering issue\nUpdate site to Bootstrap 5"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.5",
    "href": "changelog.html#rtraining-0.8.5",
    "title": "Changelog",
    "section": "rtraining 0.8.5",
    "text": "rtraining 0.8.5\n\nRenamed “Advanced R Workbook” to “Advanced R Workbook (Foundations)”; future notebooks will be added for each major section\nUpdated Advanced R Workbook (Foundations): completed Chapter 6-8, added Solutions section for comparing solutions against Advanced R Solutions"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.4",
    "href": "changelog.html#rtraining-0.8.4",
    "title": "Changelog",
    "section": "rtraining 0.8.4",
    "text": "rtraining 0.8.4\n\nUpdated Advanced R Workbook: completed Chapter 4, 5"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.3",
    "href": "changelog.html#rtraining-0.8.3",
    "title": "Changelog",
    "section": "rtraining 0.8.3",
    "text": "rtraining 0.8.3\n\nUpdated Advanced R Workbook: completed Chapter 3"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.2",
    "href": "changelog.html#rtraining-0.8.2",
    "title": "Changelog",
    "section": "rtraining 0.8.2",
    "text": "rtraining 0.8.2\n\nUpdate links"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.1",
    "href": "changelog.html#rtraining-0.8.1",
    "title": "Changelog",
    "section": "rtraining 0.8.1",
    "text": "rtraining 0.8.1\n\nAdd demo from Wikipedia article on R\nUpdated Advanced R Workbook: added Chapter 3, 3.2.5 Exercises\nReplace development lintr with CRAN release 3.0.0"
  },
  {
    "objectID": "changelog.html#rtraining-0.8.0",
    "href": "changelog.html#rtraining-0.8.0",
    "title": "Changelog",
    "section": "rtraining 0.8.0",
    "text": "rtraining 0.8.0\n\nAdded Advanced R Workbook: Workbook for completing quizzes and exercises from Advanced R, second edition.\nmaintenance updates, update links"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.17",
    "href": "changelog.html#rtraining-0.7.17",
    "title": "Changelog",
    "section": "rtraining 0.7.17",
    "text": "rtraining 0.7.17\n\nmaintenance release"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.16",
    "href": "changelog.html#rtraining-0.7.16",
    "title": "Changelog",
    "section": "rtraining 0.7.16",
    "text": "rtraining 0.7.16\n\nmaintenance release"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.15",
    "href": "changelog.html#rtraining-0.7.15",
    "title": "Changelog",
    "section": "rtraining 0.7.15",
    "text": "rtraining 0.7.15\n\nmaintenance release, fix links"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.14",
    "href": "changelog.html#rtraining-0.7.14",
    "title": "Changelog",
    "section": "rtraining 0.7.14",
    "text": "rtraining 0.7.14\n\nmaintenance release"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.13",
    "href": "changelog.html#rtraining-0.7.13",
    "title": "Changelog",
    "section": "rtraining 0.7.13",
    "text": "rtraining 0.7.13\n\nmaintenance release"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.12",
    "href": "changelog.html#rtraining-0.7.12",
    "title": "Changelog",
    "section": "rtraining 0.7.12",
    "text": "rtraining 0.7.12\n\nmaintenance release, minor updates to rtraining log"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.11",
    "href": "changelog.html#rtraining-0.7.11",
    "title": "Changelog",
    "section": "rtraining 0.7.11",
    "text": "rtraining 0.7.11\n\nmaintenance release"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.10",
    "href": "changelog.html#rtraining-0.7.10",
    "title": "Changelog",
    "section": "rtraining 0.7.10",
    "text": "rtraining 0.7.10\n\nmaintenance release, fix broken links"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.9",
    "href": "changelog.html#rtraining-0.7.9",
    "title": "Changelog",
    "section": "rtraining 0.7.9",
    "text": "rtraining 0.7.9\n\nImportant update from renv 0.15.0 to 0.15.1"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.8",
    "href": "changelog.html#rtraining-0.7.8",
    "title": "Changelog",
    "section": "rtraining 0.7.8",
    "text": "rtraining 0.7.8\n\nUpdated with new analysis package updates"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.7",
    "href": "changelog.html#rtraining-0.7.7",
    "title": "Changelog",
    "section": "rtraining 0.7.7",
    "text": "rtraining 0.7.7\n\nmaintenance release"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.6",
    "href": "changelog.html#rtraining-0.7.6",
    "title": "Changelog",
    "section": "rtraining 0.7.6",
    "text": "rtraining 0.7.6\n\nAdd new viridis_quo() styling to rtraining log, maintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.5",
    "href": "changelog.html#rtraining-0.7.5",
    "title": "Changelog",
    "section": "rtraining 0.7.5",
    "text": "rtraining 0.7.5\n\nmaintenance release"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.4",
    "href": "changelog.html#rtraining-0.7.4",
    "title": "Changelog",
    "section": "rtraining 0.7.4",
    "text": "rtraining 0.7.4\n\nmaintenance release, update README and GitHub Actions"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.3",
    "href": "changelog.html#rtraining-0.7.3",
    "title": "Changelog",
    "section": "rtraining 0.7.3",
    "text": "rtraining 0.7.3\n\nAdd FaultTree.widget Test notebook for demonstrating ftree2widget() issue"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.2",
    "href": "changelog.html#rtraining-0.7.2",
    "title": "Changelog",
    "section": "rtraining 0.7.2",
    "text": "rtraining 0.7.2\n\nmaintenance release"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.1",
    "href": "changelog.html#rtraining-0.7.1",
    "title": "Changelog",
    "section": "rtraining 0.7.1",
    "text": "rtraining 0.7.1\n\nmaintenance release, updated for R 4.1.0"
  },
  {
    "objectID": "changelog.html#rtraining-0.7.0",
    "href": "changelog.html#rtraining-0.7.0",
    "title": "Changelog",
    "section": "rtraining 0.7.0",
    "text": "rtraining 0.7.0\n\nbuild_analysis_site() migrated to rdev"
  },
  {
    "objectID": "changelog.html#rtraining-0.6.0",
    "href": "changelog.html#rtraining-0.6.0",
    "title": "Changelog",
    "section": "rtraining 0.6.0",
    "text": "rtraining 0.6.0\n\nNew Features\n\nmajor update: build-site has been replaced with an R function, build_analysis_site(), which retains all of the functionality of the old shell script. It is still considered Experimental, due to lack of test coverage and some features that are not implemented, but should work for projects with limited pkgdown customization. The update also includes a function to convert notebooks to html_document, to_document().\nbuild_analysis_site() will be migrated to rdev in a future release\n\n\n\nNew Content\n\nR Setup Log: added notes on the package layout I use for “analysis” packages (will be converted to an rdev vignette in a future release)\nR Setup Log: added notes on my R Workflow\nR Training Log: updated with notes on my current book, R Packages"
  },
  {
    "objectID": "changelog.html#rtraining-0.5.1",
    "href": "changelog.html#rtraining-0.5.1",
    "title": "Changelog",
    "section": "rtraining 0.5.1",
    "text": "rtraining 0.5.1\n\nR Training Log content updates"
  },
  {
    "objectID": "changelog.html#rtraining-0.5.0",
    "href": "changelog.html#rtraining-0.5.0",
    "title": "Changelog",
    "section": "rtraining 0.5.0",
    "text": "rtraining 0.5.0\n\nmoved rmarkdown::render_site header files to pkgdown - analysis now contains only R Notebooks!"
  },
  {
    "objectID": "changelog.html#rtraining-0.4.0",
    "href": "changelog.html#rtraining-0.4.0",
    "title": "Changelog",
    "section": "rtraining 0.4.0",
    "text": "rtraining 0.4.0\npkgdown integration\n\nbuild-site has been updated to (mostly) seamlessly build a site that integrates pkgdown as the base site and adds an “Analysis” menu that contains all of the R Notebooks (html_notebook) or Documents (html_document) in analysis/ (moved from notebooks/)"
  },
  {
    "objectID": "changelog.html#rtraining-0.3.0",
    "href": "changelog.html#rtraining-0.3.0",
    "title": "Changelog",
    "section": "rtraining 0.3.0",
    "text": "rtraining 0.3.0\nrdev migration\n\nci(), check_renv(), style_all(), lint_all(), and tools/setup-r have been migrated to rdev, my “opinionated collection of R development tools”\nrtraining has been updated to import and load development tools through rdev\nupdated README"
  },
  {
    "objectID": "changelog.html#rtraining-0.2.1",
    "href": "changelog.html#rtraining-0.2.1",
    "title": "Changelog",
    "section": "rtraining 0.2.1",
    "text": "rtraining 0.2.1\n\nupdated package description (Authors)\nGitHub Action updates"
  },
  {
    "objectID": "changelog.html#rtraining-0.2.0",
    "href": "changelog.html#rtraining-0.2.0",
    "title": "Changelog",
    "section": "rtraining 0.2.0",
    "text": "rtraining 0.2.0\n\nNew Content/Features\n\nci(): run continuous integration tests locally: lint, R CMD check, and style (off by default).\ncheck_renv(): convenience function that runs renv status(), clean(), and optionally update() (on by default)."
  },
  {
    "objectID": "changelog.html#rtraining-0.1.1",
    "href": "changelog.html#rtraining-0.1.1",
    "title": "Changelog",
    "section": "rtraining 0.1.1",
    "text": "rtraining 0.1.1\n\nminor maintenance updates"
  },
  {
    "objectID": "changelog.html#rtraining-0.1.0",
    "href": "changelog.html#rtraining-0.1.0",
    "title": "Changelog",
    "section": "rtraining 0.1.0",
    "text": "rtraining 0.1.0\nInitial GitHub release\n\nNew Content/Features\n\nR Setup Log Notebook (r-setup-log.Rmd): My notes on my personal R setup\nminor updates to R Training Log\nstyle_all(): style all .R and .Rmd files in a project using styler\nlint_all(): lint all .R and .Rmd files in a project using lintr\nadd GitHub Actions for continuous integration testing"
  },
  {
    "objectID": "changelog.html#rtraining-0.0.1",
    "href": "changelog.html#rtraining-0.0.1",
    "title": "Changelog",
    "section": "rtraining 0.0.1",
    "text": "rtraining 0.0.1\nPre-release\n\ninitial package setup, GitHub pages build\n\n\nNew Content/Features\n\nR Training Log Notebook (r-training-log.Rmd): Notes on learning R and RStudio\ntools/setup-r: shell script to install development packages to site repository on macOS + Homebrew\nbuild-site: build a website from a collection of R Notebooks (html_notebook) in notebooks/"
  },
  {
    "objectID": "TODO.html",
    "href": "TODO.html",
    "title": "TODO",
    "section": "",
    "text": "Inspired by renv’s historical TODO.md\n\n\n\nAdd R Setup notebook\nAdd problems and solutions to the training log, including how to get around the limitation that you can’t debug R Notebooks. (considered and rejected the knitr-spin.R approach)\nAdd notes on resolving the error message generated by use_package(\"tidyverse\")\nUpdate README.Rmd\nAdd notes from https://r-pkgs.org\nConvert R Setup notebook to a vignette\nUpdate setup notes with current configuration using rig\n\n\n\n\n\nWrite wrapper functions to styler and lintr all files: the package, README.Rmd, and notebooks directory\nWrite a utility/maintenance function to verify: renv::status, renv::clean, and possibly renv::update - see https://github.com/rstudio/renv/blob/master/R/status.R\nWrite a utility function to sort .Rbuildignore\nMigrate utility functions to rdev\nIntegrate build-site and pkgdown using custom navbars\n\nImplement pkgdown\nRename notebooks/ to analysis/, build-site in a subdirectory (docs/analysis)\n\nRefactor site builder as an R function\n\nwrapper for rmarkdown::render_site()\nrun the build in a temporary directory like render_site()\nre-use code from render_site() to create list of R Notebooks\ndynamically build the _site.yml file using yaml with configuration settings passed to the wrapper function\ndynamically build the index.Rmd using DESCRIPTION\nsupport for additional links in the navbar\norder links by Title, not filename\nbetter logic for converting html_notebook to html_document\n\nMigrate site builder to rdev\nReview https://github.com/rstudio/renv/ for ideas to include here\nReview bslib, pkgdown documentation, and bootswatch themes to determine new site look and feel\nEvaluate converting from notebooks to a Quarto website\nReview https://github.com/jimbrig/rtraining/ for ideas to include here\n\n\n\n\n\nImplement site builder for a collection of notebooks leveraging the rmarkdown site generator, render_site\nUpdate DESCRIPTION and use description data in README.Rmd\nSet up GitHub Actions\n\nUse standard R CMD check\nUse lintr\n\nAdd GitHub Action for html/link checking using something like htmlproofer\nRun test coverage\nSwitch to full R CMD check ?\nAutobuild docs/ like pkgdown ?"
  },
  {
    "objectID": "TODO.html#content",
    "href": "TODO.html#content",
    "title": "TODO",
    "section": "",
    "text": "Add R Setup notebook\nAdd problems and solutions to the training log, including how to get around the limitation that you can’t debug R Notebooks. (considered and rejected the knitr-spin.R approach)\nAdd notes on resolving the error message generated by use_package(\"tidyverse\")\nUpdate README.Rmd\nAdd notes from https://r-pkgs.org\nConvert R Setup notebook to a vignette\nUpdate setup notes with current configuration using rig"
  },
  {
    "objectID": "TODO.html#package",
    "href": "TODO.html#package",
    "title": "TODO",
    "section": "",
    "text": "Write wrapper functions to styler and lintr all files: the package, README.Rmd, and notebooks directory\nWrite a utility/maintenance function to verify: renv::status, renv::clean, and possibly renv::update - see https://github.com/rstudio/renv/blob/master/R/status.R\nWrite a utility function to sort .Rbuildignore\nMigrate utility functions to rdev\nIntegrate build-site and pkgdown using custom navbars\n\nImplement pkgdown\nRename notebooks/ to analysis/, build-site in a subdirectory (docs/analysis)\n\nRefactor site builder as an R function\n\nwrapper for rmarkdown::render_site()\nrun the build in a temporary directory like render_site()\nre-use code from render_site() to create list of R Notebooks\ndynamically build the _site.yml file using yaml with configuration settings passed to the wrapper function\ndynamically build the index.Rmd using DESCRIPTION\nsupport for additional links in the navbar\norder links by Title, not filename\nbetter logic for converting html_notebook to html_document\n\nMigrate site builder to rdev\nReview https://github.com/rstudio/renv/ for ideas to include here\nReview bslib, pkgdown documentation, and bootswatch themes to determine new site look and feel\nEvaluate converting from notebooks to a Quarto website\nReview https://github.com/jimbrig/rtraining/ for ideas to include here"
  },
  {
    "objectID": "TODO.html#github",
    "href": "TODO.html#github",
    "title": "TODO",
    "section": "",
    "text": "Implement site builder for a collection of notebooks leveraging the rmarkdown site generator, render_site\nUpdate DESCRIPTION and use description data in README.Rmd\nSet up GitHub Actions\n\nUse standard R CMD check\nUse lintr\n\nAdd GitHub Action for html/link checking using something like htmlproofer\nRun test coverage\nSwitch to full R CMD check ?\nAutobuild docs/ like pkgdown ?"
  },
  {
    "objectID": "analysis/r-setup-log.html",
    "href": "analysis/r-setup-log.html",
    "title": "R Setup Log",
    "section": "",
    "text": "My notes on my personal R setup. I started my R journey in September 2020 after SIRACon 2020. Important: this historical setup is outdated and differs from my current approach, which is documented in rdev.\n# no libraries",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#installing-r",
    "href": "analysis/r-setup-log.html#installing-r",
    "title": "R Setup Log",
    "section": "Installing R",
    "text": "Installing R\nI prefer installing R and RStudio using Homebrew. I use Homebrew Bundle to install all software on my systems, but installing R and RStudio is simple enough using the command line:\n\nbrew install --formula r && brew install --cask rstudio\n\nR Variants\nTL;DR: just use homebrew.\nI don’t recommend installing the cask variant of r because it creates problems with brew doctor:\n\nbrew info --cask r\n\n==&gt; r-app: 4.5.1\nhttps://www.r-project.org/\nNot installed\nFrom: https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/r/r-app.rb\n==&gt; Name\nR\n==&gt; Description\nEnvironment for statistical computing and graphics\n==&gt; Artifacts\nR-4.5.1-arm64.pkg (Pkg)\n==&gt; Analytics\ninstall: 1,314 (30 days), 2,440 (90 days), 2,440 (365 days)\n\n\nI tried “installing all the things” with homebrew-r-srf but didn’t like how the uninstall doesn’t clean up, and frankly, I haven’t found a need for more than the capabilities included with homebrew R:\n\ncapabilities()\n\n       jpeg         png        tiff       tcltk         X11        aqua \n       TRUE        TRUE        TRUE        TRUE        TRUE        TRUE \n   http/ftp     sockets      libxml        fifo      cledit       iconv \n       TRUE        TRUE       FALSE        TRUE       FALSE        TRUE \n        NLS       Rprof     profmem       cairo         ICU long.double \n       TRUE        TRUE        TRUE        TRUE        TRUE       FALSE \n    libcurl \n       TRUE \n\n\nCurrently, this is everything except the X11 dependencies, which aren’t really needed:\n?capabilities\n\nNote to macOS users\nCapabilities “jpeg”, “png” and “tiff” refer to the X11-based versions of these devices. If capabilities(“aqua”) is true, then these devices with type = “quartz” will be available, and out-of-the-box will be the default type. Thus for example the tiff device will be available if capabilities(“aqua”) || capabilities(“tiff”) if the defaults are unchanged.\n\nAs an active contributor to Homebrew, I strongly recommend using it for any/all software; their quality control is excellent.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#r-workspace",
    "href": "analysis/r-setup-log.html#r-workspace",
    "title": "R Setup Log",
    "section": "R Workspace",
    "text": "R Workspace\nOnce R and RStudio have been installed, you’ll need a development environment and some packages.\n\nDevelopment Environment\nWell, obviously, I use RStudio. There are other IDEs available, and it’s also possible to develop using the command line, but RStudio provides a pleasant, integrated experience for R development, and actively supports the R community. I don’t typically use the built-in Git client, instead using the GitHub Desktop client and git command-line tool.\nbrew install github\nI also occasionally use vim (mainly for shell scripts) and atom (mainly for vanilla .md files using markdown-preview-enhanced).\n\n\nPackages\nManaging packages and environments are a challenge for most modern languages. Thankfully R doesn’t have the same level of challenge as python, or even ruby, managing packages available within a project is a best practice. I use renv for this purpose. (I originally discovered packrat but quickly discovered RStudio is replacing it with renv)\nHere is my package maintenance approach:\n\nBase R Packages\nWith no projects open, I periodically check for updates to the base R packages using the RStudio Packages “Update” function. These are the only packages I install to the base directory /usr/local/Cellar/r/4.0.3_2/lib/R/library. Note: upgrading or reinstalling r through homebrew may ‘downgrade’ the base packages.\n\n\nDevelopment Packages\nThe only other tools I install outside of projects are for supporting development. Originally this was just renv, but now it includes a number of development tools needed to create projects. I use the R site library used by homebrew, currently /usr/local/lib/R/4.0/site-library. I’ve developed a shell script to install development packages that you can find in the tools directory of this repository.\n#!/bin/sh\n# install development packages to site repository\n# thanks to https://blog.sellorm.com/2017/10/21/quick-script-to-install-an-r-package-from-the-command-line/\n# and https://github.com/Homebrew/homebrew-core/blob/master/Formula/r/r.rb\n# designed to work with homebrew: `brew install --formula r && brew install --cask rstudio`\nset -ex # halt script on error, echo on\n\nPREFIX=`brew --prefix`\nRVERSION=`${PREFIX}/bin/Rscript -e 'cat(as.character(getRversion()[1,1:2]))'`\nSITELIB=\"${PREFIX}/lib/R/${RVERSION}/site-library\"\nDEVPKG='c(\"renv\", \"styler\", \"lintr\", \"miniUI\", \"devtools\", \"available\")'\n\nif [ ! -d \"${SITELIB}\" ]\nthen\n    echo \"fatal error: ${SITELIB} does not exist - not using \\`brew install --formula r\\`?\"\n    exit 1\nfi\n\nbrew install libgit2 # required by devtools\n\necho \"install.packages(${DEVPKG}, repos=\\\"https://cran.rstudio.com\\\", lib=\\\"${SITELIB}\\\")\" | R --no-save\n\n\nProject Packages\nAny packages not needed to create projects I install within a project using renv - here are some good intros:\n\nA presentation at rstudio::conf 2020\nThe RStudio Blog post\nAn Introduction to renv\nrenv on GitHub\n\nrenv::init() # to set up renv in the project\nrenv::install(\"rtraining\") # to install a package\nrenv::status() # checks if renv.lock is in sync\nrenv::snapshot() # save libraries in renv.lock\nrenv::restore() # restore libraries from renv.lock - use when first using an existing project\nrenv::clean() # remove extra libraries\nrenv::update() # check for unpdated versions of installed libraries\nIf you’re installing (development) versions of packages from GitHub, you’ll be prompted to set up a personal access token using create_github_token() and adding it to your .Renviron as GITHUB_PAT= using usethis::edit_r_environ(). I had to install the development versions of both styler and lintr due to bugs not yet fixed in the released (CRAN) versions. I did also look at using pak but found it too buggy to use.\nNote: I came across an odd quirk where renv will prompt you to upgrade base R projects, even if they’re not used. I resolved these by just upgrading the base packages with RStudio with no project open.\nI’ve included some comments on useful packages in my R Training Log notebook.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#using-r",
    "href": "analysis/r-setup-log.html#using-r",
    "title": "R Setup Log",
    "section": "Using R",
    "text": "Using R\nSo - what have I learned about using R? I won’t cover the actual Data Science part here, but have some recommended reading in my R Training Log.\n\nUse git!\nThis wasn’t really something I learned with R, but use of version control for any kind of code/script is crucial. These days, I keep all scripts and configuration files in some flavor of public or private version control. Mostly that means GitHub, but also private git servers (via ssh) are easy to set up for work that you want to keep off of GitHub.\nI don’t want to get too much into managing code via version control, but I favor trunk-based development with short-lived branches, small commits of working code, and rebase and merge for linear commit history. There’s a lot of good research on this topic from Google’s Dev Ops Research and Assessment team.\n\n\nUsing RStudio with GitHub\nRStudio has good integration with GitHub. I’ve adopted the convention of “one RStudio Project (.Rproj) per repository” and storing the Rproj file in the repository. That seems to be the norm.\n\n\nR Notebooks\nR Notebooks are my preferred file format for data analysis, as they allow an easy mixing of text (using pandoc markdown) and R code chunks. This allows me to document what I’m doing as I go, both for reproducibility as well as recording my observations, thoughts and conclusions. It especially lends itself to iterative development:\n\nWrite code\nRun code\nSee results\nUpdate code\n\nThis method of development is not always appropriate, but fits well with exploratory analysis. Once I get to writing functions, I’m starting to adopt the formal structure of packages, testthat, and roxygen2.\nSpecifically, I use html_notebook, which was recommended to me. RStudio handles this differently than html_document:\n\n\n\n\n\n\n\n\nBehavior\nhtml_notebook\nhtml_document\n\n\n\n\nQuick View\nPreview Button\nNo Preview Button\n\n\nSaving Files\nAutomatically knits file on save\nManually knit file\n\n\nRendering Files\nRenders R output as it exists in the IDE on save\nRenders R output by running all R code\n\n\nDefault Options\nIncludes options for readability, hiding and downloading code, and paged tables\nHigher-quality rendering of PNG graphics\n\n\n\nEssentially, R Notebooks are generally faster and more convenient when doing analysis, and html_document R Markdown files offer higher-quality output. This site uses a custom framework to convert html_notebooks to html_documents for publishing (see the next section for details). They are also a convenient way to share analysis with peers - just email the .nb.html file, which will include all of the output, as well as embedding the .Rmd source code for easy editing. This also allows people who don’t have R/RStudio to see the results of an analysis.\nThere are some drawbacks to using R Notebooks:\n\nBecause R Notebooks are render-on-save, you can inadvertently end up with missing or outdated R output from your notebook when saving, if you’ve made updates and haven’t re-run the entire document. My habit is to do the following at the end of a writing session, before committing to git, which ensures a “clean” notebook:\n\nClear the Global Environment\n“Restart R and Clear Output”\n“Run All”\nSave\n\nDebug breakpoints don’t work in R Markdown documents. To fix this, convert R Markdown documents to R Scripts using purl for debugging.\nNot really a drawback, but…Rcpp and rprojroot are erroneously listed in RStudio as required to create R Markdown, which can also cause problems with renv. This is a bug in RStudio, which will be fixed in version 1.4.944.\n\n\n\nPublishing R Notebooks\nSince R Notebooks are saved as html files, it’s possible to publish them on GitHub using GitHub pages. GitHub published a tutorial in 2018 on getting RStudio integrated with GitHub, and I started working on that. Quickly I discovered that while the tutorial was helpful, it wasn’t quite the setup I wanted; it published R Markdown through GitHub pages, but wouldn’t directly support the automatically generated html of R Notebooks. After more searching, I was able to get Notebooks working on GitHub, but I used the method described in rstudio/rmarkdown #1020 - checking in the .nb.html into git, and using GitHub Pages so that you can view the rendered HTML instead of just the HTML code.\n\nPublishing with rmarkdown\nAfter using README.md and GitHub pages to publish notebooks, I found I wanted an easier way to publish and navigate across collections of notebooks. Publishing R Notebooks on GitHub pages works fine, but doesn’t offer an easy navigation structure, like pkgdown. I tried using pkgdown to display notebooks, but pkgdown only supports building vignettes, which have a distinctly different look and feel than R Notebooks. The rmarkdown site generator, render_site, allows more flexible building of websites from R Markdown files with a simple navigation bar at the top, but doesn’t support html_notebook files OOB.\nTo work around this, I created a simple framework for converting html_notebook files to html_document and building a _site.yml from a list of notebooks stored in the non-standard notebooks/ directory, initially using a shell script, build_site (stored at the root of this repo). It does the following:\n\nCreates a working directory, .build-site\nBuilds a rmarkdown::render_site() _site.yml file that includes a menu with all notebooks in the notebooks/ directory\nCopies all .Rmd files to .build-site changing their type from html_notebook to html_document\nIncludes some configuration to make html_documents work more like html_notebook\nCalls rmarkdown::render_site() to render the site in the docs/ directory\n\nI typically rebuild a site with the following command, run from the top-level directory of the project:\nrm -rf .build-site && sh build-site && open docs/index.html\nThis approach leverages the docs functionality of GitHub pages, like pkgdown.\n\n\nUpdate on Publishing\nbuild-site has been replaced with build_analysis_site()! At its core, it is functionally the same: builds a pkgdown site, adding an “Analysis” menu with all notebooks in the (renamed) analysis/ directory, then converts and builds the notebooks using rmarkdown, and moves them into the docs/ directory. Since it is now an R Script, it’s more portable and can be more easily bundled with packages. I will be migrating its functionality to rdev shortly, so that it’s usable across multiple analysis projects.\n\n\n\nR Package Layout\nHere is my package layout - the table shows the path, whether it’s part of the formal R package definition, and my notes on its use.\n\n\n\nPath\nR\nNotes\n\n\n\n\n.Rbuildignore\nx\nExclude files from package\n\n\n.Rprofile\nx\nUsed by renv and to attach development tools\n\n\n.github\n\nGitHub templates and workflows\n\n\n.gitignore\nx\nI use R and macOS exclusions, and always exclude generated files outside of docs/\n\n\n.lintr\n\nlintr default linters with 100 columns: linters: with_defaults(line_length_linter(100))\n\n\nDESCRIPTION\nx\nuse “Suggests” for development tools, per renv\n\n\nLICENSE\nx\nGenerated with use_mit_license()\n\n\nLICENSE.md\n\nSee above, used by pkgdown\n\n\nNAMESPACE\nx\nGenerated with roxygen2\n\n\nNEWS.md\n\nRelease notes, used by pkgdown\n\n\nREADME.Rmd\nx\nGenerated with use_readme_md()\n\n\nREADME.md\nx\nGenerated with build_readme()\n\n\nR\nx\nAll project functions go here, with roxygen2 comments\n\n\nTODO.md\n\nTo-do list, inspired by renv’s historical TODO.md\n\n\nanalysis\n\nExploratory data analysis in R Notebooks and R Presentations\n\n\nanalysis/data\n\nWhen appropriate, analysis data lives here\n\n\nanalysis/assets\n\nExternal assets (images, other files) included in R Notebooks\n\n\nanalysis/rendered\n\nManually rendered html versions of analysis/ files to be included in docs/, ie .Rpres files, not stored in git\n\n\ndemos\nx\nI don’t use demos, as recommended by R Packages\n\n\ndocs\n\nUsed by pkgdown::build_site() and R Notebooks rendered as html_document using rmarkdown::render_site() via build_analysis_site()\n\n\nexec\nx\nIn theory this is where command line executable scrips reside\n\n\ninst/templates/rmarkdown\nx\nPlanned location for R Markdown Templates\n\n\nman\nx\nGenerated with roxygen2\n\n\npackage.Rproj\n\nI use the same name for the package, .Rproj, directory, and GitHub repo\n\n\npkgdown\n\nI store all pkgdown files here\n\n\npo\nx\nUsed for Internationalization\n\n\nrenv\n\nUsed by renv\n\n\nrenv.lock\n\nThe renv lockfile\n\n\ntests\nx\nTests using testthat\n\n\ntools\nx\nI use tools/ for shell scripts that support development, like setup-r\n\n\nvignettes\nx\nMore typical package articles, used by pkgdown\n\n\n\n\n\nR Workflow\nHere is the typical workflow I’m settling into (or at least trying to…I still don’t have TDD down just yet), once a project is created. Projects are either vanilla packages and don’t contain analysis/, like rdev, or “analysis packages” and bundle analysis notebooks as a project, like rtraining.\n\nCheck for updated packages when starting to work, (I created check_renv() for this) and check for errors using local CI checks (ci()).\nWhen creating a new function, write the documentation first, using Roxygen - this helps encourage up-front design and clarifies goals/requirements.\nWrite tests next - both happy path and negative test cases whenever possible. 100% test coverage is overkill, but I try to write a ‘data validity checker’ which also helps define the expected format of the data.\nTDD: run tests, write code that fails tests, fix code, repeat. (Don’t forget to refactor)\nI use trunk-based development, which I learned from Homebrew. I try to keep commits small, related, and implementing changes that don’t break code, merge back to main frequently - before the end of the day - and require linear commit history (ie rebase and merge).\nBefore pushing commits, I run style_all() and ci() to fix any problems locally (just “undo” in GitHub Desktop, fix, and re-commit).\n\nOne thing that annoys me is that by default, devtools just writes new lines to the end of .Rbuildignore, so I wrote sort_rbuildignore().",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/r-setup-log.html#next-steps",
    "href": "analysis/r-setup-log.html#next-steps",
    "title": "R Setup Log",
    "section": "Next Steps",
    "text": "Next Steps\nI’ll keep adding to this document as I go, and will likely eventually migrate this notebook to a vignette and switch to pkgdown.",
    "crumbs": [
      "Changelog",
      "R Setup Log"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html",
    "href": "analysis/advanced-r-3.html",
    "title": "Advanced R (Object-oriented programming)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Object-oriented programming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions.\nlibrary(sloop)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(R6)\nlibrary(methods)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#introduction",
    "href": "analysis/advanced-r-3.html#introduction",
    "title": "Advanced R (Object-oriented programming)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from Advanced R and Advanced R Solutions, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read Advanced R and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#base-types",
    "href": "analysis/advanced-r-3.html#base-types",
    "title": "Advanced R (Object-oriented programming)",
    "section": "12 Base types",
    "text": "12 Base types\nTo talk about objects and OOP in R we first need to clear up a fundamental confusion about two uses of the word “object”. So far in this book, we’ve used the word in the general sense captured by John Chambers’ pithy quote: “Everything that exists in R is an object”. However, while everything is an object, not everything is object-oriented. This confusion arises because the base objects come from S, and were developed before anyone thought that S might need an OOP system. The tools and nomenclature evolved organically over many years without a single guiding principle.\nMost of the time, the distinction between objects and object-oriented objects is not important. But here we need to get into the nitty gritty details so we’ll use the terms base objects and OO objects to distinguish them.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#s3",
    "href": "analysis/advanced-r-3.html#s3",
    "title": "Advanced R (Object-oriented programming)",
    "section": "13 S3",
    "text": "13 S3\nS3 is R’s first and simplest OO system. S3 is informal and ad hoc, but there is a certain elegance in its minimalism: you can’t take away any part of it and still have a useful OO system. For these reasons, you should use it, unless you have a compelling reason to do otherwise. S3 is the only OO system used in the base and stats packages, and it’s the most commonly used system in CRAN packages.\nS3 is very flexible, which means it allows you to do things that are quite ill-advised. If you’re coming from a strict environment like Java this will seem pretty frightening, but it gives R programmers a tremendous amount of freedom. It may be very difficult to prevent people from doing something you don’t want them to do, but your users will never be held back because there is something you haven’t implemented yet. Since S3 has few built-in constraints, the key to its successful use is applying the constraints yourself. This chapter will therefore teach you the conventions you should (almost) always follow.\nThe goal of this chapter is to show you how the S3 system works, not how to use it effectively to create new classes and generics. I’d recommend coupling the theoretical knowledge from this chapter with the practical knowledge encoded in the vctrs package.\n\n13.2.1 Exercises\n\nDescribe the difference between t.test() and t.data.frame(). When is each function called?\n\n\nftype(t.test)\n\n#&gt; [1] \"S3\"      \"generic\"\n\nftype(t.data.frame)\n\n#&gt; [1] \"S3\"     \"method\"\n\ns3_dispatch(t.test(formula()))\n\n#&gt; =&gt; t.test.formula\n#&gt;  * t.test.default\n\ns3_dispatch(t(data.frame()))\n\n#&gt; =&gt; t.data.frame\n#&gt; -&gt; t.default\n\n\nAnswer: As noted by sloop::ftype() and the docs, t.test() is a S3 generic, and t.data.frame() is an S3 method for t() (transpose). t.data.frame() is called as a method when calling t(x) when x is a data.frame. t.test() calls either t.test.default or t.test.formula.\nAR Solutions: Because of S3’s generic.class() naming scheme, both functions may initially look similar, while they are in fact unrelated.\n\nt.test() is a generic function that performs a t-test.\nt.data.frame() is a method that gets called by the generic t() to transpose data frame input.\n\nDue to R’s S3 dispatch rules, t.test() would also get called when t() is applied to an object of class test\n\n\nMake a list of commonly used base R functions that contain . in their name but are not S3 methods.\n\n\nftype(as.character)\n\n#&gt; [1] \"primitive\" \"generic\"\n\nftype(as.data.frame)\n\n#&gt; [1] \"S3\"      \"generic\"\n\nftype(data.frame)\n\n#&gt; [1] \"function\"\n\nftype(eval.parent)\n\n#&gt; [1] \"function\"\n\nftype(file.path)\n\n#&gt; [1] \"internal\"\n\nftype(file.copy)\n\n#&gt; [1] \"internal\"\n\nftype(is.null)\n\n#&gt; [1] \"primitive\"\n\nftype(is.data.frame)\n\n#&gt; [1] \"function\"\n\nftype(Sys.localeconv)\n\n#&gt; [1] \"internal\"\n\nftype(Sys.time)\n\n#&gt; [1] \"internal\"\n\n\nAnswer:\n\nAll of the as. functions\ndata.frame\nAll of the file. functions\nAll of the is. functions\nAll of the Sys. functions\n\nAR Solutions: In recent years “snake_case”-style has become increasingly common when naming functions and variables in R. But many functions in base R will continue to be “point.separated”, which is why some inconsistency in your R code most likely cannot be avoided. (install.packages(), read.csv(), list.files(), download.file(), data.frame(), as.character(), Sys.Date(), all.equal(), do.call(), on.exit())\n\n\nWhat does the as.data.frame.data.frame() method do? Why is it confusing? How could you avoid this confusion in your own code?\n\n\ns3_dispatch(as.data.frame(data.frame()))\n\n#&gt; =&gt; as.data.frame.data.frame\n#&gt;  * as.data.frame.default\n\n\nAnswer: as.data.frame.data.frame() is the method used to coerce a data.frame to a data.frame. This is confusing because the class contains a period (as does the function call); avoiding periods improves readability: as_dataframe.dataframe makes the generic and method clear.\nAR Solutions: The function as.data.frame.data.frame() implements the data.frame() method for the as.data.frame() generic, which coerces objects to data frames.\nThe name is confusing, because it does not clearly communicate the type of the function, which could be a regular function, a generic or a method. Even if we assume a method, the amount of .’s makes it difficult to separate the generic- and the class-part of the name. Is it the data.frame.data.frame() method for the as() generic? Is it the frame.data.frame() method for the as.data() generic?\nWe could avoid this confusion by applying a different naming convention (e.g. “snake_case”) for our class and function names.\n\n\nDescribe the difference in behaviour in these two calls.\n\n\nset.seed(1014)\nsome_days &lt;- as.Date(\"2017-01-31\") + sample(10, 5)\nmean(some_days)\n\n#&gt; [1] \"2017-02-06\"\n\nmean(unclass(some_days))\n\n#&gt; [1] 17203.4\n\ns3_dispatch(mean(some_days))\n\n#&gt; =&gt; mean.Date\n#&gt;  * mean.default\n\ns3_dispatch(mean(unclass(some_days)))\n\n#&gt;    mean.double\n#&gt;    mean.numeric\n#&gt; =&gt; mean.default\n\n\nAnswer: the first call calculates the mean using mean.Date(), and so returns a date. using unclass() changes the date to its underlying value (double) which calculates the mean using mean.default().\nAR Solutions: mean() is a generic function, which will select the appropriate method based on the class of the input. some_days has the class Date and mean.Date(some_days) will be used to calculate the mean date of some_days.\nAfter unclass() has removed the class attribute from some_date, the default method is chosen. mean.default(unclass(some_days)) then calculates the mean of the underlying double.\n\n\nWhat class of object does the following code return? What base type is it built on? What attributes does it use?\n\n\nx &lt;- ecdf(rpois(100, 10))\nx\n\n#&gt; Empirical CDF \n#&gt; Call: ecdf(rpois(100, 10))\n#&gt;  x[1:18] =      2,      3,      4,  ...,     18,     19\n\nstr(x)\n\n#&gt; function (v)  \n#&gt;  - attr(*, \"class\")= chr [1:3] \"ecdf\" \"stepfun\" \"function\"\n#&gt;  - attr(*, \"call\")= language ecdf(rpois(100, 10))\n\n\nAnswer: the code returns an object of class ecdf, which is build on the stepfun object, and the function base type. It additionally includes the call attribute.\nAR Solutions: It returns an object of the class ecdf (empirical cumulative distribution function) with the superclasses stepfun and function. The ecdf object is built on the base type closure (a function). The expression, which was used to create it (rpois(100, 10)), is stored in the call attribute.\n\ntypeof(x)\n\n#&gt; [1] \"closure\"\n\n\n\n\nWhat class of object does the following code return? What base type is it built on? What attributes does it use?\n\n\nx &lt;- table(rpois(100, 5))\nx\n\n#&gt; \n#&gt;  1  2  3  4  5  6  7  8  9 10 \n#&gt;  7  5 18 14 15 15 14  4  5  3\n\nstr(x)\n\n#&gt;  'table' int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3\n#&gt;  - attr(*, \"dimnames\")=List of 1\n#&gt;   ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n\nstr(unclass(x))\n\n#&gt;  int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3\n#&gt;  - attr(*, \"dimnames\")=List of 1\n#&gt;   ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n\n\nAnswer: per the docs, the code returns an object of class table, which is built on array, which uses the dimnames attribute in combination with a vector.\nAR Solutions: This code returns a table object, which is built upon the integer type. The attribute dimnames is used to name the elements of the integer vector.\n\n\n\n13.3.4 Exercises\n\nWrite a constructor for data.frame objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?\n\n\ndput(data.frame())\n\n#&gt; structure(list(), names = character(0), row.names = integer(0), class = \"data.frame\")\n\ndput(data.frame(a = 1:2, b = 3:4))\n\n#&gt; structure(list(a = 1:2, b = 3:4), class = \"data.frame\", row.names = c(NA, \n#&gt; -2L))\n\nunclass(data.frame(a = 1:2, b = 3:4))\n\n#&gt; $a\n#&gt; [1] 1 2\n#&gt; \n#&gt; $b\n#&gt; [1] 3 4\n#&gt; \n#&gt; attr(,\"row.names\")\n#&gt; [1] 1 2\n\n\nAnswer: code below. The data frame is built on the list base type, and includes the names, row.names, and class attributes. This implementation requires values to be a list, names to be a character, and row.names to be an integer.\n\nnew_data.frame &lt;- function(values = list(),\n                           names = character(length(values)),\n                           row.names = integer(length(values))) {\n  stopifnot(\n    is.list(values),\n    is.character(names),\n    is.integer(row.names)\n  )\n  structure(values, names = names, row.names = row.names, class = \"data.frame\")\n}\n\nnew_data.frame()\n\n#&gt; data frame with 0 columns and 0 rows\n\nnew_data.frame(list(1:3, 4:6, 7:9))\n\n#&gt;        \n#&gt; 0 1 4 7\n#&gt; 0 2 5 8\n#&gt; 0 3 6 9\n\nnew_data.frame(list(1:3, 4:6, 7:9), names = c(\"a\", \"b\", \"c\"), row.names = 1:3)\n\n#&gt;   a b c\n#&gt; 1 1 4 7\n#&gt; 2 2 5 8\n#&gt; 3 3 6 9\n\n\nAR Solutions: Data frames are built on named lists of vectors, which all have the same length. Besides the class and the column names (names), the row.names are their only further attribute. This must be a character vector with the same length as the other vectors.\nWe need to provide the number of rows as an input to make it possible to create data frames with 0 columns but multiple rows.\nThis leads to the following constructor:\n\nnew_data.frame &lt;- function(x, n, row.names = NULL) {\n  # Check if the underlying object is a list\n  stopifnot(is.list(x))\n\n  # Check all inputs are the same length\n  # (This check also allows that x has length 0)\n  stopifnot(all(lengths(x) == n)) # nolint: stopifnot_all_linter.\n\n  if (is.null(row.names)) {\n    # Use special row names helper from base R\n    row.names &lt;- .set_row_names(n)\n  } else {\n    # Otherwise check that they're a character vector with the\n    # correct length\n    stopifnot(is.character(row.names), length(row.names) == n)\n  }\n\n  structure(\n    x,\n    class = \"data.frame\",\n    row.names = row.names\n  )\n}\n\n# Test\nx &lt;- list(a = 1, b = 2)\nnew_data.frame(x, n = 1)\n\n#&gt;   a b\n#&gt; 1 1 2\n\nnew_data.frame(x, n = 1, row.names = \"l1\")\n\n#&gt;    a b\n#&gt; l1 1 2\n\n# Create a data frame with 0 columns and 2 rows\nnew_data.frame(list(), n = 2)\n\n#&gt; data frame with 0 columns and 2 rows\n\n\nNote: AR Solutions approach also validates that all inputs are same length, and supports creation of dataframes with 0 columns but multiple rows.\n\n\nEnhance my factor() helper to have better behaviour when one or more values is not found in levels. What does base::factor() do in this situation?\n\n\nnew_factor &lt;- function(x = integer(), levels = character()) {\n  stopifnot(\n    is.integer(x),\n    is.character(levels)\n  )\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nAnswer: the fix is to update validate_factor() to allow NA values, since the helper already fills in NA when values is not found in levels. This matches the behavior of base::factor().\n\nvalidate_factor &lt;- function(x) {\n  values &lt;- unclass(x)\n  levels &lt;- attr(x, \"levels\")\n\n  if (!all(is.na(values) | values &gt; 0)) {\n    stop(\n      \"All non-missing `x` values must be greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) &lt; max(values, na.rm = TRUE)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nmy_factor &lt;- function(x = character(), levels = unique(x)) {\n  ind &lt;- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nfactor(c(\"a\", \"a\", \"b\"), levels = \"a\")\n\n#&gt; [1] a    a    &lt;NA&gt;\n#&gt; Levels: a\n\nmy_factor(c(\"a\", \"a\", \"b\"), levels = \"a\")\n\n#&gt; [1] a    a    &lt;NA&gt;\n#&gt; Levels: a\n\n\nAR Solutions: base::factor() converts these values (silently) into NAs.\nThe factor() helper including the constructor (new_factor()) and its validator (validate_factor()) were given in Advanced R. However, as the goal of this question is to throw an early error within the helper, we only repeat the code for the helper:\nTo improve the factor() helper we choose to return an informative error message instead.\n\nfactor2 &lt;- function(x, levels = unique(x)) {\n  new_levels &lt;- match(x, levels)\n\n  # Error if levels don't include all values\n  missing &lt;- unique(setdiff(x, levels))\n  if (length(missing) &gt; 0) {\n    stop(\n      \"The following values do not occur in the levels of x: \",\n      paste0(\"'\", missing, \"'\", collapse = \", \"), \".\",\n      call. = FALSE\n    )\n  }\n\n  validate_factor(new_factor(new_levels, levels))\n}\n\n# Test\ntry(factor2(c(\"a\", \"b\", \"c\"), levels = c(\"a\", \"b\")))\n\n#&gt; Error : The following values do not occur in the levels of x: 'c'.\n\n\n\n\nCarefully read the source code of factor(). What does it do that my constructor does not?\n\n\nfactor(c(\"a\", \"a\", \"b\", \"c\"), labels = c(\"alpha\", \"beta\", \"beta\"))\n\n#&gt; [1] alpha alpha beta  beta \n#&gt; Levels: alpha beta\n\nclass(factor(1:10, ordered = TRUE))\n\n#&gt; [1] \"ordered\" \"factor\"\n\n\nAnswer: the base implementation:\n\nsets the value to character(0) if the value is null\nretains value names\nallows an upper bound on the number of levels, nmax\ncoerces the value to character\nprovides a method for excluding values from levels, exclude\nprovides labels for remapping factors\nadds an “ordered” class if the value is ordered (ordered = TRUE)\n\nNote: labels are an interesting and unexpected feature of factor()\n\nfactor\n\n#&gt; function (x = character(), levels, labels = levels, exclude = NA, \n#&gt;     ordered = is.ordered(x), nmax = NA) \n#&gt; {\n#&gt;     if (is.null(x)) \n#&gt;         x &lt;- character()\n#&gt;     nx &lt;- names(x)\n#&gt;     matchAsChar &lt;- is.object(x) || !(is.character(x) || is.integer(x) || \n#&gt;         is.logical(x))\n#&gt;     if (missing(levels)) {\n#&gt;         y &lt;- unique(x, nmax = nmax)\n#&gt;         ind &lt;- order(y)\n#&gt;         if (matchAsChar) \n#&gt;             y &lt;- as.character(y)\n#&gt;         levels &lt;- unique(y[ind])\n#&gt;     }\n#&gt;     force(ordered)\n#&gt;     if (matchAsChar) \n#&gt;         x &lt;- as.character(x)\n#&gt;     levels &lt;- levels[is.na(match(levels, exclude))]\n#&gt;     f &lt;- match(x, levels)\n#&gt;     if (!is.null(nx)) \n#&gt;         names(f) &lt;- nx\n#&gt;     if (missing(labels)) {\n#&gt;         levels(f) &lt;- as.character(levels)\n#&gt;     }\n#&gt;     else {\n#&gt;         nlab &lt;- length(labels)\n#&gt;         if (nlab == length(levels)) {\n#&gt;             nlevs &lt;- unique(xlevs &lt;- as.character(labels))\n#&gt;             at &lt;- attributes(f)\n#&gt;             at$levels &lt;- nlevs\n#&gt;             f &lt;- match(xlevs, nlevs)[f]\n#&gt;             attributes(f) &lt;- at\n#&gt;         }\n#&gt;         else if (nlab == 1L) \n#&gt;             levels(f) &lt;- paste0(labels, seq_along(levels))\n#&gt;         else stop(gettextf(\"invalid 'labels'; length %d should be 1 or %d\", \n#&gt;             nlab, length(levels)), domain = NA)\n#&gt;     }\n#&gt;     class(f) &lt;- c(if (ordered) \"ordered\", \"factor\")\n#&gt;     f\n#&gt; }\n#&gt; &lt;bytecode: 0x124834c08&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\nAR Solutions: The original implementation (base::factor()) allows more flexible input for x. It coerces x to character or replaces it with character(0) (in case of NULL). It also ensures that the levels are unique. This is achieved by setting them via base::levels&lt;-, which fails when duplicate values are supplied.\nNote: I missed the fact that base::levels&lt;- fails when duplicate values are supplied.\n\n\nFactors have an optional “contrasts” attribute. Read the help for C(), and briefly describe the purpose of the attribute. What type should it have? Rewrite the new_factor() constructor to include this attribute.\n\nAnswer: per the “contrast {stats}” documentation, contrast matrices are used in fitting analysis of variance and regression models, so the attribute should be a matrix.\n\nnew_factor &lt;- function(x = integer(), levels = character(), contr = matrix()) {\n  stopifnot(is.integer(x), is.character(levels), is.matrix(contr))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contr\n  )\n}\n\nAR Solutions: When factor variables (representing nominal or ordinal information) are used in statistical models, they are typically encoded as dummy variables and by default each level is compared with the first factor level. However, many different encodings (“contrasts”) are possible, see Contrast.\nWithin R’s formula interface you can wrap a factor in stats::C() and specify the contrast of your choice. Alternatively, you can set the contrasts attribute of your factor variable, which accepts matrix input. (See ?contr.helmert or similar for details.)\nOur updated new_factor() constructor gets a contrasts argument, which accepts a numeric matrix or NULL (default).\n\n# Updated new_factor() constructor\nnew_factor &lt;- function(x = integer(),\n                       levels = character(),\n                       contrasts = NULL) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  if (!is.null(constrasts)) {\n    stopifnot(is.matrix(contrasts) && is.numeric(contrasts)) # nolint: conjunct_test_linter.\n  }\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contrasts\n  )\n}\n\n\n\nRead the documentation for utils::as.roman(). How would you write a constructor for this class? Does it need a validator? What might a helper do?\n\n\ndput(as.roman(3899))\n\n#&gt; structure(3899L, class = \"roman\")\n\nnew_roman &lt;- function(x = integer()) {\n  stopifnot(is.integer(x))\n\n  structure(\n    x,\n    class = \"roman\"\n  )\n}\n\nnew_roman(2022L)\n\n#&gt; [1] MMXXII\n\n\nAnswer: the structure of the class “roman” is simple, an integer with a defined class. A simple constructor would take an integer and return an object of class “roman” as above. A validator is probably not needed, but could validate that the integer is within the supported range of integers (1-3899). A helper might coerce the number to be an integer using as.integer().\nAR Solutions: This function transforms numeric input into Roman numbers. It is built on the integer type, which results in the following constructor.\n\nnew_roman &lt;- function(x = integer()) {\n  stopifnot(is.integer(x))\n  structure(x, class = \"roman\")\n}\n\nThe documentation tells us, that only values between 1 and 3899 are uniquely represented, which we then include in our validation function.\n\nvalidate_roman &lt;- function(x) {\n  values &lt;- unclass(x)\n\n  if (any(values &lt; 1 | values &gt; 3899)) {\n    stop(\n      \"Roman numbers must fall between 1 and 3899.\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nFor convenience, we allow the user to also pass real values to a helper function.\n\nroman &lt;- function(x = integer()) {\n  x &lt;- as.integer(x)\n\n  validate_roman(new_roman(x))\n}\n\n# Test\nroman(c(1, 753, 2019))\n\n#&gt; [1] I       DCCLIII MMXIX\n\ntry(roman(0))\n\n#&gt; Error : Roman numbers must fall between 1 and 3899.\n\n\n\n\n\n13.4.4 Exercises\n\nRead the source code for t() and t.test() and confirm that t.test() is an S3 generic and not an S3 method. What happens if you create an object with class test and call t() with it? Why?\n\n\nx &lt;- structure(1:10, class = \"test\")\nt(x)\n\n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#&gt; [1,]    1    2    3    4    5    6    7    8    9    10\n#&gt; attr(,\"class\")\n#&gt; [1] \"test\"\n\n\nAnswer: both t() and t.test() simply call UseMethod(), and are S3 generics.\n\nt\n\n#&gt; function (x) \n#&gt; UseMethod(\"t\")\n#&gt; &lt;bytecode: 0x123934ca0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nt.test\n\n#&gt; function (x, ...) \n#&gt; UseMethod(\"t.test\")\n#&gt; &lt;bytecode: 0x1252f0fc8&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\n\nCreating an object with class test and calling t() uses the default method since t.test() is not a registered method for t(), as this code shows:\n\nmethods(\"t\")\n\n#&gt; [1] t.data.frame  t.default     t.ts*         t.vctrs_sclr* t.vctrs_vctr*\n#&gt; see '?methods' for accessing help and source code\n\ns3_dispatch(t(x))\n\n#&gt;    t.test\n#&gt; =&gt; t.default\n\n\nAR Solutions: We can see that t.test() is a generic because it calls UseMethod().\n\n# or simply call\nftype(t.test)\n\n#&gt; [1] \"S3\"      \"generic\"\n\n\nInterestingly, R also provides helpers, which list functions that look like methods, but in fact are not:\n\ntools::nonS3methods(\"stats\")\n\n#&gt; [1] \"anova.lmlist\"        \"expand.model.frame\"  \"fitted.values\"      \n#&gt; [4] \"influence.measures\"  \"lag.plot\"            \"qr.influence\"       \n#&gt; [7] \"t.test\"              \"plot.spec.phase\"     \"plot.spec.coherency\"\n\n\nWhen we create an object with class test, t() dispatches to the t.default() method. This happens, because UseMethod() simply searches for functions named paste0(\"generic\", \".\", c(class(x), \"default\")).\nHowever, in older versions of R (pre R 4.0.0; when Advanced R was written) this behaviour was slightly different. Instead of dispatching to the t.default() method, the t.test() generic was erroneously treated as a method of t() which then dispatched to t.test.default() or (when defined) to t.test.test().\n\n\nWhat generics does the table class have methods for?\n\nAnswer: s3_methods_class() answers this question:\n\ns3_methods_class(\"table\")\n\n#&gt; # A tibble: 11 × 4\n#&gt;    generic       class visible source             \n#&gt;    &lt;chr&gt;         &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n#&gt;  1 [             table TRUE    base               \n#&gt;  2 aperm         table TRUE    base               \n#&gt;  3 as_tibble     table FALSE   registered S3method\n#&gt;  4 as.data.frame table TRUE    base               \n#&gt;  5 Axis          table FALSE   registered S3method\n#&gt;  6 lines         table FALSE   registered S3method\n#&gt;  7 plot          table FALSE   registered S3method\n#&gt;  8 points        table FALSE   registered S3method\n#&gt;  9 print         table TRUE    base               \n#&gt; 10 summary       table TRUE    base               \n#&gt; 11 tail          table FALSE   registered S3method\n\n\nAR Solutions: This is a simple application of sloop::s3_methods_class().\nInterestingly, the table class has a number of methods designed to help plotting with base graphics.\n\nx &lt;- rpois(100, 5)\nplot(table(x))\n\n\n\n\n\n\n\n\n\n\nWhat generics does the ecdf class have methods for?\n\nAnswer:\n\ns3_methods_class(\"ecdf\")\n\n#&gt; # A tibble: 4 × 4\n#&gt;   generic  class visible source             \n#&gt;   &lt;chr&gt;    &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 plot     ecdf  TRUE    stats              \n#&gt; 2 print    ecdf  FALSE   registered S3method\n#&gt; 3 quantile ecdf  FALSE   registered S3method\n#&gt; 4 summary  ecdf  FALSE   registered S3method\n\n\nAR Solutions: We use the same approach as above.\nThe methods are primarily designed for display (plot(), print(), summary()), but you can also extract quantiles with quantile().\n\n\nWhich base generic has the greatest number of defined methods?\n\nAnswer: using code from 6.2.5, identify generics and count defined methods:\n\n# from 6.2.5 exercises, this code makes a list of all functions in the base package\nfuns &lt;- Filter(is.function, mget(ls(\"package:base\", all.names = TRUE), inherits = TRUE))\n\nget_method_count &lt;- function(fname) {\n  data.frame(\n    name = fname,\n    # this code should work but doesn't:\n    # method_count = nrow(s3_methods_generic(fname))\n    method_count = length(methods(fname))\n  )\n}\n\nmap_dfr(names(funs), get_method_count) |&gt;\n  arrange(desc(method_count))\n\n#&gt;                                    name method_count\n#&gt; 1                                 print          280\n#&gt; 2                                format          126\n#&gt; 3                                     [           50\n#&gt; 4                               summary           40\n#&gt; 5                          as.character           33\n#&gt; 6                         as.data.frame           33\n#&gt; 7                                  plot           31\n#&gt; 8                                    [[           22\n#&gt; 9                                   [&lt;-           20\n#&gt; 10                                  $&lt;-           18\n#&gt; 11                                 [[&lt;-           17\n#&gt; 12                                    $           17\n#&gt; 13                                 file           17\n#&gt; 14                              as.list           15\n#&gt; 15                                    c           15\n#&gt; 16                            all.equal           12\n#&gt; 17                                  rep           11\n#&gt; 18                               unique           11\n#&gt; 19                                xtfrm           11\n#&gt; 20                           duplicated            9\n#&gt; 21                              as.Date            8\n#&gt; 22                            as.matrix            8\n#&gt; 23                           as.POSIXlt            7\n#&gt; 24                             length&lt;-            7\n#&gt; 25                                 mean            7\n#&gt; 26                              names&lt;-            7\n#&gt; 27                                  row            7\n#&gt; 28                        anyDuplicated            6\n#&gt; 29                           as.POSIXct            6\n#&gt; 30                                 diff            6\n#&gt; 31                               length            6\n#&gt; 32                                write            6\n#&gt; 33                                anyNA            5\n#&gt; 34                     conditionMessage            5\n#&gt; 35                                is.na            5\n#&gt; 36                              is.na&lt;-            5\n#&gt; 37                               labels            5\n#&gt; 38                                names            5\n#&gt; 39                                    t            5\n#&gt; 40                                    -            4\n#&gt; 41                                    +            4\n#&gt; 42                            as.double            4\n#&gt; 43                            as.vector            4\n#&gt; 44                                close            4\n#&gt; 45                                  cut            4\n#&gt; 46                                 open            4\n#&gt; 47                                range            4\n#&gt; 48                                split            4\n#&gt; 49                               subset            4\n#&gt; 50                                    !            3\n#&gt; 51                                    &            3\n#&gt; 52                                    |            3\n#&gt; 53                           as.logical            3\n#&gt; 54                                cbind            3\n#&gt; 55                           dimnames&lt;-            3\n#&gt; 56                           is.numeric            3\n#&gt; 57                                kappa            3\n#&gt; 58                               levels            3\n#&gt; 59                             levels&lt;-            3\n#&gt; 60                                   ls            3\n#&gt; 61                                match            3\n#&gt; 62                                merge            3\n#&gt; 63                                mtfrm            3\n#&gt; 64                               pretty            3\n#&gt; 65                          row.names&lt;-            3\n#&gt; 66                                  seq            3\n#&gt; 67                                 sort            3\n#&gt; 68                            transform            3\n#&gt; 69                                    *            2\n#&gt; 70                                    /            2\n#&gt; 71                                aperm            2\n#&gt; 72                           as.integer            2\n#&gt; 73                             as.table            2\n#&gt; 74                               body&lt;-            2\n#&gt; 75                                   by            2\n#&gt; 76                                dim&lt;-            2\n#&gt; 77                             dimnames            2\n#&gt; 78                                  dir            2\n#&gt; 79                                 drop            2\n#&gt; 80                           droplevels            2\n#&gt; 81             getDLLRegisteredRoutines            2\n#&gt; 82                            intersect            2\n#&gt; 83                            is.finite            2\n#&gt; 84                          is.infinite            2\n#&gt; 85                               is.nan            2\n#&gt; 86                               julian            2\n#&gt; 87                              library            2\n#&gt; 88                                 list            2\n#&gt; 89                                  max            2\n#&gt; 90                                  min            2\n#&gt; 91                               months            2\n#&gt; 92                                   qr            2\n#&gt; 93                             quarters            2\n#&gt; 94                                rbind            2\n#&gt; 95                                  rev            2\n#&gt; 96                                round            2\n#&gt; 97                            row.names            2\n#&gt; 98                               rowsum            2\n#&gt; 99                              setdiff            2\n#&gt; 100                            setequal            2\n#&gt; 101                               solve            2\n#&gt; 102                             sort_by            2\n#&gt; 103                             split&lt;-            2\n#&gt; 104                              system            2\n#&gt; 105                               trunc            2\n#&gt; 106                               union            2\n#&gt; 107                              unlist            2\n#&gt; 108                            weekdays            2\n#&gt; 109                               which            2\n#&gt; 110                              within            2\n#&gt; 111                                  !=            1\n#&gt; 112                                 %/%            1\n#&gt; 113                                  %%            1\n#&gt; 114                                   ^            1\n#&gt; 115                                   &lt;            1\n#&gt; 116                                  &lt;=            1\n#&gt; 117                                  ==            1\n#&gt; 118                                   &gt;            1\n#&gt; 119                                  &gt;=            1\n#&gt; 120                            as.array            1\n#&gt; 121                      as.environment            1\n#&gt; 122                       as.expression            1\n#&gt; 123                         as.function            1\n#&gt; 124                             as.null            1\n#&gt; 125                           as.single            1\n#&gt; 126                                attr            1\n#&gt; 127                                chol            1\n#&gt; 128                     chooseOpsMethod            1\n#&gt; 129                       conditionCall            1\n#&gt; 130                         determinant            1\n#&gt; 131                                 dim            1\n#&gt; 132                                dump            1\n#&gt; 133                                eval            1\n#&gt; 134                              factor            1\n#&gt; 135                               flush            1\n#&gt; 136                                  gc            1\n#&gt; 137                         interaction            1\n#&gt; 138                         isSymmetric            1\n#&gt; 139                           kronecker            1\n#&gt; 140                             lengths            1\n#&gt; 141                       library.dynam            1\n#&gt; 142                         nameOfClass            1\n#&gt; 143                               order            1\n#&gt; 144                                pmax            1\n#&gt; 145                                pmin            1\n#&gt; 146                              remove            1\n#&gt; 147                              sample            1\n#&gt; 148                                save            1\n#&gt; 149                               scale            1\n#&gt; 150                                seek            1\n#&gt; 151                            sequence            1\n#&gt; 152                                sink            1\n#&gt; 153                                 sum            1\n#&gt; 154                            toString            1\n#&gt; 155                            truncate            1\n#&gt; 156                               units            1\n#&gt; 157                             units&lt;-            1\n#&gt; 158                                 url            1\n#&gt; 159                                with            1\n#&gt; 160                              -.Date            0\n#&gt; 161                            -.POSIXt            0\n#&gt; 162                                   :            0\n#&gt; 163                                  ::            0\n#&gt; 164                                 :::            0\n#&gt; 165                           !.hexmode            0\n#&gt; 166                           !.octmode            0\n#&gt; 167                        .__H__.cbind            0\n#&gt; 168                        .__H__.rbind            0\n#&gt; 169                              ...elt            0\n#&gt; 170                           ...length            0\n#&gt; 171                            ...names            0\n#&gt; 172                      ..getNamespace            0\n#&gt; 173                      .amatch_bounds            0\n#&gt; 174                       .amatch_costs            0\n#&gt; 175                            .bincode            0\n#&gt; 176                                  .C            0\n#&gt; 177                        .cache_class            0\n#&gt; 178                               .Call            0\n#&gt; 179                      .Call.graphics            0\n#&gt; 180                       .check_tzones            0\n#&gt; 181                             .class2            0\n#&gt; 182                                .col            0\n#&gt; 183                           .colMeans            0\n#&gt; 184                            .colSums            0\n#&gt; 185                               .Date            0\n#&gt; 186             .decode_numeric_version            0\n#&gt; 187                            .Defunct            0\n#&gt; 188                        .deparseOpts            0\n#&gt; 189                         .Deprecated            0\n#&gt; 190                             .detach            0\n#&gt; 191                           .difftime            0\n#&gt; 192                         .doSortWrap            0\n#&gt; 193                            .doTrace            0\n#&gt; 194                             .doWrap            0\n#&gt; 195                            .dynLibs            0\n#&gt; 196             .encode_numeric_version            0\n#&gt; 197              .expand_R_libs_env_var            0\n#&gt; 198                           .External            0\n#&gt; 199                  .External.graphics            0\n#&gt; 200                          .External2            0\n#&gt; 201                          .First.sys            0\n#&gt; 202                       .format.zeros            0\n#&gt; 203                    .formula2varlist            0\n#&gt; 204                            .Fortran            0\n#&gt; 205                       .getNamespace            0\n#&gt; 206                   .getNamespaceInfo            0\n#&gt; 207                .getRequiredPackages            0\n#&gt; 208               .getRequiredPackages2            0\n#&gt; 209                                 .gt            0\n#&gt; 210                                .gtn            0\n#&gt; 211                  .handleSimpleError            0\n#&gt; 212                           .Internal            0\n#&gt; 213                .isMethodsDispatchOn            0\n#&gt; 214                             .isOpen            0\n#&gt; 215                          .kappa_tri            0\n#&gt; 216                          .kronecker            0\n#&gt; 217                           .libPaths            0\n#&gt; 218               .make_numeric_version            0\n#&gt; 219                        .makeMessage            0\n#&gt; 220                             .mapply            0\n#&gt; 221                          .maskedMsg            0\n#&gt; 222                 .mergeExportMethods            0\n#&gt; 223                 .mergeImportMethods            0\n#&gt; 224                  .NotYetImplemented            0\n#&gt; 225                         .NotYetUsed            0\n#&gt; 226                  .OptRequireMethods            0\n#&gt; 227                           .packages            0\n#&gt; 228              .packageStartupMessage            0\n#&gt; 229                            .POSIXct            0\n#&gt; 230                            .POSIXlt            0\n#&gt; 231                             .pretty            0\n#&gt; 232                          .Primitive            0\n#&gt; 233                          .primTrace            0\n#&gt; 234                        .primUntrace            0\n#&gt; 235                           .rangeNum            0\n#&gt; 236                              .rmpkg            0\n#&gt; 237                                .row            0\n#&gt; 238                     .row_names_info            0\n#&gt; 239                           .rowMeans            0\n#&gt; 240                       .rowNamesDF&lt;-            0\n#&gt; 241                            .rowSums            0\n#&gt; 242                           .S3method            0\n#&gt; 243                             .Script            0\n#&gt; 244             .set_ops_need_as_vector            0\n#&gt; 245                      .set_row_names            0\n#&gt; 246                .signalSimpleWarning            0\n#&gt; 247                   .standard_regexps            0\n#&gt; 248                             .subset            0\n#&gt; 249                            .subset2            0\n#&gt; 250                      .TAOCP1997init            0\n#&gt; 251                          .traceback            0\n#&gt; 252                 .tryResumeInterrupt            0\n#&gt; 253                       .valid.factor            0\n#&gt; 254                                   (            0\n#&gt; 255                              [.AsIs            0\n#&gt; 256                        [.data.frame            0\n#&gt; 257                              [.Date            0\n#&gt; 258                          [.difftime            0\n#&gt; 259                             [.Dlist            0\n#&gt; 260                       [.DLLInfoList            0\n#&gt; 261                            [.factor            0\n#&gt; 262                           [.hexmode            0\n#&gt; 263                            [.listof            0\n#&gt; 264                           [.noquote            0\n#&gt; 265                   [.numeric_version            0\n#&gt; 266                           [.octmode            0\n#&gt; 267                           [.POSIXct            0\n#&gt; 268                           [.POSIXlt            0\n#&gt; 269                       [.simple.list            0\n#&gt; 270                             [.table            0\n#&gt; 271                          [.warnings            0\n#&gt; 272                       [[.data.frame            0\n#&gt; 273                             [[.Date            0\n#&gt; 274                           [[.factor            0\n#&gt; 275                  [[.numeric_version            0\n#&gt; 276                          [[.POSIXct            0\n#&gt; 277                          [[.POSIXlt            0\n#&gt; 278                     [[&lt;-.data.frame            0\n#&gt; 279                         [[&lt;-.factor            0\n#&gt; 280                [[&lt;-.numeric_version            0\n#&gt; 281                        [[&lt;-.POSIXlt            0\n#&gt; 282                      [&lt;-.data.frame            0\n#&gt; 283                            [&lt;-.Date            0\n#&gt; 284                        [&lt;-.difftime            0\n#&gt; 285                          [&lt;-.factor            0\n#&gt; 286                 [&lt;-.numeric_version            0\n#&gt; 287                         [&lt;-.POSIXct            0\n#&gt; 288                         [&lt;-.POSIXlt            0\n#&gt; 289                                   {            0\n#&gt; 290                                   @            0\n#&gt; 291                                 @&lt;-            0\n#&gt; 292                          *.difftime            0\n#&gt; 293                          /.difftime            0\n#&gt; 294                           &.hexmode            0\n#&gt; 295                           &.octmode            0\n#&gt; 296                                  &&            0\n#&gt; 297                                 %*%            0\n#&gt; 298                                %||%            0\n#&gt; 299                                %in%            0\n#&gt; 300                                 %o%            0\n#&gt; 301                                 %x%            0\n#&gt; 302                              +.Date            0\n#&gt; 303                            +.POSIXt            0\n#&gt; 304                                  &lt;-            0\n#&gt; 305                                 &lt;&lt;-            0\n#&gt; 306                                   =            0\n#&gt; 307                           |.hexmode            0\n#&gt; 308                           |.octmode            0\n#&gt; 309                                  ||            0\n#&gt; 310                                   ~            0\n#&gt; 311                           $.DLLInfo            0\n#&gt; 312                   $.package_version            0\n#&gt; 313                      $&lt;-.data.frame            0\n#&gt; 314                         $&lt;-.POSIXlt            0\n#&gt; 315                          abbreviate            0\n#&gt; 316                                 abs            0\n#&gt; 317                                acos            0\n#&gt; 318                               acosh            0\n#&gt; 319               activeBindingFunction            0\n#&gt; 320                               addNA            0\n#&gt; 321                     addTaskCallback            0\n#&gt; 322                               agrep            0\n#&gt; 323                              agrepl            0\n#&gt; 324                               alist            0\n#&gt; 325                                 all            0\n#&gt; 326                 all.equal.character            0\n#&gt; 327                   all.equal.default            0\n#&gt; 328               all.equal.environment            0\n#&gt; 329               all.equal.envRefClass            0\n#&gt; 330                    all.equal.factor            0\n#&gt; 331                   all.equal.formula            0\n#&gt; 332                  all.equal.function            0\n#&gt; 333                  all.equal.language            0\n#&gt; 334                      all.equal.list            0\n#&gt; 335                   all.equal.numeric            0\n#&gt; 336                    all.equal.POSIXt            0\n#&gt; 337                       all.equal.raw            0\n#&gt; 338                           all.names            0\n#&gt; 339                            all.vars            0\n#&gt; 340                     allowInterrupts            0\n#&gt; 341                                 any            0\n#&gt; 342                 anyDuplicated.array            0\n#&gt; 343            anyDuplicated.data.frame            0\n#&gt; 344               anyDuplicated.default            0\n#&gt; 345                anyDuplicated.matrix            0\n#&gt; 346                    anyNA.data.frame            0\n#&gt; 347               anyNA.numeric_version            0\n#&gt; 348                       anyNA.POSIXlt            0\n#&gt; 349                       aperm.default            0\n#&gt; 350                         aperm.table            0\n#&gt; 351                              append            0\n#&gt; 352                               apply            0\n#&gt; 353                                 Arg            0\n#&gt; 354                                args            0\n#&gt; 355                               array            0\n#&gt; 356                            array2DF            0\n#&gt; 357                            arrayInd            0\n#&gt; 358                    as.array.default            0\n#&gt; 359                             as.call            0\n#&gt; 360              as.character.condition            0\n#&gt; 361                   as.character.Date            0\n#&gt; 362                as.character.default            0\n#&gt; 363                  as.character.error            0\n#&gt; 364                 as.character.factor            0\n#&gt; 365                as.character.hexmode            0\n#&gt; 366        as.character.numeric_version            0\n#&gt; 367                as.character.octmode            0\n#&gt; 368                 as.character.POSIXt            0\n#&gt; 369                 as.character.srcref            0\n#&gt; 370                          as.complex            0\n#&gt; 371                 as.data.frame.array            0\n#&gt; 372                  as.data.frame.AsIs            0\n#&gt; 373             as.data.frame.character            0\n#&gt; 374               as.data.frame.complex            0\n#&gt; 375            as.data.frame.data.frame            0\n#&gt; 376                  as.data.frame.Date            0\n#&gt; 377               as.data.frame.default            0\n#&gt; 378              as.data.frame.difftime            0\n#&gt; 379                as.data.frame.factor            0\n#&gt; 380               as.data.frame.integer            0\n#&gt; 381                  as.data.frame.list            0\n#&gt; 382               as.data.frame.logical            0\n#&gt; 383                as.data.frame.matrix            0\n#&gt; 384          as.data.frame.model.matrix            0\n#&gt; 385               as.data.frame.noquote            0\n#&gt; 386               as.data.frame.numeric            0\n#&gt; 387       as.data.frame.numeric_version            0\n#&gt; 388               as.data.frame.ordered            0\n#&gt; 389               as.data.frame.POSIXct            0\n#&gt; 390               as.data.frame.POSIXlt            0\n#&gt; 391                   as.data.frame.raw            0\n#&gt; 392                 as.data.frame.table            0\n#&gt; 393                    as.data.frame.ts            0\n#&gt; 394                as.data.frame.vector            0\n#&gt; 395                   as.Date.character            0\n#&gt; 396                     as.Date.default            0\n#&gt; 397                      as.Date.factor            0\n#&gt; 398                     as.Date.numeric            0\n#&gt; 399                     as.Date.POSIXct            0\n#&gt; 400                     as.Date.POSIXlt            0\n#&gt; 401                         as.difftime            0\n#&gt; 402                  as.double.difftime            0\n#&gt; 403                   as.double.POSIXlt            0\n#&gt; 404               as.expression.default            0\n#&gt; 405                           as.factor            0\n#&gt; 406                 as.function.default            0\n#&gt; 407                          as.hexmode            0\n#&gt; 408                  as.list.data.frame            0\n#&gt; 409                        as.list.Date            0\n#&gt; 410                     as.list.default            0\n#&gt; 411                    as.list.difftime            0\n#&gt; 412                 as.list.environment            0\n#&gt; 413                      as.list.factor            0\n#&gt; 414                    as.list.function            0\n#&gt; 415             as.list.numeric_version            0\n#&gt; 416                     as.list.POSIXct            0\n#&gt; 417                     as.list.POSIXlt            0\n#&gt; 418                   as.logical.factor            0\n#&gt; 419                as.matrix.data.frame            0\n#&gt; 420                   as.matrix.default            0\n#&gt; 421                   as.matrix.noquote            0\n#&gt; 422                   as.matrix.POSIXlt            0\n#&gt; 423                             as.name            0\n#&gt; 424                     as.null.default            0\n#&gt; 425                          as.numeric            0\n#&gt; 426                  as.numeric_version            0\n#&gt; 427                          as.octmode            0\n#&gt; 428                          as.ordered            0\n#&gt; 429                  as.package_version            0\n#&gt; 430                         as.pairlist            0\n#&gt; 431                     as.POSIXct.Date            0\n#&gt; 432                  as.POSIXct.default            0\n#&gt; 433                  as.POSIXct.numeric            0\n#&gt; 434                  as.POSIXct.POSIXlt            0\n#&gt; 435                as.POSIXlt.character            0\n#&gt; 436                     as.POSIXlt.Date            0\n#&gt; 437                  as.POSIXlt.default            0\n#&gt; 438                   as.POSIXlt.factor            0\n#&gt; 439                  as.POSIXlt.numeric            0\n#&gt; 440                  as.POSIXlt.POSIXct            0\n#&gt; 441                               as.qr            0\n#&gt; 442                              as.raw            0\n#&gt; 443                   as.single.default            0\n#&gt; 444                           as.symbol            0\n#&gt; 445                    as.table.default            0\n#&gt; 446                as.vector.data.frame            0\n#&gt; 447                    as.vector.factor            0\n#&gt; 448                   as.vector.POSIXlt            0\n#&gt; 449                                asin            0\n#&gt; 450                               asinh            0\n#&gt; 451                         asNamespace            0\n#&gt; 452                              asplit            0\n#&gt; 453                                asS3            0\n#&gt; 454                                asS4            0\n#&gt; 455                              assign            0\n#&gt; 456                                atan            0\n#&gt; 457                               atan2            0\n#&gt; 458                               atanh            0\n#&gt; 459                              attach            0\n#&gt; 460                     attachNamespace            0\n#&gt; 461                      attr.all.equal            0\n#&gt; 462                              attr&lt;-            0\n#&gt; 463                          attributes            0\n#&gt; 464                        attributes&lt;-            0\n#&gt; 465                            autoload            0\n#&gt; 466                          autoloader            0\n#&gt; 467                           backsolve            0\n#&gt; 468                      balancePOSIXlt            0\n#&gt; 469                             baseenv            0\n#&gt; 470                            basename            0\n#&gt; 471                             besselI            0\n#&gt; 472                             besselJ            0\n#&gt; 473                             besselK            0\n#&gt; 474                             besselY            0\n#&gt; 475                                beta            0\n#&gt; 476                     bindingIsActive            0\n#&gt; 477                     bindingIsLocked            0\n#&gt; 478                      bindtextdomain            0\n#&gt; 479                             bitwAnd            0\n#&gt; 480                             bitwNot            0\n#&gt; 481                              bitwOr            0\n#&gt; 482                          bitwShiftL            0\n#&gt; 483                          bitwShiftR            0\n#&gt; 484                             bitwXor            0\n#&gt; 485                                body            0\n#&gt; 486                              bquote            0\n#&gt; 487                               break            0\n#&gt; 488                             browser            0\n#&gt; 489                    browserCondition            0\n#&gt; 490                     browserSetDebug            0\n#&gt; 491                         browserText            0\n#&gt; 492                            builtins            0\n#&gt; 493                       by.data.frame            0\n#&gt; 494                          by.default            0\n#&gt; 495                              bzfile            0\n#&gt; 496                              c.Date            0\n#&gt; 497                          c.difftime            0\n#&gt; 498                            c.factor            0\n#&gt; 499                           c.noquote            0\n#&gt; 500                   c.numeric_version            0\n#&gt; 501                           c.POSIXct            0\n#&gt; 502                           c.POSIXlt            0\n#&gt; 503                          c.warnings            0\n#&gt; 504                                call            0\n#&gt; 505                              callCC            0\n#&gt; 506                        capabilities            0\n#&gt; 507                            casefold            0\n#&gt; 508                                 cat            0\n#&gt; 509                    cbind.data.frame            0\n#&gt; 510                             ceiling            0\n#&gt; 511                         char.expand            0\n#&gt; 512                           character            0\n#&gt; 513                           charmatch            0\n#&gt; 514                           charToRaw            0\n#&gt; 515                              chartr            0\n#&gt; 516                             chkDots            0\n#&gt; 517                        chol.default            0\n#&gt; 518                            chol2inv            0\n#&gt; 519                              choose            0\n#&gt; 520             chooseOpsMethod.default            0\n#&gt; 521                               class            0\n#&gt; 522                             class&lt;-            0\n#&gt; 523                       clearPushBack            0\n#&gt; 524                    close.connection            0\n#&gt; 525                       close.srcfile            0\n#&gt; 526                  close.srcfilealias            0\n#&gt; 527                 closeAllConnections            0\n#&gt; 528                                 col            0\n#&gt; 529                            colMeans            0\n#&gt; 530                            colnames            0\n#&gt; 531                          colnames&lt;-            0\n#&gt; 532                             colSums            0\n#&gt; 533                         commandArgs            0\n#&gt; 534                             comment            0\n#&gt; 535                           comment&lt;-            0\n#&gt; 536                             complex            0\n#&gt; 537                     computeRestarts            0\n#&gt; 538             conditionCall.condition            0\n#&gt; 539          conditionMessage.condition            0\n#&gt; 540                       conflictRules            0\n#&gt; 541                           conflicts            0\n#&gt; 542                                Conj            0\n#&gt; 543                        contributors            0\n#&gt; 544                                 cos            0\n#&gt; 545                                cosh            0\n#&gt; 546                               cospi            0\n#&gt; 547                           crossprod            0\n#&gt; 548                         Cstack_info            0\n#&gt; 549                              cummax            0\n#&gt; 550                              cummin            0\n#&gt; 551                             cumprod            0\n#&gt; 552                              cumsum            0\n#&gt; 553                      curlGetHeaders            0\n#&gt; 554                            cut.Date            0\n#&gt; 555                         cut.default            0\n#&gt; 556                          cut.POSIXt            0\n#&gt; 557                          data.class            0\n#&gt; 558                          data.frame            0\n#&gt; 559                         data.matrix            0\n#&gt; 560                                date            0\n#&gt; 561                               debug            0\n#&gt; 562                      debuggingState            0\n#&gt; 563                           debugonce            0\n#&gt; 564                             declare            0\n#&gt; 565            default.stringsAsFactors            0\n#&gt; 566                       delayedAssign            0\n#&gt; 567                             deparse            0\n#&gt; 568                            deparse1            0\n#&gt; 569                                 det            0\n#&gt; 570                              detach            0\n#&gt; 571                  determinant.matrix            0\n#&gt; 572                                dget            0\n#&gt; 573                                diag            0\n#&gt; 574                              diag&lt;-            0\n#&gt; 575                           diff.Date            0\n#&gt; 576                        diff.default            0\n#&gt; 577                       diff.difftime            0\n#&gt; 578                         diff.POSIXt            0\n#&gt; 579                            difftime            0\n#&gt; 580                             digamma            0\n#&gt; 581                      dim.data.frame            0\n#&gt; 582                 dimnames.data.frame            0\n#&gt; 583               dimnames&lt;-.data.frame            0\n#&gt; 584                          dir.create            0\n#&gt; 585                          dir.exists            0\n#&gt; 586                             dirname            0\n#&gt; 587                             do.call            0\n#&gt; 588                           dontCheck            0\n#&gt; 589                              double            0\n#&gt; 590                                dput            0\n#&gt; 591                              dQuote            0\n#&gt; 592               droplevels.data.frame            0\n#&gt; 593                   droplevels.factor            0\n#&gt; 594                    duplicated.array            0\n#&gt; 595               duplicated.data.frame            0\n#&gt; 596                  duplicated.default            0\n#&gt; 597                   duplicated.matrix            0\n#&gt; 598          duplicated.numeric_version            0\n#&gt; 599                  duplicated.POSIXlt            0\n#&gt; 600                 duplicated.warnings            0\n#&gt; 601                            dyn.load            0\n#&gt; 602                          dyn.unload            0\n#&gt; 603                              dynGet            0\n#&gt; 604                              eapply            0\n#&gt; 605                               eigen            0\n#&gt; 606                            emptyenv            0\n#&gt; 607                          enc2native            0\n#&gt; 608                            enc2utf8            0\n#&gt; 609                        encodeString            0\n#&gt; 610                            Encoding            0\n#&gt; 611                          Encoding&lt;-            0\n#&gt; 612                            endsWith            0\n#&gt; 613                             enquote            0\n#&gt; 614                         env.profile            0\n#&gt; 615                         environment            0\n#&gt; 616                       environment&lt;-            0\n#&gt; 617                 environmentIsLocked            0\n#&gt; 618                     environmentName            0\n#&gt; 619                      errorCondition            0\n#&gt; 620                         eval.parent            0\n#&gt; 621                               evalq            0\n#&gt; 622                                Exec            0\n#&gt; 623                              exists            0\n#&gt; 624                                 exp            0\n#&gt; 625                         expand.grid            0\n#&gt; 626                               expm1            0\n#&gt; 627                          expression            0\n#&gt; 628                      extSoftVersion            0\n#&gt; 629                           factorial            0\n#&gt; 630                                fifo            0\n#&gt; 631                         file.access            0\n#&gt; 632                         file.append            0\n#&gt; 633                         file.choose            0\n#&gt; 634                           file.copy            0\n#&gt; 635                         file.create            0\n#&gt; 636                         file.exists            0\n#&gt; 637                           file.info            0\n#&gt; 638                           file.link            0\n#&gt; 639                           file.mode            0\n#&gt; 640                          file.mtime            0\n#&gt; 641                           file.path            0\n#&gt; 642                         file.remove            0\n#&gt; 643                         file.rename            0\n#&gt; 644                           file.show            0\n#&gt; 645                           file.size            0\n#&gt; 646                        file.symlink            0\n#&gt; 647                              Filter            0\n#&gt; 648                                Find            0\n#&gt; 649                        find.package            0\n#&gt; 650                        findInterval            0\n#&gt; 651                      findPackageEnv            0\n#&gt; 652                         findRestart            0\n#&gt; 653                               floor            0\n#&gt; 654                    flush.connection            0\n#&gt; 655                                 for            0\n#&gt; 656                               force            0\n#&gt; 657                        forceAndCall            0\n#&gt; 658                             formals            0\n#&gt; 659                           formals&lt;-            0\n#&gt; 660                         format.AsIs            0\n#&gt; 661                   format.data.frame            0\n#&gt; 662                         format.Date            0\n#&gt; 663                      format.default            0\n#&gt; 664                     format.difftime            0\n#&gt; 665                       format.factor            0\n#&gt; 666                      format.hexmode            0\n#&gt; 667                         format.info            0\n#&gt; 668                   format.libraryIQR            0\n#&gt; 669              format.numeric_version            0\n#&gt; 670                      format.octmode            0\n#&gt; 671                  format.packageInfo            0\n#&gt; 672                      format.POSIXct            0\n#&gt; 673                      format.POSIXlt            0\n#&gt; 674                         format.pval            0\n#&gt; 675               format.summaryDefault            0\n#&gt; 676                             formatC            0\n#&gt; 677                            formatDL            0\n#&gt; 678                        forwardsolve            0\n#&gt; 679                            function            0\n#&gt; 680                               gamma            0\n#&gt; 681                             gc.time            0\n#&gt; 682                              gcinfo            0\n#&gt; 683                           gctorture            0\n#&gt; 684                          gctorture2            0\n#&gt; 685                                 get            0\n#&gt; 686                                get0            0\n#&gt; 687                   getAllConnections            0\n#&gt; 688                       getCallingDLL            0\n#&gt; 689                      getCallingDLLe            0\n#&gt; 690                       getConnection            0\n#&gt; 691  getDLLRegisteredRoutines.character            0\n#&gt; 692    getDLLRegisteredRoutines.DLLInfo            0\n#&gt; 693                          getElement            0\n#&gt; 694                       geterrmessage            0\n#&gt; 695                    getExportedValue            0\n#&gt; 696                             getHook            0\n#&gt; 697                       getLoadedDLLs            0\n#&gt; 698                        getNamespace            0\n#&gt; 699                 getNamespaceExports            0\n#&gt; 700                 getNamespaceImports            0\n#&gt; 701                    getNamespaceInfo            0\n#&gt; 702                    getNamespaceName            0\n#&gt; 703                   getNamespaceUsers            0\n#&gt; 704                 getNamespaceVersion            0\n#&gt; 705                 getNativeSymbolInfo            0\n#&gt; 706                           getOption            0\n#&gt; 707                         getRversion            0\n#&gt; 708                         getSrcLines            0\n#&gt; 709                getTaskCallbackNames            0\n#&gt; 710                             gettext            0\n#&gt; 711                            gettextf            0\n#&gt; 712                               getwd            0\n#&gt; 713                                  gl            0\n#&gt; 714               globalCallingHandlers            0\n#&gt; 715                           globalenv            0\n#&gt; 716                            gregexec            0\n#&gt; 717                            gregexpr            0\n#&gt; 718                                grep            0\n#&gt; 719                               grepl            0\n#&gt; 720                             grepRaw            0\n#&gt; 721                               grepv            0\n#&gt; 722                            grouping            0\n#&gt; 723                                gsub            0\n#&gt; 724                               gzcon            0\n#&gt; 725                              gzfile            0\n#&gt; 726                                   I            0\n#&gt; 727                               iconv            0\n#&gt; 728                           iconvlist            0\n#&gt; 729                       icuGetCollate            0\n#&gt; 730                       icuSetCollate            0\n#&gt; 731                           identical            0\n#&gt; 732                            identity            0\n#&gt; 733                                  if            0\n#&gt; 734                              ifelse            0\n#&gt; 735                                  Im            0\n#&gt; 736                       importIntoEnv            0\n#&gt; 737                             infoRDS            0\n#&gt; 738                            inherits            0\n#&gt; 739                             integer            0\n#&gt; 740                         interactive            0\n#&gt; 741                           intToBits            0\n#&gt; 742                           intToUtf8            0\n#&gt; 743                         inverse.rle            0\n#&gt; 744                           invisible            0\n#&gt; 745                       invokeRestart            0\n#&gt; 746          invokeRestartInteractively            0\n#&gt; 747                            is.array            0\n#&gt; 748                           is.atomic            0\n#&gt; 749                             is.call            0\n#&gt; 750                        is.character            0\n#&gt; 751                          is.complex            0\n#&gt; 752                       is.data.frame            0\n#&gt; 753                           is.double            0\n#&gt; 754                          is.element            0\n#&gt; 755                      is.environment            0\n#&gt; 756                       is.expression            0\n#&gt; 757                           is.factor            0\n#&gt; 758                   is.finite.POSIXlt            0\n#&gt; 759                         is.function            0\n#&gt; 760                 is.infinite.POSIXlt            0\n#&gt; 761                          is.integer            0\n#&gt; 762                         is.language            0\n#&gt; 763                             is.list            0\n#&gt; 764                           is.loaded            0\n#&gt; 765                          is.logical            0\n#&gt; 766                           is.matrix            0\n#&gt; 767                    is.na.data.frame            0\n#&gt; 768               is.na.numeric_version            0\n#&gt; 769                       is.na.POSIXlt            0\n#&gt; 770                     is.na&lt;-.default            0\n#&gt; 771                      is.na&lt;-.factor            0\n#&gt; 772             is.na&lt;-.numeric_version            0\n#&gt; 773                             is.name            0\n#&gt; 774                      is.nan.POSIXlt            0\n#&gt; 775                             is.null            0\n#&gt; 776                  is.numeric_version            0\n#&gt; 777                     is.numeric.Date            0\n#&gt; 778                 is.numeric.difftime            0\n#&gt; 779                   is.numeric.POSIXt            0\n#&gt; 780                           is.object            0\n#&gt; 781                          is.ordered            0\n#&gt; 782                  is.package_version            0\n#&gt; 783                         is.pairlist            0\n#&gt; 784                        is.primitive            0\n#&gt; 785                               is.qr            0\n#&gt; 786                                is.R            0\n#&gt; 787                              is.raw            0\n#&gt; 788                        is.recursive            0\n#&gt; 789                           is.single            0\n#&gt; 790                           is.symbol            0\n#&gt; 791                            is.table            0\n#&gt; 792                         is.unsorted            0\n#&gt; 793                           is.vector            0\n#&gt; 794                                 isa            0\n#&gt; 795                              isatty            0\n#&gt; 796                     isBaseNamespace            0\n#&gt; 797                          isdebugged            0\n#&gt; 798                             isFALSE            0\n#&gt; 799                        isIncomplete            0\n#&gt; 800                         isNamespace            0\n#&gt; 801                   isNamespaceLoaded            0\n#&gt; 802                             ISOdate            0\n#&gt; 803                         ISOdatetime            0\n#&gt; 804                              isOpen            0\n#&gt; 805                           isRestart            0\n#&gt; 806                                isS4            0\n#&gt; 807                          isSeekable            0\n#&gt; 808                  isSymmetric.matrix            0\n#&gt; 809                              isTRUE            0\n#&gt; 810                              jitter            0\n#&gt; 811                         julian.Date            0\n#&gt; 812                       julian.POSIXt            0\n#&gt; 813                       kappa.default            0\n#&gt; 814                            kappa.lm            0\n#&gt; 815                            kappa.qr            0\n#&gt; 816                           l10n_info            0\n#&gt; 817                          La_library            0\n#&gt; 818                          La_version            0\n#&gt; 819                              La.svd            0\n#&gt; 820                      labels.default            0\n#&gt; 821                              lapply            0\n#&gt; 822                            lazyLoad            0\n#&gt; 823                      lazyLoadDBexec            0\n#&gt; 824                     lazyLoadDBfetch            0\n#&gt; 825                               lbeta            0\n#&gt; 826                             lchoose            0\n#&gt; 827                      length.POSIXlt            0\n#&gt; 828                       length&lt;-.Date            0\n#&gt; 829                   length&lt;-.difftime            0\n#&gt; 830                     length&lt;-.factor            0\n#&gt; 831                    length&lt;-.POSIXct            0\n#&gt; 832                    length&lt;-.POSIXlt            0\n#&gt; 833                      levels.default            0\n#&gt; 834                     levels&lt;-.factor            0\n#&gt; 835                          lfactorial            0\n#&gt; 836                              lgamma            0\n#&gt; 837                      libcurlVersion            0\n#&gt; 838                library.dynam.unload            0\n#&gt; 839                             licence            0\n#&gt; 840                             license            0\n#&gt; 841                           list.dirs            0\n#&gt; 842                          list.files            0\n#&gt; 843                             list2DF            0\n#&gt; 844                            list2env            0\n#&gt; 845                                load            0\n#&gt; 846                    loadedNamespaces            0\n#&gt; 847                loadingNamespaceInfo            0\n#&gt; 848                       loadNamespace            0\n#&gt; 849                               local            0\n#&gt; 850                         lockBinding            0\n#&gt; 851                     lockEnvironment            0\n#&gt; 852                                 log            0\n#&gt; 853                               log10            0\n#&gt; 854                               log1p            0\n#&gt; 855                                log2            0\n#&gt; 856                                logb            0\n#&gt; 857                             logical            0\n#&gt; 858                           lower.tri            0\n#&gt; 859                          make.names            0\n#&gt; 860                         make.unique            0\n#&gt; 861                   makeActiveBinding            0\n#&gt; 862                                 Map            0\n#&gt; 863                              mapply            0\n#&gt; 864                        margin.table            0\n#&gt; 865                          marginSums            0\n#&gt; 866                          mat.or.vec            0\n#&gt; 867                           match.arg            0\n#&gt; 868                          match.call            0\n#&gt; 869                           match.fun            0\n#&gt; 870                     Math.data.frame            0\n#&gt; 871                           Math.Date            0\n#&gt; 872                       Math.difftime            0\n#&gt; 873                         Math.factor            0\n#&gt; 874                         Math.POSIXt            0\n#&gt; 875                              matrix            0\n#&gt; 876                             max.col            0\n#&gt; 877                           mean.Date            0\n#&gt; 878                        mean.default            0\n#&gt; 879                       mean.difftime            0\n#&gt; 880                        mean.POSIXct            0\n#&gt; 881                        mean.POSIXlt            0\n#&gt; 882                        mem.maxNSize            0\n#&gt; 883                        mem.maxVSize            0\n#&gt; 884                         memCompress            0\n#&gt; 885                       memDecompress            0\n#&gt; 886                      memory.profile            0\n#&gt; 887                    merge.data.frame            0\n#&gt; 888                       merge.default            0\n#&gt; 889                             message            0\n#&gt; 890                                mget            0\n#&gt; 891                             missing            0\n#&gt; 892                                 Mod            0\n#&gt; 893                                mode            0\n#&gt; 894                              mode&lt;-            0\n#&gt; 895                         months.Date            0\n#&gt; 896                       months.POSIXt            0\n#&gt; 897                    mostattributes&lt;-            0\n#&gt; 898                       mtfrm.default            0\n#&gt; 899                       mtfrm.POSIXct            0\n#&gt; 900                       mtfrm.POSIXlt            0\n#&gt; 901                 nameOfClass.default            0\n#&gt; 902                       names.POSIXlt            0\n#&gt; 903                     names&lt;-.POSIXlt            0\n#&gt; 904                     namespaceExport            0\n#&gt; 905                     namespaceImport            0\n#&gt; 906              namespaceImportClasses            0\n#&gt; 907                 namespaceImportFrom            0\n#&gt; 908              namespaceImportMethods            0\n#&gt; 909                               nargs            0\n#&gt; 910                               nchar            0\n#&gt; 911                                ncol            0\n#&gt; 912                                NCOL            0\n#&gt; 913                              Negate            0\n#&gt; 914                             new.env            0\n#&gt; 915                                next            0\n#&gt; 916                          NextMethod            0\n#&gt; 917                            ngettext            0\n#&gt; 918                             nlevels            0\n#&gt; 919                             noquote            0\n#&gt; 920                                norm            0\n#&gt; 921                       normalizePath            0\n#&gt; 922                                nrow            0\n#&gt; 923                                NROW            0\n#&gt; 924                            nullfile            0\n#&gt; 925                             numeric            0\n#&gt; 926                     numeric_version            0\n#&gt; 927                           numToBits            0\n#&gt; 928                           numToInts            0\n#&gt; 929                              nzchar            0\n#&gt; 930                             objects            0\n#&gt; 931                            oldClass            0\n#&gt; 932                          oldClass&lt;-            0\n#&gt; 933                          OlsonNames            0\n#&gt; 934                             on.exit            0\n#&gt; 935                     open.connection            0\n#&gt; 936                        open.srcfile            0\n#&gt; 937                   open.srcfilealias            0\n#&gt; 938                    open.srcfilecopy            0\n#&gt; 939                      Ops.data.frame            0\n#&gt; 940                            Ops.Date            0\n#&gt; 941                        Ops.difftime            0\n#&gt; 942                          Ops.factor            0\n#&gt; 943                 Ops.numeric_version            0\n#&gt; 944                         Ops.ordered            0\n#&gt; 945                          Ops.POSIXt            0\n#&gt; 946                             options            0\n#&gt; 947                             ordered            0\n#&gt; 948                               outer            0\n#&gt; 949                     package_version            0\n#&gt; 950                        packageEvent            0\n#&gt; 951                 packageHasNamespace            0\n#&gt; 952                packageNotFoundError            0\n#&gt; 953               packageStartupMessage            0\n#&gt; 954                            packBits            0\n#&gt; 955                            pairlist            0\n#&gt; 956                          parent.env            0\n#&gt; 957                        parent.env&lt;-            0\n#&gt; 958                        parent.frame            0\n#&gt; 959                               parse            0\n#&gt; 960                  parseNamespaceFile            0\n#&gt; 961                               paste            0\n#&gt; 962                              paste0            0\n#&gt; 963                         path.expand            0\n#&gt; 964                        path.package            0\n#&gt; 965                         pcre_config            0\n#&gt; 966                                pipe            0\n#&gt; 967                              pmatch            0\n#&gt; 968                            pmax.int            0\n#&gt; 969                            pmin.int            0\n#&gt; 970                            polyroot            0\n#&gt; 971                          pos.to.env            0\n#&gt; 972                            Position            0\n#&gt; 973                      pretty.default            0\n#&gt; 974                           prettyNum            0\n#&gt; 975                          print.AsIs            0\n#&gt; 976                            print.by            0\n#&gt; 977                     print.condition            0\n#&gt; 978                    print.connection            0\n#&gt; 979                    print.data.frame            0\n#&gt; 980                          print.Date            0\n#&gt; 981                       print.default            0\n#&gt; 982                      print.difftime            0\n#&gt; 983                         print.Dlist            0\n#&gt; 984                       print.DLLInfo            0\n#&gt; 985                   print.DLLInfoList            0\n#&gt; 986         print.DLLRegisteredRoutines            0\n#&gt; 987                         print.eigen            0\n#&gt; 988                        print.factor            0\n#&gt; 989                      print.function            0\n#&gt; 990                       print.hexmode            0\n#&gt; 991                    print.libraryIQR            0\n#&gt; 992                        print.listof            0\n#&gt; 993             print.NativeRoutineList            0\n#&gt; 994                       print.noquote            0\n#&gt; 995               print.numeric_version            0\n#&gt; 996                       print.octmode            0\n#&gt; 997                   print.packageInfo            0\n#&gt; 998                       print.POSIXct            0\n#&gt; 999                       print.POSIXlt            0\n#&gt; 1000                    print.proc_time            0\n#&gt; 1001                      print.restart            0\n#&gt; 1002                          print.rle            0\n#&gt; 1003                  print.simple.list            0\n#&gt; 1004                      print.srcfile            0\n#&gt; 1005                       print.srcref            0\n#&gt; 1006                print.summary.table            0\n#&gt; 1007             print.summary.warnings            0\n#&gt; 1008               print.summaryDefault            0\n#&gt; 1009                        print.table            0\n#&gt; 1010                     print.warnings            0\n#&gt; 1011                           prmatrix            0\n#&gt; 1012                          proc.time            0\n#&gt; 1013                               prod            0\n#&gt; 1014                         prop.table            0\n#&gt; 1015                        proportions            0\n#&gt; 1016                    provideDimnames            0\n#&gt; 1017                           psigamma            0\n#&gt; 1018                           pushBack            0\n#&gt; 1019                     pushBackLength            0\n#&gt; 1020                                  q            0\n#&gt; 1021                            qr.coef            0\n#&gt; 1022                         qr.default            0\n#&gt; 1023                          qr.fitted            0\n#&gt; 1024                               qr.Q            0\n#&gt; 1025                             qr.qty            0\n#&gt; 1026                              qr.qy            0\n#&gt; 1027                               qr.R            0\n#&gt; 1028                           qr.resid            0\n#&gt; 1029                           qr.solve            0\n#&gt; 1030                               qr.X            0\n#&gt; 1031                      quarters.Date            0\n#&gt; 1032                    quarters.POSIXt            0\n#&gt; 1033                               quit            0\n#&gt; 1034                              quote            0\n#&gt; 1035                      R_compiled_by            0\n#&gt; 1036                   R_system_version            0\n#&gt; 1037                             R.home            0\n#&gt; 1038                          R.Version            0\n#&gt; 1039                         range.Date            0\n#&gt; 1040                      range.default            0\n#&gt; 1041                      range.POSIXct            0\n#&gt; 1042                               rank            0\n#&gt; 1043                             rapply            0\n#&gt; 1044                                raw            0\n#&gt; 1045                      rawConnection            0\n#&gt; 1046                 rawConnectionValue            0\n#&gt; 1047                           rawShift            0\n#&gt; 1048                          rawToBits            0\n#&gt; 1049                          rawToChar            0\n#&gt; 1050                   rbind.data.frame            0\n#&gt; 1051                              rcond            0\n#&gt; 1052                                 Re            0\n#&gt; 1053                           read.dcf            0\n#&gt; 1054                            readBin            0\n#&gt; 1055                           readChar            0\n#&gt; 1056                           readline            0\n#&gt; 1057                          readLines            0\n#&gt; 1058                            readRDS            0\n#&gt; 1059                       readRenviron            0\n#&gt; 1060                             Recall            0\n#&gt; 1061                             Reduce            0\n#&gt; 1062                      reg.finalizer            0\n#&gt; 1063                            regexec            0\n#&gt; 1064                            regexpr            0\n#&gt; 1065                   registerS3method            0\n#&gt; 1066                  registerS3methods            0\n#&gt; 1067                         regmatches            0\n#&gt; 1068                       regmatches&lt;-            0\n#&gt; 1069                 removeTaskCallback            0\n#&gt; 1070                            rep_len            0\n#&gt; 1071                           rep.Date            0\n#&gt; 1072                       rep.difftime            0\n#&gt; 1073                         rep.factor            0\n#&gt; 1074                            rep.int            0\n#&gt; 1075                rep.numeric_version            0\n#&gt; 1076                        rep.POSIXct            0\n#&gt; 1077                        rep.POSIXlt            0\n#&gt; 1078                             repeat            0\n#&gt; 1079                            replace            0\n#&gt; 1080                          replicate            0\n#&gt; 1081                            require            0\n#&gt; 1082                   requireNamespace            0\n#&gt; 1083                 restartDescription            0\n#&gt; 1084                     restartFormals            0\n#&gt; 1085                         retracemem            0\n#&gt; 1086                             return            0\n#&gt; 1087                        returnValue            0\n#&gt; 1088                        rev.default            0\n#&gt; 1089                                rle            0\n#&gt; 1090                                 rm            0\n#&gt; 1091                            RNGkind            0\n#&gt; 1092                         RNGversion            0\n#&gt; 1093                         round.Date            0\n#&gt; 1094                       round.POSIXt            0\n#&gt; 1095               row.names.data.frame            0\n#&gt; 1096                  row.names.default            0\n#&gt; 1097             row.names&lt;-.data.frame            0\n#&gt; 1098                row.names&lt;-.default            0\n#&gt; 1099                           rowMeans            0\n#&gt; 1100                           rownames            0\n#&gt; 1101                         rownames&lt;-            0\n#&gt; 1102                  rowsum.data.frame            0\n#&gt; 1103                     rowsum.default            0\n#&gt; 1104                            rowSums            0\n#&gt; 1105                         sample.int            0\n#&gt; 1106                             sapply            0\n#&gt; 1107                         save.image            0\n#&gt; 1108                            saveRDS            0\n#&gt; 1109                      scale.default            0\n#&gt; 1110                               scan            0\n#&gt; 1111                             search            0\n#&gt; 1112                        searchpaths            0\n#&gt; 1113                    seek.connection            0\n#&gt; 1114                          seq_along            0\n#&gt; 1115                            seq_len            0\n#&gt; 1116                           seq.Date            0\n#&gt; 1117                        seq.default            0\n#&gt; 1118                            seq.int            0\n#&gt; 1119                         seq.POSIXt            0\n#&gt; 1120                   sequence.default            0\n#&gt; 1121                          serialize            0\n#&gt; 1122                       serverSocket            0\n#&gt; 1123                           set.seed            0\n#&gt; 1124                            setHook            0\n#&gt; 1125                   setNamespaceInfo            0\n#&gt; 1126                setSessionTimeLimit            0\n#&gt; 1127                       setTimeLimit            0\n#&gt; 1128                              setwd            0\n#&gt; 1129                    showConnections            0\n#&gt; 1130                            shQuote            0\n#&gt; 1131                               sign            0\n#&gt; 1132                    signalCondition            0\n#&gt; 1133                             signif            0\n#&gt; 1134                    simpleCondition            0\n#&gt; 1135                        simpleError            0\n#&gt; 1136                      simpleMessage            0\n#&gt; 1137                      simpleWarning            0\n#&gt; 1138                     simplify2array            0\n#&gt; 1139                                sin            0\n#&gt; 1140                             single            0\n#&gt; 1141                               sinh            0\n#&gt; 1142                        sink.number            0\n#&gt; 1143                              sinpi            0\n#&gt; 1144                        slice.index            0\n#&gt; 1145                       socketAccept            0\n#&gt; 1146                   socketConnection            0\n#&gt; 1147                       socketSelect            0\n#&gt; 1148                      socketTimeout            0\n#&gt; 1149                      solve.default            0\n#&gt; 1150                           solve.qr            0\n#&gt; 1151                 sort_by.data.frame            0\n#&gt; 1152                    sort_by.default            0\n#&gt; 1153                       sort.default            0\n#&gt; 1154                           sort.int            0\n#&gt; 1155                          sort.list            0\n#&gt; 1156                       sort.POSIXlt            0\n#&gt; 1157                             source            0\n#&gt; 1158                   split.data.frame            0\n#&gt; 1159                         split.Date            0\n#&gt; 1160                      split.default            0\n#&gt; 1161                      split.POSIXct            0\n#&gt; 1162                 split&lt;-.data.frame            0\n#&gt; 1163                    split&lt;-.default            0\n#&gt; 1164                            sprintf            0\n#&gt; 1165                               sqrt            0\n#&gt; 1166                             sQuote            0\n#&gt; 1167                            srcfile            0\n#&gt; 1168                       srcfilealias            0\n#&gt; 1169                        srcfilecopy            0\n#&gt; 1170                             srcref            0\n#&gt; 1171                    standardGeneric            0\n#&gt; 1172                         startsWith            0\n#&gt; 1173                             stderr            0\n#&gt; 1174                              stdin            0\n#&gt; 1175                             stdout            0\n#&gt; 1176                               stop            0\n#&gt; 1177                          stopifnot            0\n#&gt; 1178                       storage.mode            0\n#&gt; 1179                     storage.mode&lt;-            0\n#&gt; 1180                     str2expression            0\n#&gt; 1181                           str2lang            0\n#&gt; 1182                           strftime            0\n#&gt; 1183                           strptime            0\n#&gt; 1184                             strrep            0\n#&gt; 1185                           strsplit            0\n#&gt; 1186                             strtoi            0\n#&gt; 1187                            strtrim            0\n#&gt; 1188                          structure            0\n#&gt; 1189                            strwrap            0\n#&gt; 1190                                sub            0\n#&gt; 1191                  subset.data.frame            0\n#&gt; 1192                     subset.default            0\n#&gt; 1193                      subset.matrix            0\n#&gt; 1194                         substitute            0\n#&gt; 1195                             substr            0\n#&gt; 1196                           substr&lt;-            0\n#&gt; 1197                          substring            0\n#&gt; 1198                        substring&lt;-            0\n#&gt; 1199                 summary.connection            0\n#&gt; 1200                 summary.data.frame            0\n#&gt; 1201                 Summary.data.frame            0\n#&gt; 1202                       summary.Date            0\n#&gt; 1203                       Summary.Date            0\n#&gt; 1204                    summary.default            0\n#&gt; 1205                   summary.difftime            0\n#&gt; 1206                   Summary.difftime            0\n#&gt; 1207                     summary.factor            0\n#&gt; 1208                     Summary.factor            0\n#&gt; 1209                     summary.matrix            0\n#&gt; 1210            Summary.numeric_version            0\n#&gt; 1211                    Summary.ordered            0\n#&gt; 1212                    summary.POSIXct            0\n#&gt; 1213                    Summary.POSIXct            0\n#&gt; 1214                    summary.POSIXlt            0\n#&gt; 1215                    Summary.POSIXlt            0\n#&gt; 1216                  summary.proc_time            0\n#&gt; 1217                    summary.srcfile            0\n#&gt; 1218                     summary.srcref            0\n#&gt; 1219                      summary.table            0\n#&gt; 1220                   summary.warnings            0\n#&gt; 1221                   suppressMessages            0\n#&gt; 1222     suppressPackageStartupMessages            0\n#&gt; 1223                   suppressWarnings            0\n#&gt; 1224                  suspendInterrupts            0\n#&gt; 1225                                svd            0\n#&gt; 1226                              sweep            0\n#&gt; 1227                             switch            0\n#&gt; 1228                           sys.call            0\n#&gt; 1229                          sys.calls            0\n#&gt; 1230                          Sys.chmod            0\n#&gt; 1231                           Sys.Date            0\n#&gt; 1232                          sys.frame            0\n#&gt; 1233                         sys.frames            0\n#&gt; 1234                       sys.function            0\n#&gt; 1235                         Sys.getenv            0\n#&gt; 1236                      Sys.getlocale            0\n#&gt; 1237                         Sys.getpid            0\n#&gt; 1238                           Sys.glob            0\n#&gt; 1239                           Sys.info            0\n#&gt; 1240                     sys.load.image            0\n#&gt; 1241                     Sys.localeconv            0\n#&gt; 1242                         sys.nframe            0\n#&gt; 1243                        sys.on.exit            0\n#&gt; 1244                         sys.parent            0\n#&gt; 1245                        sys.parents            0\n#&gt; 1246                       Sys.readlink            0\n#&gt; 1247                     sys.save.image            0\n#&gt; 1248                         Sys.setenv            0\n#&gt; 1249                    Sys.setFileTime            0\n#&gt; 1250                    Sys.setLanguage            0\n#&gt; 1251                      Sys.setlocale            0\n#&gt; 1252                          Sys.sleep            0\n#&gt; 1253                         sys.source            0\n#&gt; 1254                         sys.status            0\n#&gt; 1255                           Sys.time            0\n#&gt; 1256                       Sys.timezone            0\n#&gt; 1257                          Sys.umask            0\n#&gt; 1258                       Sys.unsetenv            0\n#&gt; 1259                          Sys.which            0\n#&gt; 1260                        system.file            0\n#&gt; 1261                        system.time            0\n#&gt; 1262                            system2            0\n#&gt; 1263                       t.data.frame            0\n#&gt; 1264                          t.default            0\n#&gt; 1265                              table            0\n#&gt; 1266                           tabulate            0\n#&gt; 1267                           Tailcall            0\n#&gt; 1268                                tan            0\n#&gt; 1269                               tanh            0\n#&gt; 1270                              tanpi            0\n#&gt; 1271                             tapply            0\n#&gt; 1272                taskCallbackManager            0\n#&gt; 1273                         tcrossprod            0\n#&gt; 1274                            tempdir            0\n#&gt; 1275                           tempfile            0\n#&gt; 1276                     textConnection            0\n#&gt; 1277                textConnectionValue            0\n#&gt; 1278                            tolower            0\n#&gt; 1279                             topenv            0\n#&gt; 1280                   toString.default            0\n#&gt; 1281                            toupper            0\n#&gt; 1282                              trace            0\n#&gt; 1283                          traceback            0\n#&gt; 1284                           tracemem            0\n#&gt; 1285                       tracingState            0\n#&gt; 1286               transform.data.frame            0\n#&gt; 1287                  transform.default            0\n#&gt; 1288                           trigamma            0\n#&gt; 1289                             trimws            0\n#&gt; 1290                         trunc.Date            0\n#&gt; 1291                       trunc.POSIXt            0\n#&gt; 1292                truncate.connection            0\n#&gt; 1293                                try            0\n#&gt; 1294                           tryCatch            0\n#&gt; 1295                   tryInvokeRestart            0\n#&gt; 1296                             typeof            0\n#&gt; 1297                     unCfillPOSIXlt            0\n#&gt; 1298                            unclass            0\n#&gt; 1299                            undebug            0\n#&gt; 1300                       unique.array            0\n#&gt; 1301                  unique.data.frame            0\n#&gt; 1302                     unique.default            0\n#&gt; 1303                      unique.matrix            0\n#&gt; 1304             unique.numeric_version            0\n#&gt; 1305                     unique.POSIXlt            0\n#&gt; 1306                    unique.warnings            0\n#&gt; 1307                     units.difftime            0\n#&gt; 1308                   units&lt;-.difftime            0\n#&gt; 1309                          unix.time            0\n#&gt; 1310                             unlink            0\n#&gt; 1311                    unloadNamespace            0\n#&gt; 1312                      unlockBinding            0\n#&gt; 1313                             unname            0\n#&gt; 1314                        unserialize            0\n#&gt; 1315                            unsplit            0\n#&gt; 1316                            untrace            0\n#&gt; 1317                         untracemem            0\n#&gt; 1318                                unz            0\n#&gt; 1319                          upper.tri            0\n#&gt; 1320                                use            0\n#&gt; 1321                          UseMethod            0\n#&gt; 1322                          utf8ToInt            0\n#&gt; 1323                           validEnc            0\n#&gt; 1324                          validUTF8            0\n#&gt; 1325                             vapply            0\n#&gt; 1326                             vector            0\n#&gt; 1327                          Vectorize            0\n#&gt; 1328                            warning            0\n#&gt; 1329                   warningCondition            0\n#&gt; 1330                           warnings            0\n#&gt; 1331                      weekdays.Date            0\n#&gt; 1332                    weekdays.POSIXt            0\n#&gt; 1333                          which.max            0\n#&gt; 1334                          which.min            0\n#&gt; 1335                              while            0\n#&gt; 1336                       with.default            0\n#&gt; 1337                      withAutoprint            0\n#&gt; 1338                withCallingHandlers            0\n#&gt; 1339                  within.data.frame            0\n#&gt; 1340                        within.list            0\n#&gt; 1341                       withRestarts            0\n#&gt; 1342                        withVisible            0\n#&gt; 1343                          write.dcf            0\n#&gt; 1344                           writeBin            0\n#&gt; 1345                          writeChar            0\n#&gt; 1346                         writeLines            0\n#&gt; 1347                                xor            0\n#&gt; 1348                 xpdrows.data.frame            0\n#&gt; 1349                         xtfrm.AsIs            0\n#&gt; 1350                   xtfrm.data.frame            0\n#&gt; 1351                         xtfrm.Date            0\n#&gt; 1352                      xtfrm.default            0\n#&gt; 1353                     xtfrm.difftime            0\n#&gt; 1354                       xtfrm.factor            0\n#&gt; 1355              xtfrm.numeric_version            0\n#&gt; 1356                      xtfrm.POSIXct            0\n#&gt; 1357                      xtfrm.POSIXlt            0\n#&gt; 1358                             xzfile            0\n#&gt; 1359                           zapsmall            0\n#&gt; 1360                           zstdfile            0\n\n\nThis brute-force code unsurprisingly identifies print() as having the greatest number of methods. A bug in s3_methods_generic() prevents its use (error below).\nError in gsub(paste0(\"^\", generic_esc, \"[.,]\"), \"\", info$method) : \ninvalid regular expression '^([.,]', reason 'Missing ')''\nAR Solutions: A little experimentation (and thinking about the most popular functions) suggests that the print() generic has the most defined methods.\nLet’s verify this programmatically with the tools we have learned in this and the previous chapters.\n\nls(all.names = TRUE, envir = baseenv()) %&gt;%\n  mget(envir = baseenv()) %&gt;%\n  keep(is_function) %&gt;%\n  names() %&gt;%\n  keep(is_s3_generic) %&gt;%\n  map(~ set_names(nrow(s3_methods_generic(.x)), .x)) %&gt;%\n  flatten_int() %&gt;%\n  sort(decreasing = TRUE) %&gt;%\n  head()\n\n#&gt;         print        format             [       summary  as.character \n#&gt;           280           126            49            40            33 \n#&gt; as.data.frame \n#&gt;            33\n\n\n\n\nCarefully read the documentation for UseMethod() and explain why the following code returns the results that it does. What two usual rules of function evaluation does UseMethod() violate?\n\n\ng &lt;- function(x) {\n  x &lt;- 10\n  y &lt;- 10\n  UseMethod(\"g\")\n}\ng.default &lt;- function(x) c(x = x, y = y)\nx &lt;- 1\ny &lt;- 1\ng(x)\n\n#&gt; x y \n#&gt; 1 1\n\n\nAnswer: the documentation states in Technical Details:\n\nUseMethod creates a new function call with arguments matched as they came in to the generic. Any local variables defined before the call to UseMethod are retained (unlike S).\n\nSo, UseMethod() creates a new function call where x matches x &lt;- 1 and the local variable y &lt;- 10 is retained. This is passed to g.default(). This violates both lazy evaluation and lexical scoping.\nAR Solutions: Let’s take this step by step. If you call g.default(x) directly you get c(1, 1) as you might expect.\nThe value bound to x comes from the argument, the value from y comes from the global environment.\nBut when we call g(x) we get c(1, 10).\nThis is seemingly inconsistent: why does x come from the value defined inside of g(), and y still come from the global environment? It’s because UseMethod() calls g.default() in a special way so that variables defined inside the generic are available to methods. The exception are arguments supplied to the function: they are passed on as is and cannot be affected by code inside the generic.\n\n\nWhat are the arguments to [? Why is this a hard question to answer?\n\nAnswer: the possible arguments include the x, the object being extracted (or replaced), indices (i, j, ...), name, drop, exact, and value.\nThis is a hard question to answer since [ is an irregular primitive function that can be called in multiple ways, none of which support using all possible arguments.\nAR Solutions: The subsetting operator [ is a primitive and a generic function, which can be confirmed via ftype().\n\nftype(`[`)\n\n#&gt; [1] \"primitive\" \"generic\"\n\n\nFor primitive functions formals([) returns NULL so we need to find another way to determine the functions arguments. One possible way to figure out [’s arguments would be to inspect the underlying C source code, which can be searched for via pryr::show_c_source(.Primitive(\"[\")). When we inspect the arguments of some of [’s methods, we see that the arguments vary with the class of x.\n\nnames(formals(`[.data.frame`))\n\n#&gt; [1] \"x\"    \"i\"    \"j\"    \"drop\"\n\nnames(formals(`[.table`))\n\n#&gt; [1] \"x\"    \"i\"    \"j\"    \"...\"  \"drop\"\n\nnames(formals(`[.Date`))\n\n#&gt; [1] \"x\"    \"...\"  \"drop\"\n\nnames(formals(`[.AsIs`))\n\n#&gt; [1] \"x\"   \"i\"   \"...\"\n\n\nTo finally get a better overview, we have to put in a little more effort and also use s3_methods_generic() again.\n\ns3_methods_generic(\"[\") %&gt;%\n  filter(visible) %&gt;%\n  mutate(\n    method = paste0(\"[.\", class),\n    argnames = purrr::map(method, ~ names(formals(.x))),\n    args = purrr::map(method, ~ formals(.x)),\n    args = purrr::map2(\n      argnames, args,\n      ~ paste(.x, .y, sep = \" = \")\n    ),\n    args = purrr::set_names(args, method)\n  ) %&gt;%\n  pull(args) %&gt;%\n  head()\n\n#&gt; $`[.AsIs`\n#&gt; [1] \"x = \"   \"i = \"   \"... = \"\n#&gt; \n#&gt; $`[.data.frame`\n#&gt; [1] \"x = \"                                              \n#&gt; [2] \"i = \"                                              \n#&gt; [3] \"j = \"                                              \n#&gt; [4] \"drop = if (missing(i)) TRUE else length(cols) == 1\"\n#&gt; \n#&gt; $`[.Date`\n#&gt; [1] \"x = \"        \"... = \"      \"drop = TRUE\"\n#&gt; \n#&gt; $`[.difftime`\n#&gt; [1] \"x = \"        \"... = \"      \"drop = TRUE\"\n#&gt; \n#&gt; $`[.Dlist`\n#&gt; [1] \"x = \"   \"i = \"   \"... = \"\n#&gt; \n#&gt; $`[.DLLInfoList`\n#&gt; [1] \"x = \"   \"... = \"\n\n\n\n\n\n13.5.1 Exercises\n\nCategorise the objects returned by lm(), factor(), table(), as.Date(), as.POSIXct(), ecdf(), ordered(), I() into the styles described above.\n\nAnswer:\n\nlm(), ecdf(): scalar\nfactor(), as.Date(), as.POSIXct(), ordered: vector\ntable(): data frame\nI(): same as the source object\n\nAR Solutions: We can categorise the return values into the various object styles by observing how the number of observations is calculated: For vector style classes, length(x) represents the number of observations. Record style objects use a list of equal length elements to represent individual components. For data frames and matrices, the observations are represented by the rows. Scalar style objects use a list to represent a single thing.\nThis leads us to:\n\nVector object-style: factor(), table(), as.Date(), as.POSIXct(), ordered()\nRecord object-style: not observed\nData frame object-style: not observed\nScalar object-style: lm(), ecdf()\n\nThe object style of I() depends on the input since this function returns a “copy of the object with class AsIs prepended to the class(es)”.\n\n\nWhat would a constructor function for lm objects, new_lm(), look like? Use ?lm and experimentation to figure out the required fields and their types.\n\nAnswer: the only required field is formula, provided that the variables listed in the formula exist (and are both vectors). formula must be of type “formula”.\n\nmpg &lt;- pull(mtcars, mpg)\nwt &lt;- pull(mtcars, wt)\nlm(mpg ~ wt)\n\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ wt)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)           wt  \n#&gt;      37.285       -5.344\n\n\nAR Solutions: The constructor needs to populate the attributes of an lm object and check their types for correctness. Let’s start by creating a simple lm object and explore its underlying base type and attributes:\n\nmod &lt;- lm(cyl ~ ., data = mtcars)\ntypeof(mod)\n\n#&gt; [1] \"list\"\n\nattributes(mod)\n\n#&gt; $names\n#&gt;  [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n#&gt;  [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n#&gt;  [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n#&gt; \n#&gt; $class\n#&gt; [1] \"lm\"\n\n\nAs mod is built upon a list, we can simply use map(mod, typeof) to find out the base types of its elements. (Additionally, we inspect ?lm, to learn more about the individual attributes.)\n\nmap_chr(mod, typeof)\n\n#&gt;  coefficients     residuals       effects          rank fitted.values \n#&gt;      \"double\"      \"double\"      \"double\"     \"integer\"      \"double\" \n#&gt;        assign            qr   df.residual       xlevels          call \n#&gt;     \"integer\"        \"list\"     \"integer\"        \"list\"    \"language\" \n#&gt;         terms         model \n#&gt;    \"language\"        \"list\"\n\n\nNow we should have enough information to write a constructor for new lm objects.\n\nnew_lm &lt;- function(coefficients, residuals, effects, rank, fitted.values, assign,\n                   qr, df.residual, xlevels, call, terms, model) {\n  stopifnot(\n    is.double(coefficients), is.double(residuals),\n    is.double(effects), is.integer(rank), is.double(fitted.values),\n    is.integer(assign), is.list(qr), is.integer(df.residual),\n    is.list(xlevels), is.language(call), is.language(terms),\n    is.list(model)\n  )\n\n  structure(\n    list(\n      coefficients = coefficients,\n      residuals = residuals,\n      effects = effects,\n      rank = rank,\n      fitted.values = fitted.values,\n      assign = assign,\n      qr = qr,\n      df.residual = df.residual,\n      xlevels = xlevels,\n      call = call,\n      terms = terms,\n      model = model\n    ),\n    class = \"lm\"\n  )\n}\n\n\n\n\n13.6.3 Exercises\n\nHow does [.Date support subclasses? How does it fail to support subclasses?\n\n\n`[.Date`\n\n#&gt; function (x, ..., drop = TRUE) \n#&gt; {\n#&gt;     .Date(NextMethod(\"[\"), oldClass(x))\n#&gt; }\n#&gt; &lt;bytecode: 0x107527220&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n`.Date`\n\n#&gt; function (xx, cl = \"Date\") \n#&gt; `class&lt;-`(xx, cl)\n#&gt; &lt;bytecode: 0x106f508d8&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\nAnswer: by passing the object’s class to .Date, [.Date avoids the problem of [.secret and can return subclasses of Date. However, the .Date method can return objects that don’t contain the class Date.\nAR Solutions: [.Date calls .Date with the result of calling [ on the parent class, along with oldClass():\n.Date is kind of like a constructor for date classes, although it doesn’t check the input is the correct type:\noldClass() is basically the same as class(), except that it doesn’t return implicit classes, i.e. it’s basically attr(x, \"class\") (looking at the C code that’s exactly what it does, except that it also handles S4 objects).\nAs oldClass() is “basically” class(), we can rewrite [.Date to make the implementation more clear:\n\n`[.Date` &lt;- function(x, ..., drop = TRUE) {\n  out &lt;- NextMethod(\"[\")\n  class(out) &lt;- class(x)\n  out\n}\n\nSo, [.Date ensures that the output has the same class as in the input. But what about other attributes that a subclass might possess? They get lost:\n\nx &lt;- structure(1:4, test = \"test\", class = c(\"myDate\", \"Date\"))\nattributes(x[1])\n\n#&gt; $class\n#&gt; [1] \"myDate\" \"Date\"\n\n\nNote: this is a better explanation of how it fails to support subclasses; it drops non-class attributes.\n\n\nR has two classes for representing date time data, POSIXct and POSIXlt, which both inherit from POSIXt. Which generics have different behaviours for the two classes? Which generics share the same behaviour?\n\nAnswer: if a generic is defined for either class, it must have different behaviors. Generics that aren’t defined for either class must have the same behavior. We can get the list of generics defined for either class using sloop::s3_methods_class(). These generics have different behaviors for the two classes:\n\nct_generics &lt;- s3_methods_class(\"POSIXct\")$generic\nlt_generics &lt;- s3_methods_class(\"POSIXlt\")$generic\ndefined_generics &lt;- union(ct_generics, lt_generics)\ndefined_generics\n\n#&gt;  [1] \"[\"             \"[[\"            \"[&lt;-\"           \"as.data.frame\"\n#&gt;  [5] \"as.Date\"       \"as.list\"       \"as.POSIXlt\"    \"c\"            \n#&gt;  [9] \"format\"        \"length&lt;-\"      \"mean\"          \"mtfrm\"        \n#&gt; [13] \"print\"         \"range\"         \"rep\"           \"split\"        \n#&gt; [17] \"summary\"       \"Summary\"       \"weighted.mean\" \"xtfrm\"        \n#&gt; [21] \"[[&lt;-\"          \"$&lt;-\"           \"anyNA\"         \"as.double\"    \n#&gt; [25] \"as.matrix\"     \"as.POSIXct\"    \"as.vector\"     \"duplicated\"   \n#&gt; [29] \"is.finite\"     \"is.infinite\"   \"is.na\"         \"is.nan\"       \n#&gt; [33] \"length\"        \"names\"         \"names&lt;-\"       \"sort\"         \n#&gt; [37] \"unique\"\n\n\nWe adapt work from previous exercises to get the list of all generics, and identify S3 generics that aren’t defined for either class, which must have the same behavior:\n\ns3_generic_funs &lt;- Filter(is_s3_generic, names(funs))\nunion(setdiff(defined_generics, s3_generic_funs), setdiff(s3_generic_funs, defined_generics))\n\n#&gt;   [1] \"Summary\"                  \"weighted.mean\"           \n#&gt;   [3] \"-\"                        \"!=\"                      \n#&gt;   [5] \"*\"                        \"/\"                       \n#&gt;   [7] \"&\"                        \"%/%\"                     \n#&gt;   [9] \"%%\"                       \"^\"                       \n#&gt;  [11] \"+\"                        \"&lt;\"                       \n#&gt;  [13] \"&lt;=\"                       \"==\"                      \n#&gt;  [15] \"&gt;\"                        \"&gt;=\"                      \n#&gt;  [17] \"|\"                        \"$\"                       \n#&gt;  [19] \"abs\"                      \"acos\"                    \n#&gt;  [21] \"acosh\"                    \"all\"                     \n#&gt;  [23] \"all.equal\"                \"any\"                     \n#&gt;  [25] \"anyDuplicated\"            \"aperm\"                   \n#&gt;  [27] \"Arg\"                      \"as.array\"                \n#&gt;  [29] \"as.call\"                  \"as.character\"            \n#&gt;  [31] \"as.complex\"               \"as.environment\"          \n#&gt;  [33] \"as.expression\"            \"as.function\"             \n#&gt;  [35] \"as.integer\"               \"as.logical\"              \n#&gt;  [37] \"as.null\"                  \"as.numeric\"              \n#&gt;  [39] \"as.raw\"                   \"as.single\"               \n#&gt;  [41] \"as.table\"                 \"asin\"                    \n#&gt;  [43] \"asinh\"                    \"atan\"                    \n#&gt;  [45] \"atanh\"                    \"by\"                      \n#&gt;  [47] \"cbind\"                    \"ceiling\"                 \n#&gt;  [49] \"chol\"                     \"chooseOpsMethod\"         \n#&gt;  [51] \"close\"                    \"conditionCall\"           \n#&gt;  [53] \"conditionMessage\"         \"Conj\"                    \n#&gt;  [55] \"cos\"                      \"cosh\"                    \n#&gt;  [57] \"cospi\"                    \"cummax\"                  \n#&gt;  [59] \"cummin\"                   \"cumprod\"                 \n#&gt;  [61] \"cumsum\"                   \"cut\"                     \n#&gt;  [63] \"determinant\"              \"diff\"                    \n#&gt;  [65] \"digamma\"                  \"dim\"                     \n#&gt;  [67] \"dim&lt;-\"                    \"dimnames\"                \n#&gt;  [69] \"dimnames&lt;-\"               \"droplevels\"              \n#&gt;  [71] \"exp\"                      \"expm1\"                   \n#&gt;  [73] \"floor\"                    \"flush\"                   \n#&gt;  [75] \"gamma\"                    \"getDLLRegisteredRoutines\"\n#&gt;  [77] \"Im\"                       \"is.array\"                \n#&gt;  [79] \"is.matrix\"                \"is.na&lt;-\"                 \n#&gt;  [81] \"is.numeric\"               \"isSymmetric\"             \n#&gt;  [83] \"julian\"                   \"kappa\"                   \n#&gt;  [85] \"labels\"                   \"levels\"                  \n#&gt;  [87] \"levels&lt;-\"                 \"lgamma\"                  \n#&gt;  [89] \"log\"                      \"log10\"                   \n#&gt;  [91] \"log1p\"                    \"log2\"                    \n#&gt;  [93] \"max\"                      \"merge\"                   \n#&gt;  [95] \"min\"                      \"Mod\"                     \n#&gt;  [97] \"months\"                   \"nameOfClass\"             \n#&gt;  [99] \"open\"                     \"plot\"                    \n#&gt; [101] \"pretty\"                   \"prod\"                    \n#&gt; [103] \"qr\"                       \"quarters\"                \n#&gt; [105] \"rbind\"                    \"Re\"                      \n#&gt; [107] \"rev\"                      \"round\"                   \n#&gt; [109] \"row.names\"                \"row.names&lt;-\"             \n#&gt; [111] \"rowsum\"                   \"scale\"                   \n#&gt; [113] \"seek\"                     \"seq\"                     \n#&gt; [115] \"seq.int\"                  \"sequence\"                \n#&gt; [117] \"sign\"                     \"signif\"                  \n#&gt; [119] \"sin\"                      \"sinh\"                    \n#&gt; [121] \"sinpi\"                    \"solve\"                   \n#&gt; [123] \"sort_by\"                  \"split&lt;-\"                 \n#&gt; [125] \"sqrt\"                     \"subset\"                  \n#&gt; [127] \"sum\"                      \"t\"                       \n#&gt; [129] \"tan\"                      \"tanh\"                    \n#&gt; [131] \"tanpi\"                    \"toString\"                \n#&gt; [133] \"transform\"                \"trigamma\"                \n#&gt; [135] \"trunc\"                    \"truncate\"                \n#&gt; [137] \"units\"                    \"units&lt;-\"                 \n#&gt; [139] \"unlist\"                   \"weekdays\"                \n#&gt; [141] \"with\"                     \"within\"\n\n\nNote: this code doesn’t quite work, since Summary is a generic according to isGeneric and is not according to is_s3_generic, and weighted.mean is a non-base S3 generic.\nAR Solutions: To answer this question, we have to get the respective generics\n\ngenerics_t &lt;- s3_methods_class(\"POSIXt\")$generic\ngenerics_ct &lt;- s3_methods_class(\"POSIXct\")$generic\ngenerics_lt &lt;- s3_methods_class(\"POSIXlt\")$generic\n\nThe generics in generics_t with a method for the superclass POSIXt potentially share the same behaviour for both subclasses. However, if a generic has a specific method for one of the subclasses, it has to be subtracted:\n\n# These generics provide subclass-specific methods\nunion(generics_ct, generics_lt)\n\n#&gt;  [1] \"[\"             \"[[\"            \"[&lt;-\"           \"as.data.frame\"\n#&gt;  [5] \"as.Date\"       \"as.list\"       \"as.POSIXlt\"    \"c\"            \n#&gt;  [9] \"format\"        \"length&lt;-\"      \"mean\"          \"mtfrm\"        \n#&gt; [13] \"print\"         \"range\"         \"rep\"           \"split\"        \n#&gt; [17] \"summary\"       \"Summary\"       \"weighted.mean\" \"xtfrm\"        \n#&gt; [21] \"[[&lt;-\"          \"$&lt;-\"           \"anyNA\"         \"as.double\"    \n#&gt; [25] \"as.matrix\"     \"as.POSIXct\"    \"as.vector\"     \"duplicated\"   \n#&gt; [29] \"is.finite\"     \"is.infinite\"   \"is.na\"         \"is.nan\"       \n#&gt; [33] \"length\"        \"names\"         \"names&lt;-\"       \"sort\"         \n#&gt; [37] \"unique\"\n\n# These generics share (inherited) methods for both subclasses\nsetdiff(generics_t, union(generics_ct, generics_lt))\n\n#&gt;  [1] \"-\"            \"+\"            \"all.equal\"    \"as.character\" \"Axis\"        \n#&gt;  [6] \"cut\"          \"diff\"         \"hist\"         \"is.numeric\"   \"julian\"      \n#&gt; [11] \"Math\"         \"months\"       \"Ops\"          \"pretty\"       \"quantile\"    \n#&gt; [16] \"quarters\"     \"round\"        \"seq\"          \"str\"          \"trunc\"       \n#&gt; [21] \"weekdays\"\n\n\nNote: again, advanced R gives a better answer to this question, by comparing to the generics supported by the parent class.\n\n\nWhat do you expect this code to return? What does it actually return? Why?\n\n\ngeneric2 &lt;- function(x) UseMethod(\"generic2\")\ngeneric2.a1 &lt;- function(x) \"a1\"\ngeneric2.a2 &lt;- function(x) \"a2\"\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  NextMethod()\n}\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n\n#&gt; [1] \"a2\"\n\n\nAnswer: I’d expect this code to return \"a2\" with a class of c(\"a1\", \"a2\"). It actually returns “a2” with a class of character. This is because when generic2.b calls NextMethod(), generic2.a2 is called which returns a bare \"a2\", dropping the class assigned by generic2.b.\n\nclass(generic2(structure(list(), class = c(\"b\", \"a2\"))))\n\n#&gt; [1] \"character\"\n\n\nAR Solutions: When we execute the code above, this is what is happening:\n\nwe pass an object of classes b and a2 to generic2(), which prompts R to look for a methodgeneric2.b()\nthe method generic2.b() then changes the class to a1 and calls NextMethod()\nOne would think that this will lead R to call generic2.a1(), but in fact, as mentioned in Advanced R, NextMethod() &gt; doesn’t actually work with the class attribute of the object, but instead uses a special global variable (.Class) to keep track of which method to call next.\nThis is why generic2.a2() is called instead.\n\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n\n#&gt; [1] \"a2\"\n\n\nLet’s just double check the statement above and evaluate .Class explicitly within the generic2.b() method.\n\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  print(.Class)\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n\n#&gt; [1] \"b\"  \"a2\"\n\n\n#&gt; [1] \"a2\"\n\n\n\n\n\n13.7.5 Exercises\n\nExplain the differences in dispatch below:\n\n\nlength.integer &lt;- function(x) 10\n\nx1 &lt;- 1:5\nclass(x1)\n\n#&gt; [1] \"integer\"\n\ns3_dispatch(length(x1))\n\n#&gt;  * length.integer\n#&gt;    length.numeric\n#&gt;    length.default\n#&gt; =&gt; length (internal)\n\nx2 &lt;- structure(x1, class = \"integer\")\nclass(x2)\n\n#&gt; [1] \"integer\"\n\ns3_dispatch(length(x2))\n\n#&gt; =&gt; length.integer\n#&gt;    length.default\n#&gt;  * length (internal)\n\n\nAnswer: x1 dispatches using implicit class, which is c(\"integer\", \"numeric\"). x2 has an explicit class, so it is dispatched to length.integer.\n\ns3_class(x1)\n\n#&gt; [1] \"integer\" \"numeric\"\n\ns3_class(x2)\n\n#&gt; [1] \"integer\"\n\n\nAR Solutions: class() returns integer in both cases. However, while the class of x1 is created implicitly and inherits from the numeric class, the class of x2 is set explicitly. This is important because length() is an internal generic and internal generics only dispatch to methods when the class attribute has been set, i.e. internal generics do not use implicit classes.\nAn object has no explicit class if attr(x, \"class\") returns NULL:\n\nattr(x1, \"class\")\n\n#&gt; NULL\n\nattr(x2, \"class\")\n\n#&gt; [1] \"integer\"\n\n\nTo see the relevant classes for the S3 dispatch, one can use sloop::s3_class():\n\ns3_class(x1) # implicit\n\n#&gt; [1] \"integer\" \"numeric\"\n\ns3_class(x2) # explicit\n\n#&gt; [1] \"integer\"\n\n\nFor a better understanding of s3_dipatch()’s output we quote from ?s3_dispatch: - =&gt; method exists and is found by UseMethod(). - -&gt; method exists and is used by NextMethod(). - * method exists but is not used. - Nothing (and greyed out in console): method does not exist.\nNote: AR Solutions includes an additional important detail, that “internal generics only dispatch to methods when the class attribute has been set”, which explains why the internal generic is used for x1.\n\n\nWhat classes have a method for the Math group generic in base R? Read the source code. How do the methods work?\n\nAnswer: four base classes have a method for Math: data.frame, Date, difftime, factor, and POSIXt.\n\ns3_methods_generic(\"Math\") |&gt;\n  filter(source == \"base\")\n\n#&gt; # A tibble: 5 × 4\n#&gt;   generic class      visible source\n#&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt; \n#&gt; 1 Math    data.frame TRUE    base  \n#&gt; 2 Math    Date       TRUE    base  \n#&gt; 3 Math    difftime   TRUE    base  \n#&gt; 4 Math    factor     TRUE    base  \n#&gt; 5 Math    POSIXt     TRUE    base\n\n\n\nMath.data.frame\n\n#&gt; function (x, ...) \n#&gt; {\n#&gt;     mode.ok &lt;- vapply(x, function(x) is.numeric(x) || is.logical(x) || \n#&gt;         is.complex(x), NA)\n#&gt;     if (all(mode.ok)) {\n#&gt;         x[] &lt;- lapply(X = x, FUN = .Generic, ...)\n#&gt;         return(x)\n#&gt;     }\n#&gt;     else {\n#&gt;         vnames &lt;- names(x)\n#&gt;         if (is.null(vnames)) \n#&gt;             vnames &lt;- seq_along(x)\n#&gt;         stop(\"non-numeric-alike variable(s) in data frame: \", \n#&gt;             paste(vnames[!mode.ok], collapse = \", \"))\n#&gt;     }\n#&gt; }\n#&gt; &lt;bytecode: 0x107dd72d0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nMath.Date\n\n#&gt; function (x, ...) \n#&gt; stop(gettextf(\"%s not defined for \\\"Date\\\" objects\", .Generic), \n#&gt;     domain = NA)\n#&gt; &lt;bytecode: 0x107ddc430&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nMath.difftime\n\n#&gt; function (x, ...) \n#&gt; {\n#&gt;     switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , \n#&gt;         round = , signif = {\n#&gt;             units &lt;- attr(x, \"units\")\n#&gt;             .difftime(NextMethod(), units)\n#&gt;         }, stop(gettextf(\"'%s' not defined for \\\"difftime\\\" objects\", \n#&gt;             .Generic), domain = NA))\n#&gt; }\n#&gt; &lt;bytecode: 0x107ddb9e8&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nMath.factor\n\n#&gt; function (x, ...) \n#&gt; stop(gettextf(\"%s not meaningful for factors\", sQuote(.Generic)))\n#&gt; &lt;bytecode: 0x107de0be8&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nMath.POSIXt\n\n#&gt; function (x, ...) \n#&gt; {\n#&gt;     stop(gettextf(\"'%s' not defined for \\\"POSIXt\\\" objects\", \n#&gt;         .Generic), domain = NA)\n#&gt; }\n#&gt; &lt;bytecode: 0x107de00f8&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\n\nMath.data.frame performs math if all columns (variables) are either numeric, logical or complex, and errors if any are not\nMath.difftime performs only certain math functions: abs, sign, floor, ceiling, trunc, round, and signif, and errors for other functions\nMath.Date, Math.factor, and Math.POSIXt always error\n\nAR Solutions: : The following functions belong to this group (see ?Math):\n\nabs, sign, sqrt, floor, ceiling, trunc, round, signif\nexp, log, expm1, log1p, cos, sin, tan, cospi, sinpi, tanpi, acos, asin, atan, cosh, sinh, tanh, acosh, asinh, atanh\nlgamma, gamma, digamma, trigamma\ncumsum, cumprod, cummax, cummin\n\nThe following classes have a method for this group generic:\n\ns3_methods_generic(\"Math\")\n\n#&gt; # A tibble: 8 × 4\n#&gt;   generic class      visible source             \n#&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 Math    data.frame TRUE    base               \n#&gt; 2 Math    Date       TRUE    base               \n#&gt; 3 Math    difftime   TRUE    base               \n#&gt; 4 Math    factor     TRUE    base               \n#&gt; 5 Math    POSIXt     TRUE    base               \n#&gt; 6 Math    quosure    FALSE   registered S3method\n#&gt; 7 Math    vctrs_sclr FALSE   registered S3method\n#&gt; 8 Math    vctrs_vctr FALSE   registered S3method\n\n\nTo explain the basic idea, we just overwrite the data frame method:\n\nMath.data.frame &lt;- function(x) \"hello\"\n\nNow all functions from the math generic group, will return \"hello\"\n\nabs(mtcars)\n\n#&gt; [1] \"hello\"\n\nexp(mtcars)\n\n#&gt; [1] \"hello\"\n\nlgamma(mtcars)\n\n#&gt; [1] \"hello\"\n\n\nOf course, different functions should perform different calculations. Here .Generic comes into play, which provides us with the calling generic as a string\n\nMath.data.frame &lt;- function(x, ...) {\n  .Generic\n}\nabs(mtcars)\n\n#&gt; [1] \"abs\"\n\nexp(mtcars)\n\n#&gt; [1] \"exp\"\n\nlgamma(mtcars)\n\n#&gt; [1] \"lgamma\"\n\nrm(Math.data.frame)\n\nThe original source code of Math.data.frame() is a good example on how to invoke the string returned by .Generic into a specific method. Math.factor() is a good example of a method, which is simply defined for better error messages.\nNote: I prefer my answer to the AR Solutions answer.\n\n\nMath.difftime() is more complicated than I described. Why?\n\nAnswer: the explanation in the text omits the fact that Math.difftime() first checks that the math function being called.\nAR Solutions: Math.difftime() also excludes cases apart from abs, sign, floor, ceiling, trunc, round and signif and needs to return a fitting error message.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#r6",
    "href": "analysis/advanced-r-3.html#r6",
    "title": "Advanced R (Object-oriented programming)",
    "section": "14 R6",
    "text": "14 R6\n\nrm(list = ls())\n\nThis chapter describes the R6 OOP system. R6 has two special properties:\n\nIt uses the encapsulated OOP paradigm, which means that methods belong to objects, not generics, and you call them like object$method().\nR6 objects are mutable, which means that they are modified in place, and hence have reference semantics.\n\nIf you’ve learned OOP in another programming language, it’s likely that R6 will feel very natural, and you’ll be inclined to prefer it over S3. Resist the temptation to follow the path of least resistance: in most cases R6 will lead you to non-idiomatic R code. We’ll come back to this theme in Section 16.3.\nR6 is very similar to a base OOP system called reference classes, or RC for short. I describe why I teach R6 and not RC in Section 14.5.\n\n14.2.6 Exercises\n\nCreate a bank account R6 class that stores a balance and allows you to deposit and withdraw money. Create a subclass that throws an error if you attempt to go into overdraft. Create another subclass that allows you to go into overdraft, but charges you a fee.\n\nAnswer: Account stores a balance as an integer value of cents, and prints in dollars (to avoid problems with floating point math).\n\nAccount &lt;- R6Class(\"Account\", list(\n  balance = 0L,\n  initialize = function(balance = 0L) {\n    stopifnot(is.integer(balance), length(balance) == 1)\n    self$balance &lt;- balance\n  },\n  print = function(...) {\n    cat(\"Account: \\n\")\n    cat(\"  Balance: $\", format(self$balance / 100, nsmall = 2), \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  deposit = function(value) {\n    stopifnot(is.integer(value), length(value) == 1)\n    self$balance &lt;- self$balance + value\n    invisible(self)\n  },\n  withdraw = function(value) {\n    stopifnot(is.integer(value), length(value) == 1)\n    self$balance &lt;- self$balance - value\n    invisible(self)\n  }\n))\n\nAccountOverdraft &lt;- R6Class(\"AccountOverdraft\",\n  inherit = Account,\n  public = list(\n    withdraw = function(value) {\n      stopifnot(value &lt;= self$balance)\n      super$withdraw(value)\n    }\n  )\n)\n\nAccountOverdraftFee &lt;- R6Class(\"AccountOverdraftFee\",\n  inherit = Account,\n  public = list(\n    withdraw = function(value) {\n      if (value &gt; self$balance) value &lt;- value + 500L\n      super$withdraw(value)\n    }\n  )\n)\n\ntry(Account$new(1.5))\n\n#&gt; Error in initialize(...) : is.integer(balance) is not TRUE\n\na &lt;- Account$new(100L)\na$deposit(100L)\na$withdraw(250L)\na\n\n#&gt; Account: \n#&gt;   Balance: $-0.50\n\na2 &lt;- AccountOverdraft$new(200L)\ntry(a2$withdraw(250L))\n\n#&gt; Error in a2$withdraw(250L) : value &lt;= self$balance is not TRUE\n\na2$withdraw(150L)\na2\n\n#&gt; Account: \n#&gt;   Balance: $0.50\n\na3 &lt;- AccountOverdraftFee$new(200L)\na3$withdraw(250L)\na3\n\n#&gt; Account: \n#&gt;   Balance: $-5.50\n\n\nAR Solutions: BankAccount is a similar, simpler approach:\n\nBankAccount &lt;- R6Class(\n  classname = \"BankAccount\",\n  public = list(\n    balance = 0,\n    deposit = function(dep = 0) {\n      self$balance &lt;- self$balance + dep\n      invisible(self)\n    },\n    withdraw = function(draw) {\n      self$balance &lt;- self$balance - draw\n      invisible(self)\n    }\n  )\n)\n\nBankAccountStrict &lt;- R6Class(\n  classname = \"BankAccountStrict\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(draw = 0) {\n      if (self$balance - draw &lt; 0) {\n        stop(\"Your `withdraw` must be smaller \",\n          \"than your `balance`.\",\n          call. = FALSE\n        )\n      }\n      super$withdraw(draw = draw)\n    }\n  )\n)\n\nBankAccountCharging &lt;- R6Class(\n  classname = \"BankAccountCharging\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(draw = 0) {\n      if (self$balance - draw &lt; 0) {\n        draw &lt;- draw + 1\n      }\n      super$withdraw(draw = draw)\n    }\n  )\n)\n\nNote: my object name, AccountOverdraftFee is misleading, since it is not a subclass of AccountOverdraft - the R Solutions naming convention is clearer.\n\n\nCreate an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with $draw(n), and return all cards to the deck and reshuffle with $reshuffle(). Use the following code to make a vector of cards.\n\n\nsuit &lt;- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue &lt;- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards &lt;- paste0(rep(value, 4), suit)\n\nAnswer: Cards shuffles the deck using sample(). The draw() function prints the cards drawn and moves them into play.\n\nCards &lt;- R6Class(\"Cards\", list(\n  deck = sample(cards, 52),\n  play = NULL,\n  print = function(...) {\n    cat(\"Cards: \\n\")\n    cat(\"  Deck:\", self$deck, \"\\n\", sep = \" \")\n    cat(\"  Play:\", self$play, \"\\n\", sep = \" \")\n    invisible(self)\n  },\n  draw = function(n = 1L) {\n    stopifnot(is.integer(n), length(n) == 1, n &gt; 0, n &lt;= length(self$deck))\n    d &lt;- head(self$deck, n)\n    self$play &lt;- c(self$play, d)\n    self$deck &lt;- tail(self$deck, -n)\n    invisible(self)\n  },\n  reshuffle = function() {\n    self$deck &lt;- sample(cards, 52)\n    self$play &lt;- NULL\n    invisible(self)\n  }\n))\n\nd &lt;- Cards$new()\nd\n\n#&gt; Cards: \n#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play:\n\ntry(d$draw(1.5))\n\n#&gt; Error in d$draw(1.5) : is.integer(n) is not TRUE\n\ntry(d$draw(0L))\n\n#&gt; Error in d$draw(0L) : n &gt; 0 is not TRUE\n\ntry(d$draw(53L))\n\n#&gt; Error in d$draw(53L) : n &lt;= length(self$deck) is not TRUE\n\nd$draw(13L)\nd\n\n#&gt; Cards: \n#&gt;   Deck: 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠\n\nd$draw(13L)\nd\n\n#&gt; Cards: \n#&gt;   Deck: 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠\n\nd$reshuffle()\nd\n\n#&gt; Cards: \n#&gt;   Deck: K♠ Q♠ 9♠ 4♠ 5♣ 7♥ 10♥ 6♠ A♥ K♣ 8♦ 5♠ 6♣ J♠ J♦ 7♦ 2♠ 6♥ 2♦ 2♣ 10♣ A♣ 4♦ A♠ 8♠ J♥ K♥ 4♣ Q♥ 9♣ 9♥ 3♦ 6♦ 3♠ 8♣ 5♦ A♦ Q♦ 7♠ 3♣ 3♥ 4♥ 7♣ 5♥ J♣ 9♦ 2♥ 10♦ Q♣ 8♥ K♦ 10♠ \n#&gt;   Play:\n\n\nAR Solutions: Our new ShuffledDeck class will use sample() and positive integer subsetting to implement the reshuffling and drawing functionality. We also add a check, so you cannot draw more cards than there are left in the deck.\n\nShuffledDeck &lt;- R6Class(\n  classname = \"ShuffledDeck\",\n  public = list(\n    deck = NULL,\n    initialize = function(deck = cards) {\n      self$deck &lt;- sample(deck)\n    },\n    reshuffle = function() {\n      self$deck &lt;- sample(cards)\n      invisible(self)\n    },\n    n = function() {\n      length(self$deck)\n    },\n    draw = function(n = 1) {\n      if (n &gt; self$n()) {\n        stop(\"Only \", self$n(), \" cards remaining.\", call. = FALSE)\n      }\n\n      output &lt;- self$deck[seq_len(n)]\n      self$deck &lt;- self$deck[-seq_len(n)]\n      output\n    }\n  )\n)\n\nNotes: it seems simpler to set deck directly instead of using an initialize function, although sample(cards) is cleaner. self$n() is a useful function, and the choice of removing and returning cards with draw() is probably a better design. I prefer my approach using head() and tail() over R Solutions use of seq_len().\nBug: per 14.4.3 setting fields directly fixes the order when the class is defined. This results in a bug: Cards has the same starting shuffle for each new object, but ShuffledDeck does not:\n\nCards$new()\n\n#&gt; Cards: \n#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play:\n\nCards$new()\n\n#&gt; Cards: \n#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ \n#&gt;   Play:\n\nShuffledDeck$new()$draw(52)\n\n#&gt;  [1] \"K♥\"  \"4♠\"  \"7♥\"  \"9♠\"  \"9♥\"  \"6♥\"  \"Q♦\"  \"4♦\"  \"9♦\"  \"J♦\"  \"A♠\"  \"10♠\"\n#&gt; [13] \"4♥\"  \"K♣\"  \"8♥\"  \"3♠\"  \"8♣\"  \"3♣\"  \"A♦\"  \"6♣\"  \"K♠\"  \"J♠\"  \"3♥\"  \"2♥\" \n#&gt; [25] \"3♦\"  \"5♥\"  \"J♥\"  \"J♣\"  \"2♠\"  \"7♠\"  \"A♥\"  \"5♠\"  \"Q♥\"  \"Q♣\"  \"6♦\"  \"7♦\" \n#&gt; [37] \"10♥\" \"5♣\"  \"5♦\"  \"6♠\"  \"4♣\"  \"2♦\"  \"9♣\"  \"10♣\" \"2♣\"  \"7♣\"  \"K♦\"  \"A♣\" \n#&gt; [49] \"10♦\" \"8♠\"  \"8♦\"  \"Q♠\"\n\nShuffledDeck$new()$draw(52)\n\n#&gt;  [1] \"8♣\"  \"6♠\"  \"3♠\"  \"4♥\"  \"J♥\"  \"Q♣\"  \"J♣\"  \"8♦\"  \"5♦\"  \"K♠\"  \"10♣\" \"K♣\" \n#&gt; [13] \"2♦\"  \"Q♥\"  \"A♦\"  \"9♠\"  \"7♦\"  \"3♥\"  \"7♣\"  \"9♦\"  \"A♥\"  \"J♠\"  \"8♥\"  \"A♣\" \n#&gt; [25] \"8♠\"  \"7♠\"  \"K♥\"  \"5♥\"  \"2♣\"  \"2♥\"  \"5♠\"  \"10♠\" \"3♦\"  \"4♣\"  \"A♠\"  \"Q♠\" \n#&gt; [37] \"9♥\"  \"9♣\"  \"6♥\"  \"10♥\" \"K♦\"  \"7♥\"  \"2♠\"  \"Q♦\"  \"3♣\"  \"10♦\" \"4♠\"  \"6♣\" \n#&gt; [49] \"4♦\"  \"5♣\"  \"6♦\"  \"J♦\"\n\n\n\n\nWhy can’t you model a bank account or a deck of cards with an S3 class?\n\nAnswer: because S3 classes are copied-on-modify, they lack state. R6 classes are stateful since they are modified in-place. Both bank accounts and a deck of cards are stateful objects.\nAR Solutions: Because S3 classes obey R’s usual semantics of copy-on-modify: every time you deposit money into your bank account or draw a card from the deck, you’d get a new copy of the object.\nIt is possible to combine S3 classes with an environment (which is how R6 works), but it is ill-advised to create an object that looks like a regular R object but has reference semantics.\n\n\nCreate an R6 class that allows you to get and set the current time zone. You can access the current time zone with Sys.timezone() and set it with Sys.setenv(TZ = \"newtimezone\"). When setting the time zone, make sure the new time zone is in the list provided by OlsonNames().\n\nAnswer: TimeZone is initialized with the current time zone, stored as tz in the object.\n\norig_tz &lt;- Sys.timezone()\n\nTimeZone &lt;- R6Class(\"TimeZone\", list(\n  tz = Sys.timezone(),\n  get = function() {\n    cat(\"Current time zone: \", self$tz, \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  set = function(tz) {\n    stopifnot(tz %in% OlsonNames())\n    Sys.setenv(TZ = tz)\n    self$tz &lt;- tz\n    cat(\"Set time zone: \", self$tz, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\ntz &lt;- TimeZone$new()\ntz$get()\n\n#&gt; Current time zone: America/Chicago\n\ndate()\n\n#&gt; [1] \"Wed Oct  1 21:51:18 2025\"\n\ntz$set(\"America/New_York\")\n\n#&gt; Set time zone: America/New_York\n\ndate()\n\n#&gt; [1] \"Wed Oct  1 22:51:18 2025\"\n\nSys.setenv(TZ = orig_tz)\n\nBug: like Cards, TimeZone should set tz in initialize().\nAR Solutions: To create an R6 class that allows us to get and set the time zone, we provide the respective functions as public methods to the R6 class.\n\nTimezone &lt;- R6Class(\n  classname = \"Timezone\",\n  public = list(\n    get = function() {\n      Sys.timezone()\n    },\n    set = function(value) {\n      stopifnot(value %in% OlsonNames())\n      old &lt;- self$get()\n      Sys.setenv(TZ = value)\n      invisible(old)\n    }\n  )\n)\n\n(When setting, we return the old value invisibly because this makes it easy to restore the previous value.)\n\n\nCreate an R6 class that manages the current working directory. It should have $get() and $set() methods.\n\nAnswer: similar to TimeZone, WorkingDirectory initializes wd to getwd().\n\norig_wd &lt;- getwd()\n\nWorkingDirectory &lt;- R6Class(\"WorkingDirectory\", list(\n  wd = getwd(),\n  get = function() {\n    cat(\"Current directory: \", self$wd, \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  set = function(dir) {\n    self$wd &lt;- setwd(dir)\n    cat(\"Set directory: \", self$wd, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\nwd &lt;- WorkingDirectory$new()\nwd$get()\n\n#&gt; Current directory: /Users/agamemnon/GitHub/rtraining/analysis\n\nwd$set(\"assets\")\n\n#&gt; Set directory: /Users/agamemnon/GitHub/rtraining/analysis\n\nlist.files()\n\n#&gt; [1] \"extra.css\"       \"recursive-1.png\" \"recursive-2.png\"\n\nsetwd(orig_wd)\n\nAR Solutions: Take a look at the following implementation, which is quite minimalistic:\n\nWorkingDirectory &lt;- R6Class(\n  classname = \"WorkingDirectory\",\n  public = list(\n    get = function() {\n      getwd()\n    },\n    set = function(value) {\n      setwd(value)\n    }\n  )\n)\n\nBug: like Cards, WorkingDirectory should set wd in initialize(). Also, as AR Solutions notes in a comment:\n\nYou should never do get = getwd() etc because in packages, that inlines the function definition at package build time, creating a subtle dependency that will cause bugs that are extremely difficult to track down\n\n\n\nWhy can’t you model the time zone or current working directory with an S3 class?\n\nAnswer: per exercise 3, time zone and current working directory are both stateful.\nAR Solutions: Because S3 classes are not suitable for modelling a state that changes over time. S3 methods should (almost) always return the same result when called with the same inputs.\n\n\nWhat base type are R6 objects built on top of? What attributes do they have?\n\nAnswer: R6n objects are built on environments, and have a class attribute with an S3 hierarchy including the base R6 class, per 14.2.5.\n\ntypeof(tz)\n\n#&gt; [1] \"environment\"\n\nattributes(tz)\n\n#&gt; $class\n#&gt; [1] \"TimeZone\" \"R6\"\n\n\nAR Solutions: R6 objects are built on top of environments. They have a class attribute, which is a character vector containing the class name, the name of any super classes (if existent) and the string \"R6\" as the last element.\n\n\n\n14.3.3 Exercises\n\nCreate a bank account class that prevents you from directly setting the account balance, but you can still withdraw from and deposit to. Throw an error if you attempt to go into overdraft.\n\nAnswer: SecureAccount uses a private internal balance exposed through an active function.\n\nSecureAccount &lt;- R6Class(\"SecureAccount\",\n  private = list(\n    .balance = 0L\n  ),\n  public = list(\n    deposit = function(value) {\n      stopifnot(is.integer(value), length(value) == 1)\n      private$.balance &lt;- private$.balance + value\n      invisible(self)\n    },\n    withdraw = function(value) {\n      stopifnot(is.integer(value), length(value) == 1, value &lt;= private$.balance)\n      private$.balance &lt;- private$.balance - value\n      invisible(self)\n    }\n  ),\n  active = list(\n    balance = function(value) {\n      if (missing(value)) {\n        private$.balance\n      } else {\n        stop(\"`$balance` is read only\", call. = FALSE)\n      }\n    }\n  )\n)\n\nsa &lt;- SecureAccount$new()\nsa$deposit(10L)\nsa$withdraw(5L)\ntry(sa$withdraw(20L))\n\n#&gt; Error in sa$withdraw(20L) : value &lt;= private$.balance is not TRUE\n\ntry(sa$balance &lt;- 100L)\n\n#&gt; Error : `$balance` is read only\n\nsa$balance\n\n#&gt; [1] 5\n\n\nAR Solutions: To fulfill this requirement, we make balance a private field. The user has to use the $deposit() and $withdraw() methods which have access to the balance field.\n\nBankAccountStrict2 &lt;- R6Class(\n  classname = \"BankAccountStrict2\",\n  public = list(\n    deposit = function(dep = 0) {\n      private$balance &lt;- private$balance + dep\n      invisible(self)\n    },\n    withdraw = function(draw = 0) {\n      if (private$balance - draw &lt; 0) {\n        stop(\n          \"Your `withdraw` must be smaller \",\n          \"than your `balance`.\",\n          call. = FALSE\n        )\n      }\n      private$balance &lt;- private$balance - draw\n      invisible(self)\n    }\n  ),\n  private = list(\n    balance = 0\n  )\n)\n\n\n\nCreate a class with a write-only $password field. It should have $check_password(password) method that returns TRUE or FALSE, but there should be no way to view the complete password.\n\nAnswer: Login implements a write-only $password field using an active function. check_password() will error if a password hasn’t been set. In real life, this should be implemented with a secure password hashing function, like bcrypt or scrypt.\n\nLogin &lt;- R6Class(\"Login\",\n  private = list(\n    .password = NULL\n  ),\n  public = list(\n    check_password = function(password) {\n      stopifnot(is.character(password), length(password) == 1)\n      if (is.null(private$.password)) stop(\"Error: password not set\")\n      password == private$.password\n    }\n  ),\n  active = list(\n    password = function(value) {\n      if (missing(value)) {\n        stop(\"`$password` is write only\", call. = FALSE)\n      } else {\n        stopifnot(is.character(value), length(value) == 1)\n        private$.password &lt;- value\n        invisible(self)\n      }\n    }\n  )\n)\n\nl &lt;- Login$new()\ntry(l$check_password(\"Password1\"))\n\n#&gt; Error in l$check_password(\"Password1\") : Error: password not set\n\nl$password &lt;- \"Password1\"\nl$check_password(\"Password1\")\n\n#&gt; [1] TRUE\n\nl$check_password(\"Password2\")\n\n#&gt; [1] FALSE\n\ntry(l$password)\n\n#&gt; Error : `$password` is write only\n\n\nAR Solutions: To protect the password from changes and direct access, the password will be a private field. Further, our Password will get its own print method which hides the password.\n\nPassword &lt;- R6Class(\n  classname = \"Password\",\n  public = list(\n    print = function(...) {\n      cat(\"&lt;Password&gt;: ********\\n\")\n      invisible(self)\n    },\n    set = function(value) {\n      private$password &lt;- value\n    },\n    check = function(password) {\n      identical(password, private$password)\n    }\n  ),\n  private = list(\n    password = NULL\n  )\n)\n\nLet’s create one instance of our new class and confirm that the password is neither accessible nor visible, but still check-able.\n\nmy_pw &lt;- Password$new()\nmy_pw$set(\"snuffles\")\nmy_pw$password\n\n#&gt; NULL\n\nmy_pw\n\n#&gt; &lt;Password&gt;: ********\n\nmy_pw$check(\"snuggles\")\n\n#&gt; [1] FALSE\n\nmy_pw$check(\"snuffles\")\n\n#&gt; [1] TRUE\n\n\nNote: the AR Solutions class properly masks the password when calling print(), but mine does not:\n\nl\n\n#&gt; &lt;Login&gt;\n#&gt;   Public:\n#&gt;     check_password: function (password) \n#&gt;     clone: function (deep = FALSE) \n#&gt;     password: active binding\n#&gt;   Private:\n#&gt;     .password: Password1\n\n\n\n\nExtend the Rando class with another active binding that allows you to access the previous random value. Ensure that active binding is the only way to access the value.\n\nAnswer: the updated Rando class sets a private value when random is run that is accessible only through previous, initially set to NA.\n\nRando &lt;- R6::R6Class(\"Rando\",\n  private = list(\n    .previous = NA\n  ),\n  active = list(\n    random = function(value) {\n      if (missing(value)) {\n        private$.previous &lt;- runif(1)\n        private$.previous\n      } else {\n        stop(\"Can't set `$random`\", call. = FALSE)\n      }\n    },\n    previous = function(value) {\n      if (missing(value)) {\n        private$.previous\n      } else {\n        stop(\"Can't set `$previous`\", call. = FALSE)\n      }\n    }\n  )\n)\nx &lt;- Rando$new()\n\nx$previous\n\n#&gt; [1] NA\n\nx$random\n\n#&gt; [1] 0.9643438\n\nx$previous\n\n#&gt; [1] 0.9643438\n\nx$random\n\n#&gt; [1] 0.1186832\n\nx$previous\n\n#&gt; [1] 0.1186832\n\n\nAR Solutions: To access the previous random value from an instance, we add a private $last_random field to our class, and we modify $random() to write to this field, whenever it is called. To access the $last_random field we provide $previous().\n\nRando &lt;- R6::R6Class(\n  classname = \"Rando\",\n  private = list(\n    last_random = NULL\n  ),\n  active = list(\n    random = function(value) {\n      if (missing(value)) {\n        private$last_random &lt;- runif(1)\n        private$last_random\n      } else {\n        stop(\"Can't set `$random`.\", call. = FALSE)\n      }\n    },\n    previous = function(value) {\n      if (missing(value)) {\n        private$last_random\n      }\n    }\n  )\n)\n\n\n\nCan subclasses access private fields/methods from their parent? Perform an experiment to find out.\n\nAnswer: LoginEvil shows that subclasses can access private fields from their parent.\n\nLoginEvil &lt;- R6Class(\"LoginEvil\",\n  inherit = Login,\n  public = list(\n    steal_password = function() {\n      cat(\"The password is: \", private$.password, \"\\n\", sep = \"\")\n    }\n  )\n)\n\nevil &lt;- LoginEvil$new()\nevil$password &lt;- \"SuperSecretPassword\"\nevil$steal_password()\n\n#&gt; The password is: SuperSecretPassword\n\n\nAR Solutions: To find out if private fields/methods can be accessed from subclasses, we first create a class A with a private field foo and a private method bar(). Afterwards, an instance of a subclass B is created and calls the foobar() methods, which tries to access the foo field and the bar() method from its superclass A.\n\nA &lt;- R6Class(\n  classname = \"A\",\n  private = list(\n    field = \"foo\",\n    method = function() {\n      \"bar\"\n    }\n  )\n)\nB &lt;- R6Class(\n  classname = \"B\",\n  inherit = A,\n  public = list(\n    test = function() {\n      cat(\"Field:  \", super$field, \"\\n\", sep = \"\")\n      cat(\"Method: \", super$method(), \"\\n\", sep = \"\")\n    }\n  )\n)\nB$new()$test()\n\n#&gt; Field:  \n#&gt; Method: bar\n\n\nWe conclude that subclasses can access private methods from their superclasses, but not private fields.\nNote: as I discovered, private fields are not accessible through super$, but are accessible through private$.\n\n\n\n14.4.4 Exercises\n\nCreate a class that allows you to write a line to a specified file. You should open a connection to the file in $initialize(), append a line using cat() in $append_line(), and close the connection in $finalize().\n\nAnswer: WriteFile implemented below.\n\nWriteFile &lt;- R6Class(\"WriteFile\", list(\n  wfile = NULL,\n  initialize = function(filename) {\n    self$wfile &lt;- file(filename, \"a\")\n  },\n  append_line = function(line) {\n    cat(line, file = self$wfile)\n  },\n  finalize = function() {\n    close(self$wfile)\n  }\n))\n\n#&gt; R6Class WriteFile: finalize() method is public, but it should be private as of R6 2.4.0. This code will continue to work, but in a future version of R6, finalize() will be required to be private.\n\ntmp &lt;- tempfile()\nwf &lt;- WriteFile$new(tmp)\nwf$append_line(\"The quick brown fox jumps over the lazy dog.\\n\")\nreadLines(tmp)\n\n#&gt; [1] \"The quick brown fox jumps over the lazy dog.\"\n\n\nAR Solutions: Our FileWriter class will create a connection to a file at initialization. Therefore, we open a connection to a user specified file during the initialisation. Note that we need to set open = \"a\" in file() to open connection for appending text. Otherwise, cat() would only work when applied to files, but not with connections as explicitly asked for in the exercise. Further, we add the append_line() method and a close() statement as finalizer.\n\nFileWriter &lt;- R6::R6Class(\n  classname = \"FileWriter\",\n  public = list(\n    con = NULL,\n    initialize = function(filename) {\n      self$con &lt;- file(filename, open = \"a\")\n    },\n    finalize = function() {\n      close(self$con)\n    },\n    append_line = function(x) {\n      cat(x, \"\\n\", sep = \"\", file = self$con)\n    }\n  )\n)\n\n#&gt; R6Class FileWriter: finalize() method is public, but it should be private as of R6 2.4.0. This code will continue to work, but in a future version of R6, finalize() will be required to be private.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#s4",
    "href": "analysis/advanced-r-3.html#s4",
    "title": "Advanced R (Object-oriented programming)",
    "section": "15 S4",
    "text": "15 S4\n\nrm(list = ls())\n\nS4 provides a formal approach to functional OOP. The underlying ideas are similar to S3 (the topic of Chapter 13), but implementation is much stricter and makes use of specialised functions for creating classes (setClass()), generics (setGeneric()), and methods (setMethod()). Additionally, S4 provides both multiple inheritance (i.e. a class can have multiple parents) and multiple dispatch (i.e. method dispatch can use the class of multiple arguments).\nAn important new component of S4 is the slot, a named component of the object that is accessed using the specialised subsetting operator @ (pronounced at). The set of slots, and their classes, forms an important part of the definition of an S4 class.\n\n15.2.1 Exercises\n\nlubridate::period() returns an S4 class. What slots does it have? What class is each slot? What accessors does it provide?\n\nAnswer: the S4 class, Period, has 6 slots: .Data, year, month, day, hour, and minute, all numeric. I couldn’t figure out how to get the accessors.\n\np &lt;- lubridate::period()\nis(p)\n\n#&gt; [1] \"Period\"   \"Timespan\" \"numeric\"  \"vector\"\n\nvapply(slotNames(p), function(x) class(slot(p, x)), character(1))\n\n#&gt;     .Data      year     month       day      hour    minute \n#&gt; \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\"\n\n\nAR Solutions: Objects of the S4 Period class have six slots named year, month, day, hour, minute, and .Data (which contains the number of seconds). All slots are of type double. Most fields can be retrieved by an identically named accessor (e.g. lubridate::year() will return the field), use second() to get the .Data slot.\nAs a short example, we create a period of 1 second, 2 minutes, 3 hours, 4 days and 5 weeks.\n\nexample_12345 &lt;- lubridate::period(\n  c(1, 2, 3, 4, 5),\n  c(\"second\", \"minute\", \"hour\", \"day\", \"week\")\n)\n\nThis should add up to a period of 39 days, 3 hours, 2 minutes and 1 second.\n\nexample_12345\n\n#&gt; [1] \"39d 3H 2M 1S\"\n\n\nWhen we inspect example_12345, we see the fields and infer that the seconds are stored in the .Data field.\n\nstr(example_12345)\n\n#&gt; Formal class 'Period' [package \"lubridate\"] with 6 slots\n#&gt;   ..@ .Data : num 1\n#&gt;   ..@ year  : num 0\n#&gt;   ..@ month : num 0\n#&gt;   ..@ day   : num 39\n#&gt;   ..@ hour  : num 3\n#&gt;   ..@ minute: num 2\n\n\nNotes: it is easier to just use getClass to enumerate slots and slot classes:\n\ngetClass(is(lubridate::period()))\n\n#&gt; Class \"Period\" [package \"lubridate\"]\n#&gt; \n#&gt; Slots:\n#&gt;                                                       \n#&gt; Name:    .Data    year   month     day    hour  minute\n#&gt; Class: numeric numeric numeric numeric numeric numeric\n#&gt; \n#&gt; Extends: \n#&gt; Class \"Timespan\", directly\n#&gt; Class \"numeric\", from data part\n#&gt; Class \"vector\", by class \"numeric\", distance 2\n\n\nMethods defined for a particular class can be listed using showMethods(), and S4 methods can be listed using .S4methods():\n\n.S4methods(\"Period\")\n\n#&gt; no methods found\n\n\nPeriod has no S4 methods, only regular functions.\n\n\nWhat other ways can you find help for a method? Read ?\"?\" and summarise the details.\n\nAnswer: there are three ways to get help for a method:\n\n?function provides the function documentation\nmethods?function provides the overall documentation methods for the function\nmethods?function(signature) provides the documentation for a specific method\n\nAR Solutions: Besides adding ? in front of a function call (i.e. ?method()), we may find:\n\ngeneral documentation for a generic via ?genericName\ngeneral documentation for the methods of a generic via methods?genericName\ndocumentation for a specific method via ClassName?methodName.\n\n\n\n\n15.3.6 Exercises\n\nExtend the Person class with fields to match utils::person(). Think about what slots you will need, what class each slot should have, and what you’ll need to check in your validity method.\n\nAnswer: the Person class uses the fields from utils::person(), excluding deprecated fields. Per the docs, family must be a string (length 1), others can be vectors (but this is not enforced).\n\nsetClass(\"Person\",\n  slots = c(\n    given = \"character\",\n    family = \"character\",\n    email = \"character\",\n    role = \"character\",\n    comment = \"character\"\n  ),\n  prototype = list(\n    given = NA_character_,\n    family = NA_character_,\n    email = NA_character_,\n    role = NA_character_,\n    comment = NA_character_\n  )\n)\n\nsetValidity(\"Person\", function(object) {\n  # regex from https://www.nicebread.de/validating-email-adresses-in-r/\n  regex &lt;- \"\\\\&lt;[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\&gt;\"\n\n  if (length(object@family) &gt; 1) {\n    \"@family must be a string (length 1)\"\n  } else if (!is.na(object@email) & !grepl(regex, object@email, ignore.case = TRUE)) {\n    \"invalid @email\"\n  } else {\n    TRUE\n  }\n}) |&gt;\n  invisible()\n\nPerson &lt;- function(given = NA_character_, family = NA_character_,\n                   email = NA_character_, role = NA_character_, comment = NA_character_) {\n  given &lt;- as.character(given)\n  family &lt;- as.character(family)\n  email &lt;- as.character(email)\n  role &lt;- as.character(role)\n  comment &lt;- as.character(comment)\n\n  new(\"Person\", given = given, family = family, email = email, role = role, comment = comment)\n}\n\nPerson(\"John\", \"Benninghoff\", email = \"john@example.com\", comment = 51)\n\n#&gt; An object of class \"Person\"\n#&gt; Slot \"given\":\n#&gt; [1] \"John\"\n#&gt; \n#&gt; Slot \"family\":\n#&gt; [1] \"Benninghoff\"\n#&gt; \n#&gt; Slot \"email\":\n#&gt; [1] \"john@example.com\"\n#&gt; \n#&gt; Slot \"role\":\n#&gt; [1] NA\n#&gt; \n#&gt; Slot \"comment\":\n#&gt; [1] \"51\"\n\ntry(Person(\"John\", c(\"Three\", \"Last\", \"Names\")))\n\n#&gt; Error in validObject(.Object) : \n#&gt;   invalid class \"Person\" object: @family must be a string (length 1)\n\ntry(Person(\"John\", email = \"invalid@local\"))\n\n#&gt; Error in validObject(.Object) : \n#&gt;   invalid class \"Person\" object: invalid @email\n\n\nAR Solutions: The Person class from Advanced R contains the slots name and age. The person class from the {utils} package contains the slots given (vector of given names), family, role, email and comment (see ?utils::person).\nAll slots from utils::person() besides role must be of type character and length 1. The entries in the role slot must match one of the following abbreviations “aut”, “com”, “cph”, “cre”, “ctb”, “ctr”, “dtc”, “fnd”, “rev”, “ths”, “trl”. Therefore, role might be of different length than the other slots and we’ll add a corresponding constraint within the validator.\n\n# Definition of the Person class\nsetClass(\"Person\",\n  slots = c(\n    age = \"numeric\",\n    given = \"character\",\n    family = \"character\",\n    role = \"character\",\n    email = \"character\",\n    comment = \"character\"\n  ),\n  prototype = list(\n    age = NA_real_,\n    given = NA_character_,\n    family = NA_character_,\n    role = NA_character_,\n    email = NA_character_,\n    comment = NA_character_\n  )\n)\n# Helper to create instances of the Person class\nPerson &lt;- function(given, family,\n                   age = NA_real_,\n                   role = NA_character_,\n                   email = NA_character_,\n                   comment = NA_character_) {\n  age &lt;- as.double(age)\n  new(\"Person\",\n    age = age,\n    given = given,\n    family = family,\n    role = role,\n    email = email,\n    comment = comment\n  )\n}\n# Validator to ensure that each slot is of length one\nsetValidity(\"Person\", function(object) { # nolint: cyclocomp_linter.\n  invalids &lt;- character(0)\n  if (length(object@age) != 1 ||\n    length(object@given) != 1 ||\n    length(object@family) != 1 ||\n    length(object@email) != 1 ||\n    length(object@comment) != 1) {\n    invalids &lt;- paste0(\n      \"@name, @age, @given, @family, @email, \",\n      \"@comment must be of length 1\"\n    )\n  }\n\n  known_roles &lt;- c(\n    NA_character_, \"aut\", \"com\", \"cph\", \"cre\", \"ctb\",\n    \"ctr\", \"dtc\", \"fnd\", \"rev\", \"ths\", \"trl\"\n  )\n\n  if (!all(object@role %in% known_roles)) {\n    paste(\n      \"@role(s) must be one of\",\n      paste(known_roles, collapse = \", \") # nolint: paste_linter.\n    )\n  }\n\n  if (length(invalids)) {\n    return(invalids)\n  }\n  TRUE\n}) |&gt;\n  invisible()\n\nNotes: while I missed including age, our implementations are similar except for validations.\n\n\nWhat happens if you define a new S4 class that doesn’t have any slots? (Hint: read about virtual classes in ?setClass.)\n\nAnswer: defining a new class with no slots makes it a virtual class, which can’t be used to create new objects, but can be used to define a class union.\n\nsetClass(\"Virtual\")\ntry(new(\"Virtual\"))\n\n#&gt; Error in new(\"Virtual\") : \n#&gt;   trying to generate an object from a virtual class (\"Virtual\")\n\nsetClassUnion(\"Virtual\", \"Person\")\ngetClass(\"Virtual\")\n\n#&gt; Extended class definition ( \"ClassUnionRepresentation\" )\n#&gt; Virtual Class \"Virtual\" [in \".GlobalEnv\"]\n#&gt; \n#&gt; No Slots, prototype of class \"Person\"\n#&gt; \n#&gt; Known Subclasses: \"Person\"\n\n\nAR Solutions: It depends on the other arguments. If we inherit from another class, we get the same slots. But something interesting happens if we don’t inherit from an existing class. We get a virtual class. A virtual class can’t be instantiated:\n\nsetClass(\"Human\")\ntry(new(\"Human\"))\n\n#&gt; Error in new(\"Human\") : \n#&gt;   trying to generate an object from a virtual class (\"Human\")\n\n\nBut can be inherited from:\n\nsetClass(\"Programmer\", contains = \"Human\")\n\n\n\nImagine you were going to reimplement factors, dates, and data frames in S4. Sketch out the setClass() calls that you would use to define the classes. Think about appropriate slots and prototype.\n\nAnswer: sketch below. Default values would be set in initialize().\n\nsetClass(\"Factor\",\n  slots = list(\n    x = \"character\",\n    levels = \"character\",\n    labels = \"character\",\n    exclude = \"character\",\n    ordered = \"logical\",\n    nmax = \"integer\"\n  ),\n  prototype = list(\n    x = character(0),\n    levels = character(0),\n    labels = character(0),\n    exclude = NA_character_,\n    ordered = FALSE,\n    nmax = NA_integer_\n  )\n)\n\nsetClass(\"S4Date\",\n  slots = list(\n    days = \"integer\"\n  ),\n  prototype = list(\n    days = 0L\n  )\n)\n\nsetClass(\"DataFrame\",\n  slots = list(\n    data = \"matrix\",\n    col_names = \"character\",\n    row_names = \"character\"\n  ),\n  prototype = list(\n    data = matrix(nrow = 0, ncol = 0),\n    col_names = NULL,\n    row_names = NULL\n  )\n)\n\nAR Solutions: For all these classes we need one slot for the data and one slot per attribute. Keep in mind, that inheritance matters for ordered factors and dates. For data frames, special checks like equal lengths of the underlying list’s elements should be done within a validator.\nFor simplicity we don’t introduce an explicit subclass for ordered factors. Instead, we introduce ordered as a slot.\n\nsetClass(\"Factor\",\n  slots = c(\n    data = \"integer\",\n    levels = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = list(\n    data = integer(),\n    levels = character(),\n    ordered = FALSE\n  )\n)\nnew(\"Factor\", data = c(1L, 2L), levels = letters[1:3])\n\n#&gt; An object of class \"Factor\"\n#&gt; Slot \"data\":\n#&gt; [1] 1 2\n#&gt; \n#&gt; Slot \"levels\":\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; Slot \"ordered\":\n#&gt; [1] FALSE\n\n\nThe Date2 class stores its dates as integers, similarly to base R which uses doubles. Dates don’t have any other attributes.\n\nsetClass(\"Date2\",\n  slots = list(\n    data = \"integer\"\n  ),\n  prototype = list(\n    data = integer()\n  )\n)\n\nnew(\"Date2\", data = 1L)\n\n#&gt; An object of class \"Date2\"\n#&gt; Slot \"data\":\n#&gt; [1] 1\n\n\nOur DataFrame class consists of a list and a slot for row.names. Most of the logic (e.g. checking that all elements of the list are a vector, and that they all have the same length) would need to be part of a validator.\n\nsetClass(\"DataFrame\",\n  slots = c(\n    data = \"list\",\n    row.names = \"character\"\n  ),\n  prototype = list(\n    data = list(),\n    row.names = character(0)\n  )\n)\n\nnew(\"DataFrame\", data = list(a = 1, b = 2))\n\n#&gt; An object of class \"DataFrame\"\n#&gt; Slot \"data\":\n#&gt; $a\n#&gt; [1] 1\n#&gt; \n#&gt; $b\n#&gt; [1] 2\n#&gt; \n#&gt; \n#&gt; Slot \"row.names\":\n#&gt; character(0)\n\n\nNotes:\n\nA key insight from AR Solutions is that the objects need one slot for data and one for each attribute\nMy implementation of Factor is wrong, where the AR Solutions answer is clearly right\nThe implementations of the new Date object are similar; the prototype for AR Solutions is better\nThe AR Solutions DataFrame omits column names (names), where mine does not; using a list for the data in DataFrame is a better choice, but harder to implement\n\n\nattributes(data.frame())\n\n#&gt; $names\n#&gt; character(0)\n#&gt; \n#&gt; $row.names\n#&gt; integer(0)\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n\n\n\n\n\n15.4.5 Exercises\n\nAdd age() accessors for the Person class.\n\nAnswer: the code below adds age accessors to Advanced R Person.\n\nsetClass(\"Person\",\n  slots = c(\n    name = \"character\",\n    age = \"numeric\"\n  ),\n  prototype = list(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\njohn &lt;- new(\"Person\", name = \"John Smith\")\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\")) |&gt;\n  invisible()\nsetMethod(\"age\", \"Person\", function(x) x@age)\n\nage(john)\n\n#&gt; [1] NA\n\nsetGeneric(\"age&lt;-\", function(x, value) standardGeneric(\"age&lt;-\")) |&gt;\n  invisible()\nsetMethod(\"age&lt;-\", \"Person\", function(x, value) {\n  x@age &lt;- value\n  validObject(x)\n  x\n})\n\nage(john) &lt;- 51\nage(john)\n\n#&gt; [1] 51\n\n\nAR Solutions: We implement the accessors via an age() generic, with a method for the Person class and a corresponding replacement function age&lt;-:\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\n\n#&gt; [1] \"age\"\n\nsetMethod(\"age\", \"Person\", function(x) x@age)\n\nsetGeneric(\"age&lt;-\", function(x, value) standardGeneric(\"age&lt;-\"))\n\n#&gt; [1] \"age&lt;-\"\n\nsetMethod(\"age&lt;-\", \"Person\", function(x, value) {\n  x@age &lt;- value\n  validObject(x)\n  x\n})\n\n\n\nIn the definition of the generic, why is it necessary to repeat the name of the generic twice?\n\nAnswer: according to the R docs, setGeneric(name) specifies an existing function. When creating a new generic, the form setGeneric(name, def) is used, where def is standardGeneric(name).\nAR Solutions: Within setGeneric() the name (1st argument) is needed as the name of the generic. Then, the name also explicitly incorporates method dispatch via standardGeneric() within the generic’s body (def parameter of setGeneric()). This behaviour is similar to UseMethod() in S3.\n\n\nWhy does the show() method defined in Section 15.4.3 use is(object)[[1]]? (Hint: try printing the employee subclass.)\n\nAnswer: is(object) returns a vector for a subclass, with the current class first.\n\nsetClass(\"Employee\",\n  contains = \"Person\",\n  slots = c(\n    boss = \"Person\"\n  ),\n  prototype = list(\n    boss = new(\"Person\")\n  )\n)\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(is(object)[[1]], \"\\n\",\n    \"  Name: \", object@name, \"\\n\",\n    \"  Age:  \", object@age, \"\\n\",\n    sep = \"\"\n  )\n})\n\njohn\n\n#&gt; Person\n#&gt;   Name: John Smith\n#&gt;   Age:  51\n\njane &lt;- new(\"Employee\", name = \"Jane Doe\")\nis(jane)\n\n#&gt; [1] \"Employee\" \"Person\"\n\njane\n\n#&gt; Employee\n#&gt;   Name: Jane Doe\n#&gt;   Age:  NA\n\n\nAR Solutions: is(object) returns the class of the object. is(object) also contains the superclass, for subclasses like Employee. In order to always return the most specific class (the subclass), show() returns the first element of is(object).\n\n\nWhat happens if you define a method with different argument names to the generic?\n\nAnswer: this should cause method dispatch to fail, but I don’t know of a way to test.\nAR Solutions: It depends. We first create the object hadley of class Person:\n\n.Person &lt;- setClass(\n  \"Person\",\n  slots = c(name = \"character\", age = \"numeric\")\n)\nhadley &lt;- .Person(name = \"Hadley\")\nhadley\n\n#&gt; Person\n#&gt;   Name: Hadley\n#&gt;   Age:\n\n\nNow let’s see which arguments can be supplied to the show() generic.\n\nformals(\"show\")\n\n#&gt; $object\n\n\nUsually, we would use this argument when defining a new method.\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(object@name, \"creates hard exercises\")\n})\n\nhadley\n\n#&gt; Hadley creates hard exercises\n\n\nWhen we supply another name as a first element of our method (e.g. x instead of object), this element will be matched to the correct object argument and we receive a warning. Our method will work, though:\n\nsetMethod(\"show\", \"Person\", function(x) {\n  cat(x@name, \"creates hard exercises\")\n})\n\n#&gt; Warning: For function 'show', signature 'Person': argument in method definition\n#&gt; changed from (x) to (object)\n\nhadley\n\n#&gt; Hadley creates hard exercises\n\n\nIf we add more arguments to our method than our generic can handle, we will get an error.\n\ntry(\n  setMethod(\"show\", \"Person\", function(x, y) {\n    cat(x@name, \"is\", x@age, \"years old\")\n  })\n)\n\n#&gt; Error in conformMethod(signature, mnames, fnames, f, fdef, definition) : \n#&gt;   in method for 'show' with signature 'object=\"Person\"': formal arguments (object = \"Person\") omitted in the method definition cannot be in the signature\n\n\nIf we do this with arguments added to the correctly written object argument, we will receive an informative error message. It states that we could add other argument names for generics, which can take the ... argument.\n\ntry(\n  setMethod(\"show\", \"Person\", function(object, y) {\n    cat(object@name, \"is\", object@age, \"years old\")\n  })\n)\n\n#&gt; Error in rematchDefinition(definition, fdef, mnames, fnames, signature) : \n#&gt;   methods can add arguments to the generic 'show' only if '...' is an argument to the generic\n\n\n\n\n\n15.5.5 Exercises\n\nDraw the method graph for f(sweat_smile, kissing_cat)\n\nAnswer: skipped.\nAR Solutions: Look at the graph and repeat after me: “I will keep my class structure simple and use multiple inheritance sparingly”.\n\n\nDraw the method graph for f(smiley, wink, kissing_smiling_eyes)\n\nAnswer: skipped.\nAR Solutions: We see that the method graph below looks simpler than the one above. Relatively speaking, multiple dispatch seems to introduce less complexity than multiple inheritance. Use it with care, though!\n\n\nTake the last example which shows multiple dispatch over two classes that use multiple inheritance. What happens if you define a method for all terminal classes? Why does method dispatch not save us much work here?\n\nAnswer: since all terminal nodes are equidistant from the classes, the method is ambiguous. This is true at the first level as well. The only way to avoid ambiguity is to avoid method dispatch altogether and define a method at the root node.\nAR Solutions: We will introduce ambiguity, since one class has distance 2 to all terminal nodes and the other four have distance 1 to two terminal nodes each. To resolve this ambiguity we have to define five more methods, one per class combination.\n\n\n\n15.6.3 Exercises\n\nWhat would a full setOldClass() definition look like for an ordered factor (i.e. add slots and prototype the definition above)?\n\nAnswer: building on the AR Solutions example and the factor example in 15.6.1, the following S4 object behaves like the ordered() version:\n\nsetClass(\"Ordered\",\n  contains = \"integer\",\n  slots = c(\n    levels = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = structure(\n    integer(),\n    levels = character(),\n    ordered = TRUE\n  )\n)\nsetOldClass(\"ordered\", S4Class = \"Ordered\")\n\no &lt;- new(\"Ordered\", 1:4, levels = letters[1:4])\no\n\n#&gt; An object of class \"Ordered\"\n#&gt; [1] 1 2 3 4\n#&gt; Slot \"levels\":\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n#&gt; \n#&gt; Slot \"ordered\":\n#&gt; [1] TRUE\n\nstr(ordered(c(\"a\", \"b\", \"c\", \"d\")))\n\n#&gt;  Ord.factor w/ 4 levels \"a\"&lt;\"b\"&lt;\"c\"&lt;\"d\": 1 2 3 4\n\n\nAR Solutions: The purpose of setOldClass() lies in registering an S3 class as a “formally defined class”, so that it can be used within the S4 object-oriented programming system. When using it, we may provide the argument S4Class, which will inherit the slots and their default values (prototype) to the registered class.\nLet’s build an S4 OrderedFactor on top of the S3 factor in such a way.\n\nsetOldClass(\"factor\") # use build-in definition for brevity\nOrderedFactor &lt;- setClass(\n  \"OrderedFactor\",\n  contains = \"factor\", # inherit from registered S3 class\n  slots = c(\n    levels = \"character\",\n    ordered = \"logical\" # add logical order slot\n  ),\n  prototype = structure(\n    integer(),\n    levels = character(),\n    ordered = logical() # add default value\n  )\n)\n\nWe can now register the (S3) ordered-class, while providing an “S4 template”. We can also use the S4-class to create new object directly.\n\nsetOldClass(\"ordered\", S4Class = \"OrderedFactor\")\nx &lt;- OrderedFactor(\n  c(1L, 2L, 2L),\n  levels = c(\"a\", \"b\", \"c\"),\n  ordered = TRUE\n)\nstr(x)\n\n#&gt; Formal class 'OrderedFactor' [package \".GlobalEnv\"] with 4 slots\n#&gt;   ..@ .Data   : int [1:3] 1 2 2\n#&gt;   ..@ levels  : chr [1:3] \"a\" \"b\" \"c\"\n#&gt;   ..@ ordered : logi TRUE\n#&gt;   ..@ .S3Class: chr \"factor\"\n\n\nNotes: while my class Ordered looks similar to the AR Solutions version, it does not include the S3 class:\n\nstr(o)\n\n#&gt; Formal class 'Ordered' [package \".GlobalEnv\"] with 3 slots\n#&gt;   ..@ .Data  : int [1:4] 1 2 3 4\n#&gt;   ..@ levels : chr [1:4] \"a\" \"b\" \"c\" \"d\"\n#&gt;   ..@ ordered: logi TRUE\n\n\n\n\nDefine a length method for the Person class.\n\nAnswer: since Person is a vector class, its length is the length() of any of its fields (we use Person2 here due to prevent conflicts with the already defined Person class):\n\nsetClass(\"Person2\",\n  slots = c(\n    name = \"character\",\n    age = \"numeric\"\n  ),\n  prototype = list(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\nsetGeneric(\"length\") |&gt;\n  invisible()\nsetMethod(\"length\", \"Person2\", function(x) length(x@name))\n\npeople &lt;- new(\"Person2\", name = c(\"John Smith\", \"Jane Doe\"), age = c(NA_real_, NA_real_))\npeople\n\n#&gt; An object of class \"Person2\"\n#&gt; Slot \"name\":\n#&gt; [1] \"John Smith\" \"Jane Doe\"  \n#&gt; \n#&gt; Slot \"age\":\n#&gt; [1] NA NA\n\nlength(people)\n\n#&gt; [1] 2\n\n\nAR Solutions: We keep things simple and will just return \"180cm\" when the length() method is called on a Person object. The method can be defined either as an S3 or S4 method.\n\nlength.Person &lt;- function(x) \"180cm\" # S3\nsetMethod(\"length\", \"Person\", function(x) \"180cm\") # S4",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-3.html#trade-offs",
    "href": "analysis/advanced-r-3.html#trade-offs",
    "title": "Advanced R (Object-oriented programming)",
    "section": "16 Trade-offs",
    "text": "16 Trade-offs\nYou now know about the three most important OOP toolkits available in R. Now that you understand their basic operation and the principles that underlie them, we can start to compare and contrast the systems in order to understand their strengths and weaknesses. This will help you pick the system that is most likely to solve new problems.\nOverall, when picking an OO system, I recommend that you default to S3. S3 is simple, and widely used throughout base R and CRAN. While it’s far from perfect, its idiosyncrasies are well understood and there are known approaches to overcome most shortcomings. If you have an existing background in programming you are likely to lean towards R6, because it will feel familiar. I think you should resist this tendency for two reasons. Firstly, if you use R6 it’s very easy to create a non-idiomatic API that will feel very odd to native R users, and will have surprising pain points because of the reference semantics. Secondly, if you stick to R6, you’ll lose out on learning a new way of thinking about OOP that gives you a new set of tools for solving problems.",
    "crumbs": [
      "Changelog",
      "Advanced R (Object-oriented programming)"
    ]
  },
  {
    "objectID": "analysis/FaultTree.html",
    "href": "analysis/FaultTree.html",
    "title": "FaultTree.widget Test",
    "section": "",
    "text": "Notebook for testing FaultTree.widget rendering fixes.",
    "crumbs": [
      "Changelog",
      "FaultTree.widget Test"
    ]
  },
  {
    "objectID": "analysis/FaultTree.html#example",
    "href": "analysis/FaultTree.html#example",
    "title": "FaultTree.widget Test",
    "section": "Example",
    "text": "Example\nThe fault tree below is centered in-frame when viewed in RStudio, but is partially off-frame when viewed in a browser, and completely off-frame if the browser window is wide enough. This is true for both html_notebook and html_document.\n\nlibrary(FaultTree)\nlibrary(FaultTree.widget)\n\n# nolint start\ntree1 &lt;- ftree.make(type = \"priority\", reversible_cond = TRUE, name = \"Site power loss\")\ntree1 &lt;- addLogic(tree1, at = 1, type = \"or\", name = \"neither emergency\", name2 = \"generator operable\")\ntree1 &lt;- addLogic(tree1, at = 2, type = \"and\", name = \"Independent failure\", name2 = \"of generators\")\ntree1 &lt;- addLatent(tree1, at = 3, mttf = 5, mttr = 12 / 8760, inspect = 1 / 26, name = \"e-gen set fails\")\ntree1 &lt;- addLatent(tree1, at = 3, mttf = 5, mttr = 12 / 8760, inspect = 1 / 26, name = \"e-gen set fails\")\ntree1 &lt;- addLogic(tree1, at = 2, type = \"inhibit\", name = \"Common cause\", name2 = \"failure of generators\")\ntree1 &lt;- addProbability(tree1, at = 6, prob = .05, name = \"Common cause\", name2 = \"beta factor\")\ntree1 &lt;- addLatent(tree1, at = 6, mttf = 5, mttr = 12 / 8760, inspect = 1 / 26, name = \"e-gen set fails\")\ntree1 &lt;- addDemand(tree1, at = 1, mttf = 1.0, name = \"External power\", name2 = \"interruption\")\n# nolint end\n\ntree1 &lt;- ftree.calc(tree1)\n\nftree2widget(tree1, height = 500, width = 800)\n\n\n\n\n\nCheck rendering without height and width specified:\n\nftree2widget(tree1)",
    "crumbs": [
      "Changelog",
      "FaultTree.widget Test"
    ]
  },
  {
    "objectID": "analysis/FaultTree.html#solution",
    "href": "analysis/FaultTree.html#solution",
    "title": "FaultTree.widget Test",
    "section": "Solution",
    "text": "Solution\nA partial fix is to change the line in inst/htmlwidgets/ftree_widget1.js and inst/htmlwidgets/ftree_widget2.js\nfrom (which sets the position based on the width of the browser window):\nvar width_initial = $(window).width()/2-60;\nto (which sets the position based on the width of the div containing the widget):\nvar width_initial = $(\"div\").width()/2-60;\nThen the fault tree will position itself within view, but not always centered. A complete fix would render the fault tree centered within the widget.\nOther approaches tested:\n// var width_initial = $('div:contains(\"htmlwidget\")').width()/2-60;\n// var width_initial = $(\"div\").filter(function(){ return this.children.length === 0; }).width()/2-60;",
    "crumbs": [
      "Changelog",
      "FaultTree.widget Test"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html",
    "href": "analysis/ggplot2-1.html",
    "title": "ggplot2 (Getting started)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Getting started” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(modelr)\nlibrary(jbplot)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html#introduction",
    "href": "analysis/ggplot2-1.html#introduction",
    "title": "ggplot2 (Getting started)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from ggplot2: Elegant Graphics for Data Analysis and Solutions to ggplot2: Elegant Graphics for Data Analysis, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read the ggplot2 book and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-1.html#first-steps",
    "href": "analysis/ggplot2-1.html#first-steps",
    "title": "ggplot2 (Getting started)",
    "section": "2 First steps",
    "text": "2 First steps\nThe goal of this chapter is to teach you how to produce useful graphics with ggplot2 as quickly as possible. You’ll learn the basics of ggplot() along with some useful “recipes” to make the most important plots. ggplot() allows you to make complex plots with just a few lines of code because it’s based on a rich underlying theory, the grammar of graphics. Here we’ll skip the theory and focus on the practice, and in later chapters you’ll learn how to use the full expressive power of the grammar.\n\n2.2.1 Exercises\n\nList five functions that you could use to get more information about the mpg dataset.\n\nAnswer:\nFive common base R functions I use to interrogate dataframes are:\n\nsummary()\nhist()\nplot()\nlm()\nView()\n\nGG Solutions:\n\nhelp(mpg): Documentation of dataset\ndim(mpg): Dimensions of dataset\nsummary(mpg): Summary measures of dataset\nstr(mpg): Display of the internal structure of dataset\nglimpse(mpg): dplyr version of str(mpg)\n\n\n\nHow can you find out what other datasets are included with ggplot2?\n\nAnswer: use data(package = \"ggplot2\"), which returns the following:\nData sets in package ‘ggplot2’:\n\ndiamonds                      Prices of over 50,000 round cut diamonds\neconomics                     US economic time series\neconomics_long                US economic time series\nfaithfuld                     2d density estimate of Old Faithful data\nluv_colours                   'colors()' in Luv space\nmidwest                       Midwest demographics\nmpg                           Fuel economy data from 1999 to 2008 for 38 popular models of\n                              cars\nmsleep                        An updated and expanded version of the mammals sleep dataset\npresidential                  Terms of 12 presidents from Eisenhower to Trump\nseals                         Vector field of seal movements\ntxhousing                     Housing sales in TX\nGG Solutions:\ndata(package = \"ggplot2\") loads the available data sets in ggplot2. Alternatively,if you have internet access, go to https://ggplot2.tidyverse.org/reference/index.html#section-data\n\n\nApart from the US, most countries use fuel consumption (fuel consumed over fixed distance) rather than fuel economy (distance travelled with fixed amount of fuel). How could you convert cty and hwy into the European standard of l/100km?\n\nAnswer: to convert miles/gallon to liters/100km, we use the formula:\n\\(\\frac{1}{miles/gallon} \\times \\frac{3.78541}{1.609344 \\div 100} = l/100km\\)\n\nmpg_l100km &lt;- function(x) {\n  (1 / x) * 3.78541 / (1.609344 / 100)\n}\n\nmpg |&gt;\n  mutate(cty = mpg_l100km(cty), hwy = mpg_l100km(hwy))\n\n#&gt; # A tibble: 234 × 11\n#&gt;    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n#&gt;    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt;  1 audi         a4           1.8  1999     4 auto… f      13.1  8.11 p     comp…\n#&gt;  2 audi         a4           1.8  1999     4 manu… f      11.2  8.11 p     comp…\n#&gt;  3 audi         a4           2    2008     4 manu… f      11.8  7.59 p     comp…\n#&gt;  4 audi         a4           2    2008     4 auto… f      11.2  7.84 p     comp…\n#&gt;  5 audi         a4           2.8  1999     6 auto… f      14.7  9.05 p     comp…\n#&gt;  6 audi         a4           2.8  1999     6 manu… f      13.1  9.05 p     comp…\n#&gt;  7 audi         a4           3.1  2008     6 auto… f      13.1  8.71 p     comp…\n#&gt;  8 audi         a4 quattro   1.8  1999     4 manu… 4      13.1  9.05 p     comp…\n#&gt;  9 audi         a4 quattro   1.8  1999     4 auto… 4      14.7  9.41 p     comp…\n#&gt; 10 audi         a4 quattro   2    2008     4 manu… 4      11.8  8.40 p     comp…\n#&gt; # ℹ 224 more rows\n\n\nGG Solutions:\n\nAccording to asknumbers, you divide 235.214583 by the mpg values in cty and hwy to convert them into the European standard of l/100km.\nFunction to convert into European standard (Rademaker, 2016):\n\n\nmpgTol100km &lt;- function(milespergallon) {\n  GalloLiter &lt;- 3.785411784\n  MileKilometer &lt;- 1.609344\n\n  l100km &lt;- (100 * GalloLiter) / (milespergallon * MileKilometer)\n  l100km\n}\n\n\n\nWhich manufacturer has the most models in this dataset? Which model has the most variations? Does your answer change if you remove the redundant specification of drive train (e.g. “pathfinder 4wd”, “a4 quattro”) from the model name?\n\nAnswer: we can generate a dataframe with manufacturers, models, and variations using:\n\nmpg_summary &lt;- mpg |&gt;\n  count(manufacturer, model) |&gt;\n  rename(variations = n)\n\nmpg_summary\n\n#&gt; # A tibble: 38 × 3\n#&gt;    manufacturer model              variations\n#&gt;    &lt;chr&gt;        &lt;chr&gt;                   &lt;int&gt;\n#&gt;  1 audi         a4                          7\n#&gt;  2 audi         a4 quattro                  8\n#&gt;  3 audi         a6 quattro                  3\n#&gt;  4 chevrolet    c1500 suburban 2wd          5\n#&gt;  5 chevrolet    corvette                    5\n#&gt;  6 chevrolet    k1500 tahoe 4wd             4\n#&gt;  7 chevrolet    malibu                      5\n#&gt;  8 dodge        caravan 2wd                11\n#&gt;  9 dodge        dakota pickup 4wd           9\n#&gt; 10 dodge        durango 4wd                 7\n#&gt; # ℹ 28 more rows\n\n\nThe model with the most variations is the Dodge Caravan 2wd.\n\nmpg_summary |&gt;\n  arrange(variations) |&gt;\n  tail(1)\n\n#&gt; # A tibble: 1 × 3\n#&gt;   manufacturer model       variations\n#&gt;   &lt;chr&gt;        &lt;chr&gt;            &lt;int&gt;\n#&gt; 1 dodge        caravan 2wd         11\n\n\nThe manufacturer with the most models is Toyota.\n\nmpg_summary |&gt;\n  count(manufacturer) |&gt;\n  arrange(n) |&gt;\n  tail(1)\n\n#&gt; # A tibble: 1 × 2\n#&gt;   manufacturer     n\n#&gt;   &lt;chr&gt;        &lt;int&gt;\n#&gt; 1 toyota           6\n\n\nIf we first remove the redundant drive train from the summary, we get:\n\nmpg_summary2 &lt;- mpg |&gt;\n  mutate(model = gsub(\" (quattro)|(2wd)|(4wd)|(awd)$\", \"\", model)) |&gt;\n  count(manufacturer, model) |&gt;\n  rename(variations = n)\n\nmpg_summary2\n\n#&gt; # A tibble: 37 × 3\n#&gt;    manufacturer model              variations\n#&gt;    &lt;chr&gt;        &lt;chr&gt;                   &lt;int&gt;\n#&gt;  1 audi         \"a4\"                       15\n#&gt;  2 audi         \"a6\"                        3\n#&gt;  3 chevrolet    \"c1500 suburban \"           5\n#&gt;  4 chevrolet    \"corvette\"                  5\n#&gt;  5 chevrolet    \"k1500 tahoe \"              4\n#&gt;  6 chevrolet    \"malibu\"                    5\n#&gt;  7 dodge        \"caravan \"                 11\n#&gt;  8 dodge        \"dakota pickup \"            9\n#&gt;  9 dodge        \"durango \"                  7\n#&gt; 10 dodge        \"ram 1500 pickup \"         10\n#&gt; # ℹ 27 more rows\n\n\nThe model with the most variations has changed to the Audi A4.\n\nmpg_summary2 |&gt;\n  arrange(variations) |&gt;\n  tail(1)\n\n#&gt; # A tibble: 1 × 3\n#&gt;   manufacturer model variations\n#&gt;   &lt;chr&gt;        &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 audi         a4            15\n\n\nThe manufacturer with the most models is still Toyota.\n\nmpg_summary2 |&gt;\n  count(manufacturer) |&gt;\n  arrange(n) |&gt;\n  tail(1)\n\n#&gt; # A tibble: 1 × 2\n#&gt;   manufacturer     n\n#&gt;   &lt;chr&gt;        &lt;int&gt;\n#&gt; 1 toyota           6\n\n\nGG Solutions:\nNot included here because I believe the answer to question 4 in 2.2 Exercises is incorrect, as it counts variants by manufacturer, not models by manufacturer.\n\n\n\n2.3.1 Exercises\n\nHow would you describe the relationship between cty and hwy? Do you have any concerns about drawing conclusions from that plot?\n\nAnswer: we can explore the relationship using a scatterplot:\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThere is a strong correlation between cty and hwy, which is expected since these are both measures of fuel efficiency of the same car.\nGG Solutions:\n\nThe plot shows a strongly linear relationship, which tells me that cty and hwy are highly correlated variables. The only concern I have is that the points seem to be overlapping.\nThere is not much insight to be gained except that cars which are fuel efficient on a highway are also fuel efficient in cities. This relationship is probably a function of speed (Rademaker, 2016)\n\n\n\nWhat does ggplot(mpg, aes(model, manufacturer)) + geom_point() show? Is it useful? How could you modify the data to make it more informative?\n\nAnswer: this plot shows each model as a point for each manufacturer, which is not particularly useful, although it does allow for a quick count of models by manufacturer. A bar chart showing count of models by manufacturer would be more useful.\n\nggplot(mpg, aes(model, manufacturer)) +\n  geom_point()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThe plot shows the manufacturer of each model. Its not very readable since there are too many models and this clutters up the x-axis with too many ticks! I would just plot 20 or so models so that the graph is more readable. See below:\n\n\nmpg %&gt;%\n  head(25) %&gt;%\n  ggplot(aes(model, manufacturer)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nA possible alternative would be to look total number of observations for each manufacturer-model combination using geom_bar(). (Rademaker, 2016)\n\n\ndf &lt;- mpg %&gt;%\n  transmute(\"man_mod\" = paste(manufacturer, model, sep = \" \")) # nolint: keyword_quote_linter.\nggplot(df, aes(man_mod)) +\n  geom_bar() +\n  coord_flip()\n\n\n\n\n\n\n\n\nNote: I prefer my solution for this exercise.\n\n\nDescribe the data, aesthetic mappings and layers used for each of the following plots. You’ll need to guess a little because you haven’t seen all the datasets and functions yet, but use your common sense! See if you can predict what the plot will look like before running the code.\n\nggplot(mpg, aes(cty, hwy)) + geom_point()\nggplot(diamonds, aes(carat, price)) + geom_point()\nggplot(economics, aes(date, unemploy)) + geom_line()\nggplot(mpg, aes(cty)) + geom_histogram()\n\n\nAnswer:\n\nggplot(mpg, aes(cty, hwy)) + geom_point() - scatterplot of city mpg against highway mpg\nggplot(diamonds, aes(carat, price)) + geom_point() - scatterplot of diamond weight in carats against price\nggplot(economics, aes(date, unemploy)) + geom_line() - a line plot showing the unemployment rate over time\nggplot(mpg, aes(cty)) + geom_histogram() - a histogram of city mpg\n\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(economics, aes(date, unemploy)) +\n  geom_line()\n\n\n\n\n\n\n\nggplot(mpg, aes(cty)) +\n  geom_histogram()\n\n#&gt; `stat_bin()` using `bins = 30`. Pick better value `binwidth`.\n\n\n\n\n\n\n\n\n\nIn general, my guesses are correct (given my existing experience with ggplot), except for the economics plot, which appears to show the number of unemployed people instead of an employment rate.\nGG Solutions: (Rademaker, 2016)\n\nggplot(mpg, aes(cty, hwy)) + geom_point()\n\n\nData: mpg\nAesthetic: highway miles per gallon is mapped to y position and city miles per gallon is mapped to x position.\nLayer: points\n\n\nggplot(diamonds, aes(carat, price)) + geom_point()\n\n\nData: diamonds\nAesthetic: price in US dollars is mapped to y position, weight of the diamond is mapped to x position.\nLayer: points\n\n\nggplot(economics, aes(date, unemploy)) + geom_line()\n\n\nData: economics\nAesthetic: median duration of unemployment, in weeks, is mapped to y position and month of data collection is mapped to x position.\nLayer: line\n\n\n\n\n2.4.1 Exercises\n\nExperiment with the colour, shape and size aesthetics. What happens when you map them to continuous values? What about categorical values? What happens when you use more than one aesthetic in a plot?\n\nAnswer: observations based on the plots below:\n\nUsing a continuous variable with shape generates an error\nUsing a categorical variable with shape for more than 6 values generates a warning\nUsing a continuous variable with size works well\nUsing a categorical variable with size generates a warning\nUsing a continuous variable with color creates a gradient\nUsing a categorical variable with color creates a discrete mapping\nMultiple aesthetics can overload the plot\n\n\n# continuous\nggplot(mpg, aes(displ, hwy, color = cyl)) +\n  geom_point()\n\n\n\n\n\n\n\n# categorical\nggplot(mpg, aes(displ, hwy, color = drv)) +\n  geom_point()\n\n\n\n\n\n\n\n# multiple\nmpg |&gt;\n  mutate(year = as.factor(year)) |&gt;\n  ggplot(aes(displ, hwy, color = drv, size = cyl, shape = year)) +\n  geom_point()\n\n\n\n\n\n\n\n\nGG Solutions offers a similar and less complete answer.\n\n\nWhat happens if you map a continuous variable to shape? Why? What happens if you map trans to shape? Why?\n\nAnswer: As noted above, using a continuous variable with shape generates an error, because plots must have discrete shapes. Using a categorical variable with shape for more than 6 values (like trans) generates a warning, since (as the error notes) many different shapes can be hard to distinguish on a plot.\nGG Solutions presents a similar answer.\n\n\nHow is drive train related to fuel economy? How is drive train related to engine size and class?\n\nAnswer: The plots below show that:\n\nFront wheel drive is correlated with higher fuel economy\nFront wheel drive is correlated with smaller displacement, rear wheel drive is correlated with larger displacement, and four wheel drive is not correlated with displacement\nSome classes only have a single drive train:\n\nTwo seaters only have rear wheel drive\nMinivans only have front wheel drive\nPickups only have four wheel drive\n\n\n\nggplot(mpg, aes(hwy, drv)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(mpg, aes(displ, drv)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(mpg, aes(class, drv)) +\n  geom_point()\n\n\n\n\n\n\n\n\nGG Solutions presents a similar answer using bar charts, and compares engine size and class together in a single plot.\nNote: GG Solutions does not explore the relationship between drive train and class.\n\n\n\n2.5.1 Exercises\n\nWhat happens if you try to facet by a continuous variable like hwy? What about cyl? What’s the key difference?\n\nAnswer: faceting on a continuous variable creates a facet for each unique value in the data frame, which holds true for both hwy and cyl. The key difference is that cyl has fewer unique values, making the plot more readable and useful.\n\nggplot(mpg, aes(displ, cty)) +\n  geom_point() +\n  facet_wrap(vars(hwy))\n\n\n\n\n\n\n\nggplot(mpg, aes(displ, cty)) +\n  geom_point() +\n  facet_wrap(vars(cyl))\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThe key difference is hwy is a continuous variable that has 27 unique values, so you get 27 different subsets. However, cly is a categorical variable and has 4 unique values, so cyl only has 4 different subsets. It is less cluttered when you try to facet.\n(Rademaker, 2016) Faceting by a continuous variable works but becomes hard to read and interpret when the variable that we facet by has too many levels.\n\n\n\nUse faceting to explore the 3-way relationship between fuel economy, engine size, and number of cylinders. How does faceting by number of cylinders change your assessment of the relationship between engine size and fuel economy?\n\nAnswer: engines with fewer cylinders have a stronger relationship between displacement and fuel economy (where larger engines have poorer fuel economy), strongest with 4 cylinders, unclear with 5 (due to limited data), weaker with 6, and no apparent relationship with 8.\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", formula = y ~ x) +\n  facet_wrap(vars(cyl))\n\n\n\n\n\n\n\n\nGG Solutions:\n\nWhen I initially plot engine size and fuel economy, I see an overall decreasing linear relationship. Upon faceting, I see that the decreasing relationship is mostly seen in the 4 cylinder subset. In the other cylinder subsets, we see a flat relationship - as engine displacement increases, fuel economy remains constant.\n\n\n\nRead the documentation for facet_wrap(). What arguments can you use to control how many rows and columns appear in the output?\n\nAnswer: use nrow and ncol.\nGG Solutions:\n\nI can use the arguments nrow, ncol to control how many rows and columns appear in the output.\n\n\n\nWhat does the scales argument to facet_wrap() do? When might you use it?\n\nAnswer: the scales argument determines whether scales are fixed (the default) or free on one or both dimensions. Using scales = \"free\" is helpful when comparing relationships when scale is less important, as shown in this reworked example of exercise 2, which focuses on the smoothed plot:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", formula = y ~ x) +\n  facet_wrap(vars(cyl), scales = \"free\")\n\n\n\n\n\n\n\n\nGG Solutions:\n\nIt allows users to decide whether scales should be fixed. I would use it whenever different subsets of the data are on vastly different scales.\n(Rademaker, 2016) If we want to compare across facets, scales = \"fixed\" is more appropriate. If our focus is on individual patterns within each facet, setting scales = \"free\" might be more appropriate.\n\n\n\n\n2.6.6 Exercises\n\nWhat’s the problem with the plot created by ggplot(mpg, aes(cty, hwy)) + geom_point()? Which of the geoms described above is most effective at remedying the problem?\n\nAnswer: as noted in GG Solutions, the problem is overplotting, which geom_jitter fixes:\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  geom_jitter()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThe problem is overplotting.\n\nSolution 1. Use geom_jitter to add random noise to the data and avoid overplotting.\nSolution 2. (Rademaker, 2016) Set opacity with alpha\n\n\nOne challenge with ggplot(mpg, aes(class, hwy)) + geom_boxplot() is that the ordering of class is alphabetical, which is not terribly useful. How could you change the factor levels to be more informative?\nRather than reordering the factor by hand, you can do it automatically based on the data: ggplot(mpg, aes(reorder(class, hwy), hwy)) + geom_boxplot(). What does reorder() do? Read the documentation.\n\nAnswer: as noted in the exercise, ordering of class by hwy is more informative. reorder() reorders levels based on the second, numeric value, by default using the mean.\n\nggplot(mpg, aes(class, hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nggplot(mpg, aes(reorder(class, hwy), hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nGG Solutions takes a similar approach but instead uses mutate(class = factor(class), class = fct_reorder(class, hwy)).\n\n\nExplore the distribution of the carat variable in the diamonds dataset. What binwidth reveals the most interesting patterns?\n\nAnswer: using trial and error, binwidth = 0.01 reveals that carat weight is skewed towards round numbers (1, 1.25, 1.5, 2, etc.). Using the smaller binwidth = 0.005 doesn’t improve the pattern, and makes it harder to see.\n\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.1)\n\n\n\n\n\n\n\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.01)\n\n\n\n\n\n\n\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.005)\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThis is a subjective answer, but binwidth of 0.2 or 0.3 reveals that the distribution of carat is heavily skewed to the right. This means that most diamonds carats are between 0 and 1.\n\n\n\nExplore the distribution of the price variable in the diamonds data. How does the distribution vary by cut?\n\nAnswer: a boxplot of price by cut shows that better cuts aren’t necessarily more expensive.\nHowever, as noted in my R Training Log:\n\n7.6 Patterns and models covers models and residuals, here showing how to reveal the expected relationship between cut and price:\n\nWe can remove the relationship between carats and price, and redo the boxplot:\n\nggplot(diamonds, aes(cut, price)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n# remove carat weight as a confounding variable\nmod &lt;- lm(log(price) ~ log(carat), data = diamonds)\n\ndiamonds2 &lt;- diamonds |&gt;\n  add_residuals(mod) |&gt;\n  mutate(resid = exp(resid))\n\nggplot(data = diamonds2) +\n  geom_boxplot(mapping = aes(x = cut, y = resid))\n\n\n\n\n\n\n\n\nGG Solutions uses both a boxplot and a frequency polygon to compare cuts, and concludes:\n\n(Rademaker, 2016) Fair quality diamonds are more expensive then others. Possible reason is they are bigger.\n\n\n\nYou now know (at least) three ways to compare the distributions of subgroups: geom_violin(), geom_freqpoly() and the colour aesthetic, or geom_histogram() and faceting. What are the strengths and weaknesses of each approach? What other approaches could you try?\n\nAnswer: Violin plots convey the most information but require an understanding of probability density. Frequency polygons allow for direct comparison on the same plot - in contrast, faceted histograms provide a better visualization of each variable, but make comparison more difficult. Other approaches include comparing boxplots, multiple density plots, or side-by-side histograms - a bar plot showing multiple variables for each bin.\nGG Solutions:\n\nAccording to the book, geom_violin() shows a compact representation of the “density” of the distribution, highlighting the areas where more points are found. Its weakness is that violin plots rely on the calculation of a density estimate, which is hard to interpret.\nAccording to the book, geom_freqploy() bins the data, then counts the number of observations in each bin using lines. One possible weakness is that you have to select the width of the bins yourself by experimentation.\nAccording to the book, geom_histogram() and faceting makes it easier to see the distribution of each group, but makes comparisons between groups a little harder.\n\n\n\nRead the documentation for geom_bar(). What does the weight aesthetic do?\n\nAnswer: for geom_bar(), the weight aesthetic changes the height of the bar from the number of cases in each group to the sum of the weights.\nGG Solutions:\n\nThe weight aesthetic converts the number of cases to a weight and makes the height of the bar proportional to the sum of the weights. See below:\n\n\ng &lt;- ggplot(mpg, aes(class))\n# Number of cars in each class:\ng + geom_bar()\n\n\n\n\n\n\n\n# Total engine displacement of each class\ng + geom_bar(aes(weight = displ))\n\n\n\n\n\n\n\n\n\n\nUsing the techniques already discussed in this chapter, come up with three ways to visualise a 2d categorical distribution. Try them out by visualising the distribution of model and manufacturer, trans and class, and cyl and trans.\n\nAnswer: three ways to visualize categorical distributions:\n\nBar charts\nA scatterplot using alpha\nA scatterplot using size\n\n\nmpg[c(\"manufacturer\", \"model\")] |&gt;\n  unique() |&gt;\n  ggplot(aes(manufacturer)) +\n  geom_bar(color = \"black\", fill = \"white\", width = 0.8) +\n  coord_flip() +\n  scale_x_discrete(limits = rev) +\n  labs(x = \"\", y = \"models\") +\n  theme_quo()\n\n\n\n\n\n\n\nmpg |&gt;\n  ggplot(aes(trans, class)) +\n  geom_point(alpha = 0.1) +\n  scale_y_discrete(limits = rev) +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n\n\n\n\n\n\n\nmpg |&gt;\n  count(trans, cyl) |&gt;\n  ggplot(aes(cyl, trans, size = n)) +\n  geom_point() +\n  scale_y_discrete(limits = rev) +\n  labs(x = \"cylinders\", y = \"\", size = \"count\") +\n  theme_quo(minor.x = FALSE)\n\n\n\n\n\n\n\n\nGG Solutions does not provide an answer.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Getting started)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html",
    "href": "analysis/ggplot2-2.html",
    "title": "ggplot2 (Layers)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Layers” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(babynames)\nlibrary(jbplot)\nlibrary(modelr)\nlibrary(maps) # nolint: unused_import_linter. maps is required by map_data().\nlibrary(sf)\nlibrary(USAboundaries)\nlibrary(USAboundariesData) # nolint: unused_import_linter. Needed by USAboundaries.\nlibrary(ggraph)\nlibrary(tidygraph)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#introduction",
    "href": "analysis/ggplot2-2.html#introduction",
    "title": "ggplot2 (Layers)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from ggplot2: Elegant Graphics for Data Analysis and Solutions to ggplot2: Elegant Graphics for Data Analysis, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read the ggplot2 book and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#individual-geoms",
    "href": "analysis/ggplot2-2.html#individual-geoms",
    "title": "ggplot2 (Layers)",
    "section": "3 Individual geoms",
    "text": "3 Individual geoms\n\n3.1.1 Exercises\n\nWhat geoms would you use to draw each of the following named plots?\n\nScatterplot\nLine chart\nHistogram\nBar chart\nPie chart\n\n\nAnswer:\n\nScatterplot: geom_point()\nLine chart: geom_line()\nHistogram: geom_histogram()\nBar chart: geom_bar()\nPie chart: there is no native geom for a pie chart, but, as the R Graph Gallery demonstrates, it is possible to create a pie chart using geom_bar() and coord_polar()\n\nGG Solutions:\n\nScatterplot: geom_point()\nLine chart: geom_line()\nHistogram: geom_histogram()\nBar chart: geom_bar()\nPie chart: ggplot2 does not have a geom to draw pie charts. One workaround, according to the R Graph Gallery is to build a stacked bar chart with one bar only using the geom_bar() function and then make it circular with coord_polar()\n\n\n\nWhat’s the difference between geom_path() and geom_polygon()? What’s the difference between geom_path() and geom_line()?\n\nAnswer: geom_path() connects observations with a line in the order they appear in the data, geom_line() connects them in order along the x axis, and geom_polygon() connects the start and end points of geom_path() and fills in the plot.\nGG Solutions:\n\ngeom_polygon draws the same graph (lines) as geom_path, but it fills these lines with color\ngeom_line() connects points from left to right, whereas geom_path() connects points in the order they appear in the data\n\n\n\nWhat low-level geoms are used to draw geom_smooth()? What about geom_boxplot() and geom_violin()?\n\nAnswer: reviewing the source code:\ngeom_smooth() uses:\n\ngeom_path() by way of geom_line()\ngeom_area() by way of geom_ribbon()\n\ngeom_boxplot() uses:\n\ngeom_point()\ngeom_path() by way of geom_segment() and geom_crossbar()\ngeom_polygon() by way of geom_crossbar()\n\ngeom_violin() uses:\n\ngeom_path()\ngeom_polygon()\n\nGG Solutions:\n(kangnade)\n\ngeom_point(), geom_path(), and geom_area() are used to draw geom_smooth()\ngeom_rect(), geom_line(), geom_point() are used for geom_boxplot()\ngeom_area() and geom_path() are used for geom_violin()\n\nNote: GG Solutions answers appear to be incorrect guesses.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#collective-geoms",
    "href": "analysis/ggplot2-2.html#collective-geoms",
    "title": "ggplot2 (Layers)",
    "section": "4 Collective geoms",
    "text": "4 Collective geoms\nGeoms can be roughly divided into individual and collective geoms. An individual geom draws a distinct graphical object for each observation (row). For example, the point geom draws one point per row. A collective geom displays multiple observations with one geometric object. This may be a result of a statistical summary, like a boxplot, or may be fundamental to the display of the geom, like a polygon. Lines and paths fall somewhere in between: each line is composed of a set of straight segments, but each segment represents two points. How do we control the assignment of observations to graphical elements? This is the job of the group aesthetic.\n\n4.5 Exercises\nGG Solutions offers no answers for this section.\n\nDraw a boxplot of hwy for each value of cyl, without turning cyl into a factor. What extra aesthetic do you need to set?\n\nAnswer: the group aesthetic is required.\n\nggplot(mpg, aes(cyl, hwy, group = cyl)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\nModify the following plot so that you get one boxplot per integer value of displ.\n\n\nggplot(mpg, aes(displ, cty)) +\n  geom_boxplot()\n\nAnswer: grouping by the floor of displacement works, but is arranged strangely. Mutating displacement first is a better solution:\n\nggplot(mpg, aes(displ, cty, group = floor(displ))) +\n  geom_boxplot()\n\n\n\n\n\n\n\nmpg |&gt;\n  mutate(displ = floor(displ)) |&gt;\n  ggplot(aes(displ, cty, group = displ)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\nWhen illustrating the difference between mapping continuous and discrete colours to a line, the discrete example needed aes(group = 1). Why? What happens if that is omitted? What’s the difference between aes(group = 1) and aes(group = 2)? Why?\n\nAnswer: using the example from the book, omitting the group aesthetic generates an error:\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\nThere is no difference between aes(group = 1) and aes(group = 2), presumably because both methods put all observations into a single group.\n\ndf &lt;- data.frame(x = 1:3, y = 1:3, colour = c(1, 3, 5))\n\nggplot(df, aes(x, y, colour = factor(colour))) +\n  geom_line(aes(group = 1), linewidth = 2) +\n  geom_point(size = 5)\n\n\n\n\n\n\n\nggplot(df, aes(x, y, colour = factor(colour))) +\n  geom_line(aes(group = 2), linewidth = 2) +\n  geom_point(size = 5)\n\n\n\n\n\n\n\n\n\n\nHow many bars are in each of the following plots? (Hint: try adding an outline around each bar with colour = \"white\")\n\n\nggplot(mpg, aes(drv)) +\n  geom_bar()\nggplot(mpg, aes(drv, fill = hwy, group = hwy)) +\n  geom_bar()\n\nmpg2 &lt;- mpg %&gt;%\n  arrange(hwy) %&gt;%\n  mutate(id = seq_along(hwy))\nggplot(mpg2, aes(drv, fill = hwy, group = id)) +\n  geom_bar()\n\nAnswer: in the first plot, there are three bars. In the second, there is one bar for each unique value for hwy in each column. In the third, there is one bar for each observation of hwy.\n\nggplot(mpg, aes(drv)) +\n  geom_bar(color = \"white\")\n\n\n\n\n\n\n\nggplot(mpg, aes(drv, fill = hwy, group = hwy)) +\n  geom_bar(color = \"white\")\n\n\n\n\n\n\n\nmpg |&gt;\n  arrange(hwy) |&gt;\n  mutate(id = seq_along(hwy)) |&gt;\n  ggplot(aes(drv, fill = hwy, group = id)) +\n  geom_bar(color = \"white\")\n\n\n\n\n\n\n\n\n\n\nInstall the babynames package. It contains data about the popularity of babynames in the US. Run the following code and fix the resulting graph. Why does this graph make me unhappy?\n\n\nhadley &lt;- filter(babynames, name == \"Hadley\")\nggplot(hadley, aes(year, n)) +\n  geom_line()\n\nAnswer: the popularity of “Hadley” is sadly declining.\n\nbabynames |&gt;\n  filter(name == \"Hadley\") |&gt;\n  ggplot(aes(year, n, group = sex, color = sex)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\nBonus: a comparison of the popularity of my name (John) and Hadley:\n\nbabynames |&gt;\n  filter(name %in% c(\"Hadley\", \"John\")) |&gt;\n  ggplot(aes(year, prop, color = interaction(name, sex, sep = \", \", lex.order = TRUE))) +\n  geom_line() +\n  scale_y_log10() +\n  scale_color_viridis_d() +\n  labs(x = \"\", y = \"\", color = \"Name, Sex\") +\n  labs(title = \"Relative popularity of the names Hadley and John\") +\n  theme_quo()\n\n\n\n\n\n\n\n\nNote: group is redundant for geom_line() when using color.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#statistical-summaries",
    "href": "analysis/ggplot2-2.html#statistical-summaries",
    "title": "ggplot2 (Layers)",
    "section": "5 Statistical summaries",
    "text": "5 Statistical summaries\n\n5.4.1 Exercises\n\nWhat binwidth tells you the most interesting story about the distribution of carat?\n\nAnswer: as answered in 2.6.6 Exercises:\nAnswer: using trial and error, binwidth = 0.01 reveals that carat weight is skewed towards round numbers (1, 1.25, 1.5, 2, etc.). Using the smaller binwidth = 0.005 doesn’t improve the pattern, and makes it harder to see.\n\nggplot(diamonds, aes(carat)) +\n  geom_histogram(binwidth = 0.01)\n\n\n\n\n\n\n\n\nGG Solutions:\n\nHighly subjective answer, but I would go with 0.2 since it gives you the right amount of information about the distribution of carat: right-skewed.\n\n\n\nDraw a histogram of price. What interesting patterns do you see?\n\nAnswer: price has a multi-modal distribution with a gap. Looking at the underlying data, there are no prices between $1454 and $1546\n\nggplot(diamonds, aes(price)) +\n  geom_histogram(binwidth = 50)\n\n\n\n\n\n\n\ndiamonds |&gt;\n  filter(price &gt;= 1454, price &lt;= 1546)\n\n#&gt; # A tibble: 24 × 10\n#&gt;    carat cut       color clarity depth table price     x     y     z\n#&gt;    &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  0.5  Very Good D     SI1      61.6    56  1454  5.09  5.11  3.14\n#&gt;  2  0.52 Ideal     I     VVS1     60.1    56  1454  5.24  5.27  3.16\n#&gt;  3  0.54 Ideal     H     VS1      61.2    55  1454  5.25  5.31  3.23\n#&gt;  4  0.51 Premium   G     VS2      61.2    60  1546  5.17  5.12  3.15\n#&gt;  5  0.51 Ideal     G     VS2      62.9    54  1546  5.12  5.08  3.21\n#&gt;  6  0.51 Premium   G     VS2      62.4    57  1546  5.11  5.09  3.18\n#&gt;  7  0.51 Premium   G     VS2      62.7    58  1546  5.12  5.09  3.2 \n#&gt;  8  0.51 Premium   G     VS2      62.2    57  1546  5.15  5.1   3.19\n#&gt;  9  0.51 Ideal     G     VS2      62.7    57  1546  5.12  5.05  3.19\n#&gt; 10  0.51 Premium   G     VS2      62.9    58  1546  5.11  5.06  3.2 \n#&gt; # ℹ 14 more rows\n\n\nGG Solutions:\n\nIt’s skewed to the right and has a long tail. Also, there is a small peak around 5000 and a huge peak around 0.\n\n\n\nHow does the distribution of price vary with clarity?\n\nAnswer: a boxplot of price by clarity shows that diamonds with better clarity aren’t necessarily more expensive.\nHowever, as noted in my R Training Log and as answered in 2.6.6 Exercises:\n\n7.6 Patterns and models covers models and residuals, here showing how to reveal the expected relationship between cut and price:\n\nWe can remove the relationship between carats and price, and redo the boxplot, which shows the expected relationship:\n\nggplot(diamonds, aes(clarity, price)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n# remove carat weight as a confounding variable\ndiamonds |&gt;\n  add_residuals(lm(log(price) ~ log(carat), data = diamonds)) |&gt;\n  mutate(resid = exp(resid)) |&gt;\n  ggplot(aes(clarity, resid)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nThe range of prices is similar across clarity and the median and IQR vary greatly with clarity.\n\n\n\nOverlay a frequency polygon and density plot of depth. What computed variable do you need to map to y to make the two plots comparable? (You can either modify geom_freqpoly() or geom_density().)\n\nAnswer: you need to either divide or multiply y by the total number of observations, nrow(diamonds) using after_stat().\n\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(aes(y = after_stat(count) / nrow(diamonds)), binwidth = 1) +\n  geom_density() +\n  labs(y = \"\")\n\n\n\n\n\n\n\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(binwidth = 1) +\n  geom_density(aes(y = after_stat(density) * nrow(diamonds))) +\n  labs(y = \"\")\n\n\n\n\n\n\n\n\nNotes: from the documentation for after_stat():\n\nMost aesthetics are mapped from variables found in the data. Sometimes, however, you want to delay the mapping until later in the rendering process. ggplot2 has three stages of the data that you can map aesthetics from. The default is to map at the beginning, using the layer data provided by the user. The second stage is after the data has been transformed by the layer stat. The third and last stage is after the data has been transformed and mapped by the plot scales. The most common example of mapping from stat transformed data is the height of bars in geom_histogram(): the height does not come from a variable in the underlying data, but is instead mapped to the count computed by stat_bin(). An example of mapping from scaled data could be to use a desaturated version of the stroke colour for fill. If you want to map directly from the layer data you should not do anything special. In order to map from stat transformed data you should use the after_stat() function to flag that evaluation of the aesthetic mapping should be postponed until after stat transformation. Similarly, you should use after_scale() to flag evaluation of mapping for after data has been scaled. If you want to map the same aesthetic multiple times, e.g. map x to a data column for the stat, but remap it for the geom, you can use the stage() function to collect multiple mappings.\n\nGG Solutions answer not included here.\nNote: after reading the Generated Variables section, there is an easier solution:\n\nggplot(diamonds, aes(depth)) +\n  geom_freqpoly(aes(y = after_stat(density)), binwidth = 1) +\n  geom_density() +\n  labs(y = \"\")\n\n\n\n\n\n\n\n\n\nBonus: overlay a PDF and ECDF on a histogram.\n\nggplot(diamonds, aes(price)) +\n  geom_histogram(aes(y = after_stat(ncount)), binwidth = 50, fill = \"gray\") +\n  stat_ecdf() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n\n\n\n\n\n\n\nggplot(diamonds, aes(price)) +\n  geom_histogram(binwidth = 50, fill = \"gray\") +\n  # nolint next: line_length_linter.\n  # see https://stackoverflow.com/questions/27611438/density-curve-overlay-on-histogram-where-vertical-axis-is-frequency-aka-count\n  geom_density(aes(y = after_stat(density * nrow(diamonds) * 50))) +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n\n\n\n\n\n\n\nggplot(diamonds, aes(price)) +\n  geom_histogram(aes(y = after_stat(ncount)), binwidth = 50, fill = \"gray\") +\n  # TODO: the factor of 0.62 was determined by trial and error, find underlying formula\n  #       the maximum density / the maximum count of the previous plot = 930.57 / 1503 = 0.62\n  #       but that doesn't work here\n  geom_density(aes(y = after_stat(ndensity * 0.62))) +\n  stat_ecdf() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#maps",
    "href": "analysis/ggplot2-2.html#maps",
    "title": "ggplot2 (Layers)",
    "section": "6 Maps",
    "text": "6 Maps\nPlotting geospatial data is a common visualisation task, and one that requires specialised tools. Typically the problem can be decomposed into two problems: using one data source to draw a map, and adding metadata from another information source to the map. This chapter will help you tackle both problems.\n\nBonus\nThere are no exercises, so let’s draw a map of Minnesota using polygon maps!\n\nmap_data(\"county\", \"minnesota\") |&gt;\n  select(lon = long, lat, group) |&gt;\n  ggplot(aes(lon, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"grey50\") +\n  coord_quickmap() +\n  labs(x = \"\", y = \"\") +\n  theme_quo()\n\n\n\n\n\n\n\n\nPolygon maps are superseded by simple features maps, so let’s draw it again, adding Minneapolis, in red:\n\nus_counties(resolution = \"high\", states = \"MN\") |&gt;\n  ggplot() +\n  geom_sf(fill = \"white\") +\n  geom_sf(data = filter(us_cities(states = \"MN\"), city == \"Minneapolis\"), color = \"red\") +\n  coord_sf() +\n  theme_quo()\n\n\n\n\n\n\n\n\nSide note: although it creates files in /usr/local, which causes Homebrew to complain, rig, The R Installation Manager, supports multiple versions of R, and supports installation of binary packages, which is substantially faster and requires fewer local dependencies.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#networks",
    "href": "analysis/ggplot2-2.html#networks",
    "title": "ggplot2 (Layers)",
    "section": "7 Networks",
    "text": "7 Networks\nLike maps and spatial data, networks and graphs occupy a special part of the visualization landscape, but whereas spatial data mostly differ from regular plotting in their use of projections, networks bring their own data structure as well as their own visualization paradigms to the table. Because of these complications networks are not directly supported in ggplot2. Several efforts over the years have tried to add this missing piece and in this chapter we will see how to use ggraph for network visualization. Other packages that offer some of the same functionality includes geomnet, ggnetwork, and GGally for regular network plots, and ggtree and ggdendro for tree visualization specifically.\n\nNotes\nWhile ggplot2 has limited support for maps, it has no direct support for networks and graphs. ggraph offers some interesting visualizations that are useful for understanding social networks, especially this one, which shows how friendships among high school boys changed from 1957 to 1958:\n\nhighschool |&gt;\n  as_tbl_graph(directed = FALSE) |&gt;\n  ggraph(layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point() +\n  facet_edges(~year)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#annotations",
    "href": "analysis/ggplot2-2.html#annotations",
    "title": "ggplot2 (Layers)",
    "section": "8 Annotations",
    "text": "8 Annotations\nWhen constructing a data visualisation, it is often necessary to make annotations to the data displayed. Conceptually, an annotation supplies metadata for the plot: that is, it provides additional information about the data being displayed. From a practical standpoint, however, metadata is just another form of data. Because of this, the annotation tools in ggplot2 reuse the same geoms that are used to create other plots. However, to meet the specific needs that users often have when annotating plots, there are some helper functions in ggplot2 itself, and a number of other packages have extended ggplot2 in ways you may find helpful.\n\nNotes\nAn important distinction on axis labels:\n\nThere are two ways to remove the axis label. Setting labs(x = \"\") omits the label but still allocates space; setting labs(x = NULL) removes the label and its space.\n\nConsider adopting showtext for non-standard fonts, with caveats for using it in R Markdown.\nOne of the most useful alignments is “inward”. It aligns text towards the middle of the plot, which ensures that labels remain within the plot limits:\n\ndf &lt;- data.frame(\n  x = c(1, 1, 2, 2, 1.5),\n  y = c(1, 2, 1, 2, 1.5),\n  text = c(\n    \"bottom-left\", \"top-left\",\n    \"bottom-right\", \"top-right\", \"center\"\n  ), stringsAsFactors = FALSE\n)\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text))\n\n\n\n\n\n\n\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text), vjust = \"inward\", hjust = \"inward\")\n\n\n\n\n\n\n\n\n\nThe font size is controlled by the size aesthetic. Unlike most tools, ggplot2 specifies the size in millimeters (mm), rather than the usual points (pts). The reason for this choice is that it makes it the units for font sizes consistent with how other sizes are specified in ggplot2. (There are 72.27 pts in a inch, so to convert from points to mm, just multiply by 72.27 / 25.4).\n\nLet’s assign blame to unemployment!\n\npresidential &lt;- subset(presidential, start &gt; economics$date[1] & start &lt; max(economics$date))\n\nggplot(economics) +\n  geom_rect(\n    aes(xmin = start, xmax = end, fill = party),\n    ymin = -Inf, ymax = Inf, alpha = 0.25,\n    data = presidential\n  ) +\n  geom_vline(\n    aes(xintercept = as.numeric(start)),\n    data = presidential,\n    colour = \"grey50\", alpha = 0.5\n  ) +\n  geom_text(\n    # themes only affect the non-data components of the plot, see:\n    #   https://github.com/tidyverse/ggplot2/issues/1859\n    aes(x = start, y = 0.0005, label = name, family = \"Lato\"),\n    data = presidential,\n    size = 3, vjust = 0, hjust = 0, nudge_x = 75\n  ) +\n  geom_line(aes(date, unemploy / pop)) +\n  scale_fill_manual(values = c(\"blue\", \"red\")) +\n  scale_y_continuous(labels = scales::percent, limits = c(0, NA)) +\n  scale_x_date(breaks = presidential$start, date_labels = \"%Y\") +\n  guides(fill = \"none\") +\n  labs(title = \"Unemployment rate by presidential term\", x = NULL, y = NULL) +\n  theme_quo(minor.y = FALSE, x = FALSE)\n\n#&gt; Warning in scale_x_date(breaks = presidential$start, date_labels = \"%Y\"): A &lt;numeric&gt; value was passed to a Date scale.\n#&gt; ℹ The value was converted to a &lt;Date&gt; object.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-2.html#arranging-plots",
    "href": "analysis/ggplot2-2.html#arranging-plots",
    "title": "ggplot2 (Layers)",
    "section": "9 Arranging plots",
    "text": "9 Arranging plots\nThe grammar presented in ggplot2 is concerned with creating single plots. While the faceting system provides the means to produce several subplots all of these are part of the same main visualization, sharing layers, data, and scales. However, it is often necessary to use multiple disparate plots to tell a story or make an argument. These can of course be created individually and assembled in a layout program, but it is beneficial to do this in code to avoid time consuming and non-reproducible manual labor. A range of packages have risen to the occasion and provide different approaches to arranging separate plots. While this chapter will focus on the patchwork package you may also find some of the same functionalities in the cowplot, gridExtra and ggpubr packages.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Layers)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html",
    "href": "analysis/ggplot2-4.html",
    "title": "ggplot2 (Grammar)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Grammar” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(MASS) # nolint: unused_import_linter. Used for \"rlm\".\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(jbplot)\nlibrary(ggthemes)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#introduction",
    "href": "analysis/ggplot2-4.html#introduction",
    "title": "ggplot2 (Grammar)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from ggplot2: Elegant Graphics for Data Analysis and Solutions to ggplot2: Elegant Graphics for Data Analysis, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read the ggplot2 book and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#mastering-the-grammar",
    "href": "analysis/ggplot2-4.html#mastering-the-grammar",
    "title": "ggplot2 (Grammar)",
    "section": "13 Mastering the grammar",
    "text": "13 Mastering the grammar\nIn order to unlock the full power of ggplot2, you’ll need to master the underlying grammar. By understanding the grammar, and how its components fit together, you can create a wider range of visualizations, combine multiple sources of data, and customise to your heart’s content.\nThis chapter describes the theoretical basis of ggplot2: the layered grammar of graphics. The layered grammar is based on Wilkinson’s grammar of graphics, but adds a number of enhancements that help it to be more expressive and fit seamlessly into the R environment. The differences between the layered grammar and Wilkinson’s grammar are described fully in Hadley Wickham. In this chapter you will learn a little bit about each component of the grammar and how they all fit together. The next chapters discuss the components in more detail, and provide more examples of how you can use them in practice.\nThe grammar makes it easier for you to iteratively update a plot, changing a single feature at a time. The grammar is also useful because it suggests the high-level aspects of a plot that can be changed, giving you a framework to think about graphics, and hopefully shortening the distance from mind to paper. It also encourages the use of graphics customised to a particular problem, rather than relying on specific chart types.\n\n13.5 Exercises\n\nOne of the best ways to get a handle on how the grammar works is to apply it to the analysis of existing graphics. For each of the graphics listed below, write down the components of the graphic. Don’t worry if you don’t know what the corresponding functions in ggplot2 are called (or if they even exist!), instead focussing on recording the key elements of a plot so you could communicate it to someone else.\n\nAnswer: use the components from 13.4 to describe each plot: data, aesthetics (aes), stat, geom, scale, coordinate system (coord), and faceting\n\n“Napoleon’s march” by Charles John Minard: link\n\nAnswer: the plot describes Napolean’s 1812 campaign. Larger version at: Wikipedia\n\ndata: the size, location and date of the army’s travel, along with temperature\naes: x, y mapped to location over time, with width representing size\nstat: no transformation\ngeom: line\nscale: scales are used for location and temperature\ncoord: Cartesian / map projection\nfacet: no faceting\n\n\n\n“Where the Heat and the Thunder Hit Their Shots”, by Jeremy White, Joe Ward, and Matthew Ericson at The New York Times. link\n\nAnswer: a plot of basketball shots and points scored.\n\ndata: number of attempts and points scored by location\naes: x, y mapped to location, size mapped to attempts, color to points scored\nstat: no transformation (possibly points per attempt)\ngeom: hex tiles\nscale: continuous scales mapped to location, size (attempts), and color (points)\ncoord: Cartesian, mapped to the court\nfacet: faceting by team and players\n\n\n\n“London Cycle Hire Journeys”, by James Cheshire. link\n\nAnswer: retrieved from archive.org.\n\ndata: travels of London bicycle rentals\naes: x, y mapped to location, density (alpha) mapped to number of trips in a location\nstat: none\ngeom: line\nscale: location\ncoord: Cartesian / map projection\nfacet: none\n\n\n\nThe Pew Research Center’s favorite data visualizations of 2014: link\n\nAnswer: multiple plots, described individually.\nPolitical Shifts\n\ndata: responses to political values questions\naes: height showing volume of responses, between consistently liberal and conservative\nstat: histogram\ngeom: area / frequency polygon, with color showing above / below median of the other party\nscale: continuous\ncoord: Cartesian\nfacet: faceting by party by year\n\nNext America\n\ndata: population by age group and gender\naes: binned data by age and gender\nstat: none\ngeom: bar and color by gender, with boomers a distinct color\nscale: continuous\ncoord: Cartesian\nfacet: faceting by year, animated\n\n“Murder Capitals”\n\ndata: murder rate for six cities, with the highest rate shown for each year, national rate\naes: x is time (year) and y is the murder rate\nstat: none\ngeom: bar, line\nscale: city is additionally mapped to year at the top of the plot, and national rate is shown as a line across the bottom\ncoord: Cartesian\nfacet: none\n\nIdeological Placement of News Sources\n\ndata: scores of responses to political values questions mapped to audiences for news sources\naes: x mapped to score for a news source audience\nstat: none\ngeom: point\nscale: a single (x-axis) continuous scale, with labels for each source\ncoord: Cartesian\nfacet: none\n\nRegional Support for Same-Sex Marriage\n\ndata: percentage of population supporting same-sex marriage by region\naes: x mapped to time (year), y mapped to percent support\nstat: none\ngeom: line\nscale: continuous\ncoord: Cartesian\nfacet: faceting by region, national support is an additional layer\n\n\n\n“The Tony’s Have Never Been so Dominated by Women”, by Joanna Kao at FiveThirtyEight: link.\n\nAnswer: a plot of Tony award winners by category.\n\ndata: Tony award categories by year with at least one female winner\naes: categories along the y axis, years along the x axis, colored red if a female won\nstat: none\ngeom: square points with color showing female winners\nscale: discrete categories and years\ncoord: Cartesian\nfacet: none\n\n\n\n“In Climbing Income Ladder, Location Matters” by the Mike Bostock, Shan Carter, Amanda Cox, Matthew Ericson, Josh Keller, Alicia Parlapiano, Kevin Quealy and Josh Williams at the New York Times: link\n\nAnswer: not visible due to paywall, unable to retrieve the graphic.\n\n\n“Dissecting a Trailer: The Parts of the Film That Make the Cut”, by Shan Carter, Amanda Cox, and Mike Bostock at the New York Times: link\n\nAnswer: multiple plots showing the sequencing of movie trailers.\n\ndata: scenes in a trailer mapped to when they occurred in the full film\naes: x axis showing the timestamp of a trailer scene, y axis and color showing when the scene occurred, including scenes not in the final film\nstat: none\ngeom: square points (with width per scene), connected by lines\nscale: continuous duration (seconds)\ncoord: Cartesian\nfacet: faceting by trailer (all plots are mapped to the same scale)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#build-a-plot-layer-by-layer",
    "href": "analysis/ggplot2-4.html#build-a-plot-layer-by-layer",
    "title": "ggplot2 (Grammar)",
    "section": "14 Build a plot layer by layer",
    "text": "14 Build a plot layer by layer\nOne of the key ideas behind ggplot2 is that it allows you to easily iterate, building up a complex plot a layer at a time. Each layer can come from a different dataset and have a different aesthetic mapping, making it possible to create sophisticated plots that display data from multiple sources.\nYou’ve already created layers with functions like geom_point() and geom_histogram(). In this chapter, you’ll dive into the details of a layer, and how you can control all five components: data, the aesthetic mappings, the geom, stat, and position adjustments. The goal here is to give you the tools to build sophisticated plots tailored to the problem at hand.\n\n14.3.1 Exercises\n\nThe first two arguments to ggplot are data and mapping. The first two arguments to all layer functions are mapping and data. Why does the order of the arguments differ? (Hint: think about what you set most commonly.)\n\nAnswer: most plots use common data for all layers, where the aesthetics are more likely to vary.\nGG Solutions:\n\nCommonly, you first set the data in ggplot() and then set aesthetics inside your layer functions, like geom_point(), geom_boxplot(), or geom_histogram().\n\n\n\nThe following code uses dplyr to generate some summary statistics about each class of car.\n\n\nclass &lt;- mpg %&gt;%\n  group_by(class) %&gt;%\n  summarise(n = n(), hwy = mean(hwy))\n\nUse the data to recreate this plot:\nAnswer: with some help from the source code to get the measurements right, here is the solution:\n\nggplot(mpg, aes(class, hwy)) +\n  geom_point() +\n  geom_jitter(width = 0.25) +\n  geom_point(data = class, color = \"red\", size = 5) +\n  geom_text(aes(y = 10, label = paste0(\"n = \", n)), data = class, size = 3)\n\n\n\n\n\n\n\n\nGG Solutions:\n\nmpg %&gt;%\n  ggplot(aes(class, hwy)) +\n  geom_jitter(width = 0.15, height = 0.35) +\n  geom_point(\n    data = class, aes(class, hwy),\n    color = \"red\",\n    size = 6\n  ) +\n  geom_text(data = class, aes(y = 10, x = class, label = paste0(\"n = \", n)))\n\n\n\n\n\n\n\n\n\nI plotted 3 different layers: jittered points, red point for the summary measure, mean, and text for the sample size (n).\n\n\n\n\n14.4.3 Exercises\n\nSimplify the following plot specifications:\n\n\nggplot(mpg) +\n  geom_point(aes(mpg$displ, mpg$hwy))\n\nggplot() +\n  geom_point(mapping = aes(y = hwy, x = cty), data = mpg) +\n  geom_smooth(data = mpg, mapping = aes(cty, hwy))\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(log(brainwt), log(bodywt)), data = msleep)\n\nAnswer:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point()\n\n\n\n\n\n\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"loess\", formula = y ~ x)\n\n\n\n\n\n\n\nggplot(msleep, aes(log(brainwt), log(bodywt))) +\n  geom_point(na.rm = TRUE)\n\n\n\n\n\n\n\n\nGG Solutions offers a similar solution for the first two and a strange solution for the third (since the diamonds data is never used in the third plot):\n\nggplot(mpg) +\n  geom_point(aes(displ, hwy))\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  geom_smooth()\n\nmsleep_processed &lt;- msleep %&gt;%\n  mutate(\n    brainwt_log = log(brainwt),\n    bodywt_log = log(bodywt)\n  )\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(brainwt_log, bodywt_log),\n    data = msleep_processed\n  )\n\nNote: I prefer my answer to GG Solutions.\n\n\nWhat does the following code do? Does it work? Does it make sense? Why/why not?\n\n\nggplot(mpg) +\n  geom_point(aes(class, cty)) +\n  geom_boxplot(aes(trans, hwy))\n\nAnswer: it does work, but does not make sense, and should be done as separate plots so that the variables comparisons are visible:\n\nggplot(mpg, aes(class, cty)) +\n  geom_point() +\n  coord_flip()\n\n\n\n\n\n\n\nggplot(mpg, aes(trans, hwy)) +\n  geom_boxplot() +\n  coord_flip()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nIt plots points of class vs cty and then a boxplot of trans vs hwy. It doesn’t make sense to plot layers with different x and y variables.\n\n\n\nWhat happens if you try to use a continuous variable on the x axis in one layer, and a categorical variable in another layer? What happens if you do it in the opposite order?\n\nAnswer: let’s experiment!\nThis code throws an error, Error: Discrete value supplied to continuous scale\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_point(aes(drv, hwy), color = \"red\")\n\nReversing the order works, but draws a strange plot:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(drv, hwy), color = \"red\") +\n  geom_point()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nNot sure\n\n\n\n\n14.5.1 Exercises\n\nDownload and print out the ggplot2 cheatsheet from rstudio so you have a handy visual reference for all the geoms.\n\nAnswer: cheatsheets have moved to posit (as the company rebranded).\n\n\nLook at the documentation for the graphical primitive geoms. Which aesthetics do they use? How can you summarise them in a compact form?\n\nAnswer: from 14.5, the primitives are:\n\ngeom_blank(): no aesthetics, “draw nothing”\ngeom_point(): x, y, alpha, color, fill, group, shape, size, stroke, “draw points”\ngeom_path(): x, y, alpha, color, group, linetype, linewidth, “connect observations”\ngeom_ribbon(): x or y, ymin or xmin, ymax or xmax, alpha, color, fill, group, linetype, linewidth, “draw an area along a line”\ngeom_segment(): x, y, xend, yend, alpha, color, group, linetype, linewidth, “connect two points”\ngeom_rect(): x, y, alpha, color, fill, group, height, linetype, linewidth, width, “draw rectangles”\ngeom_polygon(): x, y, alpha, color, fill, group, linetype, linewidth, subgroup, “draw polygons”\ngeom_text(): x, y, label, alpha, angle, color, family, fontface, group, hjust, lineheight, size, vjust, “draw text”\n\n\n\nWhat’s the best way to master an unfamiliar geom? List three resources to help you get started.\n\nAnswer:\n\nR Documentation for ggplot2, either built-in or online\nPosit cheatsheets\nThe R Graph Gallery\n\n\n\nFor each of the plots below, identify the geom used to draw it.\n\nAnswer: in the order they appear in the Exercises:\n\ngeom_violin\ngeom_point (actually uses geom_count)\ngeom_hex\ngeom_point (actually uses geom_jitter)\ngeom_area\ngeom_path\n\nNote: verifying my answers against the source code, I got two wrong, although the underlying geom is geom_point.\nGG Solutions:\nStarting from top left, clockwise direction:\n\ngeom_violin(), geom_point(), geom_point(), geom_path(), geom_area(), geom_hex().\n\nNote: GG Solutions makes the same mistakes I did.\n\n\nFor each of the following problems, suggest a useful geom:\n\nDisplay how a variable has changed over time.\nShow the detailed distribution of a single variable.\nFocus attention on the overall trend in a large dataset.\nDraw a map.\nLabel outlying points.\n\n\nAnswers below:\n\nDisplay how a variable has changed over time: geom_line, with time on the x axis, or geom_path to show changes in two dimensions over time.\nShow the detailed distribution of a single variable: one of the distribution plots, geom_histogram and geom_dotplot are good choices.\nFocus attention on the overall trend in a large dataset: geom_smooth.\nDraw a map: geom_map or its successor, geom_sf.\nLabel outlying points: geom_text or geom_label.\n\n\n\n\n14.6.2 Exercises\n\nThe code below creates a similar dataset to stat_smooth(). Use the appropriate geoms to mimic the default geom_smooth() display.\n\n\nmod &lt;- loess(hwy ~ displ, data = mpg)\nsmoothed &lt;- data.frame(displ = seq(1.6, 7, length.out = 50))\npred &lt;- predict(mod, newdata = smoothed, se = TRUE)\nsmoothed$hwy &lt;- pred$fit\nsmoothed$hwy_lwr &lt;- pred$fit - 1.96 * pred$se.fit\nsmoothed$hwy_upr &lt;- pred$fit + 1.96 * pred$se.fit\n\nAnswer: the exercise is to replicate geom_smooth using the smoothed data frame, which includes a line and a ribbon:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"loess\", formula = y ~ x)\n\n\n\n\n\n\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_line(data = smoothed, color = \"blue\", linewidth = 1) +\n  geom_ribbon(mapping = aes(ymin = hwy_lwr, ymax = hwy_upr), data = smoothed, alpha = 0.2)\n\n\n\n\n\n\n\n\nA perfect match!\nGG Solutions:\n\nsmoothed %&gt;%\n  ggplot(aes(displ, hwy)) +\n  geom_line(color = \"dodgerblue1\") +\n  geom_ribbon(aes(ymin = hwy_lwr, ymax = hwy_upr), alpha = 0.4)\n\n\n\n\n\n\n\n\n\n\nWhat stats were used to create the following plots?\n\nAnswer: in the order they appear in the Exercises:\n\nstat_ecdf\nstat_qq\nstat_density\n\nConfirmed correct by reviewing the source code.\nGG Solutions: From left to right,\nstat_ecdf(), stat_qq(), stat_function()\n\n\nRead the help for stat_sum() then use geom_count() to create a plot that shows the proportion of cars that have each combination of drv and trans.\n\nAnswer: in addition, facet by year.\n\nggplot(mpg, aes(drv, trans)) +\n  geom_count(aes(size = after_stat(prop), group = 1)) +\n  scale_size(labels = scales::label_percent()) +\n  facet_wrap(vars(year)) +\n  labs(title = \"Combinations of drive train and transmissions\", x = NULL, y = NULL) +\n  labs(size = \"% of cars\") +\n  theme_quo()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nmpg %&gt;%\n  ggplot(aes(drv, trans)) +\n  geom_count(aes(size = after_stat(prop), group = 1))\n\n\n\n\n\n\n\n\n\n\n\n14.7.1 Exercises\n\nWhen might you use position_nudge()? Read the documentation.\n\nAnswer: as the documentation states, “Nudging is built in to geom_text() because it’s so useful for moving labels a small distance from what they’re labelling.”\nGG Solutions: According to the help page, position_nudge() is generally useful for adjusting the position of items on discrete scales by a small amount. Nudging is built in to geom_text() because it’s so useful for moving labels a small distance from what they’re labelling.\n\n\nMany position adjustments can only be used with a few geoms. For example, you can’t stack boxplots or errors bars. Why not? What properties must a geom possess in order to be stackable? What properties must it possess to be dodgeable?\n\nAnswer: reading the docs, position_stack() requires that geoms have a position (points, lines, text) or a dimension (bar, area). Boxplots and error bars can’t be stacked since they don’t have a position or area. A geom must have a width in order to be dodgeable, which can be set with position_dodge(width = ...).\nGG Solutions: Not sure\n\n\nWhy might you use geom_jitter() instead of geom_count()? What are the advantages and disadvantages of each technique?\n\nAnswer: geom_jitter() preserves the size and number of points but not position, and geom_count() preserves the position but not number or size. geom_jitter() can be a better choice when there are few overlapping points.\nGG Solutions: geom_jitter() adds a small amount of random variation to the location of each point. It is useful for looking at all the overplotted points. On the other hand, geom_count() counts the number of overlapping observations at each location. It is useful for understanding the number of points in a location.\n\n\nWhen might you use a stacked area plot? What are the advantages and disadvantages compared to a line plot?\n\nAnswer: a stacked area plot is a good way to show the relationship of related variables, showing how parts of a whole change over time, for example, plotting the phases of incident response (mean time to detect, mean time to resolve). It is very similar to a line plot, and makes relative values (proportions) easier to compare and absolute values harder to compare.\nGG Solutions: Stacked area plot seems useful when you want to portray an area whereas a line plot seems useful when you just need a line.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#scales-and-guides",
    "href": "analysis/ggplot2-4.html#scales-and-guides",
    "title": "ggplot2 (Grammar)",
    "section": "15 Scales and guides",
    "text": "15 Scales and guides\nThe scales toolbox in Chapters 10 to 12 provides extensive guidance for how to work with scales, focusing on solving common data visualisation problems. The practical goals of the toolbox mean that topics are introduced when they are most relevant: for example, scale transformations are discussed in relation to continuous position scales (Section 10.1.7) because that is the most common situation in which you might want to transform a scale. However, because ggplot2 aims to provide a grammar of graphics, there is nothing preventing you from transforming other kinds of scales (see Section 15.6). This chapter aims to illustrate these concepts: I’ll discuss the theory underpinning scales and guides, and give examples showing how concepts that I’ve discussed specifically for position or colour scales also apply elsewhere.\n\nSetting color with limits\nLet’s create a pair of plots controlling color with limits (from 11.3.5)! First, we’ll just plot both independently:\n\ngg_99 &lt;- mpg |&gt;\n  filter(year == 1999) |&gt;\n  ggplot(aes(displ, hwy, color = fl)) +\n  geom_point()\n\ngg_08 &lt;- mpg |&gt;\n  filter(year == 2008) |&gt;\n  ggplot(aes(displ, hwy, color = fl)) +\n  geom_point()\n\ngg_99\n\n\n\n\n\n\n\ngg_08\n\n\n\n\n\n\n\n\nNow, let’s replot using limits:\n\ngg_99 +\n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    breaks = c(\"d\", \"p\", \"r\"),\n    labels = c(\"diesel\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\ngg_08 +\n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    labels = c(\"compressed\", \"diesel\", \"ethanol\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\n\n\n\nKey glyphs\nLet’s use a key glyph! (draw_key_timeseries())\n\nggplot(economics, aes(date, psavert, color = \"Personal\\nSavings\\nRate\")) +\n  geom_line(key_glyph = \"timeseries\") +\n  labs(x = NULL, y = NULL, color = NULL) +\n  theme_quo()",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#coordinate-systems",
    "href": "analysis/ggplot2-4.html#coordinate-systems",
    "title": "ggplot2 (Grammar)",
    "section": "16 Coordinate systems",
    "text": "16 Coordinate systems\nCoordinate systems have two main jobs:\n\nCombine the two position aesthetics to produce a 2d position on the plot. The position aesthetics are called x and y, but they might be better called position 1 and 2 because their meaning depends on the coordinate system used. For example, with the polar coordinate system they become angle and radius (or radius and angle), and with maps they become latitude and longitude.\nIn coordination with the faceter, coordinate systems draw axes and panel backgrounds. While the scales control the values that appear on the axes, and how they map from data to position, it is the coordinate system which actually draws them. This is because their appearance depends on the coordinate system: an angle axis looks quite different than an x axis.\n\n\nPolar coordinates\nLet’s draw a spiral with polar coordinates!\n\ndata.frame(x = c(1, 200), y = c(200, 1)) |&gt;\n  ggplot(aes(x, y)) +\n  geom_line() +\n  coord_polar()\n\n\n\n\n\n\n\n\nWe can use polar coordinates to draw a pie chart:\n\nggplot(mtcars, aes(factor(1), fill = factor(cyl))) +\n  geom_bar(width = 1) +\n  scale_x_discrete(NULL, expand = c(0, 0)) +\n  scale_y_continuous(NULL, expand = c(0, 0)) +\n  coord_polar(theta = \"y\") +\n  labs(title = \"Number of cylinders\", fill = NULL) +\n  theme_void()",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#faceting",
    "href": "analysis/ggplot2-4.html#faceting",
    "title": "ggplot2 (Grammar)",
    "section": "17 Faceting",
    "text": "17 Faceting\nYou first encountered faceting in Section 2.5. Faceting generates small multiples each showing a different subset of the data. Small multiples are a powerful tool for exploratory data analysis: you can rapidly compare patterns in different parts of the data and see whether they are the same or different. This section will discuss how you can fine-tune facets, particularly the way in which they interact with position scales.\n\nFacet grid\nLet’s draw a facet grid!\n\nmpg |&gt;\n  filter(cyl != 5) |&gt;\n  ggplot(aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(method = \"rlm\", formula = y ~ x) +\n  facet_grid(drv ~ cyl) +\n  labs(x = NULL, y = NULL)\n\n\n\n\n\n\n\n\n\n\nFree scales\nFree scales are useful when faceting across different variables over the same time period:\n\nggplot(economics_long, aes(date, value)) +\n  geom_line() +\n  facet_wrap(~variable, scales = \"free_y\", ncol = 1)\n\n\n\n\n\n\n\n\n\n\nFacet space\nfacet_grid() has an additional parameter called space, which takes the same values as scales. When space is “free”, each column (or row) will have width (or height) proportional to the range of the scale for that column (or row). This makes the scaling equal across the whole plot: 1 cm on each panel maps to the same range of data. (This is somewhat analogous to the ‘sliced’ axis limits of lattice.) For example, if panel a had range 2 and panel b had range 4, one-third of the space would be given to a, and two-thirds to b. This is most useful for categorical scales, where we can assign space proportionally based on the number of levels in each facet, as illustrated below.\n\nmpg2 &lt;- subset(mpg, cyl != 5 & drv %in% c(\"4\", \"f\") & class != \"2seater\")\nmpg2$model &lt;- reorder(mpg2$model, mpg2$cty)\nmpg2$manufacturer &lt;- reorder(mpg2$manufacturer, -mpg2$cty)\n\nggplot(mpg2, aes(cty, model)) +\n  geom_point() +\n  facet_grid(manufacturer ~ ., scales = \"free\", space = \"free\") +\n  labs(x = NULL, y = NULL) +\n  theme(strip.text.y = element_text(angle = 0))\n\n\n\n\n\n\n\n\n\n\nGrouping and faceting\nLet’s combine grouping and faceting!\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(data = select(mpg, -drv), color = \"grey75\") +\n  geom_point(aes(color = drv)) +\n  facet_wrap(~drv)\n\n\n\n\n\n\n\n\n\n\n17.7 Exercises\n\nDiamonds: display the distribution of price conditional on cut and carat. Try faceting by cut and grouping by carat. Try faceting by carat and grouping by cut. Which do you prefer?\n\nAnswer: faceting by caret requires discretizing, here we use cut_number():\n\nggplot(diamonds, aes(price, group = carat, color = carat)) +\n  geom_histogram(bins = 100) +\n  scale_color_viridis_c() +\n  facet_wrap(~cut)\n\n\n\n\n\n\n\ndiamonds |&gt;\n  mutate(carat_n = cut_number(carat, 6)) |&gt;\n  ggplot(aes(price, group = cut, fill = cut)) +\n  geom_histogram(bins = 100) +\n  scale_color_viridis_d() +\n  facet_wrap(~carat_n)\n\n\n\n\n\n\n\n\nFaceting by cut seems preferable, since it provides an insight not provided by faceting by carat: there are more large carat diamonds with a Fair cut.\nGG Solutions: takes a different approach, and concludes: “It makes more sense to facet by cut because its a discrete variable. Faceting by carat, a continuous variable, makes too many facets and renders the plot unreadable!”\n\n\nDiamonds: compare the relationship between price and carat for each colour. What makes it hard to compare the groups? Is grouping better or faceting? If you use faceting, what annotation might you add to make it easier to see the differences between panels?\n\nAnswer: comparing is hard because of overlap between groups and overplotting. Overall, grouping seems easier to read than faceting. Adding a reference line (in this case, a robust linear regression) makes it easier to see differences across faceting panels.\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(color = color)) +\n  geom_smooth(method = \"rlm\", formula = y ~ x, se = FALSE) +\n  coord_cartesian(ylim = c(0, max(diamonds$price)))\n\n\n\n\n\n\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(color = color)) +\n  geom_smooth(data = select(diamonds, -color), method = \"rlm\", formula = y ~ x, se = FALSE) +\n  coord_cartesian(ylim = c(0, max(diamonds$price))) +\n  facet_wrap(~color)\n\n\n\n\n\n\n\n\nGG Solutions:\n\ndiamonds %&gt;%\n  ggplot(aes(carat, price)) +\n  geom_point(aes(color = color))\n\n\n\n\n\n\n\ndiamonds %&gt;%\n  ggplot(aes(carat, price)) +\n  geom_point(aes(color = color)) +\n  facet_wrap(~color)\n\n\n\n\n\n\n\n\n\nI think its better to use grouping to compare the different colors. The panels all have the same shape, so it’s hard to compare the groups across facets. If I use faceting, I’d add that the plot is facetted by diamond colour, from D (best) to J (worst).\n\n\n\nWhy is facet_wrap() generally more useful than facet_grid()?\n\nAnswer: when faceting by a single variable, facet_wrap() is easier to use as it wraps the facets to fit the plot space automatically. facet_grid() is generally more useful only when faceting with two variables.\nGG Solutions: I think facet_wrap() is more useful than facet_grid() because the former function is useful if you have a single variable with many levels and want to arrange the plots in a more space efficient manner. In data analysis, its extremely common to have a single variable with many levels that the analyst wants to arrange the for easy comparison. Although facet_grid() works on single variables, facet_wrap() involves less typing when you have a single variable.\n\n\nRecreate the following plot. It facets mpg2 by class, overlaying a smooth curve fit to the full dataset.\n\nAnswer: plot below.\n\nggplot(mpg2, aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(data = select(mpg2, -class), method = \"loess\", formula = y ~ x, se = FALSE) +\n  facet_wrap(~class)\n\n\n\n\n\n\n\n\nComparing to the source code, the answer is correct!\nGG Solutions:\n\nmpg2 %&gt;%\n  ggplot(aes(displ, hwy)) +\n  geom_point() +\n  geom_smooth(data = mpg2 %&gt;% select(-class), se = FALSE, method = \"loess\") +\n  facet_wrap(~class)\n\n#&gt; `geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-4.html#themes",
    "href": "analysis/ggplot2-4.html#themes",
    "title": "ggplot2 (Grammar)",
    "section": "18 Themes",
    "text": "18 Themes\nIn this chapter you will learn how to use the ggplot2 theme system, which allows you to exercise fine control over the non-data elements of your plot. The theme system does not affect how the data is rendered by geoms, or how it is transformed by scales. Themes don’t change the perceptual properties of the plot, but they do help you make the plot aesthetically pleasing or match an existing style guide. Themes give you control over things like fonts, ticks, panel strips, and backgrounds.\nThis separation of control into data and non-data parts is quite different from base and lattice graphics. In base and lattice graphics, most functions take a large number of arguments that specify both data and non-data appearance, which makes the functions complicated and harder to learn. ggplot2 takes a different approach: when creating the plot you determine how the data is displayed, then after it has been created you can edit every detail of the rendering, using the theming system.\n\n18.2.1 Exercises\n\nTry out all the themes in ggthemes. Which do you like the best?\n\nAnswer: the “interesting” themes are displayed below. From the top four, I’d pick theme_solarized_2(), although theme_fivethirtyeight() is a close runner-up.\n\nbase &lt;- ggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = factor(cyl))) +\n  geom_smooth(method = \"loess\", formula = y ~ x) +\n  labs(\n    title = \"Fuel economy declines as engine size increases\",\n    subtitle = \"1999-2008\",\n    caption = \"Data from https://fueleconomy.gov/\",\n    x = \"Displacement (liters)\",\n    y = \"Miles per gallon (highway)\",\n    color = \"Cylinders\"\n  )\n\nbase\n\n\n\n\n\n\n\nbase + theme_calc()\n\n\n\n\n\n\n\nbase + theme_fivethirtyeight()\n\n\n\n\n\n\n\nbase + theme_hc()\n\n\n\n\n\n\n\nbase + theme_solarized_2()\n\n\n\n\n\n\n\n\n\n\nWhat aspects of the default theme do you like? What don’t you like?\nWhat would you change?\n\nAnswer: my personal theme, theme_quo() uses a white background with light gray gridlines (based on theme_minimal()), bold titles, captions left-adjusted, and a better font, Lato.\n\nbase +\n  theme_quo()\n\n\n\n\n\n\n\n\n\n\nLook at the plots in your favourite scientific journal. What theme do they most resemble? What are the main differences?\n\nAnswer: the plots from this paper on Safety Science most closely resemble theme_classic(), with few differences, the most notable being the position of the legend in Figures 4, 5, 8, and 9.\n\n\n\n18.4.6 Exercises\n\nCreate the ugliest plot possible! (Contributed by Andrew D. Steen, University of Tennessee - Knoxville)\n\nAnswer: using the same base, alter colors and theme settings, must still be legible:\n\nbase +\n  geom_smooth(method = \"loess\", formula = y ~ x, color = \"orange\", fill = \"limegreen\") +\n  theme_grey(base_family = \"Comic Sans MS\") +\n  theme(\n    plot.background = element_rect(fill = \"skyblue\", color = \"purple\"),\n    plot.title = element_text(face = \"bold\", hjust = 1, color = \"red\"),\n    plot.subtitle = element_text(color = \"yellow\"),\n    plot.caption = element_text(hjust = 0.5, color = \"blue\"),\n    plot.margin = margin(50, 50, 50, 50),\n    axis.line = element_line(color = \"maroon\", linetype = \"dotdash\"),\n    axis.text = element_text(color = \"hotpink\"),\n    axis.title = element_text(color = \"green\"),\n    legend.background = element_rect(fill = \"lemonchiffon\", color = \"gray50\"),\n    legend.key = element_rect(fill = \"pink\", color = \"black\"),\n    legend.text = element_text(color = \"purple\"),\n    legend.title = element_text(color = \"deeppink\"),\n    panel.background = element_rect(fill = \"lavender\"),\n    panel.grid = element_line(linetype = \"twodash\")\n  ) +\n  scale_color_excel()\n\n\n\n\n\n\n\n\n\n\ntheme_dark() makes the inside of the plot dark, but not the outside. Change the plot background to black, and then update the text settings so you can still read the labels.\n\nAnswer:\n\nbase +\n  theme_dark() +\n  theme(\n    plot.background = element_rect(fill = \"black\"),\n    legend.background = element_rect(fill = \"black\"),\n    text = element_text(color = \"gray50\")\n  )\n\n\n\n\n\n\n\n\n\n\nMake an elegant theme that uses “linen” as the background colour and a serif font for the text.\n\nAnswer:\n\nbase +\n  theme_minimal(base_family = \"Georgia\") +\n  theme(\n    plot.background = element_rect(fill = \"linen\"),\n    panel.grid.major = element_line(color = \"gray85\"),\n    panel.grid.minor = element_line(color = \"gray90\")\n  )\n\n\n\n\n\n\n\n\n\n\nSystematically explore the effects of hjust when you have a multiline title. Why doesn’t vjust do anything?\n\nAnswer: with multiline titles, hjust affects both lines in the same way, between left justified (0), centered (0.5), and right justified (1). vjust does slightly alter the vertical justification, but not significantly since two lines are just within the vertical margins.\n\nmulti &lt;- base +\n  labs(title = \"Fuel economy declines as engine size increases\\n1999-2008\", subtitle = NULL)\n\nmulti + theme(plot.title = element_text(hjust = 0))\n\n\n\n\n\n\n\nmulti + theme(plot.title = element_text(hjust = 0.25))\n\n\n\n\n\n\n\nmulti + theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\nmulti + theme(plot.title = element_text(hjust = 1))\n\n\n\n\n\n\n\nmulti + theme(plot.title = element_text(hjust = 1, vjust = 0))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Grammar)"
    ]
  },
  {
    "objectID": "analysis/using-Rcpp.html",
    "href": "analysis/using-Rcpp.html",
    "title": "Using Rcpp",
    "section": "",
    "text": "Notes on using Rcpp to implement Poker-Hand-Evaluator in the cards package.\n# no libraries",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/using-Rcpp.html#background",
    "href": "analysis/using-Rcpp.html#background",
    "title": "Using Rcpp",
    "section": "Background",
    "text": "Background\nRcpp provides an interface to C++, which allows rewriting R code in C++ to improve performance. The cards package implements functions that simulate dealing and evaluating poker hands in R and PH Evaluator using python via reticulate. Will the C++ version of PH Evaluator be faster?\nThe Thirteen Simple Steps for Creating An R Package with an External C++ Library vignette provides good high-level guidance on integrating a C++ library into an R package using base R; additional work is needed to implement Rcpp using roxygen2. The source code for the Corels package referenced in the vignette can be found on GitHub: https://github.com/corels/rcppcorels.",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/using-Rcpp.html#test-build",
    "href": "analysis/using-Rcpp.html#test-build",
    "title": "Using Rcpp",
    "section": "Test Build",
    "text": "Test Build\nTo start, I followed PH Evaluator’s instructions to build and test the pheval library, which required installation of cmake using Homebrew (brew install cmake).",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/using-Rcpp.html#example-function",
    "href": "analysis/using-Rcpp.html#example-function",
    "title": "Using Rcpp",
    "section": "Example Function",
    "text": "Example Function\nAs a next step, I implemented a simple example function to ensure Rcpp was working properly. After some research, I added the following code:\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n//' Leading NA\n//'\n//' This function returns a logical vector identifying if\n//' there are leading NA, marking the leading NAs as TRUE and\n//' everything else as FALSE.\n//'\n//' Code from [Rcpp and Roxygen2](https://www.r-bloggers.com/2016/08/rcpp-and-roxygen2/).\n//'\n//' Installed with help from [usethis::use_rcpp()] and roxygen2 instructions on\n//'   [Rcpp](https://roxygen2.r-lib.org/articles/roxygen2.html#rcpp).\n//'\n//' Steps to install:\n//'\n//' 1. Create `src/leading_na.cpp` (this file)\n//' 1. Run [usethis::use_rcpp()], add `@importFrom Rcpp sourceCpp` and\n//'    `@useDynLib cards, .registration = TRUE` to `package.R` as directed\n//' 1. Run [desc::desc_normalize()] and [devtools::document()]\n//'\n//' @param x An integer vector\n//' @export\n// [[Rcpp::export]]\nLogicalVector leading_na(IntegerVector x) {\n  int n = x.size();\n  LogicalVector leading_na(n);\n\n  int i = 0;\n  while((i &lt; n) &&(x[i] == NA_INTEGER)) {\n    leading_na[i] = TRUE;\n    i++;\n  }\n  return leading_na;\n}\nAfter the first two steps, devtools::document() automates the addition of the leading_na() function, R documentation, and Rcpp support to the package.",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/using-Rcpp.html#stub-function",
    "href": "analysis/using-Rcpp.html#stub-function",
    "title": "Using Rcpp",
    "section": "Stub Function",
    "text": "Stub Function\nAs a next step, I implemented a stub function with help from Rcpp for everyone, specifically the chapter on Data types:\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n//' Evaluate a poker hand using PH Evaluator\n//'\n//' Evaluate the rank category of a five card poker hand using\n//'   [PH Evaluator](https://github.com/HenryRLee/PokerHandEvaluator).\n//'\n//' Currently implemented as a stub function that always returns \"poker_hand\".\n//'\n//' @return string hand rank\n//' @export\n// [[Rcpp::export]]\nString eval_hand_phe() {\n  return \"poker_hand\";\n}\nThe stub works, and suggests an approach for a first implementation using Rcpp: create a function that calls phevaluator::EvaluateCards() and returns a string based on Rank.category() or Rank.describeCategory, following cpp_example.cc. A more complete implementation would use Rcpp Modules to expose the C++ classes and methods in PH Evaluator, with help from the RcppStudent R package.\nAdditional examples implementing C++ libraries in Rcpp I found include RcppAnnoy, written by Rcpp author and maintainer Dirk Eddelbuettel, rxylib, and RcppSundials.\n\nAdd Headers\nTo start the first implementation, I added the headers from cpp_example.cc:\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n#include &lt;phevaluator/phevaluator.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n\n//' Evaluate a poker hand using PH Evaluator\n//'\n//' Evaluate the rank category of a five card poker hand using\n//'   [PH Evaluator](https://github.com/HenryRLee/PokerHandEvaluator).\n//'\n//' Implemented following\n//'   [`cpp_example.cc`](https://github.com/HenryRLee/PokerHandEvaluator/blob/master/cpp/examples/cpp_example.cc)\n//'   and [RcppAnnoy](https://github.com/eddelbuettel/rcppannoy).\n//'\n//' Currently implemented as a stub function that always returns \"poker_hand\".\n//'\n//' @param hand a hand of cards (an integer vector of length 5).\n//' @return string hand rank.\n//' @export\n// [[Rcpp::export]]\nString eval_hand_phe(IntegerVector hand) {\n  // phevaluator::Rank rank = phevaluator::EvaluateCards(hand[0], hand[1], hand[2], hand[3], hand[4]);\n  // return rank.describeCategory();\n  return \"poker_hand\";\n}\nTo get the updated code to compile, I had to add src/Makevars, which I copied from RcppAnnoy, and also added the cpp/include directory from PH Evaluator to inst/.\nsrc/Makevars:\nPKG_CPPFLAGS = -I../inst/include/\nWhile this code compiled, to get the commented code working, I’d need to add the code from cpp/src. Just dumping the files from PH Evaluator into src/ didn’t work, but the rxylib Makevars file offered a clue: adapt the Makefile from PH Evaluator to the R Makevars format to properly build the library objects. Put another way, follow how rxylib translated xlib/Makefile.am to Makevars. The Stack Overflow question referenced in rxylib provided additional details on the Makevars file format.",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/using-Rcpp.html#full-implementation",
    "href": "analysis/using-Rcpp.html#full-implementation",
    "title": "Using Rcpp",
    "section": "Full Implementation",
    "text": "Full Implementation\nAfter some experimentation, I added the following files from PH Evaluator’s cpp/src to src/:\n7462.c\ndptables.c\nevaluator5.c\nevaluator5.cc\nhash.c\nhash.h\nhashtable.c\nhashtable5.c\nrank.c\ntables.h\ntables_bitwise.c\nThese were the minimal files needed to support the first implementation, which only had to support evaluation of 5 card hands.\nI also added a line to src/Makevars to enable the C++ 17 standard used by PH Evaluator:\nPKG_CPPFLAGS = -I../inst/include/\nCXX_STD = CXX17\nThis nearly compiled, but failed with an error:\n   duplicate symbol '_evaluate_5cards' in:\n       /Users/agamemnon/GitHub/cards/src/evaluator5.o\n       /Users/agamemnon/GitHub/cards/src/evaluator5.o\nUltimately this error was the result of two files with the same name but different file extensions (evaluator5.c and evaluator5.cc). Renaming evaluator5.c to evaluator_5_c.c fixed the issue, and the code below compiled and tested properly!\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n#include &lt;phevaluator/phevaluator.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n\n//' Evaluate a poker hand using PH Evaluator\n//'\n//' Evaluate the rank category of a five card poker hand using\n//'   [PH Evaluator](https://github.com/HenryRLee/PokerHandEvaluator).\n//'\n//' Implemented following\n//'   [Rcpp-libraries](https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-libraries.pdf),\n//'   PH Evaluator\n//'   [`cpp_example.cc`](https://github.com/HenryRLee/PokerHandEvaluator/blob/master/cpp/examples/cpp_example.cc),\n//'   and [RcppAnnoy](https://github.com/eddelbuettel/rcppannoy), with help from\n//'   R-Bloggers [Rcpp and Roxygen2](https://www.r-bloggers.com/2016/08/rcpp-and-roxygen2/),\n//'   [usethis::use_rcpp()], roxygen2 instructions on\n//'   [Rcpp](https://roxygen2.r-lib.org/articles/roxygen2.html#rcpp),\n//'   [Rcpp for everyone](https://teuder.github.io/rcpp4everyone_en/), the rxylib\n//'   [`Makefile`](https://github.com/R-Lum/rxylib/blob/master/src/Makevars) and\n//'   [Stack Overflow](https://stackoverflow.com/questions/43597632/understanding-the-contents-of-the-makevars-file-in-r-macros-variables-r-ma).\n//'\n//' `eval_hand_phe` returns one of the rank categories \"Straight Flush\", \"Four of a Kind\",\n//'   \"Full House\", \"Flush\", \"Straight\", \"Three of a Kind\", \"Two Pair\", \"One Pair\", or \"High Card\".\n//'\n//' \"Royal Flush\" and \"Jacks or Better\" are not currently supported.\n//'\n//' @param hand a hand of cards (an integer vector of length 5).\n//' @return string hand rank.\n//' @examples\n//' hand &lt;- deal_hand(new_deck())\n//' print_hand(hand)\n//' eval_hand_phe(hand)\n//' @export\n// [[Rcpp::export]]\nString eval_hand_phe(IntegerVector hand) {\n  phevaluator::Rank rank = phevaluator::EvaluateCards(hand[0], hand[1], hand[2], hand[3], hand[4]);\n  return rank.describeCategory();\n}\nAfter this, I removed the example function, added a C/C++ benchmark, and published cards 0.3.0.\n\nFollow-up\nI did some additional research, and there doesn’t seem to be a simple way to change R to compile using filename.cc.o instead of filename.o, as it goes against the intent of the R developers, as described in this Stack Overflow article:\n\nThe clear recommendation on r-devel (please check the archives) is that you should avoid Makefile logic if you can. IIRC this echoed in the Writing R Extension manual.\n\nSo, it seems the right answer is to rename the files to avoid this conflict. Additionally, after reading a tidyverse blog post on New CRAN requirements for packages with C and C++, I learned that the R C++ standard was now C++17, so I technically did not need that line in the Makevars file, but I decided to keep it as it was an upstream requirement.\nI also discovered an example package that explained how to put code in a subdirectory of src/, which I plan to use for the second version using Rcpp Modules.\nI later added a script to copy (or update) the PH Evaluator source and header files to the cards package, to automate future updates if needed.\nAfter reading through the Creating R Packages chapter of Writing R Extensions and evaluating my options, I am inclined to use a simple approach to creating a “phevaluator” package, copying the necessary files into src/ (with a shell script for reproducibility), use a minimal Makevars file, and use Rcpp Modules to expose the C++ classes and methods in PH Evaluator, following the approach used by the RcppStudent R package.",
    "crumbs": [
      "Changelog",
      "Using Rcpp"
    ]
  },
  {
    "objectID": "analysis/fizzbuzz.html",
    "href": "analysis/fizzbuzz.html",
    "title": "FizzBuzz",
    "section": "",
    "text": "My implementation of FizzBuzz in R, using a vector function.\nlibrary(dplyr)",
    "crumbs": [
      "Changelog",
      "FizzBuzz"
    ]
  },
  {
    "objectID": "analysis/fizzbuzz.html#fizzbuzz",
    "href": "analysis/fizzbuzz.html#fizzbuzz",
    "title": "FizzBuzz",
    "section": "FizzBuzz",
    "text": "FizzBuzz\nAn R implementation of Fizz Buzz, using the instructions from Rosetta Code.\n\nFirst Implementation\nMy implementation, written first.\nThe function:\n\nfizz_buzz &lt;- function(x) {\n  fb_single &lt;- function(n) {\n    if (n %% 3 == 0 && n %% 5 == 0) {\n      \"FizzBuzz\"\n    } else if (n %% 5 == 0) {\n      \"Buzz\"\n    } else if (n %% 3 == 0) {\n      \"Fizz\"\n    } else {\n      # use as.character() so all return values match character(1)\n      as.character(n)\n    }\n  }\n  vapply(x, fb_single, character(1))\n}\n\nThe task:\n\nfizz_buzz(1:100)\n\n  [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n  [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n [13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n [19] \"19\"       \"Buzz\"     \"Fizz\"     \"22\"       \"23\"       \"Fizz\"    \n [25] \"Buzz\"     \"26\"       \"Fizz\"     \"28\"       \"29\"       \"FizzBuzz\"\n [31] \"31\"       \"32\"       \"Fizz\"     \"34\"       \"Buzz\"     \"Fizz\"    \n [37] \"37\"       \"38\"       \"Fizz\"     \"Buzz\"     \"41\"       \"Fizz\"    \n [43] \"43\"       \"44\"       \"FizzBuzz\" \"46\"       \"47\"       \"Fizz\"    \n [49] \"49\"       \"Buzz\"     \"Fizz\"     \"52\"       \"53\"       \"Fizz\"    \n [55] \"Buzz\"     \"56\"       \"Fizz\"     \"58\"       \"59\"       \"FizzBuzz\"\n [61] \"61\"       \"62\"       \"Fizz\"     \"64\"       \"Buzz\"     \"Fizz\"    \n [67] \"67\"       \"68\"       \"Fizz\"     \"Buzz\"     \"71\"       \"Fizz\"    \n [73] \"73\"       \"74\"       \"FizzBuzz\" \"76\"       \"77\"       \"Fizz\"    \n [79] \"79\"       \"Buzz\"     \"Fizz\"     \"82\"       \"83\"       \"Fizz\"    \n [85] \"Buzz\"     \"86\"       \"Fizz\"     \"88\"       \"89\"       \"FizzBuzz\"\n [91] \"91\"       \"92\"       \"Fizz\"     \"94\"       \"Buzz\"     \"Fizz\"    \n [97] \"97\"       \"98\"       \"Fizz\"     \"Buzz\"    \n\n\nTo solve this, I first wrote the task, then wrote the function. I took advantage of the fact that R will print the return output of a function by default.\nFor the function, I wanted to use functional programming and avoid a for() loop, and only use base R, so I implemented a function for a single case and used vapply() to apply the function across the vector sequence 1:100. In my original version, I used unlist(lapply()) because I couldn’t get vapply() to work. The help for dplyr::case_when() includes a FizzBuzz example with as.character() so that the return type is always the same; I adapted this to my initial base R solution.\n\n\ndplyr\nUsing dplyr::case_when() allows much simpler code: (R doesn’t have a built-in ‘case’ statement)\n\nfizz_buzz_d &lt;- function(x) {\n  dplyr::case_when(\n    # x %% 15 == 0 is equivalent to x %% 5 == 0 && x %% 3 == 0\n    x %% 15 == 0 ~ \"FizzBuzz\",\n    x %% 5 == 0 ~ \"Buzz\",\n    x %% 3 == 0 ~ \"Fizz\",\n    .default = as.character(x)\n  )\n}\n\nfizz_buzz_d(1:100)\n\n  [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n  [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n [13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n [19] \"19\"       \"Buzz\"     \"Fizz\"     \"22\"       \"23\"       \"Fizz\"    \n [25] \"Buzz\"     \"26\"       \"Fizz\"     \"28\"       \"29\"       \"FizzBuzz\"\n [31] \"31\"       \"32\"       \"Fizz\"     \"34\"       \"Buzz\"     \"Fizz\"    \n [37] \"37\"       \"38\"       \"Fizz\"     \"Buzz\"     \"41\"       \"Fizz\"    \n [43] \"43\"       \"44\"       \"FizzBuzz\" \"46\"       \"47\"       \"Fizz\"    \n [49] \"49\"       \"Buzz\"     \"Fizz\"     \"52\"       \"53\"       \"Fizz\"    \n [55] \"Buzz\"     \"56\"       \"Fizz\"     \"58\"       \"59\"       \"FizzBuzz\"\n [61] \"61\"       \"62\"       \"Fizz\"     \"64\"       \"Buzz\"     \"Fizz\"    \n [67] \"67\"       \"68\"       \"Fizz\"     \"Buzz\"     \"71\"       \"Fizz\"    \n [73] \"73\"       \"74\"       \"FizzBuzz\" \"76\"       \"77\"       \"Fizz\"    \n [79] \"79\"       \"Buzz\"     \"Fizz\"     \"82\"       \"83\"       \"Fizz\"    \n [85] \"Buzz\"     \"86\"       \"Fizz\"     \"88\"       \"89\"       \"FizzBuzz\"\n [91] \"91\"       \"92\"       \"Fizz\"     \"94\"       \"Buzz\"     \"Fizz\"    \n [97] \"97\"       \"98\"       \"Fizz\"     \"Buzz\"    \n\n\n\n\nfor loop\nThe simplest way to solve this is with a for loop:\n\nfor (n in 1:100) {\n  if (n %% 3 == 0 && n %% 5 == 0) {\n    print(\"FizzBuzz\")\n  } else if (n %% 5 == 0) {\n    print(\"Buzz\")\n  } else if (n %% 3 == 0) {\n    print(\"Fizz\")\n  } else {\n    print(n)\n  }\n}\n\n[1] 1\n[1] 2\n[1] \"Fizz\"\n[1] 4\n[1] \"Buzz\"\n[1] \"Fizz\"\n[1] 7\n[1] 8\n[1] \"Fizz\"\n[1] \"Buzz\"\n[1] 11\n[1] \"Fizz\"\n[1] 13\n[1] 14\n[1] \"FizzBuzz\"\n[1] 16\n[1] 17\n[1] \"Fizz\"\n[1] 19\n[1] \"Buzz\"\n[1] \"Fizz\"\n[1] 22\n[1] 23\n[1] \"Fizz\"\n[1] \"Buzz\"\n[1] 26\n[1] \"Fizz\"\n[1] 28\n[1] 29\n[1] \"FizzBuzz\"\n[1] 31\n[1] 32\n[1] \"Fizz\"\n[1] 34\n[1] \"Buzz\"\n[1] \"Fizz\"\n[1] 37\n[1] 38\n[1] \"Fizz\"\n[1] \"Buzz\"\n[1] 41\n[1] \"Fizz\"\n[1] 43\n[1] 44\n[1] \"FizzBuzz\"\n[1] 46\n[1] 47\n[1] \"Fizz\"\n[1] 49\n[1] \"Buzz\"\n[1] \"Fizz\"\n[1] 52\n[1] 53\n[1] \"Fizz\"\n[1] \"Buzz\"\n[1] 56\n[1] \"Fizz\"\n[1] 58\n[1] 59\n[1] \"FizzBuzz\"\n[1] 61\n[1] 62\n[1] \"Fizz\"\n[1] 64\n[1] \"Buzz\"\n[1] \"Fizz\"\n[1] 67\n[1] 68\n[1] \"Fizz\"\n[1] \"Buzz\"\n[1] 71\n[1] \"Fizz\"\n[1] 73\n[1] 74\n[1] \"FizzBuzz\"\n[1] 76\n[1] 77\n[1] \"Fizz\"\n[1] 79\n[1] \"Buzz\"\n[1] \"Fizz\"\n[1] 82\n[1] 83\n[1] \"Fizz\"\n[1] \"Buzz\"\n[1] 86\n[1] \"Fizz\"\n[1] 88\n[1] 89\n[1] \"FizzBuzz\"\n[1] 91\n[1] 92\n[1] \"Fizz\"\n[1] 94\n[1] \"Buzz\"\n[1] \"Fizz\"\n[1] 97\n[1] 98\n[1] \"Fizz\"\n[1] \"Buzz\"\n\n\nThe downside to this approach is that it prints each result individually, instead of returning a vector.\n\n\nRosetta Code\nNote: Rosetta Code offers several different solutions for R. The first solution is cleverer yet still understandable use of base R:\n\nxx &lt;- x &lt;- 1:100\nxx[x %% 3 == 0] &lt;- \"Fizz\"\nxx[x %% 5 == 0] &lt;- \"Buzz\"\nxx[x %% 15 == 0] &lt;- \"FizzBuzz\"\nxx\n\n  [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n  [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n [13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n [19] \"19\"       \"Buzz\"     \"Fizz\"     \"22\"       \"23\"       \"Fizz\"    \n [25] \"Buzz\"     \"26\"       \"Fizz\"     \"28\"       \"29\"       \"FizzBuzz\"\n [31] \"31\"       \"32\"       \"Fizz\"     \"34\"       \"Buzz\"     \"Fizz\"    \n [37] \"37\"       \"38\"       \"Fizz\"     \"Buzz\"     \"41\"       \"Fizz\"    \n [43] \"43\"       \"44\"       \"FizzBuzz\" \"46\"       \"47\"       \"Fizz\"    \n [49] \"49\"       \"Buzz\"     \"Fizz\"     \"52\"       \"53\"       \"Fizz\"    \n [55] \"Buzz\"     \"56\"       \"Fizz\"     \"58\"       \"59\"       \"FizzBuzz\"\n [61] \"61\"       \"62\"       \"Fizz\"     \"64\"       \"Buzz\"     \"Fizz\"    \n [67] \"67\"       \"68\"       \"Fizz\"     \"Buzz\"     \"71\"       \"Fizz\"    \n [73] \"73\"       \"74\"       \"FizzBuzz\" \"76\"       \"77\"       \"Fizz\"    \n [79] \"79\"       \"Buzz\"     \"Fizz\"     \"82\"       \"83\"       \"Fizz\"    \n [85] \"Buzz\"     \"86\"       \"Fizz\"     \"88\"       \"89\"       \"FizzBuzz\"\n [91] \"91\"       \"92\"       \"Fizz\"     \"94\"       \"Buzz\"     \"Fizz\"    \n [97] \"97\"       \"98\"       \"Fizz\"     \"Buzz\"    \n\n\nOf all the solutions, I think using dplyr::case_when() is the most readable. If I needed a base R solution in the future, I’d pick the Rosetta version.",
    "crumbs": [
      "Changelog",
      "FizzBuzz"
    ]
  },
  {
    "objectID": "analysis/hockey-cards.html",
    "href": "analysis/hockey-cards.html",
    "title": "Hockey Cards Analysis",
    "section": "",
    "text": "A simple Monte Carlo simulation in R, replicating Julia code from a LinkedIn post.\nlibrary(ggplot2)\nlibrary(jbplot)",
    "crumbs": [
      "Changelog",
      "Hockey Cards Analysis"
    ]
  },
  {
    "objectID": "analysis/hockey-cards.html#background",
    "href": "analysis/hockey-cards.html#background",
    "title": "Hockey Cards Analysis",
    "section": "Background",
    "text": "Background\nI came across an interesting post on LinkedIn that used Monte Carlo simulation to help answer the question “How much is a box of unopened Canadian hockey cards worth?” The example code was in Julia, and I wanted to recreate it in R for comparison.",
    "crumbs": [
      "Changelog",
      "Hockey Cards Analysis"
    ]
  },
  {
    "objectID": "analysis/hockey-cards.html#code",
    "href": "analysis/hockey-cards.html#code",
    "title": "Hockey Cards Analysis",
    "section": "Code",
    "text": "Code\nThe base R code below is functionally equivalent to the Julia code, except it omits the trial ID in the result:\n\ngretsky_cards &lt;- function(trials) {\n  set_cards &lt;- 396\n  carton_cards &lt;- 672\n  cartons &lt;- 16\n  box_cards &lt;- carton_cards * cartons\n\n  replicate(trials, {\n    carton &lt;- sample(1:set_cards, box_cards, replace = TRUE)\n    sum(carton == 99)\n  })\n}\n\ngretskys &lt;- gretsky_cards(10000)\n\nAlso, instead of using a loop, I used replicate(), which I think is easier to use and understand.",
    "crumbs": [
      "Changelog",
      "Hockey Cards Analysis"
    ]
  },
  {
    "objectID": "analysis/hockey-cards.html#answer---base-r",
    "href": "analysis/hockey-cards.html#answer---base-r",
    "title": "Hockey Cards Analysis",
    "section": "Answer - Base R",
    "text": "Answer - Base R\nReplicating the answer in base R:\n\nsummary(gretskys)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  10.00   24.00   27.00   27.13   31.00   47.00 \n\nhist(gretskys)",
    "crumbs": [
      "Changelog",
      "Hockey Cards Analysis"
    ]
  },
  {
    "objectID": "analysis/hockey-cards.html#answer---ggplot2",
    "href": "analysis/hockey-cards.html#answer---ggplot2",
    "title": "Hockey Cards Analysis",
    "section": "Answer - ggplot2",
    "text": "Answer - ggplot2\nUse ggplot2 to create a prettier histogram:\n\nggplot(as.data.frame(gretskys), aes(gretskys)) +\n  geom_hist_bw(binwidth = 1) +\n  labs(title = \"Gretsky cards per case\", x = NULL, y = NULL) +\n  labs(caption = \"Number of occurrences over 10,000 simulations\") +\n  theme_quo()",
    "crumbs": [
      "Changelog",
      "Hockey Cards Analysis"
    ]
  },
  {
    "objectID": "analysis/hockey-cards.html#performance",
    "href": "analysis/hockey-cards.html#performance",
    "title": "Hockey Cards Analysis",
    "section": "Performance",
    "text": "Performance\nHow does the performance compare to Julia?\n\nbench::mark(gretsky_cards(10000))\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n\n# A tibble: 1 × 6\n  expression                min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 gretsky_cards(10000)    1.85s    1.85s     0.542     1.2GB     21.1\n\n\nIn this case, it certainly appears to be slower than the Julia test result which was 1.63 seconds.",
    "crumbs": [
      "Changelog",
      "Hockey Cards Analysis"
    ]
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "MIT License",
    "section": "",
    "text": "MIT License\nCopyright (c) 2024 John Benninghoff\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "analysis/r-books.html",
    "href": "analysis/r-books.html",
    "title": "R Books",
    "section": "",
    "text": "An actively maintained and curated list of R Books and other recommended resources from my reading list.",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#libraries",
    "href": "analysis/r-books.html#libraries",
    "title": "R Books",
    "section": "Libraries",
    "text": "Libraries\nLibraries used in this notebook.\n\nlibrary(palmerpenguins)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(showtext)\nlibrary(cranlogs)\nlibrary(dplyr)",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#getting-started",
    "href": "analysis/r-books.html#getting-started",
    "title": "R Books",
    "section": "Getting Started",
    "text": "Getting Started\nBooks and resources I recommend for learning R.\n\nR for Data Science\nR for Data Science (2e) - Second Edition of Hadley Wickham’s introductory book on R and exploratory data analysis. The book contains example code and exercises in most chapters. I used the first edition as my primary source when I was first learning R, and still recommend the book for beginners who want to learn R. The book teaches the basics of using tidyverse R1 for exploratory data analysis and visualization. A companion book provides suggested solutions to the exercises.\nSample visualization from the first chapter:\n\n# visualization from https://r4ds.hadley.nz/data-visualize#first-steps\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\", shape = \"Species\"\n  ) +\n  scale_color_colorblind()\n\n\n\n\n\n\n\n\n\n\nResources\nIn addition to R for Data Science, I recommend the following resources for new R users:\n\nThe R Graph Gallery - library of charts made with R and ggplot2\nPackages for writing better code:\n\nrenv - for package version management by project\nstyler - for consistent formatting of R code\nlintr - for avoiding common mistakes\n\nStyle guides for writing better code:\n\ntidyverse style guide - implemented by styler\nGoogle’s R Style Guide - a fork of the tidyverse guide\n\n\nrdev, my personalized collection of R development tools, includes all three of these packages and more, along with my own style guide and R environment setup instructions.\n\n\nCustom Fonts\nWorking with custom fonts in R can be problematic, and font support is platform-dependent. By default, R provides default mappings for three device-independent font families: sans (Helvetica or Arial), serif (Times New Roman), and mono (Courier New). On macOS, quartz is the default graphics device, and uses the following fonts:\n\nquartzFonts()\n\n$serif\n[1] \"Times-Roman\"      \"Times-Bold\"       \"Times-Italic\"     \"Times-BoldItalic\"\n\n$sans\n[1] \"Helvetica\"             \"Helvetica-Bold\"        \"Helvetica-Oblique\"    \n[4] \"Helvetica-BoldOblique\"\n\n$mono\n[1] \"Courier\"             \"Courier-Bold\"        \"Courier-Oblique\"    \n[4] \"Courier-BoldOblique\"\n\n\nCustom fonts installed on the local system should work without installing any additional packages:\n\nsize &lt;- 28\n\nggplot() +\n  annotate(\"text\", x = 0, y = 0, label = \"Default\", size = size) +\n  annotate(\"text\", x = 0, y = -1, label = \"Lato\", family = \"Lato\", size = size) +\n  annotate(\"text\", x = 0, y = -2, label = \"Metropolis\", family = \"Metropolis\", size = size) +\n  scale_y_continuous(limits = c(-2.5, 0.5)) +\n  theme_void()\n\n\n\n\n\n\n\n\nThis approach works, but isn’t portable as it introduces hidden dependencies on the custom fonts. The plot above works because I have the Lato and Metropolis fonts installed on the macOS system I use to build this page; on systems without these fonts installed this plot would generate warnings and fallback to the default font:\n\nggplot() +\n  annotate(\"text\", x = 0, y = 0, label = \"Not Missing\", size = size) +\n  annotate(\"text\", x = 0, y = -1, label = \"Missing\", family = \"missing\", size = size) +\n  scale_y_continuous(limits = c(-1.5, 0.5)) +\n  theme_void()\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, : no\nfont could be found for family \"missing\"\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, : no\nfont could be found for family \"missing\"\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, : no\nfont could be found for family \"missing\"\n\n\n\n\n\n\n\n\n\nThere are a few packages that facilitate use of custom fonts in R:\n\nextrafont is an older package that can import fonts for use in PDF, PostScript, and Windows\nshowtext is a newer package that is most often recommended for custom fonts, and can import fonts directly from Google Fonts with font_add_google()\nragg is a graphics back-end that gives access to all installed system fonts, and is recommended as an alternative to showtext\nsystemfonts locates installed fonts using system libraries on macOS and Linux, and Freetype on Windows\n\nOn macOS, no additional packages are needed to access all system fonts, although this may not be the case on other platforms (I haven’t tested). I currently use a combination of base R and showtext. systemfonts can help troubleshoot issues by showing what system fonts R recognizes.\nshowtext will work even with fonts not present on the local system:\n\nfont_add_google(\"Open Sans\")\nshowtext_auto()\n\nggplot() +\n  annotate(\"text\", x = 0, y = 0, label = \"Default\", size = size) +\n  annotate(\"text\", x = 0, y = -1, label = \"Open Sans\", family = \"Open Sans\", size = size) +\n  scale_y_continuous(limits = c(-1.5, 0.5)) +\n  theme_void()\n\n\n\n\n\n\n\n\nAn important caveat: showtext replaces all system fonts when enabled. To disable it and use the standard font system, run:\n\nshowtext_auto(FALSE)\n\nAdditional articles on using custom fonts in R:\n\nhttps://r-graph-gallery.com/custom-fonts-in-R-and-ggplot2.html\nhttps://gradientdescending.com/adding-custom-fonts-to-ggplot-in-r/\nhttps://www.cararthompson.com/posts/2024-01-12-using-fonts-in-r-for-dataviz/2024-01-12_getting-fonts-to-work",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#additional-reading",
    "href": "analysis/r-books.html#additional-reading",
    "title": "R Books",
    "section": "Additional Reading",
    "text": "Additional Reading\nBooks I read to improve my knowledge of R.\n\nR Packages (2e) - the second edition of Hadley Wickham’s book on writing R packages, which I used to build rdev\nAdvanced R - the second edition of Hadley’s book on R programming, which explains the R language (the first edition uses more base R than the second edition)\nAdvanced R Solutions - solutions to exercises from Advanced R\nggplot2: Elegant Graphics for Data Analysis (3e) - the third edition of Hadley’s book on his implementation of Leland Wilkinson’s Grammar of Graphics\nSolutions to ggplot2: Elegant Graphics for Data Analysis - solutions to exercises from ggplot2\n\nMy own notes and solutions to the Advanced R and ggplot2 exercises are available on this site.\n\nraps-with-r\nBuilding reproducible analytical pipelines with R - the stated goal of the book is to improve the reproducibility of data analysis. I don’t recommend this book. Section 1 is a reasonably good introduction to git and GitHub, but introduces trunk-based development without covering linear commit history. Section 2 provides some good advice, but much that I disagree with, including inline use of knitr::knit_child to automate creation of sections (which break the notebook workflow) and fusen to create packages from .Rmd files, which I found to create extra work with no clear benefits over using and/or extending the standard package layout like vertical or my own layout from rdev. (Interestingly, the author of vertical is also switching to Quarto for reproducible research and analysis) I also found the code examples to be inconsistent and a bit clunky.\nChapter 12 gives recommendations on testing: unit testing with some basic examples, assertive programming, Test-Driven Development (TDD), and test coverage. It suggests three packages for R assertions: assertthat, chk, and checkmate. Both chk and checkmate are designed to check function arguments; of the two, checkmate appears to be more robust and built to address the downside of R being a dynamically typed language.\nFor data validation, I currently use stopifnot(), although I may switch to either assertr or validate, which are both popular packages. I validate function arguments using manual checks, but checkmate looks appealing as a way to write more succinct code. Total downloads for the assertr, validate, chk, and checkmate packages for the last month are listed below:\n\ncran_downloads(\n  packages = c(\"assertr\", \"validate\", \"chk\", \"checkmate\"),\n  when = \"last-month\"\n) |&gt;\n  group_by(package) |&gt;\n  summarize(downloads = sum(count), as_of = max(date))\n\n# A tibble: 4 × 3\n  package   downloads as_of     \n  &lt;chr&gt;         &lt;dbl&gt; &lt;date&gt;    \n1 assertr        8170 2025-09-30\n2 checkmate    399400 2025-09-30\n3 chk           31657 2025-09-30\n4 validate       7703 2025-09-30\n\n\n2023-12-29 Update: I’ve started using checkmate to check function arguments and have found that validate is better overall at data validation.\nChapter 13 introduces targets, “a Make-like pipeline tool for statistics and data science in R.” Conceptually, targets is very similar to an R Notebook, but like Make, will skip components that are up to date, and can run targets in parallel to speed up builds. targets can also render R Markdown documents using the tarchetypes package. I found the example target pipeline in the book convoluted and didn’t attempt to follow it. The targets manual explains that it implements two kinds of literate programming:\n\n\nA literate programming source document (or Quarto project) that renders inside an individual target. Here, you define a special kind of target that runs a lightweight R Markdown report which depends on upstream targets.\nTarget Markdown, an overarching system in which one or more Quarto or R Markdown files write the _targets.R file and encapsulate the pipeline.\n\n\nOf these two types, the second is a better fit with my preferred workflow: including multiple self-contained notebooks in a single repository. From the appendix, the design of Target Markdown supports both interactive development using notebooks and running a pipeline non-interactively when rendering the final document. For my work, targets doesn’t offer significant advantages over using R Markdown and Quarto - the only slowdown I typically encounter is when building a site with many notebooks, which the Quarto freeze option handles by only re-rendering documents when the source file changes. (I’m not performing the large, complex computations that targets is designed for)\nChapter 14 covers Docker, and asserts that it is necessary for reproducibility. While using Docker ensures a stable operating system environment, I think the book overstates the case for reproducibility, citing a single example where the operating system changed the results of an analysis because the scripts relied on OS file ordering. Much like use of targets, Docker would be most useful for projects with complex development environments shared across teams, but much of the benefits can be achieved using other approaches, like using OS-independent code. The chapter also encourages using a “frozen” development environment that is updated on a fixed schedule to minimize the impact of frequent updates. This is exactly the opposite of the modern DevOps approach - the issues created by small, frequent updates are smaller and easier to address than the more complex problems created by large upgrades. I always start development by updating packages to the latest production release - while this sometimes introduces issues, they are typically easy to fix, and prioritizing maintenance first improves quality and security.\nAn alternate approach to using Docker is to leverage GitHub Actions, which provides on-demand virtual machines that can be used to consistently test, build, and deploy code. The Tidyverse community provides a library of GitHub Actions for R, which I’ve customized for rdev. In fact, chapter 15 covers use of GitHub Actions using r-lib and presents them as a potential alternative for Docker.\nOverall, I do follow the book’s core recommendations for reproducibility:\n\nUse version control extensively\nUse trunk-based development\nAdopt functional programming and DRY\nUse R Markdown which embeds analysis code and code output directly into the written report\nUse renv to manage dependencies\nPackage all R code and publish using GitHub Pages\nWrite unit tests using testthat\nUse assertions to validate function arguments and imported data\nCheck test coverage using covr\nUse automated builds (but using Quarto instead of targets)\n\nI would consider use of targets and Docker for larger, more complex, or long-lived projects, but I found that fusen offered no clear benefits and wouldn’t recommend its use. I think the biggest lesson I took from the book was to follow DRY a bit more strictly than I currently do, and use more functions, tests, and assertions in my analysis code.\nThe book does reference some interesting reading I’ve added to my list:\n\nJohn M. Chambers. “Object-Oriented Programming, Functional Programming and R.” Statist. Sci. 29 (2) 167 - 180, May 2014. https://doi.org/10.1214/13-STS452\nTrunk-Based Development And Branch By Abstraction\n\nWhile reading the book, I discovered some interesting additional resources:\n\nVertical, a “an R-based structured workflow for creating and sharing research assets in the form of an extended R package”, which I plan to review and compare to rdev\nFour ways to write assertion checks in R - an article on four methods for writing assertions in R:\n\nUse stopifnot() from base R\nUse the assertthat package (last updated March 2019)\nUse the assertive package (last updated July 2020)\nUse the assertr package for data assertions, which works especially well for assertion checks against data frames used in data analysis\n\nI also revisited the validate package, a data validation rules engine, which includes the Data Validation Cookbook (in Future Reading)\n\n\n\nrstats.wtf\nWhat They Forgot to Teach You About R - a book based on a workshop taught by current and former posit employees intended for self-taught data analysts. It’s short, still in draft, and offers good advice on R development (I use almost all the suggestions):\n\nUse an IDE (RStudio)\nDon’t save .RData\nRestart R frequently\nAutomate long workflows using targets\nDon’t use setwd()\nUse RStudio projects\nUse here and fs for paths\nUse “-” as space and “_” as a field delimiter in file names\nUse ISO standard dates (ISO 8601, YYYY-MM-DD)\nUse version control (git, GitHub)\nUse renv, rig, and homebrew\nUse .Renviron and .Rprofile\nUse CRAN R and CRAN binaries to speed up package installation\nDon’t use Conda (for Python)\nUpdate packages!\nUse debugging commands and RStudio for troubleshooting\nSearch for error messages and read the source code to understand your problem\n\nThe book also suggests use of the Posit Public Package Manager (P3M). I’d like to agree with this advice, however, I’ve had problems with their binaries; this package (rtraining) doesn’t work when using P3M, and works fine with CRAN binary packages.\n\n\ndo4ds\nDevOps for Data Science, another book written by a Posit employee was brought to my attention thanks to a LinkedIn Post by @Corey Neskey (It included a reference to rstats.wtf, which I read first). The book is split into 3 sections:\n\nDevOps Lessons for Data Science (Chapters 1-6)\nIT/Admin for Data Science (Chapters 7-14)\nEnterprise-Grade Data Science (Chapters 15-18)\n\nI chose not to do the exercises in the book.\nChapters 1-6 cover basic software engineering concepts including library/package management, the three-tier application model, types of projects (jobs, apps, reports, and APIs), connecting to databases and APIs, logging and monitoring, deploying code with CI/CD in dev, test, and production (including branching strategy) and Docker.\nUseful references from the first section include:\n\npins, a package for publishing data, models, and other R objects to folders or cloud storage, including AWS, Azure, GCP, Google Drive, OneDrive, and Dropbox.\nvetiver, R and Python libraries designed to version, deploy, and monitor a trained ML model.\nMastering Shiny, Hadley Wickham’s book on R Shiny, published in 2021.\n\nChapters 7-14 cover basic infrastructure engineering concepts, including cloud computing (IaaS, PaaS, and SaaS), the command line (terminals, shells, and SSH), Linux (Unix), scaling hardware, networking, DNS, and TLS (HTTPS).\nI disagreed with the recommendations on macOS terminals and configuration management in chapter 8; I use macOS Terminal and .zprofile and .zshrc respectively. Given my background in infrastructure and systems engineering, most of the section was not new to me, except for AWS, which I haven’t worked with.\nThere was one useful reference from the second section:\n\npaws, an Amazon Web Services SDK for R.\n\nChapters 15-18 cover issues that come up in larger, “enterprise”, organizations. It includes discussion of networking and network security (including proxies), authentication and authorization (including identity and access management: LDAP, SSO, MFA, RBAC and ABAC), infrastructure as code, Docker and Kubernetes, and how enterprise policies affect use of R and Python packages.\nThe third section doesn’t contain labs, and has one useful reference:\n\nhttr2, tools for creating and modifying HTTP requests, then performing them and processing the results.",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#future-reading",
    "href": "analysis/r-books.html#future-reading",
    "title": "R Books",
    "section": "Future Reading",
    "text": "Future Reading\nR books on my reading list.\n\nThe R Manuals - a re-styled version of the original R manuals, published using Quarto (starting with Writing R Extensions)\nR Markdown: The Definitive Guide - written by the author of knitr\nR Markdown Cookbook - the follow-up to The Definitive Guide\nThe Data Validation Cookbook - a book on the R validate package\nDiscovering Statistics Using R - recommended to me as an introduction to statistics using R",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#r-dialects",
    "href": "analysis/r-books.html#r-dialects",
    "title": "R Books",
    "section": "R Dialects",
    "text": "R Dialects\nAn explanatory note on the R dialects of base R and tidyverse R.\nThe R programming language is over 30 years old and has a large number of packages (R libraries) that extend R. Unlike python (a general purpose language), R was designed specifically for analysis, visualization, and statistical modeling, which is why I chose R for data analysis: it has built-in support for data structures like data frames (implemented in python using pandas), vectors, packages for just about any statistical tool you’d need, and of course, ggplot2. In fairness, python is more popular, more robust, and a better tool for some tasks, like data acquisition and machine learning (which were not priorities for my use).\nLike many human languages, R has developed two distinct dialects: base R and tidyverse R. Base R consists of the packages included in the R distribution (base, compiler, datasets, graphics, grDevices, grid, methods, parallel, splines, stats, stats4, tcltk, tools, utils), and the Tidyverse is a collection of packages that implement a domain-specific language for data analysis, originally created by Hadley Wickham.\nIn my experience, tidyverse R is better for data analysis, where base R is better for writing packages - tidyverse functions are closer to natural language, but have many more dependencies. Comparing two popular tools for data manipulation, dplyr (tidyverse R) and data.table (base R) shows these differences.\nThis code snippet is from a short analysis of survey responses using dplyr:\nsurvey_results &lt;- survey_import |&gt;\n  mutate(across(Q1:Q7, ~ case_when(\n    .x == \"strongly disagree\" ~ 1,\n    .x == \"disagree\" ~ 2,\n    .x == \"neither agree nor disagree\" ~ 3,\n    .x == \"agree\" ~ 4,\n    .x == \"strongly agree\" ~ 5\n  ))) |&gt;\n  mutate(Q8 = as.numeric(Q8 == \"Yes\")) |&gt;\n  arrange(end_date)\nThe code is reasonably easy to understand, even if you’re not familiar with R.\nThe same code written in data.table isn’t as clear:\nlikert_5 &lt;- c(\n  \"strongly disagree\", \"disagree\", \"neither agree nor disagree\",\n  \"agree\", \"strongly agree\"\n)\nq_likert &lt;- paste0(\"Q\", 1:7)\nq_yesno &lt;- \"Q8\"\n\nsurvey_results &lt;- copy(survey_import)\nsurvey_results &lt;- survey_results[\n  , (q_likert) := lapply(.SD, \\(x) as.numeric(factor(x, levels = likert_5))),\n  .SDcols = q_likert\n][\n  , (q_yesno) := lapply(.SD, \\(x) as.numeric(x == \"Yes\")),\n  .SDcols = q_yesno\n][\n  order(end_date)\n]\nWhile it may be harder to read, data.table has some clear advantages: it is quite fast, especially with very large datasets, and has no dependencies other than base R, where dplyr has many.\nThese tradeoffs are why I tend to use tidyverse R for analysis and base R for functions (most tidyverse expressions have functional equivalents in base R). Code used in data analysis should be clear and easy to read, which tidyverse R excels at. Packaged functions provide documentation and the source code isn’t typically read, but many dependencies can be problematic; R CMD check will raise a NOTE if there are too many imports.",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/r-books.html#footnotes",
    "href": "analysis/r-books.html#footnotes",
    "title": "R Books",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFor a detailed explanation of “tidyverse R”, see R Dialects↩︎",
    "crumbs": [
      "Changelog",
      "R Books"
    ]
  },
  {
    "objectID": "analysis/cond-prob.html",
    "href": "analysis/cond-prob.html",
    "title": "Conditional Probability",
    "section": "",
    "text": "An exploration of conditional probabilities in R, inspired by a 2015 blog post on the hot hand.\n# no libraries",
    "crumbs": [
      "Changelog",
      "Conditional Probability"
    ]
  },
  {
    "objectID": "analysis/cond-prob.html#background",
    "href": "analysis/cond-prob.html#background",
    "title": "Conditional Probability",
    "section": "Background",
    "text": "Background\nI recently stumbled across a blog post from 2015, “Hey - guess what? There really is a hot hand!” The article had some R code in it that was intriguing, exploring the following proposition the post quoted from a paper it cited:\n\nJack takes a coin from his pocket and decides that he will flip it 4 times in a row, writing down the outcome of each flip on a scrap of paper. After he is done flipping, he will look at the flips that immediately followed an outcome of heads, and compute the relative frequency of heads on those flips. Because the coin is fair, Jack of course expects this conditional relative frequency to be equal to the probability of flipping a heads: 0.5. Shockingly, Jack is wrong. If he were to sample 1 million fair coins and flip each coin 4 times, observing the conditional relative frequency for each coin, on average the relative frequency would be approximately 0.4.\n\nWhat? OK, so let’s follow along with the R code. The first block runs the simulation:\n\nrep &lt;- 1e6\nn &lt;- 4\ndata &lt;- array(sample(c(0, 1), rep * n, replace = TRUE), c(rep, n))\nprob &lt;- rep(NA, rep)\nfor (i in 1:rep) {\n  heads1 &lt;- data[i, 1:(n - 1)] == 1\n  heads2 &lt;- data[i, 2:n] == 1\n  prob[i] &lt;- sum(heads1 & heads2) / sum(heads1)\n}\n\nThe second block naively calculates the average:\n\nprint(mean(prob))\n\n[1] NaN\n\n\nThis doesn’t work since, as the post points out, “sometimes the first three flips are tails, so the probability is 0/0.” Discarding these gets us the correct average, which is approximately 0.4 and not 0.5 as the quote predicts:\n\nprint(mean(prob, na.rm = TRUE))\n\n[1] 0.4046258\n\n\nReading this and trying the code myself led me to ask, What the heck is going on here?",
    "crumbs": [
      "Changelog",
      "Conditional Probability"
    ]
  },
  {
    "objectID": "analysis/cond-prob.html#huh",
    "href": "analysis/cond-prob.html#huh",
    "title": "Conditional Probability",
    "section": "Huh?",
    "text": "Huh?\nLet’s follow along with the R code and try to work out why the conditional probability is 0.4.\n\nSimulation\nLooking at the first part of the code:\nrep &lt;- 1e6\nn &lt;- 4\ndata &lt;- array(sample(c(0, 1), rep * n, replace = TRUE), c(rep, n))\nThis code simulates flipping the coin 4 times in a row 1 million times and stores the results in a matrix:\n\nhead(data)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    0\n[2,]    1    0    1    0\n[3,]    1    0    0    1\n[4,]    1    1    1    0\n[5,]    1    0    0    1\n[6,]    1    0    1    0\n\n\nBy convention, 1 is heads and 0 is tails. If the coin is fair, we should expect the proportion of heads to be about 0.5.\n\nmean(data)\n\n[1] 0.4997455\n\nround(mean(data), 2)\n\n[1] 0.5\n\n\nWhile there is some expected variance, the proportion is approximately 0.5.\n\n\nCalculation\nLooking at the second part of the code:\nprob &lt;- rep(NA, rep)\nfor (i in 1:rep) {\n  heads1 &lt;- data[i, 1:(n - 1)] == 1\n  heads2 &lt;- data[i, 2:n] == 1\n  prob[i] &lt;- sum(heads1 & heads2) / sum(heads1)\n}\nThis counts the relative frequency of heads immediately after heads, by finding heads in positions 1-3 (heads1), comparing to heads in positions 2-4 (heads2), and calculating the proportion of heads after heads (prob[i]). To see how this works in practice, we can test all possible combinations of heads and tails:\n\ncalc_prob &lt;- function(flips) {\n  heads1 &lt;- flips[1:(n - 1)] == 1\n  heads2 &lt;- flips[2:n] == 1\n  sum(heads1 & heads2) / sum(heads1)\n}\n\ntest_data &lt;- expand.grid(0:1, 0:1, 0:1, 0:1)\ntest_prob &lt;- rep(NA, nrow(test_data))\n\nfor (i in seq_len(nrow(test_data))) {\n  f &lt;- test_data[i, ]\n  input &lt;- paste0(\"c(\", toString(f), \")\")\n  test_prob[i] &lt;- calc_prob(f)\n  print(paste0(i, \": \", input, \" = \", test_prob[i]))\n}\n\n[1] \"1: c(0, 0, 0, 0) = NaN\"\n[1] \"2: c(1, 0, 0, 0) = 0\"\n[1] \"3: c(0, 1, 0, 0) = 0\"\n[1] \"4: c(1, 1, 0, 0) = 0.5\"\n[1] \"5: c(0, 0, 1, 0) = 0\"\n[1] \"6: c(1, 0, 1, 0) = 0\"\n[1] \"7: c(0, 1, 1, 0) = 0.5\"\n[1] \"8: c(1, 1, 1, 0) = 0.666666666666667\"\n[1] \"9: c(0, 0, 0, 1) = NaN\"\n[1] \"10: c(1, 0, 0, 1) = 0\"\n[1] \"11: c(0, 1, 0, 1) = 0\"\n[1] \"12: c(1, 1, 0, 1) = 0.5\"\n[1] \"13: c(0, 0, 1, 1) = 1\"\n[1] \"14: c(1, 0, 1, 1) = 0.5\"\n[1] \"15: c(0, 1, 1, 1) = 1\"\n[1] \"16: c(1, 1, 1, 1) = 1\"\n\n\nThere are 16 possible combinations of 4 coin flips, with 5 possible outcomes: 0, 1/2, 2/3, 1, and 0/0 (NaN).\n\n\nHow it works\nLooking at the permutations, the conditional probability starts to make sense. Calculating the conditional relative frequency for all permutations gives us:\n\nmean(test_prob, na.rm = TRUE)\n\n[1] 0.4047619\n\n\nWhich is approximately 0.4. As we repeat coin flips, the frequency approaches this value.\nRecall that the conditional probability is: \\(\\large{P(A \\mid B) = \\frac{P(A \\cap B)}{P(B)}}\\) (I had to look it up).\nIn this case, we are trying to calculate the probability of heads (\\(A\\)) given heads occurring at least once (\\(B\\)), which is equivalent to mean(test_prob, na.rm = TRUE).",
    "crumbs": [
      "Changelog",
      "Conditional Probability"
    ]
  },
  {
    "objectID": "analysis/ggplot2-5.html",
    "href": "analysis/ggplot2-5.html",
    "title": "ggplot2 (Extending)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Extending” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(ggplot2)\nlibrary(wesanderson)\nlibrary(scales)\nlibrary(maps)\nlibrary(dplyr)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Extending)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-5.html#introduction",
    "href": "analysis/ggplot2-5.html#introduction",
    "title": "ggplot2 (Extending)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from ggplot2: Elegant Graphics for Data Analysis and Solutions to ggplot2: Elegant Graphics for Data Analysis, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read the ggplot2 book and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Extending)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-5.html#programming-with-ggplot2",
    "href": "analysis/ggplot2-5.html#programming-with-ggplot2",
    "title": "ggplot2 (Extending)",
    "section": "19 Programming with ggplot2",
    "text": "19 Programming with ggplot2\nA major requirement of a good data analysis is flexibility. If your data changes, or you discover something that makes you rethink your basic assumptions, you need to be able to easily change many plots at once. The main inhibitor of flexibility is code duplication. If you have the same plotting statement repeated over and over again, you’ll have to make the same change in many different places. Often just the thought of making all those changes is exhausting! This chapter will help you overcome that problem by showing you how to program with ggplot2.\nTo make your code more flexible, you need to reduce duplicated code by writing functions. When you notice you’re doing the same thing over and over again, think about how you might generalise it and turn it into a function. If you’re not that familiar with how functions work in R, you might want to brush up your knowledge at https://adv-r.hadley.nz/functions.html.\n\n19.2.1 Exercises\n\nCreate an object that represents a pink histogram with 100 bins.\n\nAnswer: pink_hist applied to the price of diamonds.\n\npink_hist &lt;- geom_histogram(bins = 100, fill = \"pink\")\n\nggplot(diamonds, aes(price)) +\n  pink_hist\n\n\n\n\n\n\n\n\nGG Solutions:\n\npink_hist_ggs &lt;- geom_histogram(\n  color = \"pink\",\n  bins = 100\n)\n\nNote: I think the intent here is to set fill, not color.\n\n\nCreate an object that represents a fill scale with the Blues ColorBrewer palette.\n\nAnswer: blues applied to a geom_bar() example:\n\nblues &lt;- scale_fill_brewer(palette = \"Blues\")\n\nggplot(mpg, aes(class, fill = drv)) +\n  geom_bar() +\n  theme_classic() +\n  blues\n\n\n\n\n\n\n\n\nGG Solutions:\n\nfill_blues &lt;- scale_fill_distiller(\n  palette = \"Blues\"\n)\n\nNote that the documentation states:\n\nThe distiller scales extend brewer scales by smoothly interpolating 7 colours from any palette to a continuous scale.\n\n\n\nRead the source code for theme_grey(). What are its arguments? How does it work?\n\nAnswer: theme_grey() has 4 arguments: base_size, base_family, base_line_size, and base_rect_size. It specifies a complete theme object, t, and uses the %+replace% function to modify an internal global, ggplot_global$theme_all_null using t.\n\ntheme_grey\n\n#&gt; function (base_size = 11, base_family = \"\", header_family = NULL, \n#&gt;     base_line_size = base_size/22, base_rect_size = base_size/22, \n#&gt;     ink = \"black\", paper = \"white\", accent = \"#3366FF\") \n#&gt; {\n#&gt;     half_line &lt;- base_size/2\n#&gt;     t &lt;- theme(line = element_line(colour = ink, linewidth = base_line_size, \n#&gt;         linetype = 1, lineend = \"butt\", linejoin = \"round\"), \n#&gt;         rect = element_rect(fill = paper, colour = ink, linewidth = base_rect_size, \n#&gt;             linetype = 1, linejoin = \"round\"), text = element_text(family = base_family, \n#&gt;             face = \"plain\", colour = ink, size = base_size, lineheight = 0.9, \n#&gt;             hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), \n#&gt;             debug = FALSE), title = element_text(family = header_family), \n#&gt;         spacing = unit(half_line, \"pt\"), margins = margin_auto(half_line), \n#&gt;         point = element_point(colour = ink, shape = 19, fill = paper, \n#&gt;             size = (base_size/11) * 1.5, stroke = base_line_size), \n#&gt;         polygon = element_polygon(fill = paper, colour = ink, \n#&gt;             linewidth = base_rect_size, linetype = 1, linejoin = \"round\"), \n#&gt;         geom = element_geom(ink = ink, paper = paper, accent = accent, \n#&gt;             linewidth = base_line_size, borderwidth = base_line_size, \n#&gt;             linetype = 1L, bordertype = 1L, family = base_family, \n#&gt;             fontsize = base_size, pointsize = (base_size/11) * \n#&gt;                 1.5, pointshape = 19), axis.line = element_blank(), \n#&gt;         axis.line.x = NULL, axis.line.y = NULL, axis.text = element_text(size = rel(0.8), \n#&gt;             colour = col_mix(ink, paper, 0.302)), axis.text.x = element_text(margin = margin(t = 0.8 * \n#&gt;             half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * \n#&gt;             half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * \n#&gt;             half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * \n#&gt;             half_line/2), hjust = 0), axis.text.r = element_text(margin = margin(l = 0.8 * \n#&gt;             half_line/2, r = 0.8 * half_line/2), hjust = 0.5), \n#&gt;         axis.ticks = element_line(colour = col_mix(ink, paper, \n#&gt;             0.2)), axis.ticks.length = rel(0.5), axis.ticks.length.x = NULL, \n#&gt;         axis.ticks.length.x.top = NULL, axis.ticks.length.x.bottom = NULL, \n#&gt;         axis.ticks.length.y = NULL, axis.ticks.length.y.left = NULL, \n#&gt;         axis.ticks.length.y.right = NULL, axis.minor.ticks.length = rel(0.75), \n#&gt;         axis.title.x = element_text(margin = margin(t = half_line/2), \n#&gt;             vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line/2), \n#&gt;             vjust = 0), axis.title.y = element_text(angle = 90, \n#&gt;             margin = margin(r = half_line/2), vjust = 1), axis.title.y.right = element_text(angle = -90, \n#&gt;             margin = margin(l = half_line/2), vjust = 1), legend.background = element_rect(colour = NA), \n#&gt;         legend.spacing = rel(2), legend.spacing.x = NULL, legend.spacing.y = NULL, \n#&gt;         legend.margin = NULL, legend.key = NULL, legend.key.size = unit(1.2, \n#&gt;             \"lines\"), legend.key.height = NULL, legend.key.width = NULL, \n#&gt;         legend.key.spacing = NULL, legend.text = element_text(size = rel(0.8)), \n#&gt;         legend.title = element_text(hjust = 0), legend.ticks.length = rel(0.2), \n#&gt;         legend.position = \"right\", legend.direction = NULL, legend.justification = \"center\", \n#&gt;         legend.box = NULL, legend.box.margin = margin_auto(0), \n#&gt;         legend.box.background = element_blank(), legend.box.spacing = rel(2), \n#&gt;         panel.background = element_rect(fill = col_mix(ink, paper, \n#&gt;             0.92), colour = NA), panel.border = element_blank(), \n#&gt;         panel.grid = element_line(colour = paper), panel.grid.minor = element_line(linewidth = rel(0.5)), \n#&gt;         panel.spacing = NULL, panel.spacing.x = NULL, panel.spacing.y = NULL, \n#&gt;         panel.ontop = FALSE, strip.background = element_rect(fill = col_mix(ink, \n#&gt;             paper, 0.85), colour = NA), strip.clip = \"on\", strip.text = element_text(colour = col_mix(ink, \n#&gt;             paper, 0.1), size = rel(0.8), margin = margin_auto(0.8 * \n#&gt;             half_line)), strip.text.x = NULL, strip.text.y = element_text(angle = -90), \n#&gt;         strip.text.y.left = element_text(angle = 90), strip.placement = \"inside\", \n#&gt;         strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(half_line/2, \n#&gt;             \"pt\"), strip.switch.pad.wrap = unit(half_line/2, \n#&gt;             \"pt\"), plot.background = element_rect(colour = paper), \n#&gt;         plot.title = element_text(size = rel(1.2), hjust = 0, \n#&gt;             vjust = 1, margin = margin(b = half_line)), plot.title.position = \"panel\", \n#&gt;         plot.subtitle = element_text(hjust = 0, vjust = 1, margin = margin(b = half_line)), \n#&gt;         plot.caption = element_text(size = rel(0.8), hjust = 1, \n#&gt;             vjust = 1, margin = margin(t = half_line)), plot.caption.position = \"panel\", \n#&gt;         plot.tag = element_text(size = rel(1.2), hjust = 0.5, \n#&gt;             vjust = 0.5), plot.tag.position = \"topleft\", plot.margin = NULL, \n#&gt;         complete = TRUE)\n#&gt;     ggplot_global$theme_all_null %+replace% t\n#&gt; }\n#&gt; &lt;bytecode: 0x10a6088f8&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n\nGG Solutions:\n\nIts arguments include base_size, base_family, base_line_size, and base_rect_size\nAccording to the help file, theme_gray() is the signature ggplot2 theme with a grey background and white gridlines and is designed to put the data forward yet make comparisons easy.\n\n\n\nCreate scale_colour_wesanderson(). It should have a parameter to pick the palette from the wesanderson package, and create either a continuous or discrete scale.\n\nAnswer: to construct this function, it is helpful to review the code for scale_color_brewer():\n\nscale_color_brewer\n\n#&gt; function (name = waiver(), ..., type = \"seq\", palette = 1, direction = 1, \n#&gt;     aesthetics = \"colour\") \n#&gt; {\n#&gt;     discrete_scale(aesthetics, name = name, palette = pal_brewer(type, \n#&gt;         palette, direction), ...)\n#&gt; }\n#&gt; &lt;bytecode: 0x10cbce328&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n\nThe function is a wrapper for discrete_scale() and calls scales::brewer_pal(), which is a function factory:\n\nscales::brewer_pal\n\n#&gt; function (type = \"seq\", palette = 1, direction = 1) \n#&gt; {\n#&gt;     pal &lt;- pal_name(palette, type)\n#&gt;     force(direction)\n#&gt;     fun &lt;- function(n) {\n#&gt;         if (n &lt; 3) {\n#&gt;             pal &lt;- suppressWarnings(RColorBrewer::brewer.pal(n, \n#&gt;                 pal))\n#&gt;         }\n#&gt;         else {\n#&gt;             pal &lt;- RColorBrewer::brewer.pal(n, pal)\n#&gt;         }\n#&gt;         pal &lt;- pal[seq_len(n)]\n#&gt;         if (direction == -1) {\n#&gt;             pal &lt;- rev(pal)\n#&gt;         }\n#&gt;         pal\n#&gt;     }\n#&gt;     nlevels &lt;- RColorBrewer::brewer.pal.info[pal, \"maxcolors\"]\n#&gt;     new_discrete_palette(fun, \"colour\", nlevels)\n#&gt; }\n#&gt; &lt;bytecode: 0x10d4565f8&gt;\n#&gt; &lt;environment: namespace:scales&gt;\n\n\nFirst we construct a discrete scale, using Darjeeling1 as the default:\n\nwesanderson_pal &lt;- function(name, type) {\n  function(n) {\n    wes_palette(name, n, type)\n  }\n}\n\nscale_color_wesanderson_d &lt;- function(..., name = \"Darjeeling1\", type = \"discrete\",\n                                      aesthetics = \"colour\") {\n  discrete_scale(aesthetics, \"wesanderson_d\", wesanderson_pal(name, type), ...)\n}\n\nNote that these functions are limited by the number of colors in each wesanderson palette (4-7), which will generate an error if more colors are requested. The wesanderson_pal function could be revised to auto-enable continuous or scale_color_wesanderson_d() can be called with type = \"continuous\".\nFor a continuous scale, it is helpful to review the code of scale_color_viridis_c():\n\nscale_color_viridis_c\n\n#&gt; function (name = waiver(), ..., alpha = 1, begin = 0, end = 1, \n#&gt;     direction = 1, option = \"D\", values = NULL, space = \"Lab\", \n#&gt;     na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\") \n#&gt; {\n#&gt;     continuous_scale(aesthetics, name = name, palette = pal_gradient_n(pal_viridis(alpha, \n#&gt;         begin, end, direction, option)(6), values, space), na.value = na.value, \n#&gt;         guide = guide, ...)\n#&gt; }\n#&gt; &lt;bytecode: 0x10a733ef0&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n\nWe can add a continuous scale based using Zissou1 as the default:\n\nscale_color_wesanderson_c &lt;- function(...,\n                                      name = \"Zissou1\",\n                                      type = \"continuous\",\n                                      values = NULL,\n                                      space = \"Lab\",\n                                      na.value = \"grey50\",\n                                      guide = \"colourbar\",\n                                      aesthetics = \"colour\") {\n  continuous_scale(\n    aesthetics, \"wesanderson_c\",\n    gradient_n_pal(wesanderson_pal(name, type)(length(wes_palettes[[name]])), values, space),\n    na.value = na.value, guide = guide, ...\n  )\n}\n\nscale_colour_wesanderson_d() applied to an mpg plot:\n\nggplot(mpg, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  scale_color_wesanderson_d()\n\n#&gt; Warning: The `scale_name` argument of `discrete_scale()` is deprecated as of ggplot2\n#&gt; 3.5.0.\n\n\n\n\n\n\n\n\n\nscale_colour_wesanderson_c() applied to an mpg plot:\n\nggplot(mpg, aes(displ, hwy, color = cyl)) +\n  geom_point() +\n  scale_color_wesanderson_c()\n\n#&gt; Warning: The `scale_name` argument of `continuous_scale()` is deprecated as of ggplot2\n#&gt; 3.5.0.\n\n\n\n\n\n\n\n\n\nNotes: while the exercise calls for a single function, this breaks the normal conventions for ggplot2. Such a function could be written by combining scale_colour_wesanderson_d() and scale_colour_wesanderson_c().\nGG Solutions:\n\nscale_colour_wesanderson &lt;- function(palette = \"BottleRocket1\", ...) {\n  scale_color_manual(values = wesanderson::wes_palette(palette), ...)\n}\n# Working example\nggplot(mtcars, aes(wt, disp, color = factor(gear))) +\n  geom_point() +\n  scale_colour_wesanderson()\n\n\n\n\n\n\n\n\n\n\n\n19.3.4 Exercises\n\nTo make the best use of space, many examples in this book hide the axes labels and legend. I’ve just copied-and-pasted the same code into multiple places, but it would make more sense to create a reusable function. What would that function look like?\n\nAnswer: hide_ll() does this, demonstrated with an mpg plot.\n\nhide_ll &lt;- function() {\n  list(\n    labs(x = NULL, y = NULL),\n    theme(legend.position = \"none\")\n  )\n}\n\nggplot(mpg, aes(displ, hwy, color = drv)) +\n  geom_point() +\n  hide_ll()\n\n\n\n\n\n\n\n\nGG Solutions:\n\nremove_labels &lt;- theme(\n  legend.position = \"none\",\n  axis.title.x = element_blank(),\n  axis.title.y = element_blank()\n)\n# Working Example\nggplot(mtcars, aes(wt, disp, color = factor(gear))) +\n  geom_point() +\n  remove_labels\n\n\n\n\n\n\n\n\nNote: the GG Solutions answer is more verbose, but uses only a single function call (theme).\n\n\nExtend the borders() function to also add coord_quickmap() to the plot.\n\nAnswer: borders_quickmap() implemented and demonstrated using a borders() example. In this case, the function passes all ... variables to borders() and none to coord_quickmap() which avoids the complexity of handling arguments for both functions.\n\nborders_quickmap &lt;- function(...) {\n  list(\n    borders(...),\n    coord_quickmap()\n  )\n}\n\nus.cities |&gt;\n  filter(capital == 2, !(country.etc %in% c(\"AK\", \"HI\"))) |&gt;\n  ggplot(aes(long, lat)) +\n  geom_point() +\n  borders_quickmap(\"state\") +\n  theme_void()\n\n#&gt; Warning: `borders()` was deprecated in ggplot2 4.0.0.\n#&gt; ℹ Please use `annotation_borders()` instead.\n\n\n\n\n\n\n\n\n\nNote: because of the complexities, it’s unlikely I’d ever implement something like Additional arguments - there are minimal gains compared to calling two functions with separate lists of parameters.\nGG Solutions: Not sure.\n\n\nLook through your own code. What combinations of geoms or scales do you use all the time? How could you extract the pattern into a reusable function?\n\nAnswer: a common pattern I use is geom_smooth with lm and y ~ x. An implementation of this using robust linear modeling from MASS is demonstrated below:\n\ngeom_rlm &lt;- function(mapping = NULL, data = NULL, stat = \"smooth\", position = \"identity\", ...,\n                     method = MASS::rlm, formula = y ~ x, se = TRUE,\n                     na.rm = FALSE,\n                     orientation = NA,\n                     show.legend = NA, inherit.aes = TRUE) {\n  geom_smooth(\n    mapping = mapping, data = data, stat = stat, position = position, ...,\n    method = method, formula = formula, se = se, na.rm = na.rm, orientation = orientation,\n    show.legend = show.legend, inherit.aes = TRUE\n  )\n}\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_rlm()\n\n\n\n\n\n\n\n\nGG Solutions: no answer.\n\n\n\n19.4.2 Exercises\n\nCreate a distribution() function specially designed for visualising continuous distributions. Allow the user to supply a dataset and the name of a variable to visualise. Let them choose between histograms, frequency polygons, and density plots. What other arguments might you want to include?\n\nAnswer: code below. In this case, it is useful to include binwidth and bins, used in creating both histograms and frequency polygons, and na.rm, used in all three. Defaults to histogram.\n\ndistribution &lt;- function(data, var, type = \"histogram\", binwidth = NULL, bins = NULL,\n                         na.rm = FALSE) {\n  ggplot(data, aes({{ var }})) +\n    switch(type,\n      histogram = geom_histogram(binwidth = binwidth, bins = bins, na.rm = na.rm),\n      freqpoly = geom_freqpoly(binwidth = binwidth, bins = bins, na.rm = na.rm),\n      density = geom_density(na.rm = na.rm),\n      stop(\"`type` must be histogram, freqpoly, or density\")\n    )\n}\n\ndistribution(diamonds, price, binwidth = 100)\n\n\n\n\n\n\n\ndistribution(diamonds, price, type = \"freqpoly\", binwidth = 100)\n\n\n\n\n\n\n\ndistribution(diamonds, price, type = \"density\")\n\n\n\n\n\n\n\ntry(distribution(diamonds, price, type = \"other\"))\n\n#&gt; Error in distribution(diamonds, price, type = \"other\") : \n#&gt;   `type` must be histogram, freqpoly, or density\n\n\n\n\nWhat additional arguments should pcp() take? What are the downsides of how ... is used in the current code?\n\nAnswer: it would be useful to add arguments for the order of the variables, and a scale adjustment for value, drawing from examples on Wikipedia. Using ... for geom_line() prevents other unnamed parameters from being passed to other functions, like ggplot().\n\n\n\n19.5.1 Exercises\n\nHow could you add a geom_point() layer to each element of the following list?\n\n\nplots &lt;- list(\n  ggplot(mpg, aes(displ, hwy)),\n  ggplot(diamonds, aes(carat, price)),\n  ggplot(faithfuld, aes(waiting, eruptions, size = density))\n)\n\nAnswer: easily done with lapply()`:\n\nlapply(plots, function(g) g + geom_point())\n\n#&gt; [[1]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[2]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[3]]\n\n\n\n\n\n\n\n\n\n\n\nWhat does the following function do? What’s a better name for it?\n\n\nmystery &lt;- function(...) {\n  Reduce(`+`, list(...), accumulate = TRUE)\n}\n\nmystery(\n  ggplot(mpg, aes(displ, hwy)) +\n    geom_point(),\n  geom_smooth(),\n  xlab(NULL),\n  ylab(NULL)\n)\n\n#&gt; [[1]]\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[2]]\n\n\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[3]]\n\n\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n#&gt; \n#&gt; [[4]]\n\n\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nAnswer: a better name would be ‘add layer and print’.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Extending)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html",
    "href": "analysis/ggplot2-3.html",
    "title": "ggplot2 (Scales)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Scales” chapters of ggplot2: Elegant Graphics for Data Analysis, third edition, with comparisons to solutions from Solutions to ggplot2: Elegant Graphics for Data Analysis.\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(jbplot)\n\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#introduction",
    "href": "analysis/ggplot2-3.html#introduction",
    "title": "ggplot2 (Scales)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from ggplot2: Elegant Graphics for Data Analysis and Solutions to ggplot2: Elegant Graphics for Data Analysis, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read the ggplot2 book and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#position-scales-and-axes",
    "href": "analysis/ggplot2-3.html#position-scales-and-axes",
    "title": "ggplot2 (Scales)",
    "section": "10 Position scales and axes",
    "text": "10 Position scales and axes\nPosition scales are used to control the locations of visual entities in a plot, and how those locations are mapped to data values. Every plot has two position scales, corresponding to the x and y aesthetics. In most cases this is clear in the plot specification, because the user explicitly specifies the variables mapped to x and y explicitly. However, this is not always the case. Consider this plot specification:\n\nggplot(mpg, aes(x = displ)) +\n  geom_histogram()\n\nIn this example the y aesthetic is not specified by the user. Rather, the aesthetic is mapped to a computed variable: geom_histogram() computes a count variable that gets mapped to the y aesthetic. The default behaviour of geom_histogram() is equivalent to the following:\n\nggplot(mpg, aes(x = displ, y = after_stat(count))) +\n  geom_histogram()\n\nBecause position scales are used in every plot, it is useful to understand how they work and how they can be modified.\n\nNotes\nThe goal of label_date_short() is to automatically construct short labels that are sufficient to uniquely identify the dates:\n\nggplot(economics, aes(date, psavert)) +\n  geom_line(na.rm = TRUE) +\n  labs(x = NULL, y = NULL) +\n  scale_x_date(limits = as.Date(c(\"2004-01-01\", \"2005-01-01\")), labels = scales::label_date_short())\n\n\n\n\n\n\n\n\nLet’s create a plot with rotated labels!\n\nggplot(mpg, aes(manufacturer, hwy)) +\n  geom_boxplot() +\n  guides(x = guide_axis(angle = 90))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#colour-scales-and-legends",
    "href": "analysis/ggplot2-3.html#colour-scales-and-legends",
    "title": "ggplot2 (Scales)",
    "section": "11 Colour scales and legends",
    "text": "11 Colour scales and legends\nA comparison of different color scales:\n\nerupt &lt;- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) +\n  geom_raster() +\n  scale_x_continuous(NULL, expand = c(0, 0)) +\n  scale_y_continuous(NULL, expand = c(0, 0)) +\n  theme(legend.position = \"none\")\n\nerupt\n\n\n\n\n\n\n\nerupt + scale_fill_viridis_c()\n\n\n\n\n\n\n\nerupt + scale_fill_viridis_c(option = \"magma\")\n\n\n\n\n\n\n\n\n\nMissing values\nAll continuous colour scales have an na.value parameter that controls what colour is used for missing values (including values outside the range of the scale limits). By default it is set to grey, which will stand out when you use a colourful scale. If you use a black and white scale, you might want to set it to something else to make it more obvious. You can set na.value = NA to make missing values invisible, or choose a specific colour if you prefer:\n\ndf &lt;- data.frame(x = 1, y = 1:5, z = c(1, 3, 2, NA, 5))\nbase &lt;- ggplot(df, aes(x, y)) +\n  geom_tile(aes(fill = z), linewidth = 5) +\n  labs(x = NULL, y = NULL) +\n  scale_x_continuous(labels = NULL)\nbase\n\n\n\n\n\n\n\nbase + scale_fill_gradient(na.value = NA)\n\n\n\n\n\n\n\nbase + scale_fill_gradient(na.value = \"yellow\")\n\n\n\n\n\n\n\n\n\n\nLimits, breaks, and labels\nScale limits for discrete colour scales can be set using the limits argument to the scale argument, or by using the lims() helper function. This can be important when the same variable is represented in different plots, and you want to ensure that the colours are consistent across plots. To demonstrate this I’ll extend the example from Section 10.1.1. Colour represents the fuel type, which can be regular, ethanol, diesel, premium or compressed natural gas.\n\nmpg_99 &lt;- mpg %&gt;% filter(year == 1999)\nmpg_08 &lt;- mpg %&gt;% filter(year == 2008)\nbase_99 &lt;- ggplot(mpg_99, aes(displ, hwy, colour = fl)) +\n  geom_point()\nbase_08 &lt;- ggplot(mpg_08, aes(displ, hwy, colour = fl)) +\n  geom_point()\nbase_99\n\n\n\n\n\n\n\nbase_08\n\n\n\n\n\n\n\n\nEach plot makes sense on its own, but visual comparison between the two is difficult. The axis limits are different, and because only regular, premium and diesel fuels are represented in the 1998 data the colours are mapped inconsistently. To ensure a consistent mapping for the colour aesthetic, we can use lims() to manually set the limits. As discussed in Section 10.1.1 it takes name-value pairs as input, where the name specifies the aesthetic and the value specifies the limits:\n\nbase_99 + lims(colour = c(\"c\", \"d\", \"e\", \"p\", \"r\"))\n\n\n\n\n\n\n\nbase_08 + lims(colour = c(\"c\", \"d\", \"e\", \"p\", \"r\"))\n\n\n\n\n\n\n\n\nThe nice thing about lims() is that we can set the limits for multiple aesthetics at once. To ensure that x, y, and colour all use consistent limits we can do this:\n\nbase_99 +\n  lims(\n    x = c(1, 7),\n    y = c(10, 45),\n    colour = c(\"c\", \"d\", \"e\", \"p\", \"r\")\n  )\n\n\n\n\n\n\n\nbase_08 +\n  lims(\n    x = c(1, 7),\n    y = c(10, 45),\n    colour = c(\"c\", \"d\", \"e\", \"p\", \"r\")\n  )\n\n\n\n\n\n\n\n\nThere are two potential limitations to these plots. First, while setting the scale limits does ensure that colours are mapped identically in both plots, it also means that the plot for the 1999 data displays labels for all five fuel types, despite the fact that ethanol and compressed natural gas fuels were not in use at that time. We can address this by manually setting the scale breaks, ensuring that only those fuel types that appear in the data are shown in the legend. The second limitation is that the labels are not particularly helpful, which we can address by specifying them manually. When setting multiple properties of a single scale, it can be more useful to customise using the arguments to the scale function rather than using the lims() helper function:\n\nbase_99 +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    breaks = c(\"d\", \"p\", \"r\"),\n    labels = c(\"diesel\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\n\nHowever, there is nothing stopping you from using lims() to control the position aesthetic limits, while using scale_colour_discrete() to exercise more fine-grained control over the colour aesthetic:\n\nbase_99 +\n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    breaks = c(\"d\", \"p\", \"r\"),\n    labels = c(\"diesel\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\nbase_08 +\n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"),\n    labels = c(\"compressed\", \"diesel\", \"ethanol\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\n\n\n\nLegends\n\noverride.aes is useful when you want the elements in the legend display differently to the geoms in the plot. This is often required when you’ve used transparency or size to deal with moderate overplotting and also used colour in the plot.\n\n\nbase &lt;- ggplot(mpg, aes(displ, hwy, colour = drv)) +\n  geom_point(size = 4, alpha = 0.2, stroke = 0)\n\nbase + guides(colour = guide_legend())\n\n\n\n\n\n\n\nbase + guides(colour = guide_legend(override.aes = list(alpha = 1)))\n\n\n\n\n\n\n\n\n\n\nBinned colour scales\nColour scales also come in binned versions. The default scale is scale_fill_binned() which in turn defaults to scale_fill_steps(). As with the binned position scales discussed in Section 10.4 these scales have an n.breaks argument that controls the number of discrete colour categories created by the scale. Counterintuitively—because the human visual system is very good at detecting edges—this can sometimes make a continuous colour gradient easier to perceive:\n\nerupt + scale_fill_binned()\n\n\n\n\n\n\n\nerupt + scale_fill_steps()\n\n\n\n\n\n\n\nerupt + scale_fill_steps(n.breaks = 8)\n\n\n\n\n\n\n\n\nThe viridis palettes can be used in the same way, by calling the palette generating functions directly when specifying the colours argument to scale_fill_stepsn():\n\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::viridis(9))\n\n\n\n\n\n\n\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::magma(9))\n\n\n\n\n\n\n\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::inferno(9))",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/ggplot2-3.html#other-aesthetics",
    "href": "analysis/ggplot2-3.html#other-aesthetics",
    "title": "ggplot2 (Scales)",
    "section": "12 Other aesthetics",
    "text": "12 Other aesthetics\nIn addition to position and colour, there are several other aesthetics that ggplot2 can use to represent data.\n\nSize\nThe size aesthetic is typically used to scale points and text. The default scale for size aesthetics is scale_size() in which a linear increase in the variable is mapped onto a linear increase in the area (not the radius) of the geom. Scaling as a function of area is a sensible default as human perception of size is more closely mimicked by area scaling than by radius scaling. By default the smallest value in the data (more precisely in the scale limits) is mapped to a size of 1 and the largest is mapped to a size of 6. The range argument allows you to scale the size of the geoms:\n\nbase &lt;- ggplot(mpg, aes(displ, hwy, size = cyl)) +\n  geom_point()\nbase\n\n\n\n\n\n\n\nbase + scale_size(range = c(1, 2))\n\n\n\n\n\n\n\n\nLet’s draw a scale model of the planets!\n\nplanets &lt;- data.frame(\n  name = c(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"),\n  type = c(rep(\"Inner\", 4), rep(\"Outer\", 4)),\n  position = 1:8,\n  radius = c(2440, 6052, 6378, 3390, 71400, 60330, 25559, 24764),\n  stringsAsFactors = FALSE\n)\nplanets$name &lt;- with(planets, factor(name, name))\n\nggplot(planets, aes(1, name, size = radius)) +\n  geom_point() +\n  scale_x_continuous(breaks = NULL) +\n  scale_radius(limits = c(0, NA), range = c(0, 15)) +\n  labs(x = NULL, y = NULL, size = \"Radius\", title = \"The planets of the solar system\") +\n  theme_quo(y = FALSE, x = FALSE)\n\n\n\n\n\n\n\n\n\n\nManual scales\nLet’s create a plot with manual scales:\n\nhuron &lt;- data.frame(year = 1875:1972, level = as.numeric(LakeHuron))\n\nggplot(huron, aes(year)) +\n  geom_line(aes(y = level + 5, colour = \"above\")) +\n  geom_line(aes(y = level - 5, colour = \"below\")) +\n  scale_colour_manual(\"Direction\",\n    values = c(above = \"red\", below = \"blue\")\n  ) +\n  labs(x = NULL, y = NULL)\n\n\n\n\n\n\n\n\n\n\nIdentity scales\nLet’s plot all the R colors!\n\nggplot(luv_colours, aes(u, v)) +\n  geom_point(aes(colour = col), size = 3) +\n  scale_color_identity() +\n  coord_equal() +\n  labs(x = NULL, y = NULL)",
    "crumbs": [
      "Changelog",
      "ggplot2 (Scales)"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html",
    "href": "analysis/r-training-log.html",
    "title": "R Training Log",
    "section": "",
    "text": "Original notes on learning R and RStudio. An updated reading list of R books and other recommended resources is available in R Books.",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html#libraries",
    "href": "analysis/r-training-log.html#libraries",
    "title": "R Training Log",
    "section": "Libraries",
    "text": "Libraries\nLoad libraries and suppress warning and error messages. Thanks to this tidyverse article. Also load rdev and set default theme and color scales.\n\nlibrary(tidyverse)\nlibrary(jbplot)\nlibrary(caTools)",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html#files",
    "href": "analysis/r-training-log.html#files",
    "title": "R Training Log",
    "section": "Files",
    "text": "Files\nFiles in this project:\n\n.Rbuildignore:\n.Rhistory:\n.Rprofile:\n.Rproj.user:\n.git:\n.gitignore:\n.lintr: lintr configuration file\nDESCRIPTION:\nLICENSE:\nLICENSE.md:\nNAMESPACE:\nREADME.Rmd:\nREADME.md:\nman:\nr-training-log.Rmd:\nr-training-log.nb.html:\nrenv:\nrenv.lock:\nrtraining.Rproj:\nsetup-r:\ntests:",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html#not-r",
    "href": "analysis/r-training-log.html#not-r",
    "title": "R Training Log",
    "section": "Not R",
    "text": "Not R\nNot R, but has advice on git best practices and a guide to fixing commit mistakes: https://sethrobertson.github.io",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html#learning-r",
    "href": "analysis/r-training-log.html#learning-r",
    "title": "R Training Log",
    "section": "Learning R",
    "text": "Learning R\nResources for learning R.\nAlready using: these are packages I’m already using in R. Note: much of this has been influenced by the work of Hadley Wickham, who seems to be one of the (if not the most) significant contributors to the modern R and RStudio environment. Most of these have good integration with RStudio.\n\nrenv - for package version management by project\nstyler and lintr - for implementing the tidyverse style guide\nVarious tidyverse packages, including:\n\ndplyr\nggplot2\nglue\nlubridate\nreadr\nstringr\ntibble\ntidyr\n\nOther packages:\n\ngt\nkableExtra\nminiUI (for RStudio plugins)\nopenxlsx\nknitr: there is a useful knitr-spin.R demo script that shows how to knit an R script (from https://yihui.org/knitr/demo/stitch/) - I briefly explored this as an alternative to notebooks\n\nR Notebooks leveraging GitHub Pages\n\nWhen in doubt, start with the tidyverse, or RStudio sponsored projects, or built-in R.\nCompleted: I’ve read these.\n\nR for Data Science - Hadley’s intro book\n\nIn progress: I’m reading these now.\n\nR Packages - even more Hadley\ntestthat - R testing framework\nroxygen2 - document functions inline\n\nFuture: I’m planning on adopting these to improve my code quality.\n\nFull ggplot2 documentation OR\nggplot2 book, 3rd edition draft: https://ggplot2-book.org\nAdvanced R - more Hadley\n\nAlso helpful: some additional helpful links, either from me or recommended by others.\n\nRStudio Education - the Beginners page\njanitor - automate data cleanup\npurrr - for list iteration\nbroom - for getting classic stats objects into tidy shapes that are easier to work with\n\nReferences: other good reference sites.\n\nYan Holtz has some good sites for data visualization:\n\nthe R Graph Gallery - charts made with R and ggplot2\nfrom Data to Viz - recommendations on data visualization\nHe also has some tips on R Markdown\n\nMIT Roxygen Quick Reference\n\n\nR for Data Science\nSelected highlights from the book:\n\nPatterns and models\n7.6 Patterns and models covers models and residuals, here showing how to reveal the expected relationship between cut and price:\n\nlibrary(modelr)\n\nmod &lt;- lm(log(price) ~ log(carat), data = diamonds)\n\ndiamonds2 &lt;- diamonds %&gt;%\n  add_residuals(mod) %&gt;%\n  mutate(resid = exp(resid))\n\nggplot(data = diamonds2) +\n  geom_point(mapping = aes(x = carat, y = resid)) +\n  theme_quo()\n\n\n\n\n\n\n\nggplot(data = diamonds2) +\n  geom_boxplot(mapping = aes(x = cut, y = resid)) +\n  theme_quo()\n\n\n\n\n\n\n\n\n\n\nNon-Tidy Data\nHadley advocates for “tidy” data, but there are times when data is usefully non-tidy.\n\n\nGraphics: Learning more\nFrom 28.8 Learning more:\n“The absolute best place to learn more is the ggplot2 book: ggplot2: Elegant graphics for data analysis. It goes into much more depth about the underlying theory, and has many more examples of how to combine the individual pieces to solve practical problems. Unfortunately, the book is not available online for free, although you can find the source code at https://github.com/hadley/ggplot2-book.\nAnother great resource is the ggplot2 extensions gallery https://exts.ggplot2.tidyverse.org/gallery/. This site lists many of the packages that extend ggplot2 with new geoms and scales. It’s a great place to start if you’re trying to do something that seems hard with ggplot2.”\n\n\nR Markdown Websites\nFrom 29.8 Websites:\n“With a little additional infrastructure you can use R Markdown to generate a complete website:\n\nPut your .Rmd files in a single directory. index.Rmd will become the home page.\nAdd a YAML file named _site.yml provides the navigation for the site. For example:\n\nname: \"my-website\"\nnavbar:\n  title: \"My Website\"\n  left:\n    - text: \"Home\"\n      href: index.html\n    - text: \"Viridis Colors\"\n      href: 1-example.html\n    - text: \"Terrain Colors\"\n      href: 3-inline.html\nExecute rmarkdown::render_site() to build _site, a directory of files ready to deploy as a standalone static website, or if you use an RStudio Project for your website directory. RStudio will add a Build tab to the IDE that you can use to build and preview your site.\nRead more at https://bookdown.org/yihui/rmarkdown/rmarkdown-site.html.”\n\n\nR Notebook Advice\nHadley has some good suggestions for R Notebooks in 30 R Markdown workflow.\n\n\n\nR Packages\nNotes from the book. I’ve started writing all code in the package structure described in the book and used by Hadley and the tidyverse. Doing so makes it easier to write tests, documentation, track dependencies, and provides convenient continuous integration through R CMD check.\n\nSystem Setup\nChapter 3 has good coverage of setting up a system for R development, I’ve incorporated what I learned from this into my “R Setup Log”.\n\n\nNaming Things\nPackage names are pretty restricted, but Hadley has some good recommendation on naming them, including the “available” package, which I’ve started using.\n\n\nRStudio\nThere are some helpful tips in the RStudio section, including 2 key shortcuts to remember:\n\ncontrol-. to “Go to file/function”\nalt-shift-k for the keyboard shortcut quick reference\nnot a shortcut, but use proj_sitrep() to query active projects and working directory\n\n\n\nWriting Better Code\nChapter 6, The Package Within, highlights some sub-optimal R code and shows how to clean it up. It never occurred to me to use a left join to clean up data, and I’ve already started using the technique.\n\n\nR and Homebrew\n7.4 Code Style includes a footnote that references my favorite open source project, Homebrew:\n\nThe Robot Pedantry, Human Empathy blog post by Mike McQuaid does an excellent job summarizing the benefit of automating tasks like code re-styling.\n\nI’ve contributed to homebrew, but I’ve only recently realized how advanced a project it truly is - “advanced” DevOps concepts like trunk-based development and pedantic continuous integration checks just make sense to me, thanks to my experiences contributing. And, I’ve been the recipient of a “You Rock!” from Mike, which felt great, and still does now, even after learning it was partially automated.\n\n\nPackage Conventions\nFrom 7.6 Respect the R landscape:\nAvoid using any of the following:\nlibrary()\nrequire()\nsource()\noptions()\npar()\nsetwd()\nSys.setenv()\nSys.setlocale()\nset.seed()\nInstead, manage dependencies through roxygen2 and the DESCRIPTION file. Use withr when you need to modify state.",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/r-training-log.html#r-demos",
    "href": "analysis/r-training-log.html#r-demos",
    "title": "R Training Log",
    "section": "R Demos",
    "text": "R Demos\nInteresting demonstrations of R code.\n\nWikipedia\nA fun demo taken from the Wikipedia article on R:\n\n\n\nMandelbrot set\n\n\n\nlocal({\n  # install.packages(\"caTools\")  # install external package\n  # library(caTools)             # external package providing write.gif function\n  # note: the code in the text of the Wikipedia article doesn't match the code\n  #       used to generate the image in the article,\n  # https://commons.wikimedia.org/wiki/File:Mandelbrot_Creation_Animation.gif\n  #       the colors here have been changed to match the image.\n  jet.colors &lt;- colorRampPalette(c(\n    \"#00007F\", \"blue\", \"#007FFF\", \"cyan\", \"#7FFF7F\",\n    \"yellow\", \"#FF7F00\", \"red\", \"#7F0000\"\n  ))\n  dx &lt;- 1500 # define width\n  dy &lt;- 1400 # define height\n  C &lt;- complex(\n    real = rep(seq(-2.2, 1.0, length.out = dx), each = dy),\n    imag = rep(seq(-1.2, 1.2, length.out = dy), dx)\n  )\n  C &lt;- matrix(C, dy, dx) # reshape as square matrix of complex numbers\n  Z &lt;- 0 # initialize Z to zero\n  X &lt;- array(0, c(dy, dx, 20)) # initialize output 3D array\n  for (k in 1:20) { # loop with 20 iterations\n    Z &lt;- Z^2 + C # the central difference equation\n    X[, , k] &lt;- exp(-abs(Z)) # capture results\n  }\n  write.gif(X, \"rendered/mandelbrot.gif\", col = jet.colors, delay = 100)\n})\n\nWarning in complex(real = rep(seq(-2.2, 1, length.out = dx), each = dy), :\npartial argument match of 'imag' to 'imaginary'",
    "crumbs": [
      "Changelog",
      "R Training Log"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html",
    "href": "analysis/advanced-r-4.html",
    "title": "Advanced R (Metaprogramming)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Metaprogramming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions.\nlibrary(lobstr)\nlibrary(rlang)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#introduction",
    "href": "analysis/advanced-r-4.html#introduction",
    "title": "Advanced R (Metaprogramming)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from Advanced R and Advanced R Solutions, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read Advanced R and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.\nImportant: advice on tidy evaluation has changed since these chapters were written; see the “Programming with dplyr” vignette.",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#big-picture",
    "href": "analysis/advanced-r-4.html#big-picture",
    "title": "Advanced R (Metaprogramming)",
    "section": "17 Big picture",
    "text": "17 Big picture\nMetaprogramming is the hardest topic in this book because it brings together many formerly unrelated topics and forces you grapple with issues that you probably haven’t thought about before. You’ll also need to learn a lot of new vocabulary, and at first it will seem like every new term is defined by three other terms that you haven’t heard of. Even if you’re an experienced programmer in another language, your existing skills are unlikely to be much help as few modern popular languages expose the level of metaprogramming that R provides. So don’t be surprised if you’re frustrated or confused at first; this is a natural part of the process that happens to everyone!\nBut I think it’s easier to learn metaprogramming now than ever before. Over the last few years, the theory and practice have matured substantially, providing a strong foundation paired with tools that allow you to solve common problems. In this chapter, you’ll get the big picture of all the main pieces and how they fit together.",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#expressions",
    "href": "analysis/advanced-r-4.html#expressions",
    "title": "Advanced R (Metaprogramming)",
    "section": "18 Expressions",
    "text": "18 Expressions\nTo compute on the language, we first need to understand its structure. That requires some new vocabulary, some new tools, and some new ways of thinking about R code. The first of these is the distinction between an operation and its result. Take the following code, which multiplies a variable x by 10 and saves the result to a new variable called y. It doesn’t work because we haven’t defined a variable called x:\n\nrm(x)\n\n#&gt; Warning in rm(x): object 'x' not found\n\ntry(y &lt;- x * 10)\n\n#&gt; Error in eval(expr, envir) : object 'x' not found\n\n\nIt would be nice if we could capture the intent of the code without executing it. In other words, how can we separate our description of the action from the action itself?\nOne way is to use rlang::expr():\n\nz &lt;- rlang::expr(y &lt;- x * 10)\nz\n\n#&gt; y &lt;- x * 10\n\n\nexpr() returns an expression, an object that captures the structure of the code without evaluating it (i.e. running it). If you have an expression, you can evaluate it with base::eval():\n\nx &lt;- 4\neval(z)\ny\n\n#&gt; [1] 40\n\n\nThe focus of this chapter is the data structures that underlie expressions. Mastering this knowledge will allow you to inspect and modify captured code, and to generate code with code. We’ll come back to expr() in Chapter 19, and to eval() in Chapter 20.\n\n18.2.4 Exercises\n\nReconstruct the code represented by the trees below:\n\n\n#&gt; █─f\n#&gt; └─█─g\n#&gt;   └─█─h\n#&gt; █─`+`\n#&gt; ├─█─`+`\n#&gt; │ ├─1\n#&gt; │ └─2\n#&gt; └─3\n#&gt; █─`*`\n#&gt; ├─█─`(`\n#&gt; │ └─█─`+`\n#&gt; │   ├─x\n#&gt; │   └─y\n#&gt; └─z\n\nAnswer: code below.\n\nlobstr::ast(f(g(h())))\n\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h\n\nlobstr::ast(1 + 2 + 3)\n\n#&gt; █─`+` \n#&gt; ├─█─`+` \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─3\n\nlobstr::ast((x + y) * z)\n\n#&gt; █─`*` \n#&gt; ├─█─`(` \n#&gt; │ └─█─`+` \n#&gt; │   ├─x \n#&gt; │   └─y \n#&gt; └─z\n\n\nAR Solutions: Let the source (of the code chunks above) be with you and show you how the ASTs (abstract syntax trees) were produced.\n\nast(f(g(h())))\n\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h\n\nast(1 + 2 + 3)\n\n#&gt; █─`+` \n#&gt; ├─█─`+` \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─3\n\nast((x + y) * z)\n\n#&gt; █─`*` \n#&gt; ├─█─`(` \n#&gt; │ └─█─`+` \n#&gt; │   ├─x \n#&gt; │   └─y \n#&gt; └─z\n\n\n\n\nDraw the following trees by hand and then check your answers with lobstr::ast().\n\n\nf(g(h(i(1, 2, 3))))\nf(1, g(2, h(3, i())))\nf(g(1, 2), h(3, i(4, 5)))\n\nAnswer: code below, expression 1:\n\n#&gt; █─f\n#&gt; └─█─g\n#&gt;   └─█─h\n#&gt;     └─█─i\n#&gt;       └─1\n#&gt;       └─2\n#&gt;       └─3\nlobstr::ast(f(g(h(i(1, 2, 3)))))\n\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h \n#&gt;     └─█─i \n#&gt;       ├─1 \n#&gt;       ├─2 \n#&gt;       └─3\n\n\nExpression 2:\n\n#&gt; █─f\n#&gt; └─1\n#&gt; └─█─g\n#&gt;   └─2\n#&gt;   └─█─h\n#&gt;     └─3\n#&gt;     └─█─i\nlobstr::ast(f(1, g(2, h(3, i()))))\n\n#&gt; █─f \n#&gt; ├─1 \n#&gt; └─█─g \n#&gt;   ├─2 \n#&gt;   └─█─h \n#&gt;     ├─3 \n#&gt;     └─█─i\n\n\nExpression 3:\n\n#&gt; █─f\n#&gt; └─█─g\n#&gt; | └─1\n#&gt; | └─2\n#&gt; └─█─h\n#&gt;   └─3\n#&gt;   └─█─i\n#&gt;     └─4\n#&gt;     └─5\nlobstr::ast(f(g(1, 2), h(3, i(4, 5))))\n\n#&gt; █─f \n#&gt; ├─█─g \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─█─h \n#&gt;   ├─3 \n#&gt;   └─█─i \n#&gt;     ├─4 \n#&gt;     └─5\n\n\nAR Solutions: Let us delegate the drawing to the lobstr package.\n\n\nWhat’s happening with the ASTs below? (Hint: carefully read ?\"^\".)\n\n\nlobstr::ast(`x` + `y`)\n\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─y\n\nlobstr::ast(x ** y) # styler: off\n\n#&gt; █─`^` \n#&gt; ├─x \n#&gt; └─y\n\nlobstr::ast(1 -&gt; x)\n\n#&gt; █─`&lt;-` \n#&gt; ├─x \n#&gt; └─1\n\n\nAnswer: all expressions are changed to their normal forms. In the first expression, the back ticks denoting symbols are not needed. In the third expression, the assignment operator is changed to the standard form. In the second expression, the operator is changed per this note in the R documentation:\n\n** is translated in the parser to ^, but this was undocumented for many years. It appears as an index entry in Becker et al (1988), pointing to the help for Deprecated but is not actually mentioned on that page. Even though it had been deprecated in S for 20 years, it was still accepted in R in 2008.\n\nAR Solutions: ASTs start function calls with the name of the function. This is why the call in the first expression is translated into its prefix form. In the second case, ** is translated by R’s parser into ^. In the last AST, the expression is flipped when R parses it.\n\n\nWhat is special about the AST below? (Hint: re-read Section 6.2.1.)\n\n\nlobstr::ast(function(x = 1, y = 2) {})\n\n#&gt; █─`function` \n#&gt; ├─█─x = 1 \n#&gt; │ └─y = 2 \n#&gt; ├─█─`{` \n#&gt; └─NULL\n\n\nAnswer: the AST includes two of the three parts of the function, the formals(), x and y, the body(), represented by { and &lt;inline srcref&gt;.\nAR Solutions: The last leaf of the AST is not explicitly specified in the expression. Instead, the srcref attribute, which points to the functions source code, is automatically created by base R.\n\n\nWhat does the call tree of an if statement with multiple else if conditions look like? Why?\n\nAnswer: the call tree shows nested if statements; this is because if-else is a function with three arguments, the cond, the cons.expr and the alt.expr. The alt.expr for each if-else statement is a new call to if.\n\nlobstr::ast(\n  if (v == 1) {\n    print(\"one\")\n  } else if (v == 2) {\n    print(\"two\")\n  } else if (v == 3) {\n    print(\"three\")\n  } else if (v == 4) {\n    print(\"four\")\n  }\n)\n\n#&gt; █─`if` \n#&gt; ├─█─`==` \n#&gt; │ ├─v \n#&gt; │ └─1 \n#&gt; ├─█─`{` \n#&gt; │ └─█─print \n#&gt; │   └─\"one\" \n#&gt; └─█─`if` \n#&gt;   ├─█─`==` \n#&gt;   │ ├─v \n#&gt;   │ └─2 \n#&gt;   ├─█─`{` \n#&gt;   │ └─█─print \n#&gt;   │   └─\"two\" \n#&gt;   └─█─`if` \n#&gt;     ├─█─`==` \n#&gt;     │ ├─v \n#&gt;     │ └─3 \n#&gt;     ├─█─`{` \n#&gt;     │ └─█─print \n#&gt;     │   └─\"three\" \n#&gt;     └─█─`if` \n#&gt;       ├─█─`==` \n#&gt;       │ ├─v \n#&gt;       │ └─4 \n#&gt;       └─█─`{` \n#&gt;         └─█─print \n#&gt;           └─\"four\"\n\n\nAR Solutions: The AST of nested else if statements might look a bit confusing because it contains multiple curly braces. However, we can see that in the else part of the AST just another expression is being evaluated, which happens to be an if statement and so forth.\n\nast(\n  if (FALSE) {\n    1\n  } else if (FALSE) {\n    2\n  } else if (TRUE) {\n    3\n  }\n)\n\n#&gt; █─`if` \n#&gt; ├─FALSE \n#&gt; ├─█─`{` \n#&gt; │ └─1 \n#&gt; └─█─`if` \n#&gt;   ├─FALSE \n#&gt;   ├─█─`{` \n#&gt;   │ └─2 \n#&gt;   └─█─`if` \n#&gt;     ├─TRUE \n#&gt;     └─█─`{` \n#&gt;       └─3\n\n\nWe can see the structure more clearly if we avoid the curly braces:\n\nast(\n  # styler: off\n  if (FALSE) 1\n  else if (FALSE) 2\n  else if (TRUE) 3\n  # styler: on\n)\n\n#&gt; █─`if` \n#&gt; ├─FALSE \n#&gt; ├─1 \n#&gt; └─█─`if` \n#&gt;   ├─FALSE \n#&gt;   ├─2 \n#&gt;   └─█─`if` \n#&gt;     ├─TRUE \n#&gt;     └─3\n\n\n\n\n\n18.3.5 Exercises\n\nWhich two of the six types of atomic vector can’t appear in an expression? Why? Similarly, why can’t you create an expression that contains an atomic vector of length greater than one?\n\nAnswer: raw and some complex numbers can’t appear in an expression, since constructing both requires a function call (raw() and + respectively). Similarly, creating atomic vectors longer than one requires c().\n\nexpr(f(TRUE, 1L, 1.0, \"x\", 1i, raw(1L), 1 + 1i))\n\n#&gt; f(TRUE, 1L, 1, \"x\", 0+1i, raw(1L), 1 + (0+1i))\n\nexpr(c(1, 2))\n\n#&gt; c(1, 2)\n\n\nAR Solutions: There is no way to create raws and complex atomics without using a function call (this is only possible for imaginary scalars like i, 5i etc.). But expressions that include a function are calls. Therefore, both of these vector types cannot appear in an expression.\nSimilarly, it is not possible to create an expression that evaluates to an atomic of length greater than one without using a function (e.g. c()).\nLet’s make this observation concrete via an example:\n\n# Atomic\nis_atomic(expr(1))\n\n#&gt; [1] TRUE\n\n# Not an atomic (although it would evaluate to an atomic)\nis_atomic(expr(c(1, 1)))\n\n#&gt; [1] FALSE\n\nis_call(expr(c(1, 1)))\n\n#&gt; [1] TRUE\n\n\n\n\nWhat happens when you subset a call object to remove the first element? e.g. expr(read.csv(\"foo.csv\", header = TRUE))[-1]. Why?\n\nAnswer: as the result demonstrates, this removes the function call which makes the first argument the new function call in the expression, since the AST structure (call object) is preserved, and the first element of the call object is the function position.\n\nexpr(read.csv(\"foo.csv\", header = TRUE))[-1]\n\n#&gt; \"foo.csv\"(header = TRUE)\n\n\nAR Solutions: When the first element of a call object is removed, the second element moves to the first position, which is the function to call. Therefore, we get \"foo.csv\"(header = TRUE).\n\n\nDescribe the differences between the following call objects.\n\n\nx &lt;- 1:10\ncall2(median, x, na.rm = TRUE)\ncall2(expr(median), x, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\ncall2(expr(median), expr(x), na.rm = TRUE)\n\nAnswer: the objects differ in their use of expr(). When using bare median and x, the object uses the evaluated function and value of x where using expr() prevents evaluation.\n\nmedian\n\n#&gt; function (x, na.rm = FALSE, ...) \n#&gt; UseMethod(\"median\")\n#&gt; &lt;bytecode: 0x110be21d0&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nexpr(median)\n\n#&gt; median\n\nx\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nexpr(x)\n\n#&gt; x\n\n\nAR Solutions: The call objects differ in their first two elements, which are in some cases evaluated before the call is constructed. In the first one, both median() and x are evaluated and inlined into the call. Therefore, we can see in the constructed call that median is a generic and the x argument is 1:10.\n\ncall2(median, x, na.rm = TRUE)\n\n#&gt; (function (x, na.rm = FALSE, ...) \n#&gt; UseMethod(\"median\"))(1:10, na.rm = TRUE)\n\n\nIn the following calls we remain with differing combinations. Once, only x and once only median() gets evaluated.\n\ncall2(expr(median), x, na.rm = TRUE)\n\n#&gt; median(1:10, na.rm = TRUE)\n\ncall2(median, expr(x), na.rm = TRUE)\n\n#&gt; (function (x, na.rm = FALSE, ...) \n#&gt; UseMethod(\"median\"))(x, na.rm = TRUE)\n\n\nIn the final call neither x nor median() is evaluated.\n\ncall2(expr(median), expr(x), na.rm = TRUE)\n\n#&gt; median(x, na.rm = TRUE)\n\n\nNote that all these calls will generate the same result when evaluated. The key difference is when the values bound to the x and median symbols are found.\n\n\nrlang::call_standardise() doesn’t work so well for the following calls. Why? What makes mean() special?\n\n\ncall_standardise(quote(mean(1:10, na.rm = TRUE)))\n\n#&gt; Warning: `call_standardise()` is deprecated as of rlang 0.4.11\n#&gt; This warning is displayed once every 8 hours.\n\n\n#&gt; mean(x = 1:10, na.rm = TRUE)\n\ncall_standardise(quote(mean(n = T, 1:10)))\n\n#&gt; mean(x = 1:10, n = T)\n\ncall_standardise(quote(mean(x = 1:10, , TRUE)))\n\n#&gt; mean(x = 1:10, , TRUE)\n\n\nAnswer: as noted in the book, “If the function uses ... it’s not possible to standardise all arguments.” mean() has a single argument, x, and uses ... for the remaining arguments, although the default S3 method is mean(x, trim = 0, na.rm = FALSE, ...).\nAR Solutions: The reason for this unexpected behaviour is that mean() uses the ... argument and therefore cannot standardise the regarding arguments. Since mean() uses S3 dispatch (i.e. UseMethod()) and the underlying mean.default() method specifies some more arguments, call_standardise() can do much better with a specific S3 method.\n\n\nWhy does this code not make sense?\n\n\nx &lt;- expr(foo(x = 1))\nnames(x) &lt;- c(\"x\", \"y\")\n\nAnswer: as the code below demonstrates, the only symbol (name) in the expression is x. Assigning a name to both components changes x to y but doesn’t change the function call foo.\n\nex &lt;- expr(foo(x = 1))\nnames(ex)\n\n#&gt; [1] \"\"  \"x\"\n\nnames(ex) &lt;- c(\"x\", \"y\")\nex\n\n#&gt; foo(y = 1)\n\n\nAR Solutions: As stated in Advanced R\n\nThe first element of a call is always the function that gets called.\n\nLet’s see what happens when we run the code\n\nx &lt;- expr(foo(x = 1))\nx\n\n#&gt; foo(x = 1)\n\nnames(x) &lt;- c(\"x\", \"\")\nx\n\n#&gt; foo(1)\n\nnames(x) &lt;- c(\"\", \"x\")\nx\n\n#&gt; foo(x = 1)\n\n\nSo, giving the first element a name just adds metadata that R ignores.\n\n\nConstruct the expression if(x &gt; 1) \"a\" else \"b\" using multiple calls to call2(). How does the code structure reflect the structure of the AST?\n\nAnswer: code below. The call2() structure mirrors the AST of the if expression.\n\ncall2(\"if\", call2(\"&gt;\", expr(x), 1), \"a\", \"b\")\n\n#&gt; if (x &gt; 1) \"a\" else \"b\"\n\nlobstr::ast(if (x &gt; 1) \"a\" else \"b\")\n\n#&gt; █─`if` \n#&gt; ├─█─`&gt;` \n#&gt; │ ├─x \n#&gt; │ └─1 \n#&gt; ├─\"a\" \n#&gt; └─\"b\"\n\n\nAR Solutions: Similar to the prefix version we get\n\ncall2(\"if\", call2(\"&gt;\", sym(\"x\"), 1), \"a\", \"b\")\n\n#&gt; if (x &gt; 1) \"a\" else \"b\"\n\n\nWhen we read the AST from left to right, we get the same structure: Function to evaluate, expression, which is another function and is evaluated first, and two constants which will be evaluated next.\n\nast(`if`(x &gt; 1, \"a\", \"b\"))\n\n#&gt; █─`if` \n#&gt; ├─█─`&gt;` \n#&gt; │ ├─x \n#&gt; │ └─1 \n#&gt; ├─\"a\" \n#&gt; └─\"b\"\n\n\n\n\n\n18.4.4 Exercises\n\nR uses parentheses in two slightly different ways as illustrated by these two calls:\n\n\nf((1))\n`(`(1 + 1)\n\nCompare and contrast the two uses by referencing the AST.\nAnswer: R uses parentheses both as a function and as part of a function call. In the first call, the outer parentheses are for f and the inner represent ( with a single parameter. In the second call, equivalent to (1 + 1), the parentheses are for the ( function call.\n\nlobstr::ast(f((1)))\n\n#&gt; █─f \n#&gt; └─█─`(` \n#&gt;   └─1\n\nlobstr::ast(`(`(1 + 1))\n\n#&gt; █─`(` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─1\n\nlobstr::ast((1 + 1))\n\n#&gt; █─`(` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─1\n\n\nAR Solutions: The trick with these examples lies in the fact that ( can be a part of R’s general prefix function syntax but can also represent a call to the ( function.\nSo, in the AST of the first example, we will not see the outer ( since it is prefix function syntax and belongs to f(). In contrast, the inner ( is a function (represented as a symbol in the AST):\n\nast(f((1)))\n\n#&gt; █─f \n#&gt; └─█─`(` \n#&gt;   └─1\n\n\nIn the second example, we can see that the outer ( is a function and the inner ( belongs to its syntax:\n\nast(`(`(1 + 1))\n\n#&gt; █─`(` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─1\n\n\nFor the sake of clarity, let’s also create a third example, where none of the ( is part of another function’s syntax:\n\nast(((1 + 1)))\n\n#&gt; █─`(` \n#&gt; └─█─`(` \n#&gt;   └─█─`+` \n#&gt;     ├─1 \n#&gt;     └─1\n\n\n\n\n= can also be used in two ways. Construct a simple example that shows both uses.\n\nAnswer: = can be used for assignment and also for function parameters.\n\nlobstr::ast(`=`(val, sum(10, na.rm = TRUE)))\n\n#&gt; █─`=` \n#&gt; ├─val \n#&gt; └─█─sum \n#&gt;   ├─10 \n#&gt;   └─na.rm = TRUE\n\n\nAR Solutions: = is used both for assignment, and for naming arguments in function calls:\n\nb = c(c = 1) # styler: off\n\nSo, when we play with ast(), we can directly see that the following is not possible:\n\ntry(ast(b = c(c = 1)))\n\n#&gt; Error in ast(b = c(c = 1)) : unused argument (b = c(c = 1))\n\n\nWe get an error because b = makes R looking for an argument called b. Since x is the only argument of ast(), we get an error.\nThe easiest way around this problem is to wrap this line in {}.\n\nast({b = c(c = 1)})  # styler: off\n\n#&gt; █─`{` \n#&gt; └─█─`=` \n#&gt;   ├─b \n#&gt;   └─█─c \n#&gt;     └─c = 1\n\n\nWhen we ignore the braces and compare the trees, we can see that the first = is used for assignment and the second = is part of the syntax of function calls.\n\n\nDoes -2^2 yield 4 or -4? Why?\n\nAnswer: the result is -4, because ^ has higher precedence than -:\n\n-2^2\n\n#&gt; [1] -4\n\nlobstr::ast(-2^2)\n\n#&gt; █─`-` \n#&gt; └─█─`^` \n#&gt;   ├─2 \n#&gt;   └─2\n\n\nAR Solutions: It yields -4, because ^ has a higher operator precedence than -, which we can verify by looking at the AST (or looking it up under ?\"Syntax\"):\n\n-2^2\n\n#&gt; [1] -4\n\nast(-2^2)\n\n#&gt; █─`-` \n#&gt; └─█─`^` \n#&gt;   ├─2 \n#&gt;   └─2\n\n\n\n\nWhat does !1 + !1 return? Why?\n\nAnswer: FALSE. As the AST demonstrates, the ! operator takes precedence.\n\n!1 + !1\n\n#&gt; [1] FALSE\n\nlobstr::ast(!1 + !1)\n\n#&gt; █─`!` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─█─`!` \n#&gt;     └─1\n\n\nThe result can be demonstrated by evaluating the AST in steps:\n\n!1 # FALSE\n\n#&gt; [1] FALSE\n\n1 + FALSE # 1\n\n#&gt; [1] 1\n\n!1 # FALSE\n\n#&gt; [1] FALSE\n\n\nAR Solutions: The answer is a little surprising:\n\n!1 + !1\n\n#&gt; [1] FALSE\n\n\nTo answer the “why?”, we take a look at the AST:\n\nast(!1 + !1)\n\n#&gt; █─`!` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─█─`!` \n#&gt;     └─1\n\n\nThe right !1 is evaluated first. It evaluates to FALSE, because R coerces every non 0 numeric to TRUE, when a logical operator is applied. The negation of TRUE then equals FALSE.\nNext 1 + FALSE is evaluated to 1, since FALSE is coerced to 0.\nFinally !1 is evaluated to FALSE.\nNote that if ! had a higher precedence, the intermediate result would be FALSE + FALSE, which would evaluate to 0.\n\n\nWhy does x1 &lt;- x2 &lt;- x3 &lt;- 0 work? Describe the two reasons.\n\nAnswer: assignment is right-associative: x1 &lt;- (x2 &lt;- 0) and x1 &lt;- x2 &lt;- 0 are equivalent, and the rightmost assignment operator is evaluated first.\n\nlobstr::ast(x1 &lt;- x2 &lt;- x3 &lt;- 0)\n\n#&gt; █─`&lt;-` \n#&gt; ├─x1 \n#&gt; └─█─`&lt;-` \n#&gt;   ├─x2 \n#&gt;   └─█─`&lt;-` \n#&gt;     ├─x3 \n#&gt;     └─0\n\n\nAR Solutions: One reason is that &lt;- is right-associative, i.e. evaluation takes place from right to left:\n\nx1 &lt;- (x2 &lt;- (x3 &lt;- 0))\n\nThe other reason is that &lt;- invisibly returns the value on the right-hand side.\n\n(x3 &lt;- 0)\n\n#&gt; [1] 0\n\n\nNote: I forgot that &lt;- returns the value invisibly.\n\n\nCompare the ASTs of x + y %+% z and x ^ y %+% z. What have you learned about the precedence of custom infix functions?\n\nAnswer: custom infix functions have higher precedence than + and lower precedence than ^.\n\nlobstr::ast(x + y %+% z)\n\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─█─`%+%` \n#&gt;   ├─y \n#&gt;   └─z\n\nlobstr::ast(x ^ y %+% z) # styler: off\n\n#&gt; █─`%+%` \n#&gt; ├─█─`^` \n#&gt; │ ├─x \n#&gt; │ └─y \n#&gt; └─z\n\n\nAR Solutions: Let’s take a look at the syntax trees:\n\nast(x + y %+% z)\n\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─█─`%+%` \n#&gt;   ├─y \n#&gt;   └─z\n\n\nHere y %+% z will be calculated first and the result will be added to x.\n\nast(x ^ y %+% z) # styler: off\n\n#&gt; █─`%+%` \n#&gt; ├─█─`^` \n#&gt; │ ├─x \n#&gt; │ └─y \n#&gt; └─z\n\n\nHere x ^ y will be calculated first, and the result will be used as first argument to %+%(). We can conclude that custom infix functions have precedence between addition and exponentiation. The exact precedence of infix functions can be looked up under ?\"Syntax\" where we see that it lies directly behind the sequence operator (:) and in front of the multiplication and division operators (* and /).\n\n\nWhat happens if you call parse_expr() with a string that generates multiple expressions? e.g. parse_expr(\"x + 1; y + 1\")\n\nAnswer: parse_expr() throws an error. Use parse_exprs() with strings containing multiple expressions.\n\ntry(parse_expr(\"x + 1; y + 1\"))\n\n#&gt; Error in parse_expr(\"x + 1; y + 1\") : \n#&gt;   `x` must contain exactly 1 expression, not 2.\n\nparse_exprs(\"x + 1; y + 1\")\n\n#&gt; [[1]]\n#&gt; x + 1\n#&gt; \n#&gt; [[2]]\n#&gt; y + 1\n\n\nAR Solutions: In this case parse_expr() notices that more than one expression would have to be generated and throws an error.\n\ntry(parse_expr(\"x + 1; y + 1\"))\n\n#&gt; Error in parse_expr(\"x + 1; y + 1\") : \n#&gt;   `x` must contain exactly 1 expression, not 2.\n\n\n\n\nWhat happens if you attempt to parse an invalid expression? e.g. \"a +\" or \"f())\".\n\nAnswer: parse_expr() throws an error.\n\ntry(parse_expr(\"a +\"))\n\n#&gt; Error in parse(text = x, keep.source = FALSE) : \n#&gt;   &lt;text&gt;:2:0: unexpected end of input\n#&gt; 1: a +\n#&gt;    ^\n\ntry(parse_expr(\"f())\"))\n\n#&gt; Error in parse(text = x, keep.source = FALSE) : \n#&gt;   &lt;text&gt;:1:4: unexpected ')'\n#&gt; 1: f())\n#&gt;        ^\n\n\nAR Solutions: Invalid expressions will lead to an error in the underlying parse() function.\n\ntry(parse_expr(\"a +\"))\n\n#&gt; Error in parse(text = x, keep.source = FALSE) : \n#&gt;   &lt;text&gt;:2:0: unexpected end of input\n#&gt; 1: a +\n#&gt;    ^\n\ntry(parse_expr(\"f())\"))\n\n#&gt; Error in parse(text = x, keep.source = FALSE) : \n#&gt;   &lt;text&gt;:1:4: unexpected ')'\n#&gt; 1: f())\n#&gt;        ^\n\ntry(parse(text = \"a +\"))\n\n#&gt; Error in parse(text = \"a +\") : &lt;text&gt;:2:0: unexpected end of input\n#&gt; 1: a +\n#&gt;    ^\n\ntry(parse(text = \"f())\"))\n\n#&gt; Error in parse(text = \"f())\") : &lt;text&gt;:1:4: unexpected ')'\n#&gt; 1: f())\n#&gt;        ^\n\n\n\n\ndeparse() produces vectors when the input is long. For example, the following call produces a vector of length two:\n\n\nexpr &lt;- expr(g(a + b + c + d + e + f + g + h + i + j + k + l +\n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\ndeparse(expr)\n\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + \"\n#&gt; [2] \"    p + q + r + s + t + u + v + w + x + y + z)\"\n\n\nWhat does expr_text() do instead?\nAnswer: expr_text() adds a newline (\\n) instead.\n\nexpr_text(expr)\n\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + \\n    p + q + r + s + t + u + v + w + x + y + z)\"\n\n\nAR Solutions: expr_text() will paste the results from deparse(expr) together and use a linebreak (\\n) as separator.\n\nexpr &lt;- expr(g(a + b + c + d + e + f + g + h + i + j + k + l + m +\n  n + o + p + q + r + s + t + u + v + w + x + y + z))\ndeparse(expr)\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + \"\n#&gt; [2] \"o + p + q + r + s + t + u + v + w + x + y + z)\"\nexpr_text(expr)\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n\n#&gt; + \\n    o + p + q + r + s + t + u + v + w + x + y + z)\"\n\n\n\npairwise.t.test() assumes that deparse() always returns a length one character vector. Can you construct an input that violates this expectation? What happens?\n\nAnswer: an especially long input for x or g would create a character vector of length two or more. However, starting in R 4.0.0, pairwise.t.test() uses deparse1() which guarantees a string (character of length one), so it is no longer possible to break pairwise.t.test().\n\npairwise.t.test\n\n#&gt; function (x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, \n#&gt;     paired = FALSE, alternative = c(\"two.sided\", \"less\", \"greater\"), \n#&gt;     ...) \n#&gt; {\n#&gt;     if (paired && pool.sd) \n#&gt;         stop(\"pooling of SD is incompatible with paired tests\")\n#&gt;     DNAME &lt;- paste(deparse1(substitute(x)), \"and\", deparse1(substitute(g)))\n#&gt;     g &lt;- factor(g)\n#&gt;     p.adjust.method &lt;- match.arg(p.adjust.method)\n#&gt;     alternative &lt;- match.arg(alternative)\n#&gt;     if (pool.sd) {\n#&gt;         METHOD &lt;- \"t tests with pooled SD\"\n#&gt;         xbar &lt;- tapply(x, g, mean, na.rm = TRUE)\n#&gt;         s &lt;- tapply(x, g, sd, na.rm = TRUE)\n#&gt;         n &lt;- tapply(!is.na(x), g, sum)\n#&gt;         degf &lt;- n - 1\n#&gt;         total.degf &lt;- sum(degf)\n#&gt;         pooled.sd &lt;- sqrt(sum(ifelse(degf, s^2, 0) * degf)/total.degf)\n#&gt;         compare.levels &lt;- function(i, j) {\n#&gt;             dif &lt;- xbar[i] - xbar[j]\n#&gt;             se.dif &lt;- pooled.sd * sqrt(1/n[i] + 1/n[j])\n#&gt;             t.val &lt;- dif/se.dif\n#&gt;             if (alternative == \"two.sided\") \n#&gt;                 2 * pt(-abs(t.val), total.degf)\n#&gt;             else pt(t.val, total.degf, lower.tail = (alternative == \n#&gt;                 \"less\"))\n#&gt;         }\n#&gt;     }\n#&gt;     else {\n#&gt;         METHOD &lt;- if (paired) \n#&gt;             \"paired t tests\"\n#&gt;         else \"t tests with non-pooled SD\"\n#&gt;         compare.levels &lt;- function(i, j) {\n#&gt;             xi &lt;- x[as.integer(g) == i]\n#&gt;             xj &lt;- x[as.integer(g) == j]\n#&gt;             t.test(xi, xj, paired = paired, alternative = alternative, \n#&gt;                 ...)$p.value\n#&gt;         }\n#&gt;     }\n#&gt;     PVAL &lt;- pairwise.table(compare.levels, levels(g), p.adjust.method)\n#&gt;     ans &lt;- list(method = METHOD, data.name = DNAME, p.value = PVAL, \n#&gt;         p.adjust.method = p.adjust.method)\n#&gt;     class(ans) &lt;- \"pairwise.htest\"\n#&gt;     ans\n#&gt; }\n#&gt; &lt;bytecode: 0x141e0a110&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\ndeparse(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))\n\n#&gt; [1] \"c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, \"\n#&gt; [2] \"18)\"\n\npairwise.t.test(1:18, c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))\n\n#&gt; \n#&gt;  Pairwise comparisons using t tests with pooled SD \n#&gt; \n#&gt; data:  1:18 and c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18) \n#&gt; \n#&gt;    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17\n#&gt; 2  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 3  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 4  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 5  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 6  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 7  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 8  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 9  - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 10 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 11 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 12 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 13 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 14 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 15 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 16 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 17 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; 18 - - - - - - - - - -  -  -  -  -  -  -  - \n#&gt; \n#&gt; P value adjustment method: holm\n\n\nAR Solutions: The function pairwise.t.test() captures its data arguments (x and g) so it can print the input expressions along the computed p-values. Prior to R 4.0.0 this used to be implemented via deparse(substitute(x)) in combination with paste(). This could lead to unexpected output, if one of the inputs exceeded the default width.cutoff value of 60 characters within deparse(). In this case, the expression would be split into a character vector of length greater 1.\n\n# Output in R version 3.6.2\nd &lt;- 1\npairwise.t.test(2, d + d + d + d + d + d + d + d +\n  d + d + d + d + d + d + d + d + d)\n#&gt;  Pairwise comparisons using t tests with pooled SD\n#&gt;\n#&gt; data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d\n#&gt; + d + d +  2 and     d\n#&gt;\n#&gt; &lt;0 x 0 matrix&gt;\n#&gt;\n#&gt; P value adjustment method: holm\n\nIn R 4.0.0 pairwise.t.test() was updated to use the newly introduced deparse1(), which serves as a wrapper around deparse().\n\ndeparse1() is a simple utility added in R 4.0.0 to ensure a string result (character vector of length one), typically used in name construction, as deparse1(substitute(.)).\n\n\n# Output since R 4.0.0\nd &lt;- 1\npairwise.t.test(2, d + d + d + d + d + d + d + d +\n  d + d + d + d + d + d + d + d + d)\n#&gt;  Pairwise comparisons using t tests with pooled SD\n#&gt;\n#&gt; data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d\n#&gt; + d + d + d\n#&gt;\n#&gt; &lt;0 x 0 matrix&gt;\n#&gt;\n#&gt; P value adjustment method: holm\n\n\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}\n\n\n\n18.5.3 Exercises\n\nlogical_abbr() returns TRUE for T(1, 2, 3). How could you modify logical_abbr_rec() so that it ignores function calls that use T or F?\n\nAR Solutions: We can apply a similar logic as in the assignment example from Advanced R. We just treat it as a special case handled within a sub function called find_T_call(), which finds T() calls and “bounces them out”. Therefore, we also repeat the expr_type() helper which tells us if we are in the base or in the recursive case.\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \",\n      typeof(x),\n      call. = FALSE\n    )\n  )\n}\n\n\nfind_T_call &lt;- function(x) {\n  if (is_call(x, \"T\")) {\n    x &lt;- as.list(x)[-1]\n    purrr::some(x, logical_abbr_rec)\n  } else {\n    purrr::some(x, logical_abbr_rec)\n  }\n}\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\"),\n\n    # Recursive cases\n    pairlist = purrr::some(x, logical_abbr_rec),\n    call = find_T_call(x)\n  )\n}\nlogical_abbr &lt;- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nNow let’s test our new logical_abbr() function:\n\nlogical_abbr(T(1, 2, 3))\n\n#&gt; [1] FALSE\n\nlogical_abbr(T(T, T(3, 4)))\n\n#&gt; [1] TRUE\n\nlogical_abbr(T(T))\n\n#&gt; [1] TRUE\n\nlogical_abbr(T())\n\n#&gt; [1] FALSE\n\nlogical_abbr()\n\n#&gt; [1] FALSE\n\nlogical_abbr(c(T, T, T))\n\n#&gt; [1] TRUE\n\n\nAnswer: taken from Advanced R solutions, we need to find function calls within the recursive call. The trick is to find and remove the T or F from the list:\n\nfind_tf_call &lt;- function(x) {\n  if (is_call(x, \"T\") || is_call(x, \"F\")) {\n    x &lt;- as.list(x)[-1]\n    purrr::some(x, logical_abbr_rec)\n  } else {\n    purrr::some(x, logical_abbr_rec)\n  }\n}\n\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\"),\n\n    # Recursive cases\n    pairlist = purrr::some(x, logical_abbr_rec),\n    call = find_tf_call(x)\n  )\n}\n\nlogical_abbr &lt;- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nlogical_abbr(T) # TRUE\n\n#&gt; [1] TRUE\n\nlogical_abbr(FALSE) # FALSE\n\n#&gt; [1] FALSE\n\nlogical_abbr(T(1, 2, 3)) # FALSE\n\n#&gt; [1] FALSE\n\nlogical_abbr(F(1, 2, 3)) # FALSE\n\n#&gt; [1] FALSE\n\n\nNote: I was unable to solve this exercise on my own, and needed to consult AR Solutions. The AR Solutions version only implements T, adding F is trivial.\n\n\nlogical_abbr() works with expressions. It currently fails when you give it a function. Why? How could you modify logical_abbr() to make it work? What components of a function will you need to recurse over?\n\n\nlogical_abbr(function(x = TRUE) {\n  g(x + T)\n})\n\nAR Solutions: The function currently fails, because \"closure\" is not handled in switch_expr() within logical_abbr_rec().\n\nf &lt;- function(x = TRUE) {\n  g(x + T)\n}\ntry(logical_abbr(!!f))\n\n#&gt; Error : Don't know how to handle type closure\n\n\nIf we want to make it work, we have to write a function to also iterate over the formals and the body of the input function.\nAnswer: the above example evaluates successfully as TRUE, however, the following fails, presumably because expr_type doesn’t handle closure:\n\ntry(logical_abbr(function(x = TRUE) {\n  g(x)\n}))\n\n#&gt; [1] FALSE\n\nis_closure(function(x = TRUE) {\n  g(x)\n})\n\n#&gt; [1] TRUE\n\ntypeof(function(x = TRUE) {\n  g(x)\n})\n\n#&gt; [1] \"closure\"\n\n\nNote: I’m not sure why the error says integer instead of closure.\n\n\nModify find_assign to also detect assignment using replacement functions, i.e. names(x) &lt;- y.\n\nAnswer: first compare the AST to normal assignment:\n\nast(x &lt;- y)\n\n#&gt; █─`&lt;-` \n#&gt; ├─x \n#&gt; └─y\n\nast(names(x) &lt;- y)\n\n#&gt; █─`&lt;-` \n#&gt; ├─█─names \n#&gt; │ └─x \n#&gt; └─y\n\n\nAssignment is a call object where the first element is the symbol &lt;-, the second is a call object with the function and the name of the variable, and the third is the value to be assigned. The original code doesn’t detect name(x) &lt;- y:\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign &lt;- function(x) unique(find_assign_rec(enexpr(x)))\n\nfind_assign(a &lt;- b &lt;- c &lt;- 1)\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nfind_assign(names(x) &lt;- y)\n\n#&gt; character(0)\n\n\nTo detect the new pattern, modify find_assign_call to detect when the second element is a call, and return the third:\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else if (is_call(x, \"&lt;-\") && is_call(x[[2]])) {\n    lhs &lt;- as_string(x[[3]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign(a &lt;- b &lt;- c &lt;- 1)\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\nfind_assign(names(x) &lt;- y)\n\n#&gt; [1] \"y\"\n\n\nAR Solutions: Let’s see what the AST of such an assignment looks like:\n\nast(names(x) &lt;- x)\n\n#&gt; █─`&lt;-` \n#&gt; ├─█─names \n#&gt; │ └─x \n#&gt; └─x\n\n\nSo, we need to catch the case where the first two elements are both calls. Further the first call is identical to &lt;- and we must return only the second call to see which objects got new values assigned.\nThis is why we add the following block within another else statement in find_assign_call():\n\nif (is_call(x, \"&lt;-\") && is_call(x[[2]])) {\n  lhs &lt;- expr_text(x[[2]])\n  children &lt;- as.list(x)[-1]\n}\n\nLet us finish with the whole code, followed by some tests for our new function:\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nfind_assign &lt;- function(x) unique(find_assign_rec(enexpr(x)))\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    if (is_call(x, \"&lt;-\") && is_call(x[[2]])) {\n      lhs &lt;- expr_text(x[[2]])\n      children &lt;- as.list(x)[-1]\n    } else {\n      lhs &lt;- character()\n      children &lt;- as.list(x)\n    }\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = , symbol = character(),\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\n# Tests functionality\nfind_assign(x &lt;- y)\n\n#&gt; [1] \"x\"\n\nfind_assign(names(x))\n\n#&gt; character(0)\n\nfind_assign(names(x) &lt;- y)\n\n#&gt; [1] \"names(x)\"\n\nfind_assign(names(x(y)) &lt;- y)\n\n#&gt; [1] \"names(x(y))\"\n\nfind_assign(names(x(y)) &lt;- y &lt;- z)\n\n#&gt; [1] \"names(x(y))\" \"y\"\n\n\nNote: using expr_text() instead of as_string() is preferable.\n\n\nWrite a function that extracts all calls to a specified function.\n\nAnswer: this is similar to the previous exercise. Here is a simple version that doesn’t properly walk the tree:\n\nfind_fun_call &lt;- function(x, fun) {\n  if (is_call(x, fun)) expr_text(x) else character()\n}\n\nfind_call_rec &lt;- function(x, fun) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_call_rec),\n    call = find_fun_call(x, fun)\n  )\n}\n\nfind_call_fun &lt;- function(x, fun) find_call_rec(enexpr(x), fun)\n\nfind_call_fun(1:10, \"sum\")\n\n#&gt; character(0)\n\nfind_call_fun(x, \"sum\")\n\n#&gt; character(0)\n\nfind_call_fun(sum(1:10), \"sum\")\n\n#&gt; [1] \"sum(1:10)\"\n\nfind_call_fun(sum(1:10), \"mean\")\n\n#&gt; character(0)\n\nfind_call_fun(sum(1:10) + sum(11:20), \"sum\")\n\n#&gt; character(0)\n\n\nUpdated version:\n\nfind_fun_call &lt;- function(x, fun) {\n  if (is_call(x, fun)) {\n    parents &lt;- expr_text(x)\n    children &lt;- as.list(x)[-1]\n  } else {\n    parents &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(parents, flat_map_chr(children, find_call_rec, fun))\n}\n\nfind_call_fun(1:10, \"sum\")\n\n#&gt; character(0)\n\nfind_call_fun(x, \"sum\")\n\n#&gt; character(0)\n\nfind_call_fun(sum(1:10), \"sum\")\n\n#&gt; [1] \"sum(1:10)\"\n\nfind_call_fun(sum(1:10), \"mean\")\n\n#&gt; character(0)\n\nfind_call_fun(sum(1:10) + sum(11:20), \"sum\")\n\n#&gt; [1] \"sum(1:10)\"  \"sum(11:20)\"\n\nfind_call_fun(sum(sum(1:10), sum(11:20)), \"sum\")\n\n#&gt; [1] \"sum(sum(1:10), sum(11:20))\" \"sum(1:10)\"                 \n#&gt; [3] \"sum(11:20)\"\n\n\nAR Solutions: Here we need to delete the previously added else statement and check for a call (not necessarily &lt;-) within the first if() in find_assign_call(). We save a call when we found one and return it later as part of our character output. Everything else stays the same:\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x)) {\n    lhs &lt;- expr_text(x)\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign(x &lt;- y)\n\n#&gt; [1] \"x &lt;- y\"\n\nfind_assign(names(x(y)) &lt;- y &lt;- z)\n\n#&gt; [1] \"names(x(y)) &lt;- y &lt;- z\" \"names(x(y))\"           \"x(y)\"                 \n#&gt; [4] \"y &lt;- z\"\n\nfind_assign(mean(sum(1:3)))\n\n#&gt; [1] \"mean(sum(1:3))\" \"sum(1:3)\"       \"1:3\"\n\n\nNote: the AR Solutions version detects any function call, not a specific function call.",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#quasiquotation",
    "href": "analysis/advanced-r-4.html#quasiquotation",
    "title": "Advanced R (Metaprogramming)",
    "section": "19 Quasiquotation",
    "text": "19 Quasiquotation\nNow that you understand the tree structure of R code, it’s time to return to one of the fundamental ideas that make expr() and ast() work: quotation. In tidy evaluation, all quoting functions are actually quasiquoting functions because they also support unquoting. Where quotation is the act of capturing an unevaluated expression, unquotation is the ability to selectively evaluate parts of an otherwise quoted expression. Together, this is called quasiquotation. Quasiquotation makes it easy to create functions that combine code written by the function’s author with code written by the function’s user. This helps to solve a wide variety of challenging problems.\nQuasiquotation is one of the three pillars of tidy evaluation. You’ll learn about the other two (quosures and the data mask) in Chapter 20. When used alone, quasiquotation is most useful for programming, particularly for generating code. But when it’s combined with the other techniques, tidy evaluation becomes a powerful tool for data analysis.\n\n19.2.2 Exercises\n\nFor each function in the following base R code, identify which arguments are quoted and which are evaluated.\n\n\nlibrary(MASS) # nolint: unused_import_linter.\n\nmtcars2 &lt;- subset(mtcars, cyl == 4)\n\nwith(mtcars2, sum(vs))\nsum(mtcars2$am)\n\nrm(mtcars2)\n\nAnswer: using the technique described in the chapter, test arguments outside their functions:\n\nlibrary(MASS) # nolint: unused_import_linter.\ntry(MASS)\n\n#&gt; Error in eval(expr, envir) : object 'MASS' not found\n\nmtcars2 &lt;- subset(mtcars, cyl == 4)\nmtcars\n\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#&gt; AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#&gt; Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#&gt; Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#&gt; Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#&gt; Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#&gt; Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#&gt; Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\ntry(cyl)\n\n#&gt; Error in eval(expr, envir) : object 'cyl' not found\n\nwith(mtcars2, sum(vs))\n\n#&gt; [1] 10\n\nmtcars2\n\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\ntry(vs)\n\n#&gt; Error in eval(expr, envir) : object 'vs' not found\n\nsum(mtcars2$am)\n\n#&gt; [1] 8\n\nmtcars2$am\n\n#&gt;  [1] 1 0 0 1 1 1 0 1 1 1 1\n\nrm(mtcars2)\n\nResults: MASS, cyl, vs are quoted, mtcars, mtcars2 and mtcars2$am are not.\nAR Solutions: For each argument we first follow the advice from Advanced R and execute the argument outside of the respective function. Since MASS, cyl, vs and am are not objects contained in the global environment, their execution raises an “Object not found” error. This way we confirm that the respective function arguments are quoted. For the other arguments, we may inspect the source code (and the documentation) to check if any quoting mechanisms are applied or the arguments are evaluated.\n\nlibrary(MASS) # MASS is quoted # nolint: unused_import_linter.\n\nlibrary() also accepts character vectors and doesn’t quote when character.only is set to TRUE, so library(MASS, character.only = TRUE) would raise an error.\n\nmtcars2 &lt;- subset(mtcars, cyl == 4) # mtcars is evaluated\n# cyl is quoted\nwith(mtcars2, sum(vs)) # mtcars2 is evaluated\n# sum(vs) is quoted\nsum(mtcars2$am) # matcars$am is evaluated\n# am is quoted by $()\n\nWhen we inspect the source code of rm(), we notice that rm() catches its ... argument as an unevaluated call (in this case a pairlist) via match.call(). This call is then converted into a string for further evaluation.\n\nrm(mtcars2) # mtcars2 is quoted\n\n\n\nFor each function in the following tidyverse code, identify which arguments are quoted and which are evaluated.\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_cyl &lt;- mtcars %&gt;%\n  group_by(cyl) %&gt;%\n  summarise(mean = mean(mpg))\n\nggplot(by_cyl, aes(cyl, mean)) +\n  geom_point()\n\nAnswer: library automatically quotes its arguments. cyl, mpg, and mean are all data.frame columns.\n\nQuoted: dplyr, ggplot2, cyl, mpg, mean (in the final ggpot call)\nEvaluated: by_cyl, mtcars\n\nAR Solutions: From the previous exercise we’ve already learned that library() quotes its first argument.\n\nlibrary(dplyr) # dplyr is quoted\nlibrary(ggplot2) # ggplot2 is quoted\n\nIn similar fashion, it becomes clear that cyl is quoted by group_by().\n\nby_cyl &lt;- mtcars %&gt;% # mtcars is evaluated\n  group_by(cyl) %&gt;% # cyl is quoted\n  summarise(mean = mean(mpg)) # mean = mean(mpg) is quoted\n\nTo find out what happens in summarise(), we inspect the source code. Tracing down the S3-dispatch of summarise(), we see that the ... argument is quoted in dplyr:::summarise_cols() which is called in the underlying summarise.data.frame() method.\n\ndplyr::summarise\n\n#&gt; function (.data, ..., .by = NULL, .groups = NULL) \n#&gt; {\n#&gt;     by &lt;- enquo(.by)\n#&gt;     if (!quo_is_null(by) && !is.null(.groups)) {\n#&gt;         abort(\"Can't supply both `.by` and `.groups`.\")\n#&gt;     }\n#&gt;     UseMethod(\"summarise\")\n#&gt; }\n#&gt; &lt;bytecode: 0x117c61068&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\n\n\ndplyr:::summarise.data.frame\n\n#&gt; function (.data, ..., .by = NULL, .groups = NULL) \n#&gt; {\n#&gt;     by &lt;- compute_by({\n#&gt;         {\n#&gt;             .by\n#&gt;         }\n#&gt;     }, .data, by_arg = \".by\", data_arg = \".data\")\n#&gt;     cols &lt;- summarise_cols(.data, dplyr_quosures(...), by, \"summarise\")\n#&gt;     out &lt;- summarise_build(by, cols)\n#&gt;     if (!cols$all_one) {\n#&gt;         summarise_deprecate_variable_size()\n#&gt;     }\n#&gt;     if (!is_tibble(.data)) {\n#&gt;         out &lt;- as.data.frame(out)\n#&gt;     }\n#&gt;     if (identical(.groups, \"rowwise\")) {\n#&gt;         out &lt;- rowwise_df(out, character())\n#&gt;     }\n#&gt;     out\n#&gt; }\n#&gt; &lt;bytecode: 0x130a41688&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\n\n\ndplyr:::summarise_cols\n#&gt; function (.data, ...)\n#&gt; {\n#&gt;     mask &lt;- DataMask$new(.data, caller_env())\n#&gt;     dots &lt;- enquos(...)\n#&gt;     dots_names &lt;- names(dots)\n#&gt;     auto_named_dots &lt;- names(enquos(..., .named = TRUE))\n#&gt;     cols &lt;- list()\n#&gt;     sizes &lt;- 1L\n#&gt;     chunks &lt;- vector(\"list\", length(dots))\n#&gt;     types &lt;- vector(\"list\", length(dots))\n#&gt;\n#&gt;     ## function definition abbreviated for clarity ##\n#&gt; }\n#&gt; &lt;bytecode: 0x55b540c07ca0&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\nIn the following {ggplot2} expression the cyl- and mean-objects are quoted.\n\nggplot(\n  by_cyl, # by_cyl is evaluated\n  aes(cyl, mean) # aes() is evaluated\n) +\n  # cyl, mean is quoted (via aes)\n  geom_point()\n\nWe can confirm this also by inspecting aes()’s source code.\n\nggplot2::aes\n\n#&gt; function (x, y, ...) \n#&gt; {\n#&gt;     xs &lt;- arg_enquos(\"x\")\n#&gt;     ys &lt;- arg_enquos(\"y\")\n#&gt;     dots &lt;- enquos(...)\n#&gt;     args &lt;- c(xs, ys, dots)\n#&gt;     args &lt;- Filter(Negate(quo_is_missing), args)\n#&gt;     local({\n#&gt;         aes &lt;- function(x, y, ...) NULL\n#&gt;         inject(aes(!!!args))\n#&gt;     })\n#&gt;     class_mapping(rename_aes(args), env = parent.frame())\n#&gt; }\n#&gt; &lt;bytecode: 0x11786fb30&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n\n\n\n\n19.3.6 Exercises\n\nHow is expr() implemented? Look at its source code.\n\nAnswer: reviewing the source code:\n\nrlang::expr\n\n#&gt; function (expr) \n#&gt; {\n#&gt;     enexpr(expr)\n#&gt; }\n#&gt; &lt;bytecode: 0x110c4f520&gt;\n#&gt; &lt;environment: namespace:rlang&gt;\n\nrlang::enexpr\n\n#&gt; function (arg) \n#&gt; {\n#&gt;     .Call(ffi_enexpr, substitute(arg), parent.frame())\n#&gt; }\n#&gt; &lt;bytecode: 0x137bd2428&gt;\n#&gt; &lt;environment: namespace:rlang&gt;\n\n\nexpr() simply calls enexpr(), which uses the C++ function ffi_enexpr and uses the base R function substitute().\nAR Solutions: expr() acts as a simple wrapper, which passes its argument to enexpr().\n\n\nCompare and contrast the following two functions. Can you predict the output before running them?\n\n\nf1 &lt;- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 &lt;- function(x, y) {\n  enexprs(x = x, y = y)\n}\nf1(a + b, c + d)\nf2(a + b, c + d)\n\nAnswer: per Advanced R, exprs(x = x, y = y) is shorthand for list(x = expr(x), y = expr(y)), and expr() will capture the argument exactly as provided. enexpr() captures what the caller supplied, with enexprs() returning a list.\nTest the predictions in comments:\n\nf1 &lt;- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 &lt;- function(x, y) {\n  enexprs(x = x, y = y)\n}\n# returns $x x $y y\nf1(a + b, c + d)\n\n#&gt; $x\n#&gt; x\n#&gt; \n#&gt; $y\n#&gt; y\n\n# returns $x a + b $y c + d\nf2(a + b, c + d)\n\n#&gt; $x\n#&gt; a + b\n#&gt; \n#&gt; $y\n#&gt; c + d\n\n\nCorrect!\nAR Solutions: Both functions are able to capture multiple arguments and will return a named list of expressions. f1() will return the arguments defined within the body of f1(). This happens because exprs() captures the expressions as specified by the developer during the definition of f1().\n\nf1(a + b, c + d)\n\n#&gt; $x\n#&gt; x\n#&gt; \n#&gt; $y\n#&gt; y\n\n\nf2() will return the arguments supplied to f2() as specified by the user when the function is called.\n\nf2(a + b, c + d)\n\n#&gt; $x\n#&gt; a + b\n#&gt; \n#&gt; $y\n#&gt; c + d\n\n\n\n\nWhat happens if you try to use enexpr() with an expression (i.e.  enexpr(x + y) ? What happens if enexpr() is passed a missing argument?\n\nAnswer: from the code below, arg must be a symbol, not an expression, and arg must exist.\n\ntry(enexpr(x + y))\n\n#&gt; Error in enexpr(x + y) : `arg` must be a symbol\n\ntry(enexpr(arg = foo))\n\n#&gt; Error in (function (arg)  : object 'foo' not found\n\n\nAR Solutions: In the first case an error is thrown:\n\non_expr &lt;- function(x) {\n  enexpr(expr(x))\n}\ntry(on_expr(x + y))\n\n#&gt; Error in enexpr(expr(x)) : `arg` must be a symbol\n\n\nIn the second case a missing argument is returned:\n\non_missing &lt;- function(x) {\n  enexpr(x)\n}\non_missing()\nis_missing(on_missing())\n\n#&gt; [1] TRUE\n\n\n\n\nHow are exprs(a) and exprs(a = ) different? Think about both the input and the output.\n\nAnswer: as the code below demonstrates, expr(a) creates an unnamed list with a as the first element. exprs(a = ) which creates an named list with an empty first element. Input of the form x = y creates a named list, while the form x creates an unnamed list.\n\nexprs(a)\n\n#&gt; [[1]]\n#&gt; a\n\nexprs(a = )\n\n#&gt; $a\n\nexprs(a = a)\n\n#&gt; $a\n#&gt; a\n\n\nAR Solutions: In exprs(a) the input a is interpreted as a symbol for an unnamed argument. Consequently, the output shows an unnamed list with the first element containing the symbol a.\n\nout1 &lt;- exprs(a)\nstr(out1)\n\n#&gt; List of 1\n#&gt;  $ : symbol a\n\n\nIn exprs(a = ) the first argument is named a, but then no value is provided. This leads to the output of a named list with the first element named a, which contains the missing argument.\n\nout2 &lt;- exprs(a = )\nstr(out2)\n\n#&gt; List of 1\n#&gt;  $ a: symbol\n\nis_missing(out2$a)\n\n#&gt; [1] TRUE\n\n\n\n\nWhat are other differences between exprs() and alist()? Read the documentation for the named arguments of exprs() to find out.\n\nAnswer: exprs() has three named arguments (alist() has none):\n\n.named, which automatically adds names to the list\n.ignore_empty, which selectively ignores empty arguments depending on the setting\n.unquote_names, which treats use of := (which allows names injection) as =\n\nAR Solutions: exprs() provides the additional arguments .named (= FALSE), .ignore_empty (c(\"trailing\", \"none\", \"all\")) and .unquote_names (TRUE). .named allows to ensure that all dots are named. ignore_empty allows to specify how empty arguments should be handled for dots (\"trailing\") or all arguments (\"none\" and \"all\"). Further via .unquote_names one can specify if := should be treated like =. := can be useful as it supports unquoting (!!) on the left-hand side.\n\n\nThe documentation for substitute() says:\n\nSubstitution takes place by examining each component of the parse tree as follows:\n\nIf it is not a bound symbol in env, it is unchanged.\nIf it is a promise object (i.e., a formal argument to a function) the expression slot of the promise replaces the symbol.\nIf it is an ordinary variable, its value is substituted, unless env is .GlobalEnv in which case the symbol is left unchanged.\n\n\nCreate examples that illustrate each of the above cases.\n\nAnswer: reviewing Google results for R bound symbol, R promise object, and chapter 6.5.1, construct the following code:\n\n# ordinary variable in `.GlobalEnv`\nfoo &lt;- \"bar\"\nsubstitute(foo)\n\n#&gt; foo\n\n# ordinary variable not in `.GlobalEnv`\nlocal({\n  foo &lt;- \"bar\"\n  substitute(foo)\n})\n\n#&gt; [1] \"bar\"\n\n# not a bound symbol in `env`\nsubstitute(func)\n\n#&gt; func\n\n# promise object\nlocal({\n  x &lt;- 1:5\n  y &lt;- 1:10\n  substitute(mean(x = y))\n})\n\n#&gt; mean(x = 1:10)\n\n\nIn the promise example, y is substituted, but not x, since x is the formal argument to mean().\nAR Solutions: Let’s create a new environment my_env, which contains no objects. In this case substitute() will just return its first argument (expr):\n\nmy_env &lt;- env()\nsubstitute(x, my_env)\n\n#&gt; x\n\n\nWhen we create a function containing an argument, which is directly returned after substitution, this function just returns the provided expression:\n\nfoo &lt;- function(x) substitute(x)\n\nfoo(x + y * sin(0))\n\n#&gt; x + y * sin(0)\n\n\nIn case substitute() can find (parts of) the expression in env, it will literally substitute. However, unless env is .GlobalEnv.\n\nmy_env$x &lt;- 7\nsubstitute(x, my_env)\n\n#&gt; [1] 7\n\nx &lt;- 7\nsubstitute(x, .GlobalEnv)\n\n#&gt; x\n\n\n\n\n\n19.4.8 Exercises\n\nGiven the following components:\n\n\nxy &lt;- expr(x + y)\nxz &lt;- expr(x + z)\nyz &lt;- expr(y + z)\nabc &lt;- exprs(a, b, c)\n\nUse quasiquotation to construct the following calls:\n\n(x + y) / (y + z)\n-(x + z)^(y + z)\n(x + y) + (y + z) - (x + y)\natan2(x + y, y + z)\nsum(x + y, x + y, y + z)\nsum(a, b, c)\nmean(c(a, b, c), na.rm = TRUE)\nfoo(a = x + y, b = y + z)\n\nAnswer: code below.\n\n# (x + y) / (y + z)\nexpr(!!xy / !!yz)\n\n#&gt; (x + y)/(y + z)\n\n# -(x + z) ^ (y + z)\nexpr(-(!!xz)^!!yz)\n\n#&gt; -(x + z)^(y + z)\n\n# (x + y) + (y + z) - (x + y)\nexpr(((!!xy)) + !!yz - !!xy)\n\n#&gt; (x + y) + (y + z) - (x + y)\n\n# atan2(x + y, y + z)\nexpr(atan2(!!xy, !!yz))\n\n#&gt; atan2(x + y, y + z)\n\n# sum(x + y, x + y, y + z)\nexpr(sum(!!xy, !!xy, !!yz))\n\n#&gt; sum(x + y, x + y, y + z)\n\n# sum(a, b, c)\nexpr(sum(!!!abc))\n\n#&gt; sum(a, b, c)\n\n# mean(c(a, b, c), na.rm = TRUE)\nexpr(mean(c(!!!abc), na.rm = TRUE))\n\n#&gt; mean(c(a, b, c), na.rm = TRUE)\n\n# foo(a = x + y, b = y + z)\nexpr(foo(a = !!xy, b = !!yz))\n\n#&gt; foo(a = x + y, b = y + z)\n\n\nSurprisingly, multiple parentheses are needed to construct (x + y) + (y + z) - (x + y).\nAR Solutions We combine and unquote the given quoted expressions to construct the desired calls like this:\n\nexpr(!!xy / !!yz) # (1)\n\n#&gt; (x + y)/(y + z)\n\nexpr(-(!!xz)^(!!yz)) # (2)\n\n#&gt; -(x + z)^(y + z)\n\nexpr(((!!xy)) + !!yz - !!xy) # (3)\n\n#&gt; (x + y) + (y + z) - (x + y)\n\nexpr(atan2(!!xy, !!yz)) # (4)\n\n#&gt; atan2(x + y, y + z)\n\nexpr(sum(!!xy, !!xy, !!yz)) # (5)\n\n#&gt; sum(x + y, x + y, y + z)\n\nexpr(sum(!!!abc)) # (6)\n\n#&gt; sum(a, b, c)\n\nexpr(mean(c(!!!abc), na.rm = TRUE)) # (7)\n\n#&gt; mean(c(a, b, c), na.rm = TRUE)\n\nexpr(foo(a = !!xy, b = !!yz)) # (8)\n\n#&gt; foo(a = x + y, b = y + z)\n\n\n\n\nThe following two calls print the same, but are actually different:\n\n\n(a &lt;- expr(mean(1:10)))\n\n#&gt; mean(1:10)\n\n(b &lt;- expr(mean(!!(1:10))))\n\n#&gt; mean(1:10)\n\nidentical(a, b)\n\n#&gt; [1] FALSE\n\n\nWhat’s the difference? Which one is more natural?\nAnswer: the key difference is the use of !! for the sequence 1:10. Comparing expr() for both of the arguments supplied to mean, !! changes the expression from a call to : to an integer vector:\n\narga &lt;- expr(1:10)\nargb &lt;- expr(!!(1:10))\narga\n\n#&gt; 1:10\n\nast(!!arga)\n\n#&gt; █─`:` \n#&gt; ├─1 \n#&gt; └─10\n\nargb\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nast(!!argb)\n\n#&gt; &lt;inline integer&gt;\n\n\nUse of !! creates a non-standard AST with an inline integer. The first form is more natural.\nAR Solutions: It’s easiest to see the difference with lobstr::ast():\n\nlobstr::ast(mean(1:10))\n\n#&gt; █─mean \n#&gt; └─█─`:` \n#&gt;   ├─1 \n#&gt;   └─10\n\nlobstr::ast(mean(!!(1:10)))\n\n#&gt; █─mean \n#&gt; └─&lt;inline integer&gt;\n\n\nIn the expression mean(!!(1:10)) the call 1:10 is evaluated to an integer vector, while still being a call object in mean(1:10).\nThe first version (mean(1:10)) seems more natural. It captures lazy evaluation, with a promise that is evaluated when the function is called. The second version (mean(!!(1:10))) inlines a vector directly into a call.\n\n\n\n19.6.5 Exercises\n\nOne way to implement exec() is shown below. Describe how it works. What are the key ideas?\n\n\nexec &lt;- function(f, ..., .env = caller_env()) {\n  args &lt;- list2(...)\n  do.call(f, args, envir = .env)\n}\n\nAnswer: the implementation is a wrapper to do.call(), which requires a function, list of arguments, and environment (it also has a quote parameter which is set to FALSE by default). list2() is used to convert the function arguments into a list which is compatible with do.call().\nAR Solutions: exec() takes a function (f), its arguments (...) and an environment (.env) as input. This allows to construct a call from f and ... and evaluate this call in the supplied environment. As the ... argument is handled via list2(), exec() supports tidy dots (quasiquotation), which means that arguments and names (on the left-hand side of :=) can be unquoted via !! and !!!.\n\n\nCarefully read the source code for interaction(), expand.grid(), and par(). Compare and contrast the techniques they use for switching between dots and list behaviour.\n\nAnswer: reviewing the source code for each function, all three functions convert dots into a list using list(...). All three also allow passing multiple arguments as well as a list as a single argument.\n\ninteraction\n\n#&gt; function (..., drop = FALSE, sep = \".\", lex.order = FALSE) \n#&gt; {\n#&gt;     args &lt;- list(...)\n#&gt;     narg &lt;- length(args)\n#&gt;     if (narg &lt; 1L) \n#&gt;         stop(\"No factors specified\")\n#&gt;     if (narg == 1L && is.list(args[[1L]])) {\n#&gt;         args &lt;- args[[1L]]\n#&gt;         narg &lt;- length(args)\n#&gt;     }\n#&gt;     for (i in narg:1L) {\n#&gt;         x &lt;- as.factor(args[[i]])[, drop = drop]\n#&gt;         ax &lt;- as.integer(x) - 1L\n#&gt;         lx &lt;- levels(x)\n#&gt;         if (i == narg) {\n#&gt;             ay &lt;- ax\n#&gt;             ly &lt;- lx\n#&gt;         }\n#&gt;         else {\n#&gt;             nx &lt;- length(lx)\n#&gt;             ny &lt;- length(ly)\n#&gt;             if (lex.order) {\n#&gt;                 ay &lt;- ay + ny * ax\n#&gt;                 if (drop) {\n#&gt;                   az &lt;- sort(unique(ay))\n#&gt;                   ly &lt;- paste(lx[az%/%ny + 1L], ly[az%%ny + 1L], \n#&gt;                     sep = sep)\n#&gt;                   ay &lt;- match(ay, az) - 1L\n#&gt;                 }\n#&gt;                 else {\n#&gt;                   ly &lt;- paste(rep(lx, each = ny), rep(ly, nx), \n#&gt;                     sep = sep)\n#&gt;                 }\n#&gt;             }\n#&gt;             else {\n#&gt;                 ay &lt;- ay * nx + ax\n#&gt;                 if (drop) {\n#&gt;                   az &lt;- sort(unique(ay))\n#&gt;                   ly &lt;- paste(lx[az%%nx + 1L], ly[az%/%nx + 1L], \n#&gt;                     sep = sep)\n#&gt;                   ay &lt;- match(ay, az) - 1L\n#&gt;                 }\n#&gt;                 else {\n#&gt;                   ly &lt;- paste(rep(lx, ny), rep(ly, each = nx), \n#&gt;                     sep = sep)\n#&gt;                 }\n#&gt;             }\n#&gt;             while (j &lt;- anyDuplicated(ly)) {\n#&gt;                 i &lt;- match(ly[j], ly)\n#&gt;                 ly &lt;- ly[-j]\n#&gt;                 j &lt;- j - 1L\n#&gt;                 ay[ay == j] &lt;- i - 1L\n#&gt;                 ay[ay &gt; j] &lt;- ay[ay &gt; j] - 1L\n#&gt;             }\n#&gt;         }\n#&gt;     }\n#&gt;     structure(as.integer(ay + 1L), levels = ly, class = \"factor\")\n#&gt; }\n#&gt; &lt;bytecode: 0x143792c28&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nexpand.grid\n\n#&gt; function (..., KEEP.OUT.ATTRS = TRUE, stringsAsFactors = TRUE) \n#&gt; {\n#&gt;     nargs &lt;- length(args &lt;- list(...))\n#&gt;     if (!nargs) \n#&gt;         return(as.data.frame(list()))\n#&gt;     if (nargs == 1L && is.list(a1 &lt;- args[[1L]])) \n#&gt;         nargs &lt;- length(args &lt;- a1)\n#&gt;     if (nargs == 0L) \n#&gt;         return(as.data.frame(list()))\n#&gt;     cargs &lt;- vector(\"list\", nargs)\n#&gt;     iArgs &lt;- seq_len(nargs)\n#&gt;     nmc &lt;- paste0(\"Var\", iArgs)\n#&gt;     nm &lt;- names(args)\n#&gt;     if (is.null(nm)) \n#&gt;         nm &lt;- nmc\n#&gt;     else if (any(ng0 &lt;- nzchar(nm))) \n#&gt;         nmc[ng0] &lt;- nm[ng0]\n#&gt;     names(cargs) &lt;- nmc\n#&gt;     rep.fac &lt;- 1L\n#&gt;     d &lt;- lengths(args)\n#&gt;     if (KEEP.OUT.ATTRS) {\n#&gt;         dn &lt;- vector(\"list\", nargs)\n#&gt;         names(dn) &lt;- nmc\n#&gt;     }\n#&gt;     orep &lt;- prod(d)\n#&gt;     if (orep == 0L) {\n#&gt;         for (i in iArgs) cargs[[i]] &lt;- args[[i]][FALSE]\n#&gt;     }\n#&gt;     else {\n#&gt;         for (i in iArgs) {\n#&gt;             x &lt;- args[[i]]\n#&gt;             if (KEEP.OUT.ATTRS) \n#&gt;                 dn[[i]] &lt;- paste0(nmc[i], \"=\", if (is.numeric(x)) \n#&gt;                   format(x)\n#&gt;                 else x)\n#&gt;             nx &lt;- length(x)\n#&gt;             orep &lt;- orep/nx\n#&gt;             if (stringsAsFactors && is.character(x)) \n#&gt;                 x &lt;- factor(x, levels = unique(x))\n#&gt;             x &lt;- x[rep.int(rep.int(seq_len(nx), rep.int(rep.fac, \n#&gt;                 nx)), orep)]\n#&gt;             cargs[[i]] &lt;- x\n#&gt;             rep.fac &lt;- rep.fac * nx\n#&gt;         }\n#&gt;     }\n#&gt;     if (KEEP.OUT.ATTRS) \n#&gt;         attr(cargs, \"out.attrs\") &lt;- list(dim = d, dimnames = dn)\n#&gt;     rn &lt;- .set_row_names(as.integer(prod(d)))\n#&gt;     structure(cargs, class = \"data.frame\", row.names = rn)\n#&gt; }\n#&gt; &lt;bytecode: 0x130a5a1c0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\npar\n\n#&gt; function (..., no.readonly = FALSE) \n#&gt; {\n#&gt;     .Pars.readonly &lt;- c(\"cin\", \"cra\", \"csi\", \"cxy\", \"din\", \"page\")\n#&gt;     single &lt;- FALSE\n#&gt;     args &lt;- list(...)\n#&gt;     if (!length(args)) \n#&gt;         args &lt;- as.list(if (no.readonly) \n#&gt;             .Pars[-match(.Pars.readonly, .Pars)]\n#&gt;         else .Pars)\n#&gt;     else {\n#&gt;         if (all(unlist(lapply(args, is.character)))) \n#&gt;             args &lt;- as.list(unlist(args))\n#&gt;         if (length(args) == 1) {\n#&gt;             if (is.list(args[[1L]]) || is.null(args[[1L]])) \n#&gt;                 args &lt;- args[[1L]]\n#&gt;             else if (is.null(names(args))) \n#&gt;                 single &lt;- TRUE\n#&gt;         }\n#&gt;     }\n#&gt;     value &lt;- .External2(C_par, args)\n#&gt;     if (single) \n#&gt;         value &lt;- value[[1L]]\n#&gt;     if (!is.null(names(args))) \n#&gt;         invisible(value)\n#&gt;     else value\n#&gt; }\n#&gt; &lt;bytecode: 0x110b1b4a0&gt;\n#&gt; &lt;environment: namespace:graphics&gt;\n\n\nAR Solutions: All three functions capture the dots via args &lt;- list(...).\ninteraction() computes factor interactions between the captured input factors by iterating over the args. When a list is provided this is detected via length(args) == 1 && is.list(args[[1]]) and one level of the list is stripped through args &lt;- args[[1]]. The rest of the function’s code doesn’t differentiate further between list and dots behaviour.\n\n# styler: off\n# Both calls create the same output\ninteraction(     a = c(\"a\", \"b\", \"c\", \"d\"), b = c(\"e\", \"f\"))  # dots\n\n#&gt; [1] a.e b.f c.e d.f\n#&gt; Levels: a.e b.e c.e d.e a.f b.f c.f d.f\n\ninteraction(list(a = c(\"a\", \"b\", \"c\", \"d\"), b = c(\"e\", \"f\"))) # list\n\n#&gt; [1] a.e b.f c.e d.f\n#&gt; Levels: a.e b.e c.e d.e a.f b.f c.f d.f\n\n# styler: on\n\nexpand.grid() uses the same strategy and also assigns args &lt;- args[[1]] in case of length(args) == 1 && is.list(args[[1]]).\npar() does the most pre-processing to ensure a valid structure of the args argument. When no dots are provided (!length(args)) it creates a list of arguments from an internal character vector (partly depending on its no.readonly argument). Further, given that all elements of args are character vectors (all(unlist(lapply(args, is.character)))), args is turned into a list via as.list(unlist(args)) (this flattens nested lists). Similar to the other functions, one level of args gets stripped via args &lt;- args[[1L]], when args is of length one and its first element is a list.\n\n\nExplain the problem with this definition of set_attr()\n\n\nset_attr &lt;- function(x, ...) {\n  attr &lt;- rlang::list2(...)\n  attributes(x) &lt;- attr\n  x\n}\ntry(set_attr(1:10, x = 10))\n\n#&gt; Error in attributes(x) &lt;- attr : attributes must be named\n\n\nAnswer: attributes(x) &lt;- value requires value to be a named list, which is only generated for list2 calls of the form list2(a = 1, b = 2) - setting .named = TRUE doesn’t help in this case as it generates zero-length names which are not allowed by attributes(). Using dots will only work when each attribute is explicitly named.\n\nset_attr &lt;- function(x, ...) {\n  attr &lt;- rlang::list2(..., .named = TRUE)\n  attributes(x) &lt;- attr\n  x\n}\ntry(set_attr(1:10, x = 10))\n\n#&gt; Error in attributes(x) &lt;- attr : attempt to use zero-length variable name\n\n\nAR Solutions: set_attr() expects an object named x and its attributes, supplied via the dots. Unfortunately, this prohibits us to provide attributes named x as these would collide with the argument name of our object. Even omitting the object’s argument name doesn’t help in this case — as can be seen in the example where the object is consequently treated as an unnamed attribute.\nHowever, we may name the first argument .x, which seems clearer and less likely to invoke errors. In this case 1:10 will get the (named) attribute x = 10 assigned:\n\nset_attr &lt;- function(.x, ...) {\n  attr &lt;- rlang::list2(...)\n\n  attributes(.x) &lt;- attr\n  .x\n}\n\nset_attr(1:10, x = 10)\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n#&gt; attr(,\"x\")\n#&gt; [1] 10\n\n\n\n\n\n19.7.5 Exercises\n\nIn the linear-model example, we could replace the expr() in reduce(summands, ~ expr(!!.x + !!.y)) with call2(): reduce(summands, call2, \"+\"). Compare and contrast the two approaches. Which do you think is easier to read?\n\nAnswer: both approaches add the first and second arguments. The call2() method implicitly passes the arguments, where the formula method explicitly adds them, making it easier to understand.\nAR Solutions:\n\n\nRe-implement the Box-Cox transform defined below using unquoting and new_function():\n\n\nbc &lt;- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x^lambda - 1) / lambda\n  }\n}\n\nbc(0)\n\n#&gt; function (x) \n#&gt; log(x)\n#&gt; &lt;environment: 0x1434676a0&gt;\n\nbc(2)\n\n#&gt; function (x) \n#&gt; (x^lambda - 1)/lambda\n#&gt; &lt;bytecode: 0x14370d0f8&gt;\n#&gt; &lt;environment: 0x1434a1278&gt;\n\nbc(0)(2)\n\n#&gt; [1] 0.6931472\n\nbc(2)(2)\n\n#&gt; [1] 1.5\n\n\nAnswer: code below.\n\nbc &lt;- function(lambda) {\n  if (lambda == 0) {\n    func &lt;- expr({\n      log(x)\n    })\n  } else {\n    func &lt;- expr({\n      ((x^!!lambda) - 1) / !!lambda\n    })\n  }\n  new_function(\n    exprs(x = ),\n    func,\n    caller_env()\n  )\n}\n\nbc(0)\n\n#&gt; function (x) \n#&gt; {\n#&gt;     log(x)\n#&gt; }\n\nbc(2)\n\n#&gt; function (x) \n#&gt; {\n#&gt;     ((x^2) - 1)/2\n#&gt; }\n\nbc(0)(2)\n\n#&gt; [1] 0.6931472\n\nbc(2)(2)\n\n#&gt; [1] 1.5\n\n\nAR Solutions: Here new_function() allows us to create a function factory using tidy evaluation.\n\nbc2 &lt;- function(lambda) {\n  lambda &lt;- enexpr(lambda)\n\n  if (!!lambda == 0) { # nolint: if_not_else_linter.\n    new_function(exprs(x = ), expr(log(x)))\n  } else {\n    new_function(exprs(x = ), expr((x^(!!lambda) - 1) / !!lambda))\n  }\n}\n\nbc2(0)\n\n#&gt; function (x) \n#&gt; log(x)\n#&gt; &lt;environment: 0x137f9e1a0&gt;\n\nbc2(2)\n\n#&gt; function (x) \n#&gt; (x^2 - 1)/2\n#&gt; &lt;environment: 0x137e1dcb8&gt;\n\nbc2(2)(2)\n\n#&gt; [1] 1.5\n\n\nNote: I prefer the base R approach to new_function().\n\n\nRe-implement the simple compose() defined below using quasiquotation and new_function():\n\n\ncompose &lt;- function(f, g) {\n  function(...) f(g(...))\n}\n\ncompose(sum, as.integer)\n\n#&gt; function (...) \n#&gt; f(g(...))\n#&gt; &lt;environment: 0x1161502e0&gt;\n\ncompose(sum, as.integer)(1:10)\n\n#&gt; [1] 55\n\n\nAnswer: (non-working) code below.\n\ncompose &lt;- function(f, g) {\n  new_function(\n    expr(...),\n    expr({\n      (!!f)((!!g)(...))\n    }),\n    caller_env()\n  )\n}\n\ncompose(sum, as.integer)\ncompose(sum, as.integer)(1:10)\n\nAR Solutions: The implementation is fairly straightforward, even though a lot of parentheses are required:\n\ncompose2 &lt;- function(f, g) {\n  f &lt;- enexpr(f)\n  g &lt;- enexpr(g)\n\n  new_function(exprs(... = ), expr((!!f)((!!g)(...))))\n}\n\ncompose(sin, cos)\n\n#&gt; function (...) \n#&gt; f(g(...))\n#&gt; &lt;bytecode: 0x1304a2ab8&gt;\n#&gt; &lt;environment: 0x1309aaf38&gt;\n\ncompose(sin, cos)(pi)\n\n#&gt; [1] -0.841471\n\ncompose2(sin, cos)\n\n#&gt; function (...) \n#&gt; sin(cos(...))\n#&gt; &lt;environment: 0x130a1d420&gt;\n\ncompose2(sin, cos)(pi)\n\n#&gt; [1] -0.841471",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-4.html#evaluation",
    "href": "analysis/advanced-r-4.html#evaluation",
    "title": "Advanced R (Metaprogramming)",
    "section": "20 Evaluation",
    "text": "20 Evaluation\nThe user-facing inverse of quotation is unquotation: it gives the user the ability to selectively evaluate parts of an otherwise quoted argument. The developer-facing complement of quotation is evaluation: this gives the developer the ability to evaluate quoted expressions in custom environments to achieve specific goals.\nThis chapter begins with a discussion of evaluation in its purest form. You’ll learn how eval() evaluates an expression in an environment, and then how it can be used to implement a number of important base R functions. Once you have the basics under your belt, you’ll learn extensions to evaluation that are needed for robustness. There are two big new ideas:\n\nThe quosure: a data structure that captures an expression along with its associated environment, as found in function arguments.\nThe data mask, which makes it easier to evaluate an expression in the context of a data frame. This introduces potential evaluation ambiguity which we’ll then resolve with data pronouns.\n\nTogether, quasiquotation, quosures, and data masks form what we call tidy evaluation, or tidy eval for short. Tidy eval provides a principled approach to non-standard evaluation that makes it possible to use such functions both interactively and embedded with other functions. Tidy evaluation is the most important practical implication of all this theory so we’ll spend a little time exploring the implications. The chapter finishes off with a discussion of the closest related approaches in base R, and how you can program around their drawbacks.\n\n20.2.4 Exercises\n\nCarefully read the documentation for source(). What environment does it use by default? What if you supply local = TRUE? How do you provide a custom environment?\n\nAnswer: by default, source() uses the global environment, and uses the calling environment with local = TRUE, and doesn’t support other options; to provide a custom environment, you must use sys.source().\nAR Solutions: By default, source() uses the global environment (local = FALSE). A specific evaluation environment may be chosen, by passing it explicitly to the local argument. To use current environment (i.e. the calling environment of source()) set local = TRUE.\n\n# Create a temporary, sourceable R script that prints x\ntmp_file &lt;- tempfile()\nwriteLines(\"print(x)\", tmp_file)\n\n# Set `x` globally\nx &lt;- \"global environment\"\nenv2 &lt;- env(x = \"specified environment\")\n\nlocate_evaluation &lt;- function(file, local) {\n  x &lt;- \"local environment\"\n  source(file, local = local)\n}\n\n# Where will source() evaluate the code?\nlocate_evaluation(tmp_file, local = FALSE) # default\n\n#&gt; [1] \"global environment\"\n\nlocate_evaluation(tmp_file, local = env2)\n\n#&gt; [1] \"specified environment\"\n\nlocate_evaluation(tmp_file, local = TRUE)\n\n#&gt; [1] \"local environment\"\n\n\n\n\nPredict the results of the following lines of code:\n\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n\nAnswer: all of these should return 4, since the innermost expression is evaluated first.\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\n\n#&gt; [1] 4\n\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n\n#&gt; [1] 4\n\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n\n#&gt; eval(expr(eval(expr(eval(expr(2 + 2))))))\n\n\nIncorrect: let’s explore how these are evaluated:\n\nexpr(2 + 2)\n\n#&gt; 2 + 2\n\neval(expr(2 + 2))\n\n#&gt; [1] 4\n\nexpr(eval(expr(2 + 2)))\n\n#&gt; eval(expr(2 + 2))\n\neval(expr(eval(expr(2 + 2))))\n\n#&gt; [1] 4\n\nexpr(eval(expr(eval(expr(2 + 2)))))\n\n#&gt; eval(expr(eval(expr(2 + 2))))\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\n\n#&gt; [1] 4\n\n\nWhen expr() is on the outside, the expression isn’t evaluated, when eval() is on the outside the answer ‘collapses’ to 4.\nAR Solutions: Let’s look at a quote from the first edition of Advanced R:\n\n“expr() and eval() are opposites. […] each eval() peels off one layer of expr()’s”.\n\nIn general, eval(expr(x)) evaluates to x. Therefore, (1) evaluates to \\(2 + 2 = 4\\). Adding another eval() doesn’t have impact here. So, also (2) evaluates to 4. However, when wrapping (1) into expr() the whole expression will be quoted.\n\neval(expr(eval(expr(eval(expr(2 + 2)))))) # (1)\n\n#&gt; [1] 4\n\neval(eval(expr(eval(expr(eval(expr(2 + 2))))))) # (2)\n\n#&gt; [1] 4\n\nexpr(eval(expr(eval(expr(eval(expr(2 + 2))))))) # (3)\n\n#&gt; eval(expr(eval(expr(eval(expr(2 + 2))))))\n\n\n\n\nFill in the function bodies below to re-implement get() using sym() and eval(), andassign() using sym(), expr(), and eval(). Don’t worry about the multiple ways of choosing an environment that get() and assign() support; assume that the user supplies it explicitly.\n\n\n# name is a string\nget2 &lt;- function(name, env) {}\nassign2 &lt;- function(name, value, env) {}\n\nAnswer: code below.\n\nget2 &lt;- function(name, env) {\n  eval(sym(name), envir = env)\n}\nassign2 &lt;- function(name, value, env) {\n  s &lt;- sym(name)\n  eval(expr(!!s &lt;- !!value), envir = env)\n}\n\ntest &lt;- 1234\nget2(\"test\", caller_env())\n\n#&gt; [1] 1234\n\nassign2(\"test\", 2345, caller_env())\ntest\n\n#&gt; [1] 1234\n\n\nAR Solutions: We reimplement these two functions using tidy evaluation. We turn the string name into a symbol, then evaluate it:\n\nget2 &lt;- function(name, env = caller_env()) {\n  name_sym &lt;- sym(name)\n  eval(name_sym, env)\n}\n\nx &lt;- 1\nget2(\"x\")\n\n#&gt; [1] 1\n\n\nTo build the correct expression for the value assignment, we unquote using !!.\n\nassign2 &lt;- function(name, value, env = caller_env()) {\n  name_sym &lt;- sym(name)\n  assign_expr &lt;- expr(!!name_sym &lt;- !!value)\n  eval(assign_expr, env)\n}\n\nassign2(\"x\", 4)\nx\n\n#&gt; [1] 4\n\n\nNote: I had to review AR Solutions to discover the need to unquote using !!.\n\n\nModify source2() so it returns the result of every expression, not just the last one. Can you eliminate the for loop?\n\nAnswer: code below.\n\nmy_source2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  invisible(lapply(exprs, eval, env))\n}\n\nAR Solutions: The code for source2() was given in Advanced R as:\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  res &lt;- NULL\n  for (i in seq_along(exprs)) {\n    res &lt;- eval(exprs[[i]], env)\n  }\n\n  invisible(res)\n}\n\nIn order to highlight the modifications in our new source2() function, we’ve preserved the differing code from the former source2() in a comment.\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  # res &lt;- NULL\n  # for (i in seq_along(exprs)) {\n  #   res[[i]] &lt;- eval(exprs[[i]], env)\n  # }\n\n  res &lt;- purrr::map(exprs, eval, env)\n\n  invisible(res)\n}\n\nLet’s create a file and test source2(). Keep in mind that &lt;- returns invisibly.\n\ntmp_file &lt;- tempfile()\nwriteLines(\n  \"x &lt;- 1\n       x\n       y &lt;- 2\n       y  # some comment\",\n  tmp_file\n)\n\n(source2(tmp_file))\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 2\n\n\nNote: validate my_source2() returns the same results:\n\n(my_source2(tmp_file))\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 2\n\n\n\n\nWe can make base::local() slightly easier to understand by spreading out over multiple lines:\n\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  eval(call, envir = parent.frame())\n}\n\nExplain how local() works in words. (Hint: you might want to print(call) to help understand what substitute() is doing, and read the documentation to remind yourself what environment new.env() will inherit from.)\nAnswer: adding print(call) shows that substitute() creates a call to evaluate the expression passed to local3() in new.env(), which inherits the environment from the caller. So:\nlocal() works by evaluating an expression in a new child environment.\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  print(call)\n  eval(call, envir = parent.frame())\n}\n\nlocal3(test &lt;- 4567)\n\n#&gt; eval(quote(test &lt;- 4567), new.env())\n\n\nAR Solutions: Let’s follow the advice and add print(call) inside of local3():\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  print(call)\n  eval(call, envir = parent.frame())\n}\n\nThe first line generates a call to eval(), because substitute() operates in the current evaluation argument. However, this doesn’t matter here, as both, expr and envir are promises and therefore “the expression slots of the promises replace the symbols”, from ?substitute.\n\nlocal3({\n  x &lt;- 10\n  x * 2\n})\n\n#&gt; eval(quote({\n#&gt;     x &lt;- 10\n#&gt;     x * 2\n#&gt; }), new.env())\n\n\n#&gt; [1] 20\n\n\nNext, call will be evaluated in the caller environment (aka the parent frame). Given that call contains another call eval() why does this matter? The answer is subtle: this outer environment determines where the bindings for eval, quote, and new.env are found.\n\neval(quote({\n  x &lt;- 10\n  x * 2\n}), new.env())\n\n#&gt; [1] 20\n\nexists(\"x\")\n\n#&gt; [1] TRUE",
    "crumbs": [
      "Changelog",
      "Advanced R (Metaprogramming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html",
    "href": "analysis/advanced-r-2.html",
    "title": "Advanced R (Functional programming)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Functional programming” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions.\nlibrary(purrr)\nlibrary(palmerpenguins)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(rlang)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#introduction",
    "href": "analysis/advanced-r-2.html#introduction",
    "title": "Advanced R (Functional programming)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from Advanced R and Advanced R Solutions, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read Advanced R and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#functionals",
    "href": "analysis/advanced-r-2.html#functionals",
    "title": "Advanced R (Functional programming)",
    "section": "9 Functionals",
    "text": "9 Functionals\n\nTo become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs.\n— Bjarne Stroustrup\n\nA functional is a function that takes a function as an input and returns a vector as output. Here’s a simple functional: it calls the function provided as input with 1000 random uniform numbers.\n\nrandomise &lt;- function(f) f(runif(1e3))\nrandomise(mean)\n\n#&gt; [1] 0.4954485\n\nrandomise(mean)\n\n#&gt; [1] 0.4872664\n\nrandomise(sum)\n\n#&gt; [1] 510.0692\n\n\nThe chances are that you’ve already used a functional. You might have used for-loop replacements like base R’s lapply(), apply(), and tapply(); or purrr’s map(); or maybe you’ve used a mathematical functional like integrate() or optim().\nA common use of functionals is as an alternative to for loops. For loops have a bad rap in R because many people believe they are slow1, but the real downside of for loops is that they’re very flexible: a loop conveys that you’re iterating, but not what should be done with the results. Just as it’s better to use while than repeat, and it’s better to use for than while (Section 5.3.2), it’s better to use a functional than for. Each functional is tailored for a specific task, so when you recognise the functional you immediately know why it’s being used.\nIf you’re an experienced for loop user, switching to functionals is typically a pattern matching exercise. You look at the for loop and find a functional that matches the basic form. If one doesn’t exist, don’t try and torture an existing functional to fit the form you need. Instead, just leave it as a for loop! (Or once you’ve repeated the same loop two or more times, maybe think about writing your own functional).\n\n9.2.6 Exercises\n\nUse as_mapper() to explore how purrr generates anonymous functions for the integer, character, and list helpers. What helper allows you to extract attributes? Read the documentation to find out.\n\n\nmap_dbl\n\n#&gt; function (.x, .f, ..., .progress = FALSE) \n#&gt; {\n#&gt;     map_(\"double\", .x, .f, ..., .progress = .progress)\n#&gt; }\n#&gt; &lt;bytecode: 0x12453c7d0&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\nmap_dbl(mtcars, ~ length(unique(.x)))\n\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nas_mapper(~ length(unique(.x)))\n\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; length(unique(.x))\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\n\nfunction(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))\n\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; length(unique(.x))\n\nas_mapper(mean)\n\n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x121d08410&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nas_mapper(function(x) mean(x, na.rm = TRUE))\n\n#&gt; function (x) \n#&gt; mean(x, na.rm = TRUE)\n\nas_mapper(~ mean(.x, na.rm = TRUE))\n\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; mean(.x, na.rm = TRUE)\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\n\n\nAnswer: Exploration above. attr_getter() supports extraction of attributes.\nAR Solutions: map() offers multiple ways (functions, formulas, and extractor functions) to specify its function argument (.f). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of as_mapper() and it is called every time map() is used.\nGiven character, numeric or list input as_mapper() will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.\nThe extractor function is implemented as a call to purrr::pluck(), which accepts a list of accessors (accessors “access” some part of your data object).\n\nas_mapper(c(1, 2)) # equivalent to function(x) x[[1]][[2]]\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(1, 2), .default = NULL)\n#&gt; &lt;environment: 0x106b24a60&gt;\n\nas_mapper(c(\"a\", \"b\")) # equivalent to function(x) x[[\"a\"]][[\"b]]\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(\"a\", \"b\"), .default = NULL)\n#&gt; &lt;environment: 0x106ae7c90&gt;\n\nas_mapper(list(1, \"b\")) # equivalent to function(x) x[[1]][[\"b]]\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(1, \"b\"), .default = NULL)\n#&gt; &lt;environment: 0x106aaaa60&gt;\n\n\nBesides mixing positions and names, it is also possible to pass along an accessor function. This is basically an anonymous function that gets information about some aspect of the input data. You are free to define your own accessor functions.\nIf you need to access certain attributes, the helper attr_getter(y) is already predefined and will create the appropriate accessor function for you.\n\n# Define custom accessor function\nget_class &lt;- function(x) attr(x, \"class\")\npluck(mtcars, get_class)\n\n#&gt; [1] \"data.frame\"\n\n# Use attr_getter() as a helper\npluck(mtcars, attr_getter(\"class\"))\n\n#&gt; [1] \"data.frame\"\n\n\nNote: AR Solutions provides good additional insight into as_mapper().\n\n\nmap(1:3, ~ runif(2)) is a useful pattern for generating random numbers, but map(1:3, runif(2)) is not. Why not? Can you explain why it returns the result that it does?\n\n\nmap(1:3, ~ runif(2))\n\n#&gt; [[1]]\n#&gt; [1] 0.8581057 0.3393704\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 0.9347891 0.5697743\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 0.03250203 0.33498419\n\nmap(1:3, runif(2))\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\n\nAnswer: ~ runif(2) generates a mapper that returns 2 random values from the uniform distribution, where runif(2) creates a pluck() mapper with 2 random values, which will (nearly) always return NULL, as demonstrated by the code below:\n\nas_mapper(~ runif(2))\n\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; runif(2)\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\n\nas_mapper(runif(2))\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(0.8141626752913, 0.0680180434137583), .default = NULL)\n#&gt; &lt;environment: 0x11391ac20&gt;\n\n\nA more reasonable use of a pluck mapper for 1:3 is 1:\n\nmap(1:3, 1)\n\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\n\nAR Solutions: The first pattern creates multiple random numbers, because ~ runif(2) successfully uses the formula interface. Internally map() applies as_mapper() to this formula, which converts ~ runif(2) into an anonymous function. Afterwards runif(2) is applied three times (one time during each iteration), leading to three different pairs of random numbers.\nIn the second pattern runif(2) is evaluated once, then the results are passed to map(). Consequently as_mapper() creates an extractor function based on the return values from runif(2) (via pluck()). This leads to three NULLs (pluck()’s .default return), because no values corresponding to the index can be found.\nNote: AR Solutions provides additional detail, but is otherwise the same.\n\n\nUse the appropriate map() function to:\n\nCompute the standard deviation of every column in a numeric data frame.\nCompute the standard deviation of every numeric column in a mixed data frame. (Hint: you’ll need to do it in two steps.)\nCompute the number of levels for every factor in a data frame.\n\n\n\n# a\nmap_dbl(mtcars, sd)\n\n#&gt;         mpg         cyl        disp          hp        drat          wt \n#&gt;   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574 \n#&gt;        qsec          vs          am        gear        carb \n#&gt;   1.7869432   0.5040161   0.4989909   0.7378041   1.6152000\n\n# b\nmap_dbl(iris[map_lgl(iris, is.numeric)], sd)\n\n#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n#&gt;    0.8280661    0.4358663    1.7652982    0.7622377\n\n# c\nmap_int(warpbreaks, nlevels)\n\n#&gt;  breaks    wool tension \n#&gt;       0       2       3\n\n# c, excluding non-factor columns\nmap_int(warpbreaks[map_lgl(warpbreaks, is.factor)], nlevels)\n\n#&gt;    wool tension \n#&gt;       2       3\n\n\nAnswer: code above.\nAR Solutions: To solve this exercise we take advantage of calling the type stable variants of map(), which give us more concise output, and use map_lgl() to select the columns of the data frame (later you’ll learn about keep(), which simplifies this pattern a little).\n\nmap_dbl(mtcars, sd)\n\n#&gt;         mpg         cyl        disp          hp        drat          wt \n#&gt;   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574 \n#&gt;        qsec          vs          am        gear        carb \n#&gt;   1.7869432   0.5040161   0.4989909   0.7378041   1.6152000\n\npenguins_numeric &lt;- map_lgl(penguins, is.numeric)\nmap_dbl(penguins[penguins_numeric], sd, na.rm = TRUE)\n\n#&gt;    bill_length_mm     bill_depth_mm flipper_length_mm       body_mass_g \n#&gt;         5.4595837         1.9747932        14.0617137       801.9545357 \n#&gt;              year \n#&gt;         0.8183559\n\npenguins_factor &lt;- map_lgl(penguins, is.factor)\nmap_int(penguins[penguins_factor], ~ length(levels(.x))) # nolint: length_levels_linter.\n\n#&gt; species  island     sex \n#&gt;       3       3       2\n\n\nNote: my code is more concise, both with selections and use of nlevels(), although using keep() is preferable.\n\nmap_int(keep(warpbreaks, is.factor), nlevels)\n\n#&gt;    wool tension \n#&gt;       2       3\n\n\n\n\nThe following code simulates the performance of a t-test for non-normal data. Extract the p-value from each test, then visualise.\n\n\ntrials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\nhist(map_dbl(trials, \"p.value\"), breaks = 10)\n\n\n\n\n\n\n\n\nAnswer: code above.\nAR Solutions: There are many ways to visualise this data. However, since there are only 100 data points, we choose a dot plot to visualise the distribution. (Unfortunately, {ggplot2}s geom_dotplot() doesn’t compute proper counts as it was created to visualise distribution densities instead of frequencies, so a histogram would be a suitable alternative).\n\n# Advanced R Solutions uses different code for trials\ntrials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))\n\nlibrary(ggplot2)\n\ndf_trials &lt;- tibble::tibble(p_value = map_dbl(trials, \"p.value\"))\n\ndf_trials %&gt;%\n  ggplot(aes(x = p_value, fill = p_value &lt; 0.05)) +\n  geom_dotplot(binwidth = 0.01) + # geom_histogram() as alternative\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    legend.position = \"top\"\n  )\n\n\n\n\n\n\n\n\nNotes: the code AR Solutions uses for trials, trials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7))), appears to be correct compared to Advanced R.\n\n\nThe following code uses a map nested inside another map to apply a function to every element of a nested list. Why does it fail, and what do you need to do to make it work?\n\n\nx &lt;- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple &lt;- function(x) x * 3\ntry(map(x, map, .f = triple))\n\n#&gt; Error in map(x, map, .f = triple) : ℹ In index: 1.\n#&gt; Caused by error in `.f()`:\n#&gt; ! unused argument (function (.x, .f, ..., .progress = FALSE) \n#&gt; {\n#&gt;     map_(\"list\", .x, .f, ..., .progress = .progress)\n#&gt; })\n\n\nAnswer: the call fails since the .f = triple specifies the function for the outer map(), and the map is passed as an additional argument to triple(), which generates the error since triple() only takes a single argument. The solution is to pass triple as an additional argument to the outer map():\n\nmap(x, map, triple)\n\n#&gt; [[1]]\n#&gt; [[1]][[1]]\n#&gt; [1] 3\n#&gt; \n#&gt; [[1]][[2]]\n#&gt; [1]  9 27\n#&gt; \n#&gt; \n#&gt; [[2]]\n#&gt; [[2]][[1]]\n#&gt; [1]  9 18\n#&gt; \n#&gt; [[2]][[2]]\n#&gt; [1] 21\n#&gt; \n#&gt; [[2]][[3]]\n#&gt; [1] 12 21 18\n\n\nAR Solutions: This function call fails, because triple() is specified as the .f argument and consequently belongs to the outer map(). The unnamed argument map is treated as an argument of triple(), which causes the error.\nThere are a number of ways we could resolve the problem. However, there is not much to choose between them for this simple example, although it is good to know your options for more complicated cases.\n\n# Don't name the argument\nmap(x, map, triple)\n\n# Use magrittr-style anonymous function\nmap(x, . %&gt;% map(triple))\n\n# Use purrr-style anonymous function\nmap(x, ~ map(.x, triple))\n\nNote: I don’t like the magrittr-style anonymous function option. The others are good.\n\n\nUse map() to fit linear models to the mtcars dataset using the formulas stored in this list:\n\n\nformulas &lt;- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\n\nAnswer: the following code works, but doesn’t display the text of the formula in the Call:\n\nmap(formulas, lm, mtcars)\n\n#&gt; [[1]]\n#&gt; \n#&gt; Call:\n#&gt; .f(formula = .x[[i]], data = ..1)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)         disp  \n#&gt;    29.59985     -0.04122  \n#&gt; \n#&gt; \n#&gt; [[2]]\n#&gt; \n#&gt; Call:\n#&gt; .f(formula = .x[[i]], data = ..1)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)    I(1/disp)  \n#&gt;       10.75      1557.67  \n#&gt; \n#&gt; \n#&gt; [[3]]\n#&gt; \n#&gt; Call:\n#&gt; .f(formula = .x[[i]], data = ..1)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)         disp           wt  \n#&gt;    34.96055     -0.01772     -3.35083  \n#&gt; \n#&gt; \n#&gt; [[4]]\n#&gt; \n#&gt; Call:\n#&gt; .f(formula = .x[[i]], data = ..1)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)    I(1/disp)           wt  \n#&gt;      19.024     1142.560       -1.798\n\n\nAR Solutions: The data (mtcars) is constant for all these models and so we iterate over the formulas provided. As the formula is the first argument of lm(), we don’t need to specify it explicitly.\n\nmodels &lt;- map(formulas, lm, data = mtcars)\n\nNote: AR Solutions specifies data = mtcars but is otherwise the same.\n\n\nFit the model mpg ~ disp to each of the bootstrap replicates of mtcars in the list below, then extract the \\(R^2\\) of the model fit (Hint: you can compute the \\(R^2\\) with summary().)\n\n\nbootstrap &lt;- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps &lt;- map(1:10, ~ bootstrap(mtcars))\n\nmap_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)\n\n#&gt;  [1] 0.5796790 0.7803434 0.7786824 0.7977490 0.6907038 0.7417862 0.7862540\n#&gt;  [8] 0.7249389 0.7997014 0.7215866\n\n\nAnswer: code above.\nAR Solutions: To accomplish this task, we take advantage of the “list in, list out”-functionality of map(). This allows us to chain multiple transformations together. We start by fitting the models. We then calculate the summaries and extract the \\(R^2\\) values. For the last call we use map_dbl(), which provides convenient output.\n\nbootstraps %&gt;%\n  map(~ lm(mpg ~ disp, data = .x)) %&gt;%\n  map(summary) %&gt;%\n  map_dbl(\"r.squared\")\n\n#&gt;  [1] 0.5796790 0.7803434 0.7786824 0.7977490 0.6907038 0.7417862 0.7862540\n#&gt;  [8] 0.7249389 0.7997014 0.7215866\n\n\nNote: while AR Solutions is arguably slightly more readable, my code should be faster:\n\nbench::mark({\n  map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)\n})\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 { map_dbl(bootstraps, ~summary(lm(… 1.61ms  1.7ms      585.    63.7KB     21.5\n\nbench::mark({\n  bootstraps %&gt;%\n    map(~ lm(mpg ~ disp, data = .x)) %&gt;%\n    map(summary) %&gt;%\n    map_dbl(\"r.squared\")\n})\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 { bootstraps %&gt;% map(~lm(mpg ~ dis… 1.57ms 1.67ms      596.    63.7KB     21.0\n\n\nIt is actually slightly slower! AR Solutions wins!\n\n\n\n9.4.6 Exercises\n\nExplain the results of modify(mtcars, 1).\n\n\nmodify(mtcars, 1)\n\n#&gt;    mpg cyl disp  hp drat   wt  qsec vs am gear carb\n#&gt; 1   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 2   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 3   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 4   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 5   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 6   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 7   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 8   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 9   21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 10  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 11  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 12  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 13  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 14  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 15  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 16  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 17  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 18  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 19  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 20  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 21  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 22  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 23  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 24  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 25  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 26  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 27  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 28  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 29  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 30  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 31  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n#&gt; 32  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n\nas_mapper(1)\n\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(1), .default = NULL)\n#&gt; &lt;environment: 0x127f66a20&gt;\n\nhead(mtcars, 1)\n\n#&gt;           mpg cyl disp  hp drat   wt  qsec vs am gear carb\n#&gt; Mazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n\n\nAnswer: modify(mtcars, 1) creates a mapper that plucks the first element of each column of mtcars and writes that value to every row.\nAR Solutions: modify() is based on map(), and in this case, the extractor interface will be used. It extracts the first element of each column in mtcars. modify() always returns the same structure as its input: in this case it forces the first row to be recycled 32 times. (Internally modify() uses .x[] &lt;- map(.x, .f, ...) for assignment.)\nNotes: this code makes the recycling clear:\n\nunlist(map(mtcars, 1))\n\n#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#&gt;  21.00   6.00 160.00 110.00   3.90   2.62  16.46   0.00   1.00   4.00   4.00\n\n\n\n\nRewrite the following code to use iwalk() instead of walk2(). What are the advantages and disadvantages?\n\n\ncyls &lt;- split(mtcars, mtcars$cyl)\npaths &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\nAnswer: code below.\n\ntemp &lt;- tempfile()\ndir.create(temp)\n\ncyls &lt;- split(mtcars, mtcars$cyl)\niwalk(cyls, ~ write.csv(.x, file.path(temp, paste0(\"cyl-\", .y, \".csv\"))))\ndir(temp)\n\n#&gt; [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\"\n\n\nThe main advantage of using iwalk() is that it will use seq_along() if x does not have names. In this case, x has names, and the resulting code is a bit harder to understand, and requires a formula (or function).\nAR Solutions: iwalk() allows us to use a single variable, storing the output path in the names.\n\ntemp &lt;- tempfile()\ndir.create(temp)\ncyls &lt;- split(mtcars, mtcars$cyl)\nnames(cyls) &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\niwalk(cyls, ~ write.csv(.x, .y))\n\nWe could do this in a single pipe by taking advantage of set_names():\n\nmtcars %&gt;%\n  split(mtcars$cyl) %&gt;%\n  set_names(~ file.path(temp, paste0(\"cyl-\", .x, \".csv\"))) %&gt;%\n  iwalk(~ write.csv(.x, .y))\n\nNotes: the AR Solutions use of names and the pipe is clever.\n\n\nExplain how the following code transforms a data frame using functions stored in a list.\n\n\nif (exists(\"mtcars\")) rm(mtcars)\n\n#&gt; Warning in rm(mtcars): object 'mtcars' not found\n\nmtcars\n\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#&gt; AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#&gt; Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#&gt; Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#&gt; Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#&gt; Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#&gt; Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#&gt; Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\ntrans &lt;- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm &lt;- names(trans)\nmtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))\n\nmtcars\n\n#&gt;                      mpg cyl     disp  hp drat    wt  qsec vs     am gear carb\n#&gt; Mazda RX4           21.0   6 2.621936 110 3.90 2.620 16.46  0 manual    4    4\n#&gt; Mazda RX4 Wag       21.0   6 2.621936 110 3.90 2.875 17.02  0 manual    4    4\n#&gt; Datsun 710          22.8   4 1.769807  93 3.85 2.320 18.61  1 manual    4    1\n#&gt; Hornet 4 Drive      21.4   6 4.227872 110 3.08 3.215 19.44  1   auto    3    1\n#&gt; Hornet Sportabout   18.7   8 5.899356 175 3.15 3.440 17.02  0   auto    3    2\n#&gt; Valiant             18.1   6 3.687098 105 2.76 3.460 20.22  1   auto    3    1\n#&gt; Duster 360          14.3   8 5.899356 245 3.21 3.570 15.84  0   auto    3    4\n#&gt; Merc 240D           24.4   4 2.403988  62 3.69 3.190 20.00  1   auto    4    2\n#&gt; Merc 230            22.8   4 2.307304  95 3.92 3.150 22.90  1   auto    4    2\n#&gt; Merc 280            19.2   6 2.746478 123 3.92 3.440 18.30  1   auto    4    4\n#&gt; Merc 280C           17.8   6 2.746478 123 3.92 3.440 18.90  1   auto    4    4\n#&gt; Merc 450SE          16.4   8 4.519562 180 3.07 4.070 17.40  0   auto    3    3\n#&gt; Merc 450SL          17.3   8 4.519562 180 3.07 3.730 17.60  0   auto    3    3\n#&gt; Merc 450SLC         15.2   8 4.519562 180 3.07 3.780 18.00  0   auto    3    3\n#&gt; Cadillac Fleetwood  10.4   8 7.734711 205 2.93 5.250 17.98  0   auto    3    4\n#&gt; Lincoln Continental 10.4   8 7.538066 215 3.00 5.424 17.82  0   auto    3    4\n#&gt; Chrysler Imperial   14.7   8 7.210324 230 3.23 5.345 17.42  0   auto    3    4\n#&gt; Fiat 128            32.4   4 1.289665  66 4.08 2.200 19.47  1 manual    4    1\n#&gt; Honda Civic         30.4   4 1.240503  52 4.93 1.615 18.52  1 manual    4    2\n#&gt; Toyota Corolla      33.9   4 1.165123  65 4.22 1.835 19.90  1 manual    4    1\n#&gt; Toyota Corona       21.5   4 1.968091  97 3.70 2.465 20.01  1   auto    3    1\n#&gt; Dodge Challenger    15.5   8 5.211098 150 2.76 3.520 16.87  0   auto    3    2\n#&gt; AMC Javelin         15.2   8 4.981678 150 3.15 3.435 17.30  0   auto    3    2\n#&gt; Camaro Z28          13.3   8 5.735485 245 3.73 3.840 15.41  0   auto    3    4\n#&gt; Pontiac Firebird    19.2   8 6.554840 175 3.08 3.845 17.05  0   auto    3    2\n#&gt; Fiat X1-9           27.3   4 1.294581  66 4.08 1.935 18.90  1 manual    4    1\n#&gt; Porsche 914-2       26.0   4 1.971368  91 4.43 2.140 16.70  0 manual    5    2\n#&gt; Lotus Europa        30.4   4 1.558413 113 3.77 1.513 16.90  1 manual    5    2\n#&gt; Ford Pantera L      15.8   8 5.751872 264 4.22 3.170 14.50  0 manual    5    4\n#&gt; Ferrari Dino        19.7   6 2.376130 175 3.62 2.770 15.50  0 manual    5    6\n#&gt; Maserati Bora       15.0   8 4.932517 335 3.54 3.570 14.60  0 manual    5    8\n#&gt; Volvo 142E          21.4   4 1.982839 109 4.11 2.780 18.60  1 manual    4    2\n\nrm(mtcars)\n\nCompare and contrast the map2() approach to this map() approach:\n\nmtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n\nAnswer: the map2() code applies the anonymous functions to the corresponding column in mtcars based on their name in the list:\n\nmtcars[nm] is equivalent to mtcars[c(\"disp\", \"am\")], so the code is modifying those two columns\nthe mapping function, function(f, var) f(var) is run as f(mtcars[[\"disp\"]]) and f(mtcars[[\"am\"]]), with the corresponding function in trans as f, since trans and mtcars[nm] are passed as parameters to the function\n\nThe equivalent map() approach isn’t as clean: it’s harder to understand what map() is doing.\nAR Solutions: In the first approach\n\nmtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))\n\nthe list of the 2 functions (trans) and the 2 appropriately selected data frame columns (mtcars[nm]) are supplied to map2(). map2() creates an anonymous function (f(var)) which applies the functions to the variables when map2() iterates over their (similar) indices. On the left-hand side, the respective 2 elements of mtcars are being replaced by their new transformations.\nThe map() variant\n\nmtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n\ndoes basically the same. However, it directly iterates over the names (nm) of the transformations. Therefore, the data frame columns are selected during the iteration.\nBesides the iteration pattern, the approaches differ in the possibilities for appropriate argument naming in the .f argument. In the map2() approach we iterate over the elements of x and y. Therefore, it is possible to choose appropriate placeholders like f and var. This makes the anonymous function more expressive at the cost of making it longer. We think using the formula interface in this way is preferable compared to the rather cryptic mtcars[nm] &lt;- map2(trans, mtcars[nm], ~ .x(.y)).\nIn the map() approach we map over the variable names. It is therefore not possible to introduce placeholders for the function and variable names. The formula syntax together with the .x pronoun is pretty compact. The object names and the brackets clearly indicate the application of transformations to specific columns of mtcars. In this case the iteration over the variable names comes in handy, as it highlights the importance of matching between trans and mtcars element names. Together with the replacement form on the left-hand side, this line is relatively easy to inspect.\nTo summarise, in situations where map() and map2() provide solutions for an iteration problem, several points may be considered before deciding for one or the other approach.\n\n\nWhat does write.csv() return, i.e. what happens if you use it with map2() instead of walk2()?\n\n\npaths &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nmap2(cyls, paths, write.csv)\n\n#&gt; $`4`\n#&gt; NULL\n#&gt; \n#&gt; $`6`\n#&gt; NULL\n#&gt; \n#&gt; $`8`\n#&gt; NULL\n\n\nAnswer: write.csv() is designed to return NULL, invisibly. While walk2() hides the NULL return values, map2() does not.\nAR Solutions: write.csv() returns NULL. As we call the function for its side effect (creating a CSV file), walk2() would be appropriate here. Otherwise, we receive a rather uninformative list of NULLs.\n\n\n\n9.6.3 Exercises\n\nWhy isn’t is.na() a predicate function? What base R function is closest to being a predicate version of is.na()?\n\nAnswer: is.na(x) returns logical(0) when x is NULL, which violates the rule that predicate functions only return TRUE or FALSE. anyNA(x, recursive = FALSE) appears to be a predicate version of is.na().\nAR Solutions: is.na() is not a predicate function, because it returns a logical vector the same length as the input, not a single TRUE or FALSE.\nanyNA() is the closest equivalent because it always returns a single TRUE or FALSE if there are any missing values present. You could also imagine an allNA() which would return TRUE if all values were missing, but that’s considerably less useful so base R does not provide it.\n\n\nsimple_reduce() has a problem when x is length 0 or length 1. Describe the source of the problem and how you might go about fixing it.\n\n\nsimple_reduce &lt;- function(x, f) {\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n  out\n}\n\nAnswer: using seq() results in a backwards count when x is length 0 or 1.\n\nseq(2, 0)\n\n#&gt; [1] 2 1 0\n\nseq(2, 1)\n\n#&gt; [1] 2 1\n\n\nThe fix is to check the length of x and return itself when length is 0 and throw an error when length is 1, as reduce() does.\nAR Solutions: The loop inside simple_reduce() always starts with the index 2, and seq() can count both up and down:\nTherefore, subsetting length-0 and length-1 vectors via [[ will lead to a subscript out of bounds error. To avoid this, we allow simple_reduce() to return before the for loop is started and include a default argument for 0-length vectors.\n\nsimple_reduce &lt;- function(x, f, default) {\n  if (length(x) == 0L) {\n    return(default)\n  }\n  if (length(x) == 1L) {\n    return(x[[1L]])\n  }\n\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n\n  out\n}\n\nOur new simple_reduce() now works as intended:\n\ntry(simple_reduce(integer(0), `+`))\n\n#&gt; Error in simple_reduce(integer(0), `+`) : \n#&gt;   argument \"default\" is missing, with no default\n\nsimple_reduce(integer(0), `+`, default = 0L)\n\n#&gt; [1] 0\n\nsimple_reduce(1, `+`)\n\n#&gt; [1] 1\n\nsimple_reduce(1:3, `+`)\n\n#&gt; [1] 6\n\n\n\n\nImplement the span() function from Haskell: given a list x and a predicate function f, span(x, f) returns the location of the longest sequential run of elements where the predicate is true. (Hint: you might find rle() helpful.)\n\n\ntest &lt;- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:39))\ntest2 &lt;- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:40))\n\nspan &lt;- function(x, f) {\n  runs &lt;- rle(map_lgl(x, f))\n  max_true &lt;- max_index &lt;- 0\n  index &lt;- 1\n  for (i in seq_along(runs$values)) {\n    if (runs$values[i] && runs$lengths[i] &gt; max_true) {\n      max_true &lt;- runs$lengths[i]\n      max_index &lt;- index\n    }\n    index &lt;- index + runs$lengths[i]\n  }\n  max_index\n}\n\nspan(test, is.numeric)\n\n#&gt; [1] 22\n\nspan(test2, is.numeric)\n\n#&gt; [1] 47\n\nspan(1, is.numeric)\n\n#&gt; [1] 1\n\nspan(\"a\", is.numeric)\n\n#&gt; [1] 0\n\nspan(list(\"a\", 1:10, 1:20), is.numeric)\n\n#&gt; [1] 2\n\n\nAnswer: code above.\nAR Solutions: Our span_r() function returns the indices of the (first occurring) longest sequential run of elements where the predicate is true. If the predicate is never true, the longest run has length 0, in which case we return integer(0).\n\nspan_r &lt;- function(x, f) {\n  idx &lt;- unname(map_lgl(x, ~ f(.x)))\n  rle &lt;- rle(idx)\n\n  # Check if the predicate is never true\n  if (!any(rle$values)) {\n    return(integer(0))\n  }\n\n  # Find the length of the longest sequence of true values\n  longest &lt;- max(rle$lengths[rle$values])\n  # Find the position of the (first) longest run in rle\n  longest_idx &lt;- which(rle$values & rle$lengths == longest)[1]\n\n  # Add up all lengths in rle before the longest run\n  ind_before_longest &lt;- sum(rle$lengths[seq_len(longest_idx - 1)])\n\n  out_start &lt;- ind_before_longest + 1L\n  out_end &lt;- ind_before_longest + longest\n  out_start:out_end\n}\n\n# Check that it works\nspan_r(c(0, 0, 0, 0, 0), is.na)\n\n#&gt; integer(0)\n\nspan_r(c(NA, 0, 0, 0, 0), is.na)\n\n#&gt; [1] 1\n\nspan_r(c(NA, 0, NA, NA, NA), is.na)\n\n#&gt; [1] 3 4 5\n\n\nNotes: AR Solutions shows how to find the index of the longest sequence using which(), which is new to me, and returns more information by returning indexes of the entire span. The AR Solutions approach is also significantly faster (which I did not expect).\n\nbench::mark(span_r(test2, is.numeric))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                     min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 span_r(test2, is.numeric)   38.3µs   44.5µs    22261.    4.01KB     29.0\n\nbench::mark(span(test2, is.numeric))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                   min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;              &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 span(test2, is.numeric)   52.3µs   59.9µs    16566.    4.01KB     20.8\n\n\n\n\nImplement arg_max(). It should take a function and a vector of inputs, and return the elements of the input where the function returns the highest value. For example, arg_max(-10:5, function(x) x ^ 2) should return -10. arg_max(-5:5, function(x) x ^ 2) should return c(-5, 5). Also implement the matching arg_min() function.\n\nAnswer: code below.\n\narg_max &lt;- function(x, f) {\n  val &lt;- map_dbl(x, f)\n  val_max &lt;- max(val)\n  x[which(val == val_max)]\n}\n\narg_max(-10:5, function(x) x^2)\n\n#&gt; [1] -10\n\narg_max(-5:5, function(x) x^2)\n\n#&gt; [1] -5  5\n\narg_min &lt;- function(x, f) {\n  val &lt;- map_dbl(x, f)\n  val_min &lt;- min(val)\n  x[which(val == val_min)]\n}\n\narg_min(-10:5, function(x) x^2)\n\n#&gt; [1] 0\n\narg_min(c(-5:-1, 1:5), function(x) x^2)\n\n#&gt; [1] -1  1\n\n\nAR Solutions: Both functions take a vector of inputs and a function as an argument. The function output is then used to subset the input accordingly.\n\narg_max &lt;- function(x, f) {\n  y &lt;- map_dbl(x, f)\n  x[y == max(y)]\n}\n\narg_min &lt;- function(x, f) {\n  y &lt;- map_dbl(x, f)\n  x[y == min(y)]\n}\n\narg_max(-10:5, function(x) x^2)\n\n#&gt; [1] -10\n\narg_min(-10:5, function(x) x^2)\n\n#&gt; [1] 0\n\n\nNotes: using which() is unnecessary, AR Solutions is a better approach.\n\n\nThe function below scales a vector so it falls in the range [0, 1]. How would you apply it to every column of a data frame? How would you apply it to every numeric column in a data frame?\n\n\nscale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nAnswer: code below.\n\n# every column\nmodify(mtcars, scale01)\n\n#&gt;          mpg cyl       disp         hp       drat         wt       qsec vs am\n#&gt; 1  0.4510638 0.5 0.22175106 0.20494700 0.52534562 0.28304781 0.23333333  0  1\n#&gt; 2  0.4510638 0.5 0.22175106 0.20494700 0.52534562 0.34824853 0.30000000  0  1\n#&gt; 3  0.5276596 0.0 0.09204290 0.14487633 0.50230415 0.20634109 0.48928571  1  1\n#&gt; 4  0.4680851 0.5 0.46620105 0.20494700 0.14746544 0.43518282 0.58809524  1  0\n#&gt; 5  0.3531915 1.0 0.72062859 0.43462898 0.17972350 0.49271286 0.30000000  0  0\n#&gt; 6  0.3276596 0.5 0.38388626 0.18727915 0.00000000 0.49782664 0.68095238  1  0\n#&gt; 7  0.1659574 1.0 0.72062859 0.68197880 0.20737327 0.52595244 0.15952381  0  0\n#&gt; 8  0.5957447 0.0 0.18857570 0.03533569 0.42857143 0.42879059 0.65476190  1  0\n#&gt; 9  0.5276596 0.0 0.17385882 0.15194346 0.53456221 0.41856303 1.00000000  1  0\n#&gt; 10 0.3744681 0.5 0.24070841 0.25088339 0.53456221 0.49271286 0.45238095  1  0\n#&gt; 11 0.3148936 0.5 0.24070841 0.25088339 0.53456221 0.49271286 0.52380952  1  0\n#&gt; 12 0.2553191 1.0 0.51060115 0.45229682 0.14285714 0.65379698 0.34523810  0  0\n#&gt; 13 0.2936170 1.0 0.51060115 0.45229682 0.14285714 0.56686269 0.36904762  0  0\n#&gt; 14 0.2042553 1.0 0.51060115 0.45229682 0.14285714 0.57964715 0.41666667  0  0\n#&gt; 15 0.0000000 1.0 1.00000000 0.54063604 0.07834101 0.95551010 0.41428571  0  0\n#&gt; 16 0.0000000 1.0 0.97006735 0.57597173 0.11059908 1.00000000 0.39523810  0  0\n#&gt; 17 0.1829787 1.0 0.92017960 0.62897527 0.21658986 0.97980056 0.34761905  0  0\n#&gt; 18 0.9361702 0.0 0.01895735 0.04946996 0.60829493 0.17565840 0.59166667  1  1\n#&gt; 19 0.8510638 0.0 0.01147418 0.00000000 1.00000000 0.02608029 0.47857143  1  1\n#&gt; 20 1.0000000 0.0 0.00000000 0.04593640 0.67281106 0.08233188 0.64285714  1  1\n#&gt; 21 0.4723404 0.0 0.12222499 0.15901060 0.43317972 0.24341601 0.65595238  1  0\n#&gt; 22 0.2170213 1.0 0.61586431 0.34628975 0.00000000 0.51316799 0.28214286  0  0\n#&gt; 23 0.2042553 1.0 0.58094288 0.34628975 0.17972350 0.49143442 0.33333333  0  0\n#&gt; 24 0.1234043 1.0 0.69568471 0.68197880 0.44700461 0.59498849 0.10833333  0  0\n#&gt; 25 0.3744681 1.0 0.82040409 0.43462898 0.14746544 0.59626694 0.30357143  0  0\n#&gt; 26 0.7191489 0.0 0.01970566 0.04946996 0.60829493 0.10790079 0.52380952  1  1\n#&gt; 27 0.6638298 0.0 0.12272387 0.13780919 0.76958525 0.16031705 0.26190476  0  1\n#&gt; 28 0.8510638 0.0 0.05986530 0.21554770 0.46543779 0.00000000 0.28571429  1  1\n#&gt; 29 0.2297872 1.0 0.69817910 0.74911661 0.67281106 0.42367681 0.00000000  0  1\n#&gt; 30 0.3957447 0.5 0.18433525 0.43462898 0.39631336 0.32140118 0.11904762  0  1\n#&gt; 31 0.1957447 1.0 0.57345972 1.00000000 0.35944700 0.52595244 0.01190476  0  1\n#&gt; 32 0.4680851 0.0 0.12446994 0.20141343 0.62211982 0.32395807 0.48809524  1  1\n#&gt;    gear      carb\n#&gt; 1   0.5 0.4285714\n#&gt; 2   0.5 0.4285714\n#&gt; 3   0.5 0.0000000\n#&gt; 4   0.0 0.0000000\n#&gt; 5   0.0 0.1428571\n#&gt; 6   0.0 0.0000000\n#&gt; 7   0.0 0.4285714\n#&gt; 8   0.5 0.1428571\n#&gt; 9   0.5 0.1428571\n#&gt; 10  0.5 0.4285714\n#&gt; 11  0.5 0.4285714\n#&gt; 12  0.0 0.2857143\n#&gt; 13  0.0 0.2857143\n#&gt; 14  0.0 0.2857143\n#&gt; 15  0.0 0.4285714\n#&gt; 16  0.0 0.4285714\n#&gt; 17  0.0 0.4285714\n#&gt; 18  0.5 0.0000000\n#&gt; 19  0.5 0.1428571\n#&gt; 20  0.5 0.0000000\n#&gt; 21  0.0 0.0000000\n#&gt; 22  0.0 0.1428571\n#&gt; 23  0.0 0.1428571\n#&gt; 24  0.0 0.4285714\n#&gt; 25  0.0 0.1428571\n#&gt; 26  0.5 0.0000000\n#&gt; 27  1.0 0.1428571\n#&gt; 28  1.0 0.1428571\n#&gt; 29  1.0 0.4285714\n#&gt; 30  1.0 0.7142857\n#&gt; 31  1.0 1.0000000\n#&gt; 32  0.5 0.1428571\n\n# every numeric column\nmodify_if(iris, is.numeric, scale01)\n\n#&gt;     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#&gt; 1     0.22222222  0.62500000   0.06779661  0.04166667     setosa\n#&gt; 2     0.16666667  0.41666667   0.06779661  0.04166667     setosa\n#&gt; 3     0.11111111  0.50000000   0.05084746  0.04166667     setosa\n#&gt; 4     0.08333333  0.45833333   0.08474576  0.04166667     setosa\n#&gt; 5     0.19444444  0.66666667   0.06779661  0.04166667     setosa\n#&gt; 6     0.30555556  0.79166667   0.11864407  0.12500000     setosa\n#&gt; 7     0.08333333  0.58333333   0.06779661  0.08333333     setosa\n#&gt; 8     0.19444444  0.58333333   0.08474576  0.04166667     setosa\n#&gt; 9     0.02777778  0.37500000   0.06779661  0.04166667     setosa\n#&gt; 10    0.16666667  0.45833333   0.08474576  0.00000000     setosa\n#&gt; 11    0.30555556  0.70833333   0.08474576  0.04166667     setosa\n#&gt; 12    0.13888889  0.58333333   0.10169492  0.04166667     setosa\n#&gt; 13    0.13888889  0.41666667   0.06779661  0.00000000     setosa\n#&gt; 14    0.00000000  0.41666667   0.01694915  0.00000000     setosa\n#&gt; 15    0.41666667  0.83333333   0.03389831  0.04166667     setosa\n#&gt; 16    0.38888889  1.00000000   0.08474576  0.12500000     setosa\n#&gt; 17    0.30555556  0.79166667   0.05084746  0.12500000     setosa\n#&gt; 18    0.22222222  0.62500000   0.06779661  0.08333333     setosa\n#&gt; 19    0.38888889  0.75000000   0.11864407  0.08333333     setosa\n#&gt; 20    0.22222222  0.75000000   0.08474576  0.08333333     setosa\n#&gt; 21    0.30555556  0.58333333   0.11864407  0.04166667     setosa\n#&gt; 22    0.22222222  0.70833333   0.08474576  0.12500000     setosa\n#&gt; 23    0.08333333  0.66666667   0.00000000  0.04166667     setosa\n#&gt; 24    0.22222222  0.54166667   0.11864407  0.16666667     setosa\n#&gt; 25    0.13888889  0.58333333   0.15254237  0.04166667     setosa\n#&gt; 26    0.19444444  0.41666667   0.10169492  0.04166667     setosa\n#&gt; 27    0.19444444  0.58333333   0.10169492  0.12500000     setosa\n#&gt; 28    0.25000000  0.62500000   0.08474576  0.04166667     setosa\n#&gt; 29    0.25000000  0.58333333   0.06779661  0.04166667     setosa\n#&gt; 30    0.11111111  0.50000000   0.10169492  0.04166667     setosa\n#&gt; 31    0.13888889  0.45833333   0.10169492  0.04166667     setosa\n#&gt; 32    0.30555556  0.58333333   0.08474576  0.12500000     setosa\n#&gt; 33    0.25000000  0.87500000   0.08474576  0.00000000     setosa\n#&gt; 34    0.33333333  0.91666667   0.06779661  0.04166667     setosa\n#&gt; 35    0.16666667  0.45833333   0.08474576  0.04166667     setosa\n#&gt; 36    0.19444444  0.50000000   0.03389831  0.04166667     setosa\n#&gt; 37    0.33333333  0.62500000   0.05084746  0.04166667     setosa\n#&gt; 38    0.16666667  0.66666667   0.06779661  0.00000000     setosa\n#&gt; 39    0.02777778  0.41666667   0.05084746  0.04166667     setosa\n#&gt; 40    0.22222222  0.58333333   0.08474576  0.04166667     setosa\n#&gt; 41    0.19444444  0.62500000   0.05084746  0.08333333     setosa\n#&gt; 42    0.05555556  0.12500000   0.05084746  0.08333333     setosa\n#&gt; 43    0.02777778  0.50000000   0.05084746  0.04166667     setosa\n#&gt; 44    0.19444444  0.62500000   0.10169492  0.20833333     setosa\n#&gt; 45    0.22222222  0.75000000   0.15254237  0.12500000     setosa\n#&gt; 46    0.13888889  0.41666667   0.06779661  0.08333333     setosa\n#&gt; 47    0.22222222  0.75000000   0.10169492  0.04166667     setosa\n#&gt; 48    0.08333333  0.50000000   0.06779661  0.04166667     setosa\n#&gt; 49    0.27777778  0.70833333   0.08474576  0.04166667     setosa\n#&gt; 50    0.19444444  0.54166667   0.06779661  0.04166667     setosa\n#&gt; 51    0.75000000  0.50000000   0.62711864  0.54166667 versicolor\n#&gt; 52    0.58333333  0.50000000   0.59322034  0.58333333 versicolor\n#&gt; 53    0.72222222  0.45833333   0.66101695  0.58333333 versicolor\n#&gt; 54    0.33333333  0.12500000   0.50847458  0.50000000 versicolor\n#&gt; 55    0.61111111  0.33333333   0.61016949  0.58333333 versicolor\n#&gt; 56    0.38888889  0.33333333   0.59322034  0.50000000 versicolor\n#&gt; 57    0.55555556  0.54166667   0.62711864  0.62500000 versicolor\n#&gt; 58    0.16666667  0.16666667   0.38983051  0.37500000 versicolor\n#&gt; 59    0.63888889  0.37500000   0.61016949  0.50000000 versicolor\n#&gt; 60    0.25000000  0.29166667   0.49152542  0.54166667 versicolor\n#&gt; 61    0.19444444  0.00000000   0.42372881  0.37500000 versicolor\n#&gt; 62    0.44444444  0.41666667   0.54237288  0.58333333 versicolor\n#&gt; 63    0.47222222  0.08333333   0.50847458  0.37500000 versicolor\n#&gt; 64    0.50000000  0.37500000   0.62711864  0.54166667 versicolor\n#&gt; 65    0.36111111  0.37500000   0.44067797  0.50000000 versicolor\n#&gt; 66    0.66666667  0.45833333   0.57627119  0.54166667 versicolor\n#&gt; 67    0.36111111  0.41666667   0.59322034  0.58333333 versicolor\n#&gt; 68    0.41666667  0.29166667   0.52542373  0.37500000 versicolor\n#&gt; 69    0.52777778  0.08333333   0.59322034  0.58333333 versicolor\n#&gt; 70    0.36111111  0.20833333   0.49152542  0.41666667 versicolor\n#&gt; 71    0.44444444  0.50000000   0.64406780  0.70833333 versicolor\n#&gt; 72    0.50000000  0.33333333   0.50847458  0.50000000 versicolor\n#&gt; 73    0.55555556  0.20833333   0.66101695  0.58333333 versicolor\n#&gt; 74    0.50000000  0.33333333   0.62711864  0.45833333 versicolor\n#&gt; 75    0.58333333  0.37500000   0.55932203  0.50000000 versicolor\n#&gt; 76    0.63888889  0.41666667   0.57627119  0.54166667 versicolor\n#&gt; 77    0.69444444  0.33333333   0.64406780  0.54166667 versicolor\n#&gt; 78    0.66666667  0.41666667   0.67796610  0.66666667 versicolor\n#&gt; 79    0.47222222  0.37500000   0.59322034  0.58333333 versicolor\n#&gt; 80    0.38888889  0.25000000   0.42372881  0.37500000 versicolor\n#&gt; 81    0.33333333  0.16666667   0.47457627  0.41666667 versicolor\n#&gt; 82    0.33333333  0.16666667   0.45762712  0.37500000 versicolor\n#&gt; 83    0.41666667  0.29166667   0.49152542  0.45833333 versicolor\n#&gt; 84    0.47222222  0.29166667   0.69491525  0.62500000 versicolor\n#&gt; 85    0.30555556  0.41666667   0.59322034  0.58333333 versicolor\n#&gt; 86    0.47222222  0.58333333   0.59322034  0.62500000 versicolor\n#&gt; 87    0.66666667  0.45833333   0.62711864  0.58333333 versicolor\n#&gt; 88    0.55555556  0.12500000   0.57627119  0.50000000 versicolor\n#&gt; 89    0.36111111  0.41666667   0.52542373  0.50000000 versicolor\n#&gt; 90    0.33333333  0.20833333   0.50847458  0.50000000 versicolor\n#&gt; 91    0.33333333  0.25000000   0.57627119  0.45833333 versicolor\n#&gt; 92    0.50000000  0.41666667   0.61016949  0.54166667 versicolor\n#&gt; 93    0.41666667  0.25000000   0.50847458  0.45833333 versicolor\n#&gt; 94    0.19444444  0.12500000   0.38983051  0.37500000 versicolor\n#&gt; 95    0.36111111  0.29166667   0.54237288  0.50000000 versicolor\n#&gt; 96    0.38888889  0.41666667   0.54237288  0.45833333 versicolor\n#&gt; 97    0.38888889  0.37500000   0.54237288  0.50000000 versicolor\n#&gt; 98    0.52777778  0.37500000   0.55932203  0.50000000 versicolor\n#&gt; 99    0.22222222  0.20833333   0.33898305  0.41666667 versicolor\n#&gt; 100   0.38888889  0.33333333   0.52542373  0.50000000 versicolor\n#&gt; 101   0.55555556  0.54166667   0.84745763  1.00000000  virginica\n#&gt; 102   0.41666667  0.29166667   0.69491525  0.75000000  virginica\n#&gt; 103   0.77777778  0.41666667   0.83050847  0.83333333  virginica\n#&gt; 104   0.55555556  0.37500000   0.77966102  0.70833333  virginica\n#&gt; 105   0.61111111  0.41666667   0.81355932  0.87500000  virginica\n#&gt; 106   0.91666667  0.41666667   0.94915254  0.83333333  virginica\n#&gt; 107   0.16666667  0.20833333   0.59322034  0.66666667  virginica\n#&gt; 108   0.83333333  0.37500000   0.89830508  0.70833333  virginica\n#&gt; 109   0.66666667  0.20833333   0.81355932  0.70833333  virginica\n#&gt; 110   0.80555556  0.66666667   0.86440678  1.00000000  virginica\n#&gt; 111   0.61111111  0.50000000   0.69491525  0.79166667  virginica\n#&gt; 112   0.58333333  0.29166667   0.72881356  0.75000000  virginica\n#&gt; 113   0.69444444  0.41666667   0.76271186  0.83333333  virginica\n#&gt; 114   0.38888889  0.20833333   0.67796610  0.79166667  virginica\n#&gt; 115   0.41666667  0.33333333   0.69491525  0.95833333  virginica\n#&gt; 116   0.58333333  0.50000000   0.72881356  0.91666667  virginica\n#&gt; 117   0.61111111  0.41666667   0.76271186  0.70833333  virginica\n#&gt; 118   0.94444444  0.75000000   0.96610169  0.87500000  virginica\n#&gt; 119   0.94444444  0.25000000   1.00000000  0.91666667  virginica\n#&gt; 120   0.47222222  0.08333333   0.67796610  0.58333333  virginica\n#&gt; 121   0.72222222  0.50000000   0.79661017  0.91666667  virginica\n#&gt; 122   0.36111111  0.33333333   0.66101695  0.79166667  virginica\n#&gt; 123   0.94444444  0.33333333   0.96610169  0.79166667  virginica\n#&gt; 124   0.55555556  0.29166667   0.66101695  0.70833333  virginica\n#&gt; 125   0.66666667  0.54166667   0.79661017  0.83333333  virginica\n#&gt; 126   0.80555556  0.50000000   0.84745763  0.70833333  virginica\n#&gt; 127   0.52777778  0.33333333   0.64406780  0.70833333  virginica\n#&gt; 128   0.50000000  0.41666667   0.66101695  0.70833333  virginica\n#&gt; 129   0.58333333  0.33333333   0.77966102  0.83333333  virginica\n#&gt; 130   0.80555556  0.41666667   0.81355932  0.62500000  virginica\n#&gt; 131   0.86111111  0.33333333   0.86440678  0.75000000  virginica\n#&gt; 132   1.00000000  0.75000000   0.91525424  0.79166667  virginica\n#&gt; 133   0.58333333  0.33333333   0.77966102  0.87500000  virginica\n#&gt; 134   0.55555556  0.33333333   0.69491525  0.58333333  virginica\n#&gt; 135   0.50000000  0.25000000   0.77966102  0.54166667  virginica\n#&gt; 136   0.94444444  0.41666667   0.86440678  0.91666667  virginica\n#&gt; 137   0.55555556  0.58333333   0.77966102  0.95833333  virginica\n#&gt; 138   0.58333333  0.45833333   0.76271186  0.70833333  virginica\n#&gt; 139   0.47222222  0.41666667   0.64406780  0.70833333  virginica\n#&gt; 140   0.72222222  0.45833333   0.74576271  0.83333333  virginica\n#&gt; 141   0.66666667  0.45833333   0.77966102  0.95833333  virginica\n#&gt; 142   0.72222222  0.45833333   0.69491525  0.91666667  virginica\n#&gt; 143   0.41666667  0.29166667   0.69491525  0.75000000  virginica\n#&gt; 144   0.69444444  0.50000000   0.83050847  0.91666667  virginica\n#&gt; 145   0.66666667  0.54166667   0.79661017  1.00000000  virginica\n#&gt; 146   0.66666667  0.41666667   0.71186441  0.91666667  virginica\n#&gt; 147   0.55555556  0.20833333   0.67796610  0.75000000  virginica\n#&gt; 148   0.61111111  0.41666667   0.71186441  0.79166667  virginica\n#&gt; 149   0.52777778  0.58333333   0.74576271  0.91666667  virginica\n#&gt; 150   0.44444444  0.41666667   0.69491525  0.70833333  virginica\n\n\nAR Solutions: To apply a function to every column of a data frame, we can use purrr::modify() (or purrr::map_dfr()), which also conveniently returns a data frame. To limit the application to numeric columns, the scoped version modify_if() can be used.\n\nmodify_if(mtcars, is.numeric, scale01)\n\n\n\n\n9.7.3 Exercises\n\nHow does apply() arrange the output? Read the documentation and perform some experiments.\n\n\n# experiments\nm1 &lt;- matrix(1:4, nrow = 1)\napply(m1, 1, sum)\napply(m1, 2, sum)\napply(m1, c(1, 2), `*`, 2)\napply(m1, 1, `*`, 2)\napply(m1, 1, `*`, 2, simplify = FALSE)\napply(m1, 2, `*`, 2)\napply(m1, 1, sum, simplify = FALSE)\n\nm1a &lt;- matrix(1:4, ncol = 1)\napply(m1a, 1, `*`, 2)\n\nm2 &lt;- matrix(1:20, ncol = 4)\napply(m2, 1, sum)\n\nm3 &lt;- array(1:24, dim = c(2, 3, 4))\napply(m3, 1, sum)\napply(m3, 2, sum)\napply(m3, 3, sum)\napply(m3, 1, `*`, 2)\napply(m3, 2, `*`, 2)\napply(m3, 3, `*`, 2)\napply(m3, c(1, 2, 3), `*`, 2)\n\nAnswer: the documentation states:\n\nIf each call to FUN returns a vector of length n, and simplify is TRUE, then apply returns an array of dimension c(n, dim(X)[MARGIN]) if n &gt; 1. If n equals 1, apply returns a vector if MARGIN has length 1 and an array of dimension dim(X)[MARGIN] otherwise. If n is 0, the result has length 0 but not necessarily the ‘correct’ dimension.\nIf the calls to FUN return vectors of different lengths, or if simplify is FALSE, apply returns a list of length prod(dim(X)[MARGIN]) with dim set to MARGIN if this has length greater than one.\n\nWith exploration, under normal circumstances:\n\nIf MARGIN includes all dimensions of an array or matrix (c(1, 2) or c(1, 2, 3)), the output is arranged in the same shape as the input\nOtherwise, the return value drops a dimension if modifying a vector in place (as with *), or returns a vector when summarizing (as with sum)\nMatrices of a single row are simplified to a vector\nMatrices of a single column are returned as a matrix\nWhen simplify = FALSE is set, a list is returned\n\nHowever, even with all this, the “rules” aren’t clear to me.\nAR Solutions: Basically apply() applies a function over the margins of an array. In the two-dimensional case, the margins are just the rows and columns of a matrix. Let’s make this concrete.\n\narr2 &lt;- array(1:12, dim = c(3, 4))\nrownames(arr2) &lt;- paste0(\"row\", 1:3)\ncolnames(arr2) &lt;- paste0(\"col\", 1:4)\narr2\n\n#&gt;      col1 col2 col3 col4\n#&gt; row1    1    4    7   10\n#&gt; row2    2    5    8   11\n#&gt; row3    3    6    9   12\n\n\nWhen we apply the head() function over the first margin of arr2() (i.e. the rows), the results are contained in the columns of the output, transposing the array compared to the original input.\n\napply(arr2, 1, function(x) x[1:2])\n\n#&gt;      row1 row2 row3\n#&gt; col1    1    2    3\n#&gt; col2    4    5    6\n\n\nAnd vice versa if we apply over the second margin (the columns):\n\napply(arr2, 2, function(x) x[1:2])\n\n#&gt;      col1 col2 col3 col4\n#&gt; row1    1    4    7   10\n#&gt; row2    2    5    8   11\n\n\nThe output of apply() is organised first by the margins being operated over, then the results of the function. This can become quite confusing for higher dimensional arrays.\nNotes: AR Solutions’ explanation is better, but the output is still confusing.\n\n\nWhat do eapply() and rapply() do? Does purrr have equivalents?\n\nAnswer: eapply() applies a function to named values in an environment. rapply() is a recursive lapply(). There are no equivalents in purrr.\nAR Solutions: eapply() is a variant of lapply(), which iterates over the (named) elements of an environment. In purrr there is no equivalent for eapply() as purrr mainly provides functions that operate on vectors and functions, but not on environments.\nrapply() applies a function to all elements of a list recursively. This function makes it possible to limit the application of the function to specified classes (default classes = ANY). One may also specify how elements of other classes should remain: as their identity (how = replace) or another value (default = NULL). The closest equivalent in purrr is modify_depth(), which allows you to modify elements at a specified depth in a nested list.\nNotes: I wasn’t aware of purrr::modify_depth().\n\n\nChallenge: read about the fixed point algorithm. Complete the exercises using R.\n\nNote: see archive.org, “Finding fixed points of functions.”\nAnswer: the fixed point algorithm is defined below, with an example solution:\n(define tolerance 0.00001)\n(define (fixed-point f first-guess)\n  (define (close-enough? v1 v2)\n    (&lt; (abs (- v1 v2)) tolerance))\n  (define (try guess)\n    (let ((next (f guess)))\n      (if (close-enough? guess next)\n          next\n          (try next))))\n  (try first-guess))\n\n(fixed-point cos 1.0)\n0.7390822985224023\n\n(fixed-point (lambda (y) (+ (sin y) (cos y)))\n             1.0)\n1.2587315962971173\n\n(define (sqrt x)\n  (fixed-point (lambda (y) (/ x y))\n               1.0))\nImplementation in R:\n\nfixed_point &lt;- function(f, x) {\n  tolerance &lt;- 0.00001\n  close_enough &lt;- function(v1, v2) {\n    abs(v1 - v2) &lt; tolerance\n  }\n\n  if (close_enough(f(x), x)) {\n    f(x)\n  } else {\n    fixed_point(f, f(x))\n  }\n}\n\nfixed_point(cos, 1.0)\n\n#&gt; [1] 0.7390823\n\nfixed_point(function(y) sin(y) + cos(y), 1.0)\n\n#&gt; [1] 1.258732\n\n\nAR Solutions: A number \\(x\\) is called a fixed point of a function \\(f\\) if it satisfies the equation \\(f(x) = x\\). For some functions we may find a fixed point by beginning with a starting value and applying \\(f\\) repeatedly. Here fixed_point() acts as a functional because it takes a function as an argument.\n\nfixed_point_ar &lt;- function(f, x_init, n_max = 10000, tol = 0.0001) {\n  n &lt;- 0\n  x &lt;- x_init\n  y &lt;- f(x)\n\n  is_fixed_point &lt;- function(x, y) {\n    abs(x - y) &lt; tol\n  }\n\n  while (!is_fixed_point(x, y)) {\n    x &lt;- y\n    y &lt;- f(y)\n\n    # Make sure we eventually stop\n    n &lt;- n + 1\n    if (n &gt; n_max) {\n      stop(\"Failed to converge.\", call. = FALSE)\n    }\n  }\n\n  x\n}\n\n# Functions with fixed points\nfixed_point_ar(sin, x_init = 1)\n\n#&gt; [1] 0.08430922\n\nfixed_point_ar(cos, x_init = 1)\n\n#&gt; [1] 0.7391302\n\n# Functions without fixed points\nadd_one &lt;- function(x) x + 1\ntry(fixed_point_ar(add_one, x_init = 1))\n\n#&gt; Error : Failed to converge.\n\n\nNotes: AR Solutions offers a different approach using a while() loop that is guaranteed to stop. My approach using recursive calls does stop eventually with a stack limit error:\nNote: in previous versions of R (before R 4.4?), this block failed with a different error.\n\ntry(fixed_point(add_one, 1))\n\n#&gt; Error : node stack overflow\n\n\nComparing benchmarks:\n\nbench::mark(fixed_point_ar(cos, x_init = 1, tol = 0.00001))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 fixed_point_ar(cos, x_init = 1, to… 8.28µs 9.35µs   105086.        0B     21.0\n\nbench::mark(fixed_point(cos, 1))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression               min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;          &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 fixed_point(cos, 1)   12.5µs   14.6µs    67545.        0B     33.8\n\n\nAs usual, AR Solutions is faster. :-(",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#function-factories",
    "href": "analysis/advanced-r-2.html#function-factories",
    "title": "Advanced R (Functional programming)",
    "section": "10 Function factories",
    "text": "10 Function factories\n\nrm(list = ls())\n\nA function factory is a function that makes functions. Here’s a very simple example: we use a function factory (power1()) to make two child functions (square() and cube()):\n\npower1 &lt;- function(exp) {\n  function(x) {\n    x^exp\n  }\n}\nsquare &lt;- power1(2)\ncube &lt;- power1(3)\n\nDon’t worry if this doesn’t make sense yet, it should by the end of the chapter!\nI’ll call square() and cube() manufactured functions, but this is just a term to ease communication with other humans: from R’s perspective they are no different to functions created any other way.\n\nsquare(3)\n\n#&gt; [1] 9\n\ncube(3)\n\n#&gt; [1] 27\n\n\nYou have already learned about the individual components that make function factories possible:\n\nIn Section 6.2.3, you learned about R’s first-class functions. In R, you bind a function to a name in the same way as you bind any object to a name: with &lt;-.\nIn Section 7.4.2, you learned that a function captures (encloses) the environment in which it is created.\nIn Section 7.4.4, you learned that a function creates a new execution environment every time it is run. This environment is usually ephemeral, but here it becomes the enclosing environment of the manufactured function.\n\nIn this chapter, you’ll learn how the non-obvious combination of these three features leads to the function factory. You’ll also see examples of their usage in visualisation and statistics.\nOf the three main functional programming tools (functionals, function factories, and function operators), function factories are the least used. Generally, they don’t tend to reduce overall code complexity but instead partition complexity into more easily digested chunks. Function factories are also an important building block for the very useful function operators, which you’ll learn about in Chapter 11.\n\n10.2.6 Exercises\n\nThe definition of force() is simple:\n\n\nforce\n\n#&gt; function (x) \n#&gt; x\n#&gt; &lt;bytecode: 0x1219567e0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\nWhy is it better to force(x) instead of just x?\nAnswer: as the R Documentation states, ‘This is semantic sugar’: in other words, force(x) makes the intent of the call explicit, to force evaluation, whereas x does not.\nAR Solutions: As you can see force(x) is similar to x. As mentioned in Advanced R, we prefer this explicit form, because\n\nusing this function clearly indicates that you’re forcing evaluation, not that you’ve accidentally typed x.”\n\n\n\nBase R contains two function factories, approxfun() and ecdf(). Read their documentation and experiment to figure out what the functions do and what they return.\n\n\nx &lt;- c(1, 3, 6, 10, 19)\ny &lt;- x * 2\nplot(x, y, xlim = c(0, 20), ylim = c(0, 40))\n\n\n\n\n\n\n\naf &lt;- approxfun(x, y)\nplot(0:20, af(0:20), xlim = c(0, 20), ylim = c(0, 40))\n\n\n\n\n\n\n\n\nAnswer: approxfun() returns “a function performing the linear (or constant) interpolation.” As the example above shows, approxfun() provides linear interpolation that by default does not return values outside the minimum and maximum.\n\nplot(ecdf(rlnorm(1000)))\n\n\n\n\n\n\n\nplot(ecdf(rnorm(1000)))\n\n\n\n\n\n\n\nplot(ecdf(runif(1000)))\n\n\n\n\n\n\n\n\necdf() “Compute[s] an empirical cumulative distribution function”, the Empirical Cumulative Distribution Function, which is a standard statistical plot. It plots the actual observations connected by a line, which is easier to see with fewer observations:\n\nplot(ecdf(runif(50)))\n\n\n\n\n\n\n\n\nAR Solutions: (Note: full solution here)\nLet’s begin with approxfun() as it is used within ecdf() as well:\napproxfun() takes a combination of data points (x and y values) as input and returns a stepwise linear (or constant) interpolation function. To find out what this means exactly, we first create a few random data points.\nNext, we use approxfun() to construct the linear and constant interpolation functions for our x and y values.\nWhen we apply these functions to new x values, these are mapped to the lines connecting the initial y values (linear case) or to the same y value as for the next smallest initial x value (constant case).\nHowever, both functions are only defined within range(x).\nTo change this behaviour, one can set rule = 2. This leads to the result that for values outside of range(x) the boundary values of the function are returned.\nAnother option is to customise the return values as individual constants for each side via yleft and/or yright.\nFurther, approxfun() provides the option to shift the y values for method = \"constant\" between their left and right values. According to the documentation this indicates a compromise between left- and right-continuous steps.\nFinally, the ties argument allows to aggregate y values if multiple ones were provided for the same x value. For example, in the following line we use mean() to aggregate these y values before they are used for the interpolation approxfun(x = c(1,1,2), y = 1:3, ties = mean).\nNext, we focus on ecdf(). “ecdf” is an acronym for empirical cumulative distribution function. For a numeric vector of density values, ecdf() initially creates the (x, y) pairs for the nodes of the density function and then passes these pairs to approxfun(), which gets called with specifically adapted settings (approxfun(vals, cumsum(tabulate(match(x, vals)))/n, method = \"constant\", yleft = 0, yright = 1, f = 0, ties = \"ordered\")).\nNew values are then mapped on the y value of the next smallest x value from within the initial input.\n\n\nCreate a function pick() that takes an index, i, as an argument and returns a function with an argument x that subsets x with i.\n\n\npick &lt;- function(i) {\n  function(x) x[[i]]\n}\n\nx &lt;- 2:8\npick(1)(x)\n\n#&gt; [1] 2\n\n# should be equivalent to\nx[[1]]\n\n#&gt; [1] 2\n\nunlist(lapply(mtcars, pick(5)))\n\n#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#&gt;  18.70   8.00 360.00 175.00   3.15   3.44  17.02   0.00   0.00   3.00   2.00\n\n# should be equivalent to\nunlist(lapply(mtcars, function(x) x[[5]]))\n\n#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb \n#&gt;  18.70   8.00 360.00 175.00   3.15   3.44  17.02   0.00   0.00   3.00   2.00\n\n\nAnswer: code above. Modified to use unlist() to shorten output.\nAR Solutions: In this exercise pick(i) acts as a function factory, which returns the required subsetting function.\n\npick &lt;- function(i) {\n  force(i)\n  function(x) x[[i]]\n}\n\nNote: the AR Solutions version appropriately uses force().\n\n\nCreate a function that creates functions that compute the ith central moment of a numeric vector. You can test it by running the following code:\n\n\nmoment &lt;- function(i) {\n  function(x) mean((x - mean(x))^i)\n}\n\nm1 &lt;- moment(1)\nm2 &lt;- moment(2)\nx &lt;- runif(100)\nstopifnot(\n  all.equal(m1(x), 0),\n  all.equal(m2(x), var(x) * 99 / 100)\n)\nbench::mark(m2(x))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 m2(x)        2.09µs   2.62µs   370126.      848B     37.0\n\n\nAnswer: code above, following the formula \\(E[(X - E[X])^i]\\), where \\(E\\) is the expected value, ie the mean.\nAR Solutions: The first moment is closely related to the mean and describes the average deviation from the mean, which is 0 (within numerical margin of error). The second moment describes the variance of the input data. If we want to compare it to var(), we need to undo Bessel’s correction by multiplying with \\(\\frac{N-1}{N}\\).\n\nmoment &lt;- function(i) {\n  force(i)\n\n  function(x) sum((x - mean(x))^i) / length(x)\n}\nm1 &lt;- moment(1)\nm2 &lt;- moment(2)\nx &lt;- runif(100)\nall.equal(m1(x), 0) # removed stopifnot() for clarity\n\n#&gt; [1] TRUE\n\nall.equal(m2(x), var(x) * 99 / 100)\n\n#&gt; [1] TRUE\n\nbench::mark(m2(x))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 m2(x)        1.35µs   1.64µs   569632.      848B     57.0\n\n\nNote: isn’t sum() / length() just mean()? For fun, compare bench::mark() (above). Curses, foiled again!\n\n\nWhat happens if you don’t use a closure? Make predictions, then verify with the code below.\n\n\ni &lt;- 0\nnew_counter2 &lt;- function() {\n  i &lt;&lt;- i + 1\n  i\n}\n\nAnswer: i should increment by 1 every time new_counter2() is run, but can be altered by changing the global variable i. [Correct!]\n\nnew_counter2()\n\n#&gt; [1] 1\n\nnew_counter2()\n\n#&gt; [1] 2\n\nnew_counter2()\n\n#&gt; [1] 3\n\ni &lt;- 5\nnew_counter2()\n\n#&gt; [1] 6\n\ni &lt;- 0\n\nAR Solutions: Without the captured and encapsulated environment of a closure the counts will be stored in the global environment. Here they can be overwritten or deleted as well as interfere with other counters.\n\nnew_counter2()\n\n#&gt; [1] 1\n\ni\n\n#&gt; [1] 1\n\nnew_counter2()\n\n#&gt; [1] 2\n\ni\n\n#&gt; [1] 2\n\ni &lt;- 0\nnew_counter2()\n\n#&gt; [1] 1\n\ni\n\n#&gt; [1] 1\n\ni &lt;- 0\n\n\n\nWhat happens if you use &lt;- instead of &lt;&lt;-? Make predictions, then verify with the code below.\n\n\nnew_counter3 &lt;- function() {\n  i &lt;- 0\n  function() {\n    i &lt;- i + 1\n    i\n  }\n}\n\nAnswer: functions created by new_counter3() starts with a new value of i &lt;- 0 each time, and will always return 1. [Correct!]\n\nnc3 &lt;- new_counter3()\n\nnc3()\n\n#&gt; [1] 1\n\nnc3()\n\n#&gt; [1] 1\n\n\nAR Solutions: Without the super assignment &lt;&lt;-, the counter will always return 1. The counter always starts in a new execution environment within the same enclosing environment, which contains an unchanged value for i (in this case it remains 0).\n\n\n\n10.3.4 Exercises\n\nCompare and contrast ggplot2::label_bquote() with scales::number_format()\n\nAnswer: ggplot2::label_bquote() “offers a flexible way of labelling facet rows or columns with plotmath expressions. Backquoted variables will be replaced with their value in the facet.”\nThe example shows a scatterplot of weight and miles per gallon faceted by engine type (v-shaped).\n\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  facet_grid(vs ~ ., labeller = label_bquote(vs == .(vs)))\n\n\n\n\n\n\n\n\nscales::number_format() has been superseded by scales::label_number():\n“Use label_number() force decimal display of numbers (i.e. don’t use scientific notation). label_comma() is a special case that inserts a comma every three digits.”\n\ndemo_continuous(c(-1e6, 1e6), labels = label_number())\n\n#&gt; scale_x_continuous(labels = label_number())\n\n\n\n\n\n\n\n\n\nggplot2::label_bquote() is a special-purpose function for facets, while scales::number_format() can be applied more generally. Both are function factories that can be applied to changing labels.\nAR Solutions: Both functions will help you in styling your output, e.g. in your plots and they do this by returning the desired formatting function to you.\nggplot2::label_bquote() takes relatively straightforward plotmath expressions and uses them for faceting labels in {ggplot2}. Because this function is used in {ggplot2} it needs to return a function of class = \"labeller\".\nscales::number_format() initially force()s the computation of all parameters. It’s essentially a parametrised wrapper around scales::number() and will help you format numbers appropriately. It will return a simple function.\n\n\n\n10.4.4 Exercises\n\nIn boot_model(), why don’t I need to force the evaluation of df or model?\n\nAnswer: assuming model actually refers to formula, both are evaluated when mod &lt;- lm(formula, data = df) is run.\nAR Solutions: boot_model() ultimately returns a function, and whenever you return a function you need to make sure all the inputs are explicitly evaluated. Here that happens automatically because we use df and formula in lm() before returning the function.\n\n\nWhy might you formulate the Box-Cox transformation like this?\n\n\nboxcox3 &lt;- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x^lambda - 1) / lambda\n    }\n  }\n}\n\nAnswer: boxcox3 returns a function where x is fixed and lambda can vary, which allows for easy exploration of different values of lambda, for example using lapply() or optimize().\nAR Solutions: boxcox3() returns a function where x is fixed (though it is not forced, so it may be manipulated later). This allows us to apply and test different transformations for different inputs and give them a descriptive name.\nNote: I missed the fact that x is not forced.\n\n\nWhy don’t you need to worry that boot_permute() stores a copy of the data inside the function that it generates?\n\nAnswer: as R is copy-on-write, and boot_permute() stores an unmodified copy of the data, the function contains only a reference to the original data.\nAR Solutions: We don’t need to worry that it stores a copy of the data, because it actually doesn’t store one; it’s just a name that points to the same underlying object in memory.\n\n\nHow much time does ll_poisson2() save compared to ll_poisson1()? Use bench::mark() to see how much faster the optimisation occurs. How does changing the length of x change the results?\n\n\nll_poisson1 &lt;- function(x) {\n  n &lt;- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\n\nll_poisson2 &lt;- function(x) {\n  n &lt;- length(x)\n  sum_x &lt;- sum(x)\n  c &lt;- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\n\nx1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\n\nbench::mark(optimize(ll_poisson1(x1), c(0, 100), maximum = TRUE))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 optimize(ll_poisson1(x1), c(0, 100… 8.69µs 10.3µs    92813.    12.8KB     18.6\n\nbench::mark(optimize(ll_poisson2(x1), c(0, 100), maximum = TRUE))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 optimize(ll_poisson2(x1), c(0, 100… 4.92µs 5.95µs   166745.        0B     33.4\n\nx &lt;- rpois(1e3, 100L)\nbench::mark(optimize(ll_poisson1(x), c(0, 100), maximum = TRUE))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                           &lt;bch&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 optimize(ll_poisson1(x), c(0, 100),… 252µs  290µs     3437.     228KB     18.7\n\nbench::mark(optimize(ll_poisson2(x), c(0, 100), maximum = TRUE))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 optimize(ll_poisson2(x), c(0, 100)… 17.5µs   21µs    47095.    7.86KB     14.1\n\n\nAnswer: ll_poisson2() is nearly twice as fast with x1 and nearly 10 times as fast when the length of x is 100.\nNotes: consulting AR Solutions was needed to understand how to benchmark the two functions.\nAR Solutions:\nA benchmark on x1 reveals a performance improvement of factor 2 for ll_poisson2() over ll_poisson1()\nAs the redundant calculations within ll_poisson1() become more expensive with growing length of x1, we expect even further relative performance improvements for ll_poisson2(). The following benchmark reveals a relative performance improvement of factor 20 for ll_poisson2() when x1 is of length 100,000.\n\n\n\n10.5.1 Exercises\n\nWhich of the following commands is equivalent to with(x, f(z))?\n\nx$f(x$z).\nf(x$z).\nx$f(z).\nf(z).\nIt depends.\n\n\nAnswer: (e). depending on the value of x, it could be any of (a) through (d).\nAR Solutions: (e) “It depends” is the correct answer. Usually with() is used with a data frame, so you’d usually expect (b), but if x is a list, it could be any of the options.\n\n\nCompare and contrast the effects of env_bind() vs. attach() for the following code.\n\n\nfuns &lt;- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n\n#&gt; The following objects are masked from package:base:\n#&gt; \n#&gt;     mean, sum\n\nmean &lt;- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean &lt;- function(x) stop(\"Hi!\")\nenv_unbind(globalenv(), names(funs))\n\nAnswer: attach() places the function names in the search path, and the env_bind() code places the function names in the global environment. Both have the effect of masking mean() and sum(), but as the chapter points out, when unbinding, “there’s no guarantee that they haven’t been rebound in the meantime, and you might be deleting an object that someone else created.”\nAR Solutions: attach() adds funs to the search path. Therefore, the provided functions are found before their respective versions from the {base} package. Further, they cannot get accidentally overwritten by similar named functions in the global environment. One annoying downside of using attach() is the possibility to attach the same object multiple times, making it necessary to call detach() equally often.\nIn contrast rlang::env_bind() just adds the functions in fun to the global environment. No further side effects are introduced, and the functions are overwritten when similarly named functions are defined.\nNotes: AR Solutions provides a more complete answer.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#function-operators",
    "href": "analysis/advanced-r-2.html#function-operators",
    "title": "Advanced R (Functional programming)",
    "section": "11 Function operators",
    "text": "11 Function operators\n\nrm(list = ls())\n\nIn this chapter, you’ll learn about function operators. A function operator is a function that takes one (or more) functions as input and returns a function as output. The following code shows a simple function operator, chatty(). It wraps a function, making a new function that prints out its first argument. You might create a function like this because it gives you a window to see how functionals, like map_int(), work.\n\nchatty &lt;- function(f) {\n  force(f)\n\n  function(x, ...) {\n    res &lt;- f(x, ...)\n    cat(\"Processing \", x, \"\\n\", sep = \"\")\n    res\n  }\n}\nf &lt;- function(x) x^2\ns &lt;- c(3, 2, 1)\npurrr::map_dbl(s, chatty(f))\n\n#&gt; Processing 3\n#&gt; Processing 2\n#&gt; Processing 1\n\n\n#&gt; [1] 9 4 1\n\n\nFunction operators are closely related to function factories; indeed they’re just a function factory that takes a function as input. Like factories, there’s nothing you can’t do without them, but they often allow you to factor out complexity in order to make your code more readable and reusable.\nFunction operators are typically paired with functionals. If you’re using a for-loop, there’s rarely a reason to use a function operator, as it will make your code more complex for little gain.\nIf you’re familiar with Python, decorators is just another name for function operators.\n\n11.2.3 Exercises\n\nBase R provides a function operator in the form of Vectorize(). What does it do? When might you use it?\n\nAnswer: according to the R documentation, “Vectorize creates a function wrapper that vectorizes the action of its argument FUN.” “The arguments named in the vectorize.args argument to Vectorize are the arguments passed in the ... list to mapply. Only those that are actually passed will be vectorized; default values will not.” and returns “A function with the same arguments as FUN, wrapping a call to mapply.”\nIn other words, it is a function operator that uses mapply() to iterate across the arguments. This is potentially simpler to understand than use of mapply().\nIn the R documentation example, the vectorized rep.int is called for each pair of values:\n\nvrep &lt;- Vectorize(rep.int)\nvrep(1:4, 4:1)\n\n#&gt; [[1]]\n#&gt; [1] 1 1 1 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2 2 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3 3\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 4\n\n\nAR Solutions: In R a lot of functions are “vectorised”. Vectorised has two meanings. First, it means (broadly) that a function inputs a vector or vectors and does something to each element. Secondly, it usually implies that these operations are implemented in a compiled language such as C or Fortran, so that the implementation is very fast.\nHowever, despite what the function’s name implies, Vectorize() is not able to speed up the provided function. It rather changes the input format of the supplied arguments (vectorize.args), so that they can be iterated over.\nVectorize() provides a convenient and concise notation to iterate over multiple arguments but has some major drawbacks that mean you generally shouldn’t use it. See this post for more details.\nNotes: Jim Hester’s article points out that most R functions are already vectorized, including paste()!\n\ncolor &lt;- c(\"blue\", \"red\", \"green\")\nobject &lt;- c(\"ball\", \"hat\", \"coat\")\nname &lt;- c(\"Sally\", \"Hank\", \"Darla\")\n\npaste(\"A\", color, object, \"for\", name)\n\n#&gt; [1] \"A blue ball for Sally\"  \"A red hat for Hank\"     \"A green coat for Darla\"\n\n\nIt also argues against use of Vectorize() because a) the functions it generates are not type stable, b) obfuscates the function code, c) can degrade performance, and d) can’t improve performance.\nHe recommends using existing vectorized functions and either vapply() or map().\n\n\nRead the source code for possibly(). How does it work?\n\n\npossibly\n\n#&gt; function (.f, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     .f &lt;- as_mapper(.f)\n#&gt;     force(otherwise)\n#&gt;     check_bool(quiet)\n#&gt;     function(...) {\n#&gt;         tryCatch(.f(...), error = function(e) {\n#&gt;             if (!quiet) {\n#&gt;                 message(\"Error: \", conditionMessage(e))\n#&gt;             }\n#&gt;             otherwise\n#&gt;         })\n#&gt;     }\n#&gt; }\n#&gt; &lt;bytecode: 0x1682b5bd8&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\n\nAnswer: possibly() returns a function that uses tryCatch() to return otherwise if the mapper .f errors, unless interrupted, forcing evaluation of otherwise before the mapper is called.\nAR Solutions: possibly() modifies functions to return a specified default value (otherwise) in case of an error and to suppress any error messages (quiet = TRUE).\nWhile reading the source code, we notice that possibly() internally uses purrr::as_mapper(). This enables users to supply not only functions, but also formulas or atomics via the same syntax as known from other functions in the {purrr} package. Besides this, the new default value (otherwise) gets evaluated once to make it (almost) immutable.\nThe main functionality of possibly() is provided by base::tryCatch(). In this part the supplied function (.f) gets wrapped and the error and interrupt handling are specified.\n\n\nRead the source code for safely(). How does it work?\n\n\nsafely\n\n#&gt; function (.f, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     .f &lt;- as_mapper(.f)\n#&gt;     force(otherwise)\n#&gt;     check_bool(quiet)\n#&gt;     function(...) capture_error(.f(...), otherwise, quiet)\n#&gt; }\n#&gt; &lt;bytecode: 0x16e8de400&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\npurrr:::capture_error\n\n#&gt; function (code, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     tryCatch(list(result = code, error = NULL), error = function(e) {\n#&gt;         if (!quiet) {\n#&gt;             message(\"Error: \", conditionMessage(e))\n#&gt;         }\n#&gt;         list(result = otherwise, error = e)\n#&gt;     })\n#&gt; }\n#&gt; &lt;bytecode: 0x16e91ac18&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\n\nAnswer: safely() returns a function that uses the internal capture_error() function to store the evaluation of the mapper .f in result, and any error in error.\nAR Solutions: safely() modifies functions to return a list, containing the elements result and error. It works in a similar fashion as possibly() and besides using as_mapper(), safely() also provides the otherwise and quiet arguments. However, in order to provide the result and the error in a consistent way, the tryCatch() part of the implementation returns a list with similar structure for both cases. In the case of successful evaluation error equals NULL and in case of an error result equals otherwise, which is NULL by default.\nAs the tryCatch() part is hidden in the internal purrr:::capture_output() function, we provide it here in addition to safely().\nTake a look at Advanced R or the documentation of safely() to see how you can take advantage of this behaviour, e.g. when fitting many models.\n\n\n\n11.3.1 Exercises\n\nWeigh the pros and cons of download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1) versus download.file %&gt;% delay_by(0.1) %&gt;% dot_every(10).\n\nAnswer: in the first version, download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1), delay_by is the outer function, so a delay is added after the dot is written. In the second version, a dot is added after the delay. The first version seems better since the feedback dots aren’t delayed.\nAR Solutions: Both commands will print a dot every 10 downloads and will take the same amount of time to run, so the differences may seem quite subtle.\nIn the first case, first the dot functionality is added to download.file(). Then the delay is added to this already tweaked function. This implies, that the printing of the dot will also be delayed, and the first dot will be printed as soon as the download for the 10th URL starts.\nIn the latter case the delay is added first and the dot-functionality is wrapped around it. This order will print the first dot immediately after the 9th download is finished, then the short delay occurs before the 10th download actually starts.\nNote: the first case seems like the better option.\n\n\nShould you memoise file.download()? Why or why not?\n\nAnswer: download.file() should not be memoised! As mentioned in the chapter, the function is not pure (the output doesn’t depend only on the input), and has side effects (saving a file to disk).\nAR Solutions: Memoising file.download() will only work if the files are immutable, i.e. if the file at a given URL is always the same. There’s no point memoising unless this is true. Even if this is true, however, memoise has to store the results in memory, and large files will potentially take up a lot of memory.\nThis implies that it’s probably not beneficial to memoise file.download() in most cases. The only exception is if you are downloading small files many times, and the file at a given URL is guaranteed not to change.\nNote: AR Solutions offers a reasonable exception case when memoising makes sense.\n\n\nCreate a function operator that reports whenever a file is created or deleted in the working directory, using dir() and setdiff(). What other global function effects might you want to track?\n\n\nwd_changes &lt;- function(f) {\n  function(...) {\n    before &lt;- dir()\n    ret &lt;- withVisible(f(...))\n    after &lt;- dir()\n    removed &lt;- setdiff(before, after)\n    added &lt;- setdiff(after, before)\n    if (length(removed) != 0) cat(\"removed files: \", removed, \"\\n\")\n    if (length(added) != 0) cat(\"added files: \", added, \"\\n\")\n    if (ret$visible) {\n      ret$value\n    } else {\n      invisible(ret$value)\n    }\n  }\n}\n\nAnswer: code above. Other effects you might want to track include changes to the global environment, output, and conditions.\nAR Solutions: We start with a function that reports the difference between two vectors containing file names:\n\ndir_compare &lt;- function(old, new) {\n  if (setequal(old, new)) {\n    return()\n  }\n\n  added &lt;- setdiff(new, old)\n  removed &lt;- setdiff(old, new)\n\n  changes &lt;- c(\n    if (length(added) &gt; 0) paste0(\" * '\", added, \"' was added\"),\n    if (length(removed) &gt; 0) paste0(\" * '\", removed, \"' was removed\")\n  )\n  message(paste(changes, collapse = \"\\n\"))\n}\ndir_compare(c(\"x\", \"y\"), c(\"x\", \"y\"))\n\n#&gt; NULL\n\ndir_compare(c(\"x\", \"y\"), c(\"x\", \"a\"))\n\n#&gt;  * 'a' was added\n#&gt;  * 'y' was removed\n\n\nThen we wrap it up in a function operator\n\ntrack_dir &lt;- function(f) {\n  force(f)\n  function(...) {\n    dir_old &lt;- dir()\n    on.exit(dir_compare(dir_old, dir()), add = TRUE)\n\n    f(...)\n  }\n}\n\nAnd try it out by creating wrappers around file.create() and file.remove():\n\nfile_create &lt;- track_dir(file.create)\nfile_remove &lt;- track_dir(file.remove)\nfile_create(\"delete_me\")\n\n#&gt;  * 'delete_me' was added\n\n\n#&gt; [1] TRUE\n\nfile_remove(\"delete_me\")\n\n#&gt;  * 'delete_me' was removed\n\n\n#&gt; [1] TRUE\n\n\nTo create a more serious version of track_dir() one might provide optionality to set the full.names and recursive arguments of dir() to TRUE. This would enable to also track the creation/deletion of hidden files and files in folders contained in the working directory.\nOther global effects that might be worth tracking include changes regarding:\n\nthe search path and possibly introduced conflicts()\noptions() and par() which modify global settings\nthe path of the working directory\nenvironment variables\n\nNotes: AR Solutions use of multiple functions, messages and on.exit is preferable.\n\n\nWrite a function operator that logs a timestamp and message to a file every time a function is run.\n\n\nlog_call &lt;- function(f, logfile = \"log_call.log\") {\n  name &lt;- deparse(enexpr(f))\n  force(f)\n  force(logfile)\n\n  function(...) {\n    m &lt;- paste0(Sys.time(), \" log_call: \", name)\n    write(m, file = logfile, append = TRUE)\n    f(...)\n  }\n}\n\nAnswer: code above.\nAR Solutions: Our logger() function operator takes a function and a file path as input. One timestamp is written to the file under log_path when we call logger() and another timestamp is written to the same file each time the new function gets called.\n\nappend_line &lt;- function(path, ...) {\n  cat(..., \"\\n\", sep = \"\", file = path, append = TRUE)\n}\n\nlogger &lt;- function(f, log_path) {\n  force(f)\n  force(log_path)\n\n  append_line(log_path, \"created at: \", as.character(Sys.time()))\n  function(...) {\n    append_line(log_path, \"called at: \", as.character(Sys.time()))\n    f(...)\n  }\n}\n\nNote: AR Solutions creates a function append_line() instead of using write(), and adds a “created at:” time, but is otherwise functionally the same. My solution also logs the name of the function called.\n\n\nModify delay_by() so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called g &lt;- delay_by(1, f); g(); Sys.sleep(2); g() there shouldn’t be an extra delay.\n\n\nsleep_if &lt;- function(start, end, delay) {\n  sleep_time &lt;- delay - as.numeric(end - start)\n  if (sleep_time &gt; 0) Sys.sleep(sleep_time)\n}\n\ndelay_by &lt;- function(f, delay) {\n  force(f)\n  force(delay)\n\n  last_called &lt;- NULL\n  function(...) {\n    if (!is.null(last_called)) {\n      sleep_if(last_called, Sys.time(), delay)\n    }\n    on.exit(last_called &lt;&lt;- Sys.time(), add = TRUE)\n\n    f(...)\n  }\n}\n\nf &lt;- function() {\n  0\n}\ng &lt;- delay_by(f, 1)\nh &lt;- delay_by(f, 1)\n\nsystem.time({\n  h()\n  h()\n})\n\n#&gt;    user  system elapsed \n#&gt;   0.002   0.000   1.007\n\nsystem.time({\n  g()\n  Sys.sleep(2)\n  g()\n})\n\n#&gt;    user  system elapsed \n#&gt;   0.004   0.000   2.009\n\n\nAnswer: code above.\nAR Solutions:\nTo ensure that the function created by delay_by() waits that a certain amount of time has passed since its last execution, we incorporate three little changes into our new delay_atleast() as indicated in the corresponding comments below.\n\ndelay_atleast &lt;- function(amount, f) {\n  force(f)\n  force(amount)\n\n  # Store the last time the function was run\n  last_time &lt;- NULL\n\n  # Return modified \"delay-aware\" function\n  function(...) {\n    if (!is.null(last_time)) {\n      wait &lt;- (last_time - Sys.time()) + amount\n      if (wait &gt; 0) {\n        Sys.sleep(wait)\n      }\n    }\n\n    # Update the time after the function has finished\n    on.exit(last_time &lt;&lt;- Sys.time())\n\n    f(...)\n  }\n}\n\nNotes: this was tricky; I had to consult AR Solutions for an answer.",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-2.html#footnotes",
    "href": "analysis/advanced-r-2.html#footnotes",
    "title": "Advanced R (Functional programming)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTypically it’s not the for loop itself that’s slow, but what you’re doing inside of it. A common culprit of slow loops is modifying a data structure, where each modification generates a copy. See Sections 2.5.1 and 24.6 for more details.↩︎",
    "crumbs": [
      "Changelog",
      "Advanced R (Functional programming)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html",
    "href": "analysis/advanced-r-1.html",
    "title": "Advanced R (Foundations)",
    "section": "",
    "text": "Workbook for completing quizzes and exercises from the “Foundations” chapters of Advanced R, second edition, with comparisons to solutions from Advanced R Solutions.\nlibrary(lobstr)\nlibrary(bench)\nlibrary(rlang)\n\n# from https://github.com/hadley/adv-r/blob/master/common.R\nknitr::opts_chunk$set(\n  comment = \"#&gt;\",\n  fig.align = \"center\"\n)\n\nknitr::knit_hooks$set(\n  small_mar = function(before, options, envir) {\n    if (before) {\n      par(mar = c(4.1, 4.1, 0.5, 0.5))\n    }\n  }\n)",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#introduction",
    "href": "analysis/advanced-r-1.html#introduction",
    "title": "Advanced R (Foundations)",
    "section": "Introduction",
    "text": "Introduction\nThis workbook includes answers and solutions to the quizzes and exercises from Advanced R and Advanced R Solutions, organized by chapter. It includes excerpts from both books, copied here.\nWARNING, SPOILERS! If you haven’t read Advanced R and intend to complete the quizzes and exercises, don’t read this notebook. It contains my (potentially wrong) answers to both.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#names-and-values",
    "href": "analysis/advanced-r-1.html#names-and-values",
    "title": "Advanced R (Foundations)",
    "section": "2 Names and values",
    "text": "2 Names and values\nIn R, it is important to understand the distinction between an object and its name. Doing so will help you:\n\nMore accurately predict the performance and memory usage of your code.\nWrite faster code by avoiding accidental copies, a major source of slow code.\nBetter understand R’s functional programming tools.\n\nThe goal of this chapter is to help you understand the distinction between names and values, and when R will copy an object.\n\n2 Quiz\n\nGiven the following data frame, how do I create a new column called “3” that contains the sum of 1 and 2? You may only use $, not [[. What makes 1, 2, and 3 challenging as variable names?\n\n\ndf &lt;- data.frame(runif(3), runif(3))\nnames(df) &lt;- c(1, 2)\n\nAnswer: use the following code.\n\ndf2 &lt;- data.frame(df, df$`1` + df$`2`)\nnames(df2) &lt;- c(1, 2, 3)\n\nUsing numbers as names is problematic due to them being interpreted as numeric constants by default.\n\n\nIn the following code, how much memory does y occupy?\n\n\nx &lt;- runif(1e6)\ny &lt;- list(x, x, x)\n\nAnswer: 3 times the size of x, 24 MB. Note: this is incorrect, as shown by obj_size and obj_addr:\n\nobj_size(x)\n\n#&gt; 8.00 MB\n\nobj_size(y)\n\n#&gt; 8.00 MB\n\nobj_addr(y[[1]])\n\n#&gt; [1] \"0x119238000\"\n\nobj_addr(y[[2]])\n\n#&gt; [1] \"0x119238000\"\n\nobj_addr(y[[3]])\n\n#&gt; [1] \"0x119238000\"\n\n\n\n\nOn which line does a get copied in the following example?\n\n\na &lt;- c(1, 5, 3, 2)\nobj_addr(a)\n\n#&gt; [1] \"0x1072abdb8\"\n\nb &lt;- a\nobj_addr(b)\n\n#&gt; [1] \"0x1072abdb8\"\n\nb[[1]] &lt;- 10\nobj_addr(b)\n\n#&gt; [1] \"0x1072a6cd8\"\n\n\nAnswer: the third line (copy-on-write). [copy-on-modify]\n\n\n2.2.2 Exercises\n\nExplain the relationship between a, b, c and d in the following code:\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\nAnswer: a, b, and c all point to the same object (1:10). d points to an identical object at a different address.\nAR Solutions: a, b, and c point to the same object (with the same address in memory). This object has the value 1:10. d points to a different object with the same value.\n\nobj_addr(a)\n\n#&gt; [1] \"0x11426b398\"\n\nobj_addr(b)\n\n#&gt; [1] \"0x11426b398\"\n\nobj_addr(c)\n\n#&gt; [1] \"0x11426b398\"\n\nobj_addr(d)\n\n#&gt; [1] \"0x113d910a0\"\n\n\n\n\nThe following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with lobstr::obj_addr().\n\n\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")\n\nCheck the obj_addr:\n\nobj_addr(mean)\n\n#&gt; [1] \"0x113291520\"\n\nobj_addr(base::mean)\n\n#&gt; [1] \"0x113291520\"\n\nobj_addr(get(\"mean\"))\n\n#&gt; [1] \"0x113291520\"\n\nobj_addr(evalq(mean))\n\n#&gt; [1] \"0x113291520\"\n\nobj_addr(match.fun(\"mean\"))\n\n#&gt; [1] \"0x113291520\"\n\n\nAnswer: they do.\nAR Solutions: Yes, they point to the same object. We confirm this by inspecting the address of the underlying function object.\n\n\nBy default, base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behaviour?\n\nAnswer: this could introduce problematic names, like 1. Setting check.names = FALSE suppresses this behavior.\nAR Solutions: Column names are often data, and the underlying make.names() transformation is non-invertible, so the default behaviour corrupts data. To avoid this, set check.names = FALSE.\n\n\nWhat rules does make.names() use to convert non-syntactic names into syntactic ones?\n\nAnswer: from ?make.names:\n\nThe character “X” is prepended if necessary. All invalid characters are translated to “.”. A missing value is translated to “NA”. Names which match R keywords have a dot appended to them. Duplicated values are altered by make.unique.\n\nAR Solutions: A valid name must start with a letter or a dot (not followed by a number) and may further contain numbers and underscores (\"_\"s are allowed since R version 1.9.0).\nThree main mechanisms ensure syntactically valid names (see ?make.names):\n\nNames that do not start with a letter or a dot will be prepended with an \"X\". The same holds for names that begin with a dot followed by a number.\nAdditionally, non-valid characters are replaced by a dot.\nReserved R keywords (see ?reserved) are suffixed by a dot.\n\nInterestingly, some of these transformations are influenced by the current locale. From ?make.names:\n\nThe definition of a letter depends on the current locale, but only ASCII digits are considered to be digits.\n\n\n\nI slightly simplified the rules that govern syntactic names. Why is .123e1 not a syntactic name? Read ?make.names for the full details.\n\nAnswer: from ?make.names:\n\nA syntactically valid name consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number. Names such as “.2way” are not valid, and neither are the reserved words.\n\nAR Solutions: .123e1 is not a syntactic name, because it starts with one dot which is followed by a number. This makes it a double, 1.23.\n\n\n\n2.3.6 Exercises\n\nWhy is tracemem(1:10) not useful?\n\nAnswer: this is tracing an ‘immutable’ object which will always have the same address.\nAR Solutions: When 1:10 is called an object with an address in memory is created, but it is not bound to a name. Therefore, the object cannot be called or manipulated from R. As no copies will be made, it is not useful to track the object for copying.\n\n\nExplain why tracemem() shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.\n\n\nrm(list = ls())\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n#&gt; [1] \"&lt;0x110f23f48&gt;\"\n\nx[[3]] &lt;- 4\n\n#&gt; tracemem[0x110f23f48 -&gt; 0x110fe9548]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n#&gt; tracemem[0x110fe9548 -&gt; 0x110c42e58]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\nuntracemem(x)\n\nAnswer: unclear. The behavior in R 4.2.0 seems to have changed, since this code shows two copies:\n\nrm(list = ls())\nx &lt;- c(1, 2, 3)\ntracemem(x)\n\n#&gt; [1] \"&lt;0x11613e4d8&gt;\"\n\ny &lt;- x\ny[[3]] &lt;- 4L\n\n#&gt; tracemem[0x11613e4d8 -&gt; 0x116182398]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\ny[[3]] &lt;- 5L\nuntracemem(x)\n\nAR Solutions: Initially the vector x has integer type. The replacement call assigns a double to the third element of x, which triggers copy-on-modify.\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n#&gt; &lt;0x66a4a70&gt;\n\nx[[3]] &lt;- 4\n#&gt; tracemem[0x55eec7b3af38 -&gt; 0x55eec774cc18]:\n\nWe can avoid the copy by sub-assigning an integer instead of a double:\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n#&gt; &lt;0x55eec6940ae0&gt;\n\nx[[3]] &lt;- 4L\n\nPlease be aware that running this code in RStudio will result in additional copies because of the reference from the environment pane.\n\n\nSketch out the relationship between the following objects:\n\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nprint(\"first object\")\n\n#&gt; [1] \"first object\"\n\nobj_addr(a)\n\n#&gt; [1] \"0x11654ada0\"\n\nobj_addr(b[[1]])\n\n#&gt; [1] \"0x11654ada0\"\n\nobj_addr(b[[2]])\n\n#&gt; [1] \"0x11654ada0\"\n\nobj_addr(c[[2]])\n\n#&gt; [1] \"0x11654ada0\"\n\nprint(\"second object\")\n\n#&gt; [1] \"second object\"\n\nobj_addr(b)\n\n#&gt; [1] \"0x116476788\"\n\nobj_addr(c[[1]])\n\n#&gt; [1] \"0x116476788\"\n\nprint(\"third object\")\n\n#&gt; [1] \"third object\"\n\nobj_addr(c)\n\n#&gt; [1] \"0x1166f8898\"\n\nprint(\"fourth object (?)\")\n\n#&gt; [1] \"fourth object (?)\"\n\nobj_addr(c[[3]])\n\n#&gt; [1] \"0x1165a6be0\"\n\n\nAnswer: four different objects with multiple names.\nAR Solutions: a contains a reference to an address with the value 1:10. b contains a list of two references to the same address as a. c contains a list of b (containing two references to a), a (containing the same reference again) and a reference pointing to a different address containing the same value (1:10).\n\n\nWhat happens when you run this code? Draw a picture.\n\n\nx &lt;- list(1:10)\n\nx[[2]] &lt;- x\n\nref(x)\n\n#&gt; █ [1:0x11675df48] &lt;list&gt; \n#&gt; ├─[2:0x116ce9dd0] &lt;int&gt; \n#&gt; └─█ [3:0x106393350] &lt;list&gt; \n#&gt;   └─[2:0x116ce9dd0]\n\n\nInitially x is a list of one element, an int vector 1:10. Then a second list element is added, which points to the original int vector.\nAR Solutions: The initial reference tree of x shows that the name x binds to a list object. This object contains a reference to the integer vector 1:10. When x is assigned to an element of itself, copy-on-modify takes place and the list is copied to a new address in memory. The list object previously bound to x is now referenced in the newly created list object. It is no longer bound to a name. The integer vector is referenced twice.\n\n\n\n2.4.1 Exercises\n\nIn the following example, why are object.size(y) and obj_size(y) so radically different? Consult the documentation of object.size().\n\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n#&gt; 8005648 bytes\n\nobj_size(y)\n\n#&gt; 80.90 kB\n\n\nAnswer: object.size() “does not detect if elements of a list are shared”, which is the case here. That is, it does not detect the list has been replicated 100 times, and overestimates by a factor of 100 compared to object_size().\nAR Solutions: object.size() doesn’t account for shared elements within lists. Therefore, the results differ by a factor of ~ 100.\n\n\nTake the following list. Why is its size somewhat misleading?\n\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n#&gt; 18.76 kB\n\n\nAnswer: it doesn’t seem misleading to me, but the list includes the function objects, not the return values. Also, it calculates the size discarding the overlap between the functions. Per the code below, there is some:\n\nobj_size(mean) + obj_size(sd) + obj_size(var)\n\n#&gt; 19.29 kB\n\n\nAR Solutions: All three functions are built-in to R as part of the {base} and {stats} packages and hence always available. So, what does it mean to measure the size of something that’s already included in R?\n(There’s typically a more general question about what you want to know when you ask for the size of something — do you want to know how much data you’d need to send to communicate the object to someone else (e.g. serialise it), or do you want to know how much memory you’d free if you deleted it?)\n\n\nPredict the output of the following code:\n\n\na &lt;- runif(1e6)\nobj_size(a) # 8,000,048 B ~ 8MB\n\n#&gt; 8.00 MB\n\n# correct: from example above, runif(1e6) ~= 8MB\n\nb &lt;- list(a, a)\nobj_size(b) # slightly larger than obj_size(a)\n\n#&gt; 8.00 MB\n\n# correct: two lists containing numeric vectors\nobj_size(a, b) # slightly larger than obj_size(b)\n\n#&gt; 8.00 MB\n\n# wrong: a is entirely contained within b\n\nb[[1]][[1]] &lt;- 10\nobj_size(b) # copy of b, same size\n\n#&gt; 16.00 MB\n\n# wrong: double, since R copies an entire column, this adds the size of runif(1e6)\nobj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)\n\n#&gt; 16.00 MB\n\n# wrong: a is still entirely contained with b\n\nb[[2]][[1]] &lt;- 10\nobj_size(b) # copy of b, same size\n\n#&gt; 16.00 MB\n\n# wrong: same size since it's still 2 numeric vectors of 1e6 length\nobj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)\n\n#&gt; 24.00 MB\n\n# wrong: there is no longer any overlap, so the size of obj_size(a, b) = obj_size(a) = obj_size(b)\n\nAnswer: answers inline.\nAR Solutions:\na &lt;- runif(1e6):\n\nIn R (on most platforms) a length-0 vector has 48 bytes of overhead.\nA single double takes up an additional 8 bytes of memory.\nSo, a 1 million double should take up 8,000,048 bytes.\n\nFor b &lt;- list(a, a) both list elements contain references to the same memory address. Therefore, no additional memory is required for the second list element. The list itself requires 64 bytes, 48 bytes for an empty list and 8 bytes for each element (obj_size(vector(\"list\", 2))). This lets us predict 8,000,048 B + 64 B = 8,000,112 B.\nb[[1]][[1]] &lt;- 10: When we modify the first element of b[[1]] copy-on-modify occurs. Both elements will still have the same size (8,000,040 B), but the first one gets a new address in memory. As b’s elements don’t share references anymore, its object size adds up to the sum of the elements and the length-2 list: 8,000,048 B + 8,000,048 B + 64 B = 16,000,160 B (16 MB). The second element of b still references the same address as a, so the combined size of a and b is the same as b.\nb[[2]][[1]] &lt;- 10: When we modify the second element of b, this element will also point to a new memory address. This does not affect the size of the list. However, as b doesn’t share references with a anymore, the memory usage of the combined objects increases.\n\n\n\n2.5.3 Exercises\n\nExplain why the following code doesn’t create a circular list.\n\n\nx &lt;- list()\nx[[1]] &lt;- x\n\nAnswer: the name x is assigned to the empty list, and then the first element of x is mapped to the object that x points to, the empty list.\nAR Solutions: In this situation copy-on-modify prevents the creation of a circular list. Let us step through the details:\n\nx &lt;- list() # creates initial object\nobj_addr(x)\n#&gt; [1] \"0x55862f23ab80\"\ntracemem(x)\n#&gt; [1] \"&lt;0x55862f23ab80&gt;\"\nx[[1]] &lt;- x # Copy-on-modify triggers new copy\n#&gt; tracemem[0x55862f23ab80 -&gt; 0x55862e8ce028]:\nobj_addr(x) # copied object has new memory address\n#&gt; [1] \"0x55862e8ce028\"\nobj_addr(x[[1]]) # list element contains old memory address\n#&gt; [1] \"0x55862f23ab80\"\n\n\n\nWrap the two methods for subtracting medians into two functions, then use the ‘bench’ package [@bench] to carefully compare their speeds. How does performance change as the number of columns increase?\n\n\nx_medians &lt;- function(ncol) {\n  x &lt;- data.frame(matrix(runif(5 * 1e4), ncol = ncol))\n  medians &lt;- vapply(x, median, numeric(1))\n  return(list(x = x, medians = medians))\n}\n\ndf_medians &lt;- function(x, medians) {\n  # subtract medians using data.frame method\n  for (i in seq_along(medians)) {\n    x[[i]] &lt;- x[[i]] - medians[[i]]\n  }\n  x\n}\n\nls_medians &lt;- function(x, medians) {\n  y &lt;- as.list(x)\n\n  for (i in seq_along(medians)) {\n    y[[i]] &lt;- y[[i]] - medians[[i]]\n  }\n  y\n}\n\n# confirm they both work\nxm &lt;- x_medians(5)\nhead(df_medians(xm$x, xm$medians), 10)\n\n#&gt;             X1           X2         X3          X4          X5\n#&gt; 1  -0.16835527 -0.473456873  0.3799435 -0.08899423  0.32717262\n#&gt; 2   0.13400482  0.298803460 -0.3848004 -0.40976468  0.24014878\n#&gt; 3   0.24329373  0.335762391  0.3255231  0.32694636 -0.24344696\n#&gt; 4  -0.20275693  0.002408049 -0.2904241  0.48495011 -0.38091733\n#&gt; 5  -0.45942317  0.188104575 -0.2822282 -0.47238504 -0.19273541\n#&gt; 6  -0.41138332 -0.366321461 -0.3841737  0.12167447 -0.08383285\n#&gt; 7  -0.07910379 -0.319984353  0.2780613 -0.39555938 -0.42864403\n#&gt; 8  -0.47928193 -0.024306796  0.2093443 -0.43801738 -0.32986170\n#&gt; 9   0.15315983 -0.425557586  0.2499339  0.11377855  0.20102636\n#&gt; 10  0.07588349 -0.418820322 -0.2682968  0.44536774 -0.24138827\n\nhead(as.data.frame(ls_medians(xm$x, xm$medians)), 10)\n\n#&gt;             X1           X2         X3          X4          X5\n#&gt; 1  -0.16835527 -0.473456873  0.3799435 -0.08899423  0.32717262\n#&gt; 2   0.13400482  0.298803460 -0.3848004 -0.40976468  0.24014878\n#&gt; 3   0.24329373  0.335762391  0.3255231  0.32694636 -0.24344696\n#&gt; 4  -0.20275693  0.002408049 -0.2904241  0.48495011 -0.38091733\n#&gt; 5  -0.45942317  0.188104575 -0.2822282 -0.47238504 -0.19273541\n#&gt; 6  -0.41138332 -0.366321461 -0.3841737  0.12167447 -0.08383285\n#&gt; 7  -0.07910379 -0.319984353  0.2780613 -0.39555938 -0.42864403\n#&gt; 8  -0.47928193 -0.024306796  0.2093443 -0.43801738 -0.32986170\n#&gt; 9   0.15315983 -0.425557586  0.2499339  0.11377855  0.20102636\n#&gt; 10  0.07588349 -0.418820322 -0.2682968  0.44536774 -0.24138827\n\n# benchmark\nmark(df_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 df_medians(xm$x, xm$medians)   24.1µs   41.9µs    23712.     391KB     330.\n\nmark(ls_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 ls_medians(xm$x, xm$medians)   7.63µs   22.1µs    47323.     391KB     541.\n\nmark(as.data.frame(ls_medians(xm$x, xm$medians))) # as.data.frame introduces significant overhead\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                             min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                          &lt;bch:&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 as.data.frame(ls_medians(xm$x, xm$… 82.2µs  103µs     9633.     391KB     115.\n\n\nAnswer: with 5 columns, the list method is about twice as fast.\n\nxm &lt;- x_medians(10)\nmark(df_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 df_medians(xm$x, xm$medians)   43.2µs   63.3µs    15627.     391KB     185.\n\nmark(ls_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 ls_medians(xm$x, xm$medians)   8.28µs   22.1µs    44487.     391KB     504.\n\nxm &lt;- x_medians(20)\nmark(df_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 df_medians(xm$x, xm$medians)   83.3µs    104µs     9615.     400KB     117.\n\nmark(ls_medians(xm$x, xm$medians))\n\n#&gt; # A tibble: 1 × 6\n#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 ls_medians(xm$x, xm$medians)   9.35µs   19.9µs    50204.     392KB     584.\n\n\nWith 10 columns, the list method is 3 times as fast. With 20, the list method is 5 times as fast. So, the list method is near constant time regardless of columns, whereas the data.frame method scales linearly with the number of columns.\nAR Solutions:\nWhen working directly with the data frame, the execution time grows quadratically with the number of columns in the input data. This is because (e.g.) the first column must be copied n times, the second column n-1 times, and so on. When working with a list, the execution time increases only linearly.\nObviously in the long run, linear growth creates shorter run-times, but there is some cost to this strategy — we have to convert between data structures with as.list() and list2DF(). Even though this is fast and probably doesn’t hurt much, the improved approach doesn’t really pay off in this scenario until we get to a data frame that is about 300 columns wide (with the exact value depending on the characteristics of the system running the code).\n\n\nWhat happens if you attempt to use tracemem() on an environment?\n\n\ne &lt;- rlang::env()\ntry(tracemem(e))\n\n#&gt; Error in tracemem(e) : \n#&gt;   'tracemem' is not useful for promise and environment objects\n\n\nAnswer: it throws an error!\nAR Solutions: tracemem() cannot be used to mark and trace environments.\nThe error occurs because “it is not useful to trace NULL, environments, promises, weak references, or external pointer objects, as these are not duplicated” (see ?tracemem). Environments are always modified in place.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#vectors",
    "href": "analysis/advanced-r-1.html#vectors",
    "title": "Advanced R (Foundations)",
    "section": "3 Vectors",
    "text": "3 Vectors\nThis chapter discusses the most important family of data types in base R: vectors. While you’ve probably already used many (if not all) of the different types of vectors, you may not have thought deeply about how they’re interrelated. In this chapter, I won’t cover individual vectors types in too much detail, but I will show you how all the types fit together as a whole. If you need more details, you can find them in R’s documentation.\nVectors come in two flavours: atomic vectors and lists. They differ in terms of their elements’ types: for atomic vectors, all elements must have the same type; for lists, elements can have different types. While not a vector, NULL is closely related to vectors and often serves the role of a generic zero length vector. This diagram, which we’ll be expanding on throughout this chapter, illustrates the basic relationships:\nEvery vector can also have attributes, which you can think of as a named list of arbitrary metadata. Two attributes are particularly important. The dimension attribute turns vectors into matrices and arrays and the class attribute powers the S3 object system. While you’ll learn how to use S3 in Chapter 13, here you’ll learn about some of the most important S3 vectors: factors, date and times, data frames, and tibbles. And while 2D structures like matrices and data frames are not necessarily what come to mind when you think of vectors, you’ll also learn why R considers them to be vectors.\n\nrm(list = ls())\n\n\n3.2.5 Exercises\n\nHow do you create raw and complex scalars? (See ?raw and ?complex.)\n\nAnswer: using either raw(), complex(), or as.raw(), as.complex().\nAR Solutions: In R, scalars are represented as vectors of length one. However, there’s no built-in syntax like there is for logicals, integers, doubles, and character vectors to create individual raw and complex values. Instead, you have to create them by calling a function. For raw vectors you can use either as.raw() or charToRaw() to create them from numeric or character values.\nIn the case of complex numbers, real and imaginary parts may be provided directly to the complex() constructor. You can create purely imaginary numbers (e.g.) 1i, but there is no way to create complex numbers without + (e.g. 1i + 1).\n\n\nTest your knowledge of the vector coercion rules by predicting the output of the following uses of c():\n\n\nc(1, FALSE) # 1.0, 0.0 - double\n\n#&gt; [1] 1 0\n\nc(\"a\", 1) # \"a\", \"1\" - character\n\n#&gt; [1] \"a\" \"1\"\n\nc(TRUE, 1L) # 1L, 1L - integer\n\n#&gt; [1] 1 1\n\ntypeof(c(1, FALSE))\n\n#&gt; [1] \"double\"\n\ntypeof(c(\"a\", 1))\n\n#&gt; [1] \"character\"\n\ntypeof(c(TRUE, 1L))\n\n#&gt; [1] \"integer\"\n\n\nAnswer: guesses inline. [correct!]\nAR Solutions:\n\nc(1, FALSE) # will be coerced to double    -&gt; 1 0\nc(\"a\", 1) # will be coerced to character -&gt; \"a\" \"1\"\nc(TRUE, 1L) # will be coerced to integer   -&gt; 1 1\n\n\n\nWhy is 1 == \"1\" true? Why is -1 &lt; FALSE true? Why is \"one\" &lt; 2 false?\n\nAnswers:\n\n1 == \"1\": the 1 is coerced to “1”\n-1 &lt; FALSE: FALSE is coerced to 0\n`“one” &lt; 2: the 2 is coerced to “2”\n\nAR Solutions: These comparisons are carried out by operator-functions (==, &lt;), which coerce their arguments to a common type. In the examples above, these types will be character, double and character: 1 will be coerced to \"1\", FALSE is represented as 0 and 2 turns into \"2\" (and numbers precede letters in lexicographic order (may depend on locale)).\n\n\nWhy is the default missing value, NA, a logical vector? What’s special about logical vectors? (Hint: think about c(FALSE, NA_character_).)\n\nAnswer: NA must be logical so that it can exist in a logical vector.\nAR Solutions: The presence of missing values shouldn’t affect the type of an object. Recall that there is a type-hierarchy for coercion from character → double → integer → logical. When combining NAs with other atomic types, the NAs will be coerced to integer (NA_integer_), double (NA_real_) or character (NA_character_) and not the other way round. If NA were a character and added to a set of other values all of these would be coerced to character as well.\n\n\nPrecisely what do is.atomic(), is.numeric(), and is.vector() test for?\n\nAnswers:\n\nis.atomic(x): tests if x is an atomic vector (logical, integer, numeric, complex, character, and raw) - is FALSE for lists\nis.numeric(x): tests if x is an atomic numeric vector\nis.vector(x, mode = \"any\"): tests if x is an atomic vector OR a list or expression\n\nAR Solutions: The documentation states that:\n\nis.atomic() tests if an object is an atomic vector (as defined in Advanced R) or is NULL (!).\nis.numeric() tests if an object has type integer or double and is not of class factor, Date, POSIXt or difftime.\nis.vector() tests if an object is a vector (as defined in Advanced R) or an expression and has no attributes, apart from names.\n\nAtomic vectors are defined in Advanced R as objects of type logical, integer, double, complex, character or raw. Vectors are defined as atomic vectors or lists.\n\n\n\n3.3.4 Exercises\n\nHow is setNames() implemented? How is unname() implemented? Read the source code.\n\n\nsetNames\n\n#&gt; function (object = nm, nm) \n#&gt; {\n#&gt;     names(object) &lt;- nm\n#&gt;     object\n#&gt; }\n#&gt; &lt;bytecode: 0x1155fcb68&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nunname\n\n#&gt; function (obj, force = FALSE) \n#&gt; {\n#&gt;     if (!is.null(names(obj))) \n#&gt;         names(obj) &lt;- NULL\n#&gt;     if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n#&gt;         dimnames(obj) &lt;- NULL\n#&gt;     obj\n#&gt; }\n#&gt; &lt;bytecode: 0x112b3ad48&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\nAnswer: using names(), and dimnames() for unname().\nAR Solutions:\nBecause the data argument comes first, setNames() also works well with the magrittr-pipe operator. When no first argument is given, the result is a named vector (this is rather untypical as required arguments usually come first):\nunname() removes existing names (or dimnames) by setting them to NULL.\n\n\nWhat does dim() return when applied to a 1-dimensional vector? When might you use NROW() or NCOL()?\n\n\ndim(1:3)\n\n#&gt; NULL\n\nnrow(1:12)\n\n#&gt; NULL\n\nNROW(1:12)\n\n#&gt; [1] 12\n\nncol(1:12)\n\n#&gt; NULL\n\nNCOL(1:12)\n\n#&gt; [1] 1\n\n\nAnswers: NULL. NROW and NCOL are useful when comparing NULL dimensional vectors with matrices and arrays.\nAR Solutions: From ?nrow:\n\ndim() will return NULL when applied to a 1d vector.\n\nOne may want to use NROW() or NCOL() to handle atomic vectors, lists and NULL values in the same way as one column matrices or data frames.\n\n\nHow would you describe the following three objects? What makes them different from 1:5?\n\n\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))\n\nx1\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    1\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    2\n#&gt; \n#&gt; , , 3\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    3\n#&gt; \n#&gt; , , 4\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    4\n#&gt; \n#&gt; , , 5\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    5\n\nx2\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    2    3    4    5\n\nx3\n\n#&gt; , , 1\n#&gt; \n#&gt;      [,1]\n#&gt; [1,]    1\n#&gt; [2,]    2\n#&gt; [3,]    3\n#&gt; [4,]    4\n#&gt; [5,]    5\n\n\nAnswer: They have a 3-dimensional structure, arranged in different ways, along the z, x, and y axis.\nAR Solutions: These are all “one dimensional”. If you imagine a 3d cube, x1 is in the x-dimension, x2 is in the y-dimension, and x3 is in the z-dimension. In contrast to 1:5, x1, x2 and x3 have a dim attribute.\n\n\nAn early draft used this code to illustrate structure():\n\n\nstructure(1:5, comment = \"my attribute\")\n\n#&gt; [1] 1 2 3 4 5\n\n\nBut when you print that object you don't see the comment attribute.\nWhy? Is the attribute missing, or is there something else special about\nit? (Hint: try using help.)\n\nfactor(\"green\", levels = c(\"red\", \"amber\", \"green\"))\n\n#&gt; [1] green\n#&gt; Levels: red amber green\n\ndput(factor(\"green\", levels = c(\"red\", \"amber\", \"green\")))\n\n#&gt; structure(3L, levels = c(\"red\", \"amber\", \"green\"), class = \"factor\")\n\n\nAnswer: print doesn’t display the attributes for arbitrary structures, only defined classes, like factors (for example, above).\nAR Solutions: The documentation states (see ?comment):\n\nContrary to other attributes, the comment is not printed (by print or print.default).\n\nAlso, from ?attributes:\n\nNote that some attributes (namely class, comment, dim, dimnames, names, row.names and tsp) are treated specially and have restrictions on the values which can be set.\n\n\n\n\n3.4.5 Exercises\n\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\n\na &lt;- letters[1:3]\na_table &lt;- table(a, sample(a))\na_table\n\n#&gt;    \n#&gt; a   a b c\n#&gt;   a 0 1 0\n#&gt;   b 1 0 0\n#&gt;   c 0 0 1\n\ntypeof(a_table)\n\n#&gt; [1] \"integer\"\n\nattributes(a_table)\n\n#&gt; $dim\n#&gt; [1] 3 3\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames$a\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; $dimnames[[2]]\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; \n#&gt; $class\n#&gt; [1] \"table\"\n\nb &lt;- letters[1:4]\nb_table &lt;- table(b, sample(b))\nb_table\n\n#&gt;    \n#&gt; b   a b c d\n#&gt;   a 0 0 1 0\n#&gt;   b 0 0 0 1\n#&gt;   c 1 0 0 0\n#&gt;   d 0 1 0 0\n\nattributes(b_table)\n\n#&gt; $dim\n#&gt; [1] 4 4\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames$b\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n#&gt; \n#&gt; $dimnames[[2]]\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n#&gt; \n#&gt; \n#&gt; $class\n#&gt; [1] \"table\"\n\n\nAnswer: an object of class “table”, an array of integer values, with type “integer”. Attributes listed above, the dimensionality is always n by n, where n is the number of variables tabulated.\nAR Solutions: table() returns a contingency table of its input variables. It is implemented as an integer vector with class table and dimensions (which makes it act like an array). Its attributes are dim (dimensions) and dimnames (one name for each input column). The dimensions correspond to the number of unique values (factor levels) in each input variable.\n\n\nWhat happens to a factor when you modify its levels?\n\n\nf1 &lt;- factor(letters)\nf1\n\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nlevels(f1) &lt;- rev(levels(f1))\nf1\n\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n\nAnswer: the factor will remain the same, but the attributes will change. the factor and its levels are reversed.\nAR Solutions: The underlying integer values stay the same, but the levels are changed, making it look like the data has changed.\n\nf1 &lt;- factor(letters)\nf1\n\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nas.integer(f1)\n\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#&gt; [26] 26\n\nlevels(f1) &lt;- rev(levels(f1))\nf1\n\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n\n\n\nWhat does this code do? How do f2 and f3 differ from f1?\n\n\nf2 &lt;- rev(factor(letters))\nf2\n\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nf3 &lt;- factor(letters, levels = rev(letters))\nf3\n\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n\nAnswer: both create a reversed list of letters. f3 also has reversed levels but f2 does not. (correct!)\nAR Solutions: For f2 and f3 either the order of the factor elements or its levels are being reversed. For f1 both transformations are occurring.\n\n\n\n3.5.4 Exercises\n\nList all the ways that a list differs from an atomic vector.\n\nAnswers:\n\nEach element can be a different type\nEach element is a reference to an object\nList size can be smaller since elements are references\nLists can contain other lists\n\nAR Solutions: To summarise:\n\nAtomic vectors are always homogeneous (all elements must be of the same type). Lists may be heterogeneous (the elements can be of different types) as described in the introduction of the vectors chapter.\nAtomic vectors point to one address in memory, while lists contain a separate reference for each element. (This was described in the list sections of the vectors and the names and values chapters.)\nSubsetting with out-of-bounds and NA values leads to different output. For example, [ returns NA for atomics and NULL for lists. (This is described in more detail within the subsetting chapter.)\n\n\n\nWhy do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?\n\n\nis.vector(list(1:4))\n\n#&gt; [1] TRUE\n\ndput(as.vector(list(1:4)))\n\n#&gt; list(1:4)\n\n\nAnswer: a list is considered a vector by as.vector().\nAR Solutions: A list is already a vector, though not an atomic one!\n\n\nCompare and contrast c() and unlist() when combining a date and date-time into a single vector.\n\n\nd &lt;- list(date = as.Date(\"2022-06-25\"), datetime = as.POSIXct(\"2022-06-25 09:59:40 CDT\"))\ndput(d)\n\n#&gt; list(date = structure(19168, class = \"Date\"), datetime = structure(1656169180, class = c(\"POSIXct\", \n#&gt; \"POSIXt\"), tzone = \"\"))\n\ndput(c(d))\n\n#&gt; list(date = structure(19168, class = \"Date\"), datetime = structure(1656169180, class = c(\"POSIXct\", \n#&gt; \"POSIXt\"), tzone = \"\"))\n\ndput(unlist(d))\n\n#&gt; c(date = 19168, datetime = 1656169180)\n\n\nAnswer: c() preserves the list structure. unlist() converts both to double.\nAR Solutions: Date and date-time objects are both built upon doubles. While dates store the number of days since the reference date 1970-01-01 (also known as “the Epoch”) in days, date-time-objects (POSIXct) store the time difference to this date in seconds.\n\ndate &lt;- as.Date(\"1970-01-02\")\ndttm_ct &lt;- as.POSIXct(\"1970-01-01 01:00\", tz = \"UTC\")\n# Internal representations\nunclass(date)\n\n#&gt; [1] 1\n\nunclass(dttm_ct)\n\n#&gt; [1] 3600\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\n\n\nAs the c() generic only dispatches on its first argument, combining date and date-time objects via c() could lead to surprising results in older R versions (pre R 4.0.0):\n\n# Output in R version 3.6.2\nc(date, dttm_ct) # equal to c.Date(date, dttm_ct)\n#&gt; [1] \"1970-01-02\" \"1979-11-10\"\nc(dttm_ct, date) # equal to c.POSIXct(date, dttm_ct)\n#&gt; [1] \"1970-01-01 02:00:00 CET\" \"1970-01-01 01:00:01 CET\"\n\nIn the first statement above c.Date() is executed, which incorrectly treats the underlying double of dttm_ct (3600) as days instead of seconds. Conversely, when c.POSIXct() is called on a date, one day is counted as one second only.\nWe can highlight these mechanics by the following code:\n\n# Output in R version 3.6.2\nunclass(c(date, dttm_ct)) # internal representation\n#&gt; [1] 1 3600\ndate + 3599\n#&gt; \"1979-11-10\"\n\nAs of R 4.0.0 these issues have been resolved and both methods now convert their input first into POSIXct and Date, respectively.\n\nc(dttm_ct, date)\n\n#&gt; [1] \"1970-01-01 01:00:00 UTC\" \"1970-01-02 00:00:00 UTC\"\n\nunclass(c(dttm_ct, date))\n\n#&gt; [1]  3600 86400\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\n\nc(date, dttm_ct)\n\n#&gt; [1] \"1970-01-02\" \"1970-01-01\"\n\nunclass(c(date, dttm_ct))\n\n#&gt; [1] 1 0\n\n\nHowever, as c() strips the time zone (and other attributes) of POSIXct objects, some caution is still recommended.\n\n(dttm_ct &lt;- as.POSIXct(\"1970-01-01 01:00\", tz = \"HST\"))\n\n#&gt; [1] \"1970-01-01 01:00:00 HST\"\n\nattributes(c(dttm_ct))\n\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"HST\"\n\n\nA package that deals with these kinds of problems in more depth and provides a structural solution for them is the vctrs package which is also used throughout the tidyverse.\nLet’s look at unlist(), which operates on list input.\n\n# Attributes are stripped\nunlist(list(date, dttm_ct))\n\n#&gt; [1]     1 39600\n\n\nWe see again that dates and date-times are internally stored as doubles. Unfortunately, this is all we are left with, when unlist strips the attributes of the list.\nTo summarise: c() coerces types and strips time zones. Errors may have occurred in older R versions because of inappropriate method dispatch/immature methods. unlist() strips attributes.\n\n\n\n3.6.8 Exercises\n\nCan you have a data frame with zero rows? What about zero columns?\n\n\n# from data.frame() examples:\ndf &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9)\n\ndf\n\n#&gt;   x y z\n#&gt; 1 1 4 7\n#&gt; 2 2 5 8\n#&gt; 3 3 6 9\n\ndf[, FALSE]\n\n#&gt; data frame with 0 columns and 3 rows\n\ndf[FALSE, ]\n\n#&gt; [1] x y z\n#&gt; &lt;0 rows&gt; (or 0-length row.names)\n\ndf[FALSE, FALSE]\n\n#&gt; data frame with 0 columns and 0 rows\n\n\nAnswer: yes!\nAR Solutions: Yes, you can create these data frames easily; either during creation or via subsetting. Even both dimensions can be zero.\n\n\nWhat happens if you attempt to set rownames that are not unique?\n\n\nrownames(df)\n\n#&gt; [1] \"1\" \"2\" \"3\"\n\ntry(rownames(df) &lt;- c(\"a\", \"a\", \"b\"))\n\n#&gt; Warning: non-unique value when setting 'row.names': 'a'\n\n\n#&gt; Error in `.rowNamesDF&lt;-`(x, value = value) : \n#&gt;   duplicate 'row.names' are not allowed\n\n\nAnswer: error, duplicates not allowed.\nAR Solutions: Matrices can have duplicated row names, so this does not cause problems.\nData frames, however, require unique rownames and you get different results depending on how you attempt to set them. If you set them directly or via row.names(), you get an error. If you use subsetting, [ automatically deduplicates.\n\n\nIf df is a data frame, what can you say about t(df), and t(t(df))? Perform some experiments, making sure to try different column types.\n\n\nt(df)\n\n#&gt;   [,1] [,2] [,3]\n#&gt; x    1    2    3\n#&gt; y    4    5    6\n#&gt; z    7    8    9\n\nt(t(df))\n\n#&gt;      x y z\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\n#&gt; [3,] 3 6 9\n\ndf2 &lt;- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"), z = 4L:6L, stringsAsFactors = FALSE)\ndf2\n\n#&gt;   x y z\n#&gt; 1 1 a 4\n#&gt; 2 2 b 5\n#&gt; 3 3 c 6\n\nt(df2)\n\n#&gt;   [,1] [,2] [,3]\n#&gt; x \"1\"  \"2\"  \"3\" \n#&gt; y \"a\"  \"b\"  \"c\" \n#&gt; z \"4\"  \"5\"  \"6\"\n\nt(t(df2))\n\n#&gt;      x   y   z  \n#&gt; [1,] \"1\" \"a\" \"4\"\n#&gt; [2,] \"2\" \"b\" \"5\"\n#&gt; [3,] \"3\" \"c\" \"6\"\n\n\nAnswer: t() coerces the vector types, so t(t(df)) is the same as df only when all columns are the same type.\nAR Solutions: Both of t(df) and t(t(df)) will return matrices:\n\ndf &lt;- data.frame(x = 1:3, y = letters[1:3])\nis.matrix(df)\n\n#&gt; [1] FALSE\n\nis.matrix(t(df))\n\n#&gt; [1] TRUE\n\nis.matrix(t(t(df)))\n\n#&gt; [1] TRUE\n\n\nThe dimensions will respect the typical transposition rules:\n\ndim(df)\n\n#&gt; [1] 3 2\n\ndim(t(df))\n\n#&gt; [1] 2 3\n\ndim(t(t(df)))\n\n#&gt; [1] 3 2\n\n\nBecause the output is a matrix, every column is coerced to the same type. (It is implemented within t.data.frame() via as.matrix() which is described below).\n\ndf\n\n#&gt;   x y\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\nt(df)\n\n#&gt;   [,1] [,2] [,3]\n#&gt; x \"1\"  \"2\"  \"3\" \n#&gt; y \"a\"  \"b\"  \"c\"\n\n\n\n\nWhat does as.matrix() do when applied to a data frame with columns of different types? How does it differ from data.matrix()?\n\n\nas.matrix(df)\n\n#&gt;      x   y  \n#&gt; [1,] \"1\" \"a\"\n#&gt; [2,] \"2\" \"b\"\n#&gt; [3,] \"3\" \"c\"\n\nas.matrix(df2)\n\n#&gt;      x   y   z  \n#&gt; [1,] \"1\" \"a\" \"4\"\n#&gt; [2,] \"2\" \"b\" \"5\"\n#&gt; [3,] \"3\" \"c\" \"6\"\n\ndata.matrix(df2)\n\n#&gt;      x y z\n#&gt; [1,] 1 1 4\n#&gt; [2,] 2 2 5\n#&gt; [3,] 3 3 6\n\nas.data.frame(data.matrix(df2))\n\n#&gt;   x y z\n#&gt; 1 1 1 4\n#&gt; 2 2 2 5\n#&gt; 3 3 3 6\n\nas.data.frame(data.matrix(data.frame(x = 1:3, y = c(0, 0.5, 1), z = 4:6)))\n\n#&gt;   x   y z\n#&gt; 1 1 0.0 4\n#&gt; 2 2 0.5 5\n#&gt; 3 3 1.0 6\n\n\nAnswer: as.matrix() coerces all elements to the same type. data.matrix() coerces elements to either integer (when possible) or double (when not).\nAR Solutions: The type of the result of as.matrix depends on the types of the input columns (see ?as.matrix):\n\nThe method for data frames will return a character matrix if there is only atomic columns and any non-(numeric/logical/complex) column, applying as.vector to factors and format to other non-character columns. Otherwise the usual coercion hierarchy (logical &lt; integer &lt; double &lt; complex) will be used, e.g. all-logical data frames will be coerced to a logical matrix, mixed logical-integer will give an integer matrix, etc.\n\nOn the other hand, data.matrix will always return a numeric matrix (see ?data.matrix()).\n\nReturn the matrix obtained by converting all the variables in a data frame to numeric mode and then binding them together as the columns of a matrix. Factors and ordered factors are replaced by their internal codes. […] Character columns are first converted to factors and then to integers.\n\nWe can illustrate and compare the mechanics of these functions using a concrete example. as.matrix() makes it possible to retrieve most of the original information from the data frame but leaves us with characters. To retrieve all information from data.matrix()’s output, we would need a lookup table for each column.",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#subsetting",
    "href": "analysis/advanced-r-1.html#subsetting",
    "title": "Advanced R (Foundations)",
    "section": "4 Subsetting",
    "text": "4 Subsetting\nR’s subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:\n\nThere are six ways to subset atomic vectors.\nThere are three subsetting operators, [[, [, and $.\nSubsetting operators interact differently with different vector types (e.g., atomic vectors, lists, factors, matrices, and data frames).\nSubsetting can be combined with assignment.\n\nSubsetting is a natural complement to str(). While str() shows you all the pieces of any object (its structure), subsetting allows you to pull out the pieces that you’re interested in. For large, complex objects, I highly recommend using the interactive RStudio Viewer, which you can activate with View(my_object).\n\nrm(list = ls())\n\n\n4.2.6 Exercises\n\nFix each of the following common data frame subsetting errors:\n\n\n# mtcars[mtcars$cyl = 4, ]\nmtcars[mtcars$cyl == 4, ]\n\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# use `==`              (instead of `=`)\n\n# mtcars[-1:4, ]\nmtcars[-(1:4), ]\n\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n#&gt; AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n#&gt; Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n#&gt; Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#&gt; Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#&gt; Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#&gt; Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#&gt; Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# use `-(1:4)`          (instead of `-1:4`)\n\n# mtcars[mtcars$cyl &lt;= 5]\nmtcars[mtcars$cyl &lt;= 5, ]\n\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# `,` is missing\n\n# mtcars[mtcars$cyl == 4 | 6, ]\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]\n\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Valiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# use `mtcars$cyl == 6` (instead of `6`)\n#  or `%in% c(4, 6)`    (instead of `== 4 | 6`)\n\nAnswer: fixed!\nAR solutions: see the comments below the fixed code.\n\n\nWhy does the following code yield five missing values? (Hint: why is it different from x[NA_real_]?)\n\n\nx &lt;- 1:5\nx[NA]\n\n#&gt; [1] NA NA NA NA NA\n\nx[NA_real_]\n\n#&gt; [1] NA\n\nx[TRUE]\n\n#&gt; [1] 1 2 3 4 5\n\n\nAnswer: NA is a logical constant of length 1.\nAR Solutions: In contrast to NA_real, NA has logical type and logical vectors are recycled to the same length as the vector being subset, i.e. x[NA] is recycled to x[c(NA, NA, NA, NA, NA)].\n\n\nWhat does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?\n\n\nx &lt;- outer(1:5, 1:5, FUN = \"*\")\nx\n\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    2    3    4    5\n#&gt; [2,]    2    4    6    8   10\n#&gt; [3,]    3    6    9   12   15\n#&gt; [4,]    4    8   12   16   20\n#&gt; [5,]    5   10   15   20   25\n\nx[upper.tri(x)]\n\n#&gt;  [1]  2  3  6  4  8 12  5 10 15 20\n\n\nAnswer: upper.tri() returns a matrix of logicals, which can be used to subset the upper triangle. This is subsetting by matrix, which is new.\nAR Solutions: upper.tri(x) returns a logical matrix, which contains TRUE values above the diagonal and FALSE values everywhere else. In upper.tri() the positions for TRUE and FALSE values are determined by comparing x’s row and column indices via .row(dim(x)) &lt; .col(dim(x)).\nWhen subsetting with logical matrices, all elements that correspond to TRUE will be selected. Matrices extend vectors with a dimension attribute, so the vector forms of subsetting can be used (including logical subsetting). We should take care, that the dimensions of the subsetting matrix match the object of interest — otherwise unintended selections due to vector recycling may occur. Please also note, that this form of subsetting returns a vector instead of a matrix, as the subsetting alters the dimensions of the object.\n\n\nWhy does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?\n\n\ntry(mtcars[1:20])\n\n#&gt; Error in `[.data.frame`(mtcars, 1:20) : undefined columns selected\n\nmtcars[1:20, ]\n\n#&gt;                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n#&gt; Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n#&gt; Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n#&gt; Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n#&gt; Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n#&gt; Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n#&gt; Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n#&gt; Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n#&gt; Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n#&gt; Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n#&gt; Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n#&gt; Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n\n\nAnswer: mtcars[1:20] selects the first 20 columns, but there are only 11. mtcars[1:20, ] selects the first 20 rows of 32.\nAR Solutions: When subsetting a data frame with a single vector, it behaves the same way as subsetting a list of columns. So, mtcars[1:20] would return a data frame containing the first 20 columns of the dataset. However, as mtcars has only 11 columns, the index will be out of bounds and an error is thrown. mtcars[1:20, ] is subsetted with two vectors, so 2d subsetting kicks in, and the first index refers to rows.\n\n\nImplement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).\n\n\nm &lt;- matrix(ncol = 3, byrow = TRUE, c(\n  1, 4, 7,\n  2, 5, 8,\n  3, 6, 9\n))\nm\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    4    7\n#&gt; [2,]    2    5    8\n#&gt; [3,]    3    6    9\n\ndiag(m)\n\n#&gt; [1] 1 5 9\n\nmy_diag &lt;- function(x) {\n  diag_element &lt;- function(n, x) {\n    x[n, n]\n  }\n  vapply(seq_len(nrow(m)), diag_element, 1, x)\n}\nmy_diag(m)\n\n#&gt; [1] 1 5 9\n\n\nAnswer: code above.\nAR Solutions: The elements in the diagonal of a matrix have the same row- and column indices. This characteristic can be used to create a suitable numeric matrix used for subsetting.\n\ndiag2 &lt;- function(x) {\n  n &lt;- min(nrow(x), ncol(x))\n  idx &lt;- cbind(seq_len(n), seq_len(n))\n  x[idx]\n}\n# Let's check if it works\n(x &lt;- matrix(1:30, 5))\n\n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]\n#&gt; [1,]    1    6   11   16   21   26\n#&gt; [2,]    2    7   12   17   22   27\n#&gt; [3,]    3    8   13   18   23   28\n#&gt; [4,]    4    9   14   19   24   29\n#&gt; [5,]    5   10   15   20   25   30\n\ndiag(x)\n\n#&gt; [1]  1  7 13 19 25\n\ndiag2(x)\n\n#&gt; [1]  1  7 13 19 25\n\n\n\n\nWhat does df[is.na(df)] &lt;- 0 do? How does it work?\n\nAnswer: sets the NA values in df to 0, by first selecting NA values then assigning 0.\n\ndf &lt;- data.frame(x = c(1, 2, NA), y = c(4, NA, 6), z = c(NA, 8, 9))\ndf\n\n#&gt;    x  y  z\n#&gt; 1  1  4 NA\n#&gt; 2  2 NA  8\n#&gt; 3 NA  6  9\n\ndf[is.na(df)] &lt;- 0\ndf\n\n#&gt;   x y z\n#&gt; 1 1 4 0\n#&gt; 2 2 0 8\n#&gt; 3 0 6 9\n\n\nCorrect!\nAR Solutions: This expression replaces the NAs in df with 0. Here is.na(df) returns a logical matrix that encodes the position of the missing values in df. Subsetting and assignment are then combined to replace only the missing values.\n\n\n\n4.3.5 Exercises\n\nBrainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.\n\n\nmtcars$cyl[3]\n\n#&gt; [1] 4\n\nmtcars$cyl[[3]]\n\n#&gt; [1] 4\n\nmtcars[[\"cyl\"]][[3]]\n\n#&gt; [1] 4\n\nmtcars[3, 2]\n\n#&gt; [1] 4\n\nmtcars[[3, 2]]\n\n#&gt; [1] 4\n\nmtcars[[\"Datsun 710\", \"cyl\"]]\n\n#&gt; [1] 4\n\nmtcars[-c(1:2, 4:32), -c(1, 3:11)]\n\n#&gt; [1] 4\n\n\nAnswer: code above (some variations omitted). There are many more.\nAR Solutions: Base R already provides an abundance of possibilities:\n\n# Select column first\nmtcars$cyl[[3]]\n\n#&gt; [1] 4\n\nmtcars[, \"cyl\"][[3]]\n\n#&gt; [1] 4\n\nmtcars[[\"cyl\"]][[3]]\n\n#&gt; [1] 4\n\nwith(mtcars, cyl[[3]])\n\n#&gt; [1] 4\n\n# Select row first\nmtcars[3, ]$cyl\n\n#&gt; [1] 4\n\nmtcars[3, \"cyl\"]\n\n#&gt; [1] 4\n\nmtcars[3, ][, \"cyl\"]\n\n#&gt; [1] 4\n\nmtcars[3, ][[\"cyl\"]]\n\n#&gt; [1] 4\n\n# Select simultaneously\nmtcars[3, 2]\n\n#&gt; [1] 4\n\nmtcars[[c(2, 3)]]\n\n#&gt; [1] 4\n\n\n\n\nGiven a linear model, e.g., mod &lt;- lm(mpg ~ wt, data = mtcars), extract the residual degrees of freedom. Then extract the R squared from the model summary (summary(mod))\n\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\nmod$df.residual\n\n#&gt; [1] 30\n\nmod_sum &lt;- summary(mod)\nmod_sum$r.squared\n\n#&gt; [1] 0.7528328\n\nmod_sum\n\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ wt, data = mtcars)\n#&gt; \n#&gt; Residuals:\n#&gt;     Min      1Q  Median      3Q     Max \n#&gt; -4.5432 -2.3647 -0.1252  1.4096  6.8727 \n#&gt; \n#&gt; Coefficients:\n#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept)  37.2851     1.8776  19.858  &lt; 2e-16 ***\n#&gt; wt           -5.3445     0.5591  -9.559 1.29e-10 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 3.046 on 30 degrees of freedom\n#&gt; Multiple R-squared:  0.7528, Adjusted R-squared:  0.7446 \n#&gt; F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10\n\n\nAnswer: code above.\nAR Solutions: mod is of type list, which opens up several possibilities. We use $ or [[ to extract a single element:\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\n\nmod$df.residual\n\n#&gt; [1] 30\n\nmod[[\"df.residual\"]]\n\n#&gt; [1] 30\n\n\nThe same also applies to summary(mod), so we could use, e.g.:\n\nsummary(mod)$r.squared\n\n#&gt; [1] 0.7528328\n\n\n(Tip: The broom package provides a very useful approach to work with models in a tidy way.)\n\n\n\n4.5.9 Exercises\n\nHow would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?\n\n\ndf &lt;- data.frame(x = 1:5, y = 5:1, z = letters[1:5], row.names = 1:5)\n\ndf[, sample(ncol(df))]\n\n#&gt;   y z x\n#&gt; 1 5 a 1\n#&gt; 2 4 b 2\n#&gt; 3 3 c 3\n#&gt; 4 2 d 4\n#&gt; 5 1 e 5\n\ndf[sample(nrow(df)), sample(ncol(df))]\n\n#&gt;   y x z\n#&gt; 5 1 5 e\n#&gt; 1 5 1 a\n#&gt; 4 2 4 d\n#&gt; 3 3 3 c\n#&gt; 2 4 2 b\n\n\nAnswer: using sample(). Yes!\nAR Solutions: This can be achieved by combining [ and sample():\n\n# Permute columns\nmtcars[sample(ncol(mtcars))]\n\n# Permute columns and rows in one step\nmtcars[sample(nrow(mtcars)), sample(ncol(mtcars))]\n\n\n\nHow would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?\n\n\nsample_rows &lt;- function(df, m, contiguous = FALSE) {\n  if (m &gt; nrow(df)) {\n    stop(\"sample size '\", m, \"' is larger than the number of rows, '\", nrow(df), \"'\")\n  }\n  if (contiguous) {\n    first_row &lt;- sample(nrow(df) - m + 1, 1)\n    last_row &lt;- first_row + m - 1\n    return(df[first_row:last_row, ])\n  }\n  df[sample(nrow(df), m), ]\n}\n\nsample_rows(df, 3)\n\n#&gt;   x y z\n#&gt; 5 5 1 e\n#&gt; 2 2 4 b\n#&gt; 4 4 2 d\n\nsample_rows(df, 3, contiguous = TRUE)\n\n#&gt;   x y z\n#&gt; 1 1 5 a\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n\ntry(sample_rows(df, 6))\n\n#&gt; Error in sample_rows(df, 6) : \n#&gt;   sample size '6' is larger than the number of rows, '5'\n\n\nAnswer: code above.\nAR Solutions: Selecting m random rows from a data frame can be achieved through subsetting.\n\nm &lt;- 10\nmtcars[sample(nrow(mtcars), m), ]\n\nHolding successive lines together as a blocked sample requires only a certain amount of caution in order to obtain the correct start and end index.\n\nstart &lt;- sample(nrow(mtcars) - m + 1, 1)\nend &lt;- start + m - 1\nmtcars[start:end, , drop = FALSE]\n\n\n\nHow could you put the columns in a data frame in alphabetical order?\n\n\nmtcars[sort(colnames(mtcars))]\n\n#&gt;                     am carb cyl  disp drat gear  hp  mpg  qsec vs    wt\n#&gt; Mazda RX4            1    4   6 160.0 3.90    4 110 21.0 16.46  0 2.620\n#&gt; Mazda RX4 Wag        1    4   6 160.0 3.90    4 110 21.0 17.02  0 2.875\n#&gt; Datsun 710           1    1   4 108.0 3.85    4  93 22.8 18.61  1 2.320\n#&gt; Hornet 4 Drive       0    1   6 258.0 3.08    3 110 21.4 19.44  1 3.215\n#&gt; Hornet Sportabout    0    2   8 360.0 3.15    3 175 18.7 17.02  0 3.440\n#&gt; Valiant              0    1   6 225.0 2.76    3 105 18.1 20.22  1 3.460\n#&gt; Duster 360           0    4   8 360.0 3.21    3 245 14.3 15.84  0 3.570\n#&gt; Merc 240D            0    2   4 146.7 3.69    4  62 24.4 20.00  1 3.190\n#&gt; Merc 230             0    2   4 140.8 3.92    4  95 22.8 22.90  1 3.150\n#&gt; Merc 280             0    4   6 167.6 3.92    4 123 19.2 18.30  1 3.440\n#&gt; Merc 280C            0    4   6 167.6 3.92    4 123 17.8 18.90  1 3.440\n#&gt; Merc 450SE           0    3   8 275.8 3.07    3 180 16.4 17.40  0 4.070\n#&gt; Merc 450SL           0    3   8 275.8 3.07    3 180 17.3 17.60  0 3.730\n#&gt; Merc 450SLC          0    3   8 275.8 3.07    3 180 15.2 18.00  0 3.780\n#&gt; Cadillac Fleetwood   0    4   8 472.0 2.93    3 205 10.4 17.98  0 5.250\n#&gt; Lincoln Continental  0    4   8 460.0 3.00    3 215 10.4 17.82  0 5.424\n#&gt; Chrysler Imperial    0    4   8 440.0 3.23    3 230 14.7 17.42  0 5.345\n#&gt; Fiat 128             1    1   4  78.7 4.08    4  66 32.4 19.47  1 2.200\n#&gt; Honda Civic          1    2   4  75.7 4.93    4  52 30.4 18.52  1 1.615\n#&gt; Toyota Corolla       1    1   4  71.1 4.22    4  65 33.9 19.90  1 1.835\n#&gt; Toyota Corona        0    1   4 120.1 3.70    3  97 21.5 20.01  1 2.465\n#&gt; Dodge Challenger     0    2   8 318.0 2.76    3 150 15.5 16.87  0 3.520\n#&gt; AMC Javelin          0    2   8 304.0 3.15    3 150 15.2 17.30  0 3.435\n#&gt; Camaro Z28           0    4   8 350.0 3.73    3 245 13.3 15.41  0 3.840\n#&gt; Pontiac Firebird     0    2   8 400.0 3.08    3 175 19.2 17.05  0 3.845\n#&gt; Fiat X1-9            1    1   4  79.0 4.08    4  66 27.3 18.90  1 1.935\n#&gt; Porsche 914-2        1    2   4 120.3 4.43    5  91 26.0 16.70  0 2.140\n#&gt; Lotus Europa         1    2   4  95.1 3.77    5 113 30.4 16.90  1 1.513\n#&gt; Ford Pantera L       1    4   8 351.0 4.22    5 264 15.8 14.50  0 3.170\n#&gt; Ferrari Dino         1    6   6 145.0 3.62    5 175 19.7 15.50  0 2.770\n#&gt; Maserati Bora        1    8   8 301.0 3.54    5 335 15.0 14.60  0 3.570\n#&gt; Volvo 142E           1    2   4 121.0 4.11    4 109 21.4 18.60  1 2.780\n\n\nAnswer: using sort(colnames).\nAR Solutions: We combine [ with order() or sort():\n\nmtcars[order(names(mtcars))]\nmtcars[sort(names(mtcars))]",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#control-flow",
    "href": "analysis/advanced-r-1.html#control-flow",
    "title": "Advanced R (Foundations)",
    "section": "5 Control flow",
    "text": "5 Control flow\nThere are two primary tools of control flow: choices and loops. Choices, like if statements and switch() calls, allow you to run different code depending on the input. Loops, like for and while, allow you to repeatedly run code, typically with changing options. I’d expect that you’re already familiar with the basics of these functions so I’ll briefly cover some technical details and then introduce some useful, but lesser known, features.\nThe condition system (messages, warnings, and errors), which you’ll learn about in Chapter 8, also provides non-local control flow.\n\nrm(list = ls())\n\n\n5.2.4 Exercises\n\nWhat type of vector does each of the following calls to ifelse() return? Read the documentation and write down the rules in your own words.\n\n\nifelse(TRUE, 1, \"no\")\n\n#&gt; [1] 1\n\ntypeof(ifelse(TRUE, 1, \"no\")) # double\n\n#&gt; [1] \"double\"\n\nifelse(FALSE, 1, \"no\")\n\n#&gt; [1] \"no\"\n\ntypeof(ifelse(FALSE, 1, \"no\")) # character\n\n#&gt; [1] \"character\"\n\nifelse(NA, 1, \"no\")\n\n#&gt; [1] NA\n\ntypeof(ifelse(NA, 1, \"no\")) # logical\n\n#&gt; [1] \"logical\"\n\nifelse(NULL, 1, \"no\")\n\n#&gt; logical(0)\n\n\nAnswer:\n\nif test is true, return a vector of the same length as test (1) populated with “yes” - here 1 is a double, 1L would be integer\nif test is false, return a vector of the same length as test (1) populated with “no” - here “no” is a character\nif test is NA, return NA, and if test is NULL, return logical(0)\n\nAR Solutions: The arguments of ifelse() are named test, yes and no. In general, ifelse() returns the entry for yes when test is TRUE, the entry for no when test is FALSE and NA when test is NA. Therefore, the expressions above return vectors of type double (1), character (\"no\") and logical (NA).\nTo be a little more precise, we will cite the part of the documentation on the return value of ifelse():\n\nA vector of the same length and attributes (including dimensions and “class”) as test and data values from the values of yes or no. The mode of the answer will be coerced from logical to accommodate first any values taken from yes and then any values taken from no.\n\nThis is surprising because it uses the type of test. In practice this means, that test is first converted to logical and if the result is neither TRUE nor FALSE, simply as.logical(test) is returned.\n\n\nWhy does the following code work?\n\n\nx &lt;- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n\n#&gt; [1] \"not empty\"\n\nx &lt;- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n\n#&gt; [1] \"empty\"\n\n\nAnswer: in the first example, length(x) is nonzero, which evaluates to TRUE. In the second example, numeric() returns a vector of length 0 (the default), length(x) is zero, which evaluates to FALSE.\nAR Solutions: if() expects a logical condition, but also accepts a numeric vector where 0 is treated as FALSE and all other numbers are treated as TRUE. Numerical missing values (including NaN) lead to an error in the same way that a logical missing, NA, does.\n\n\n\n5.3.3 Exercises\n\nWhy does this code succeed without errors or warnings?\n\n\nx &lt;- numeric() # x is numeric(0)\nout &lt;- vector(\"list\", length(x)) # out is list(0)\nfor (i in 1:length(x)) { # nolint: seq_linter. i is 1, then 0.\n  out[i] &lt;- x[i]^2 # when i = 1 x[1] is NA, sets out[1] to NA. when i = 0 nothing happens\n}\nout\n\n#&gt; [[1]]\n#&gt; [1] NA\n\n\nAnswer: in addition to notes above, out[0] and x[0] return a zero-length vector.\nAR Solutions: This loop is a delicate issue, and we have to consider a few points to explain why it is evaluated without raising any errors or warnings.\nThe beginning of this code smell is the statement 1:length(x) which creates the index of the for loop. As x has length 0 1:length(x) counts down from 1 to 0. This issue is typically avoided via usage of seq_along(x) or similar helpers which would just generate integer(0) in this case.\nAs we use [&lt;- and [ for indexing 0-length vectors at their first and zeroth position, we need to be aware of their subsetting behaviour for out-of-bounds and zero indices.\nDuring the first iteration x[1] will generate an NA (out-of-bounds indexing for atomics). The resulting NA (from squaring) will be assigned to the empty length-1 list out[1] (out-of-bounds indexing for lists).\nIn the next iteration, x[0] will return numeric(0) (zero indexing for atomics). Again, squaring doesn’t change the value and numeric(0) is assigned to out[0] (zero indexing for lists). Assigning a 0-length vector to a 0-length subset works but doesn’t change the object.\nOverall, the code works, because each step includes valid R operations (even though the result may not be what the user intended).\n\n\nWhen the following code is evaluated, what can you say about the vector being iterated?\n\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n\n#&gt; [1] 1 2 3 2 4 6\n\n\nAnswer: x iterates from 1 to 3, and is not affected by changes to xs during the loop, while xs is updated.\nAR Solution: In this loop x takes on the values of the initial xs (1, 2 and 3), indicating that it is evaluated just once in the beginning of the loop, not after each iteration. (Otherwise, we would run into an infinite loop.)\n\n\nWhat does the following code tell you about when the index is updated?\n\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i)\n}\n\n#&gt; [1] 2\n#&gt; [1] 4\n#&gt; [1] 6\n\n\nAnswer: the index is updated at the beginning of each loop.\nAR Solutions: In a for loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn’t affect the following iterations. (Again, we would otherwise run into an infinite loop.)",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#functions",
    "href": "analysis/advanced-r-1.html#functions",
    "title": "Advanced R (Foundations)",
    "section": "6 Functions",
    "text": "6 Functions\nIf you’re reading this book, you’ve probably already created many R functions and know how to use them to reduce duplication in your code. In this chapter, you’ll learn how to turn that informal, working knowledge into more rigorous, theoretical understanding. And while you’ll see some interesting tricks and techniques along the way, keep in mind that what you’ll learn here will be important for understanding the more advanced topics discussed later in the book.\n\nrm(list = ls())\n\n\n6 Quiz\nAnswer the following questions to see if you can safely skip this chapter.\n\nWhat are the three components of a function? a: arguments, code, return value [body, arguments, environment]\nWhat does the following code return? a: 11 [correct!]\n\n\nx &lt;- 10\nf1 &lt;- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()\n\n#&gt; [1] 11\n\n\n\nHow would you usually write this code? a: 1 + 2 * 3 [correct! … 1 + (2 * 3)]\n\n\n`+`(1, `*`(2, 3))\n\n\nHow could you make this call easier to read? mean(c(1:10, NA), na.rm = TRUE) [correct!]\n\n\nmean(, TRUE, x = c(1:10, NA))\n\n\nDoes the following code throw an error when executed? Why or why not? a: no, due to lazy evaluation, the stop() is never run [correct! … second argument is never used]\n\n\nf2 &lt;- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))\n\n#&gt; [1] 100\n\n\n\nWhat is an infix function? How do you write it? What’s a replacement function? How do you write it? a: function(x) x. ??? [see 6.8.3 and 6.8.4]\nHow do you ensure that cleanup action occurs regardless of how a function exits? a: ??? [on.exit()]\n\n\n\n6.2.5 Exercises\n\nGiven a name, like \"mean\", match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R?\n\nAnswer: a function is an object and could have multiple names pointing to it.\nAR Solutions: In R there is no one-to-one mapping between functions and names. A name always points to a single object, but an object may have zero, one or many names.\n\n\nIt’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?\n\n\nfunction(x) 3()\n\n#&gt; function (x) \n#&gt; 3()\n\n(function(x) 3)()\n\n#&gt; [1] 3\n\n\nAnswer: The second is correct, as the first is the form of defining a function.\nAR Solutions: The second approach is correct.\nThe anonymous function function(x) 3 is surrounded by a pair of parentheses before it is called by (). These extra parentheses separate the function call from the anonymous function’s body. Without them a function with the invalid body 3() is returned, which throws an error when we call it.\n\n\nA good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?\n\nAnswer: in rdev::build_analysis_site(), analysis_menu_item() is properly written as a named function, where get_component() could be written as an anonymous function, with dir_check_copy() and dir_check_delete() potentially either.\nAR Solutions: The use of anonymous functions allows concise and elegant code in certain situations. However, they miss a descriptive name and when re-reading the code, it can take a while to figure out what they do. That’s why it’s helpful to give long and complex functions a descriptive name. It may be worthwhile to take a look at your own projects or other people’s code to reflect on this part of your coding style.\n\n\nWhat function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?\n\nAnswer: is.function() and is.primitive().\nAR Solutions: Use is.function() to test if an object is a function. Consider using is.primitive() to test specifically for primitive functions.\n\n\nThis code makes a list of all functions in the base package.\n\n\nobjs &lt;- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\n\n#&gt; Warning in ls(\"package:base\", all = TRUE): partial argument match of 'all' to\n#&gt; 'all.names'\n\nfuns &lt;- Filter(is.function, objs)\n\nUse it to answer the following questions:\n\nWhich base function has the most arguments?\nHow many base functions have no arguments? What’s special about those functions?\nHow could you adapt the code to find all primitive functions?\n\n\nfun_args &lt;- data.frame(\n  name = names(funs),\n  args = unname(vapply(funs, function(x) length(formals(x)), 1L))\n)\nhead(fun_args[order(fun_args$args, decreasing = TRUE), ], 10)\n\n#&gt;                   name args\n#&gt; 1078              scan   22\n#&gt; 1134            source   17\n#&gt; 575     format.default   16\n#&gt; 588            formatC   15\n#&gt; 770            library   13\n#&gt; 827   merge.data.frame   13\n#&gt; 926          prettyNum   13\n#&gt; 1245           system2   12\n#&gt; 1242            system   11\n#&gt; 199  all.equal.numeric   10\n\nfun_args[fun_args$args == 0, ]\n\n#&gt;                          name args\n#&gt; 1                           -    0\n#&gt; 4                           :    0\n#&gt; 5                          ::    0\n#&gt; 6                         :::    0\n#&gt; 7                           !    0\n#&gt; 10                         !=    0\n#&gt; 13                     ...elt    0\n#&gt; 14                  ...length    0\n#&gt; 15                   ...names    0\n#&gt; 20                         .C    0\n#&gt; 21               .cache_class    0\n#&gt; 22                      .Call    0\n#&gt; 23             .Call.graphics    0\n#&gt; 25                    .class2    0\n#&gt; 42                  .External    0\n#&gt; 43         .External.graphics    0\n#&gt; 44                 .External2    0\n#&gt; 45                 .First.sys    0\n#&gt; 48                   .Fortran    0\n#&gt; 56                  .Internal    0\n#&gt; 57       .isMethodsDispatchOn    0\n#&gt; 68         .NotYetImplemented    0\n#&gt; 70         .OptRequireMethods    0\n#&gt; 76                 .Primitive    0\n#&gt; 77                 .primTrace    0\n#&gt; 78               .primUntrace    0\n#&gt; 91          .standard_regexps    0\n#&gt; 92                    .subset    0\n#&gt; 93                   .subset2    0\n#&gt; 96        .tryResumeInterrupt    0\n#&gt; 98                          (    0\n#&gt; 99                          [    0\n#&gt; 117                        [[    0\n#&gt; 124                      [[&lt;-    0\n#&gt; 129                       [&lt;-    0\n#&gt; 137                         {    0\n#&gt; 138                         @    0\n#&gt; 139                       @&lt;-    0\n#&gt; 140                         *    0\n#&gt; 142                         /    0\n#&gt; 144                         &    0\n#&gt; 147                        &&    0\n#&gt; 148                       %*%    0\n#&gt; 149                       %/%    0\n#&gt; 150                        %%    0\n#&gt; 155                         ^    0\n#&gt; 156                         +    0\n#&gt; 159                         &lt;    0\n#&gt; 160                        &lt;-    0\n#&gt; 161                       &lt;&lt;-    0\n#&gt; 162                        &lt;=    0\n#&gt; 163                         =    0\n#&gt; 164                        ==    0\n#&gt; 165                         &gt;    0\n#&gt; 166                        &gt;=    0\n#&gt; 167                         |    0\n#&gt; 170                        ||    0\n#&gt; 171                         ~    0\n#&gt; 172                         $    0\n#&gt; 175                       $&lt;-    0\n#&gt; 179                       abs    0\n#&gt; 180                      acos    0\n#&gt; 181                     acosh    0\n#&gt; 188                       all    0\n#&gt; 205                       any    0\n#&gt; 211                     anyNA    0\n#&gt; 220                       Arg    0\n#&gt; 227                   as.call    0\n#&gt; 228              as.character    0\n#&gt; 239                as.complex    0\n#&gt; 273                 as.double    0\n#&gt; 276            as.environment    0\n#&gt; 283                as.integer    0\n#&gt; 295                as.logical    0\n#&gt; 305                as.numeric    0\n#&gt; 324                    as.raw    0\n#&gt; 334                      asin    0\n#&gt; 335                     asinh    0\n#&gt; 341                      atan    0\n#&gt; 343                     atanh    0\n#&gt; 346                      attr    0\n#&gt; 348                    attr&lt;-    0\n#&gt; 349                attributes    0\n#&gt; 350              attributes&lt;-    0\n#&gt; 355                   baseenv    0\n#&gt; 374                     break    0\n#&gt; 375                   browser    0\n#&gt; 384                         c    0\n#&gt; 393                      call    0\n#&gt; 400                   ceiling    0\n#&gt; 413                     class    0\n#&gt; 414                   class&lt;-    0\n#&gt; 420       closeAllConnections    0\n#&gt; 437                      Conj    0\n#&gt; 438              contributors    0\n#&gt; 439                       cos    0\n#&gt; 440                      cosh    0\n#&gt; 441                     cospi    0\n#&gt; 442                 crossprod    0\n#&gt; 443               Cstack_info    0\n#&gt; 444                    cummax    0\n#&gt; 445                    cummin    0\n#&gt; 446                   cumprod    0\n#&gt; 447                    cumsum    0\n#&gt; 456                      date    0\n#&gt; 460                   declare    0\n#&gt; 461  default.stringsAsFactors    0\n#&gt; 478                   digamma    0\n#&gt; 479                       dim    0\n#&gt; 481                     dim&lt;-    0\n#&gt; 482                  dimnames    0\n#&gt; 484                dimnames&lt;-    0\n#&gt; 513                  emptyenv    0\n#&gt; 514                enc2native    0\n#&gt; 515                  enc2utf8    0\n#&gt; 523             environment&lt;-    0\n#&gt; 530                      Exec    0\n#&gt; 532                       exp    0\n#&gt; 534                     expm1    0\n#&gt; 535                expression    0\n#&gt; 536            extSoftVersion    0\n#&gt; 563                     floor    0\n#&gt; 566                       for    0\n#&gt; 568              forceAndCall    0\n#&gt; 591                  function    0\n#&gt; 592                     gamma    0\n#&gt; 594                   gc.time    0\n#&gt; 600         getAllConnections    0\n#&gt; 608             geterrmessage    0\n#&gt; 611             getLoadedDLLs    0\n#&gt; 621               getRversion    0\n#&gt; 623      getTaskCallbackNames    0\n#&gt; 626                     getwd    0\n#&gt; 629                 globalenv    0\n#&gt; 642                 iconvlist    0\n#&gt; 647                        if    0\n#&gt; 649                        Im    0\n#&gt; 655               interactive    0\n#&gt; 660                 invisible    0\n#&gt; 663                  is.array    0\n#&gt; 664                 is.atomic    0\n#&gt; 665                   is.call    0\n#&gt; 666              is.character    0\n#&gt; 667                is.complex    0\n#&gt; 669                 is.double    0\n#&gt; 671            is.environment    0\n#&gt; 672             is.expression    0\n#&gt; 674                 is.finite    0\n#&gt; 676               is.function    0\n#&gt; 677               is.infinite    0\n#&gt; 679                is.integer    0\n#&gt; 680               is.language    0\n#&gt; 681                   is.list    0\n#&gt; 683                is.logical    0\n#&gt; 684                 is.matrix    0\n#&gt; 685                     is.na    0\n#&gt; 693                   is.name    0\n#&gt; 694                    is.nan    0\n#&gt; 696                   is.null    0\n#&gt; 697                is.numeric    0\n#&gt; 702                 is.object    0\n#&gt; 705               is.pairlist    0\n#&gt; 708                      is.R    0\n#&gt; 709                    is.raw    0\n#&gt; 710              is.recursive    0\n#&gt; 711                 is.single    0\n#&gt; 712                 is.symbol    0\n#&gt; 728                      isS4    0\n#&gt; 742                 l10n_info    0\n#&gt; 743                La_library    0\n#&gt; 744                La_version    0\n#&gt; 751           lazyLoadDBfetch    0\n#&gt; 754                    length    0\n#&gt; 756                  length&lt;-    0\n#&gt; 765                  levels&lt;-    0\n#&gt; 768                    lgamma    0\n#&gt; 769            libcurlVersion    0\n#&gt; 773                   licence    0\n#&gt; 774                   license    0\n#&gt; 775                      list    0\n#&gt; 781          loadedNamespaces    0\n#&gt; 782      loadingNamespaceInfo    0\n#&gt; 787                       log    0\n#&gt; 788                     log10    0\n#&gt; 789                     log1p    0\n#&gt; 790                      log2    0\n#&gt; 813                       max    0\n#&gt; 825            memory.profile    0\n#&gt; 831                       min    0\n#&gt; 832                   missing    0\n#&gt; 833                       Mod    0\n#&gt; 846                     names    0\n#&gt; 848                   names&lt;-    0\n#&gt; 855                     nargs    0\n#&gt; 861                      next    0\n#&gt; 870                  nullfile    0\n#&gt; 875                    nzchar    0\n#&gt; 877                  oldClass    0\n#&gt; 878                oldClass&lt;-    0\n#&gt; 880                   on.exit    0\n#&gt; 913               pcre_config    0\n#&gt; 922                pos.to.env    0\n#&gt; 965                 proc.time    0\n#&gt; 966                      prod    0\n#&gt; 989                     quote    0\n#&gt; 990             R_compiled_by    0\n#&gt; 993                 R.Version    0\n#&gt; 994                     range    0\n#&gt; 1009                       Re    0\n#&gt; 1028                      rep    0\n#&gt; 1037                   repeat    0\n#&gt; 1044               retracemem    0\n#&gt; 1045                   return    0\n#&gt; 1053                    round    0\n#&gt; 1079                   search    0\n#&gt; 1080              searchpaths    0\n#&gt; 1084                seq_along    0\n#&gt; 1085                  seq_len    0\n#&gt; 1088                  seq.int    0\n#&gt; 1104                     sign    0\n#&gt; 1106                   signif    0\n#&gt; 1112                      sin    0\n#&gt; 1114                     sinh    0\n#&gt; 1117                    sinpi    0\n#&gt; 1144                     sqrt    0\n#&gt; 1150          standardGeneric    0\n#&gt; 1152                   stderr    0\n#&gt; 1153                    stdin    0\n#&gt; 1154                   stdout    0\n#&gt; 1158           storage.mode&lt;-    0\n#&gt; 1174               substitute    0\n#&gt; 1179                      sum    0\n#&gt; 1209                   switch    0\n#&gt; 1211                sys.calls    0\n#&gt; 1213                 Sys.Date    0\n#&gt; 1215               sys.frames    0\n#&gt; 1219               Sys.getpid    0\n#&gt; 1221                 Sys.info    0\n#&gt; 1223           Sys.localeconv    0\n#&gt; 1224               sys.nframe    0\n#&gt; 1225              sys.on.exit    0\n#&gt; 1227              sys.parents    0\n#&gt; 1236               sys.status    0\n#&gt; 1237                 Sys.time    0\n#&gt; 1251                 Tailcall    0\n#&gt; 1252                      tan    0\n#&gt; 1253                     tanh    0\n#&gt; 1254                    tanpi    0\n#&gt; 1257               tcrossprod    0\n#&gt; 1269                 tracemem    0\n#&gt; 1274                 trigamma    0\n#&gt; 1276                    trunc    0\n#&gt; 1285           unCfillPOSIXlt    0\n#&gt; 1286                  unclass    0\n#&gt; 1310               untracemem    0\n#&gt; 1315                UseMethod    0\n#&gt; 1331                    while    0\n#&gt; 1348                    xtfrm    0\n\n# check if all functions with 0 arguments are primitive\nfun_args2 &lt;- data.frame(\n  name = names(funs),\n  args = unname(vapply(funs, function(x) length(formals(x)), 1L)),\n  prim = unname(vapply(funs, is.primitive, TRUE))\n)\nfun_args2[fun_args2$args == 0, ]\n\n#&gt;                          name args  prim\n#&gt; 1                           -    0  TRUE\n#&gt; 4                           :    0  TRUE\n#&gt; 5                          ::    0  TRUE\n#&gt; 6                         :::    0  TRUE\n#&gt; 7                           !    0  TRUE\n#&gt; 10                         !=    0  TRUE\n#&gt; 13                     ...elt    0  TRUE\n#&gt; 14                  ...length    0  TRUE\n#&gt; 15                   ...names    0  TRUE\n#&gt; 20                         .C    0  TRUE\n#&gt; 21               .cache_class    0  TRUE\n#&gt; 22                      .Call    0  TRUE\n#&gt; 23             .Call.graphics    0  TRUE\n#&gt; 25                    .class2    0  TRUE\n#&gt; 42                  .External    0  TRUE\n#&gt; 43         .External.graphics    0  TRUE\n#&gt; 44                 .External2    0  TRUE\n#&gt; 45                 .First.sys    0 FALSE\n#&gt; 48                   .Fortran    0  TRUE\n#&gt; 56                  .Internal    0  TRUE\n#&gt; 57       .isMethodsDispatchOn    0  TRUE\n#&gt; 68         .NotYetImplemented    0 FALSE\n#&gt; 70         .OptRequireMethods    0 FALSE\n#&gt; 76                 .Primitive    0  TRUE\n#&gt; 77                 .primTrace    0  TRUE\n#&gt; 78               .primUntrace    0  TRUE\n#&gt; 91          .standard_regexps    0 FALSE\n#&gt; 92                    .subset    0  TRUE\n#&gt; 93                   .subset2    0  TRUE\n#&gt; 96        .tryResumeInterrupt    0 FALSE\n#&gt; 98                          (    0  TRUE\n#&gt; 99                          [    0  TRUE\n#&gt; 117                        [[    0  TRUE\n#&gt; 124                      [[&lt;-    0  TRUE\n#&gt; 129                       [&lt;-    0  TRUE\n#&gt; 137                         {    0  TRUE\n#&gt; 138                         @    0  TRUE\n#&gt; 139                       @&lt;-    0  TRUE\n#&gt; 140                         *    0  TRUE\n#&gt; 142                         /    0  TRUE\n#&gt; 144                         &    0  TRUE\n#&gt; 147                        &&    0  TRUE\n#&gt; 148                       %*%    0  TRUE\n#&gt; 149                       %/%    0  TRUE\n#&gt; 150                        %%    0  TRUE\n#&gt; 155                         ^    0  TRUE\n#&gt; 156                         +    0  TRUE\n#&gt; 159                         &lt;    0  TRUE\n#&gt; 160                        &lt;-    0  TRUE\n#&gt; 161                       &lt;&lt;-    0  TRUE\n#&gt; 162                        &lt;=    0  TRUE\n#&gt; 163                         =    0  TRUE\n#&gt; 164                        ==    0  TRUE\n#&gt; 165                         &gt;    0  TRUE\n#&gt; 166                        &gt;=    0  TRUE\n#&gt; 167                         |    0  TRUE\n#&gt; 170                        ||    0  TRUE\n#&gt; 171                         ~    0  TRUE\n#&gt; 172                         $    0  TRUE\n#&gt; 175                       $&lt;-    0  TRUE\n#&gt; 179                       abs    0  TRUE\n#&gt; 180                      acos    0  TRUE\n#&gt; 181                     acosh    0  TRUE\n#&gt; 188                       all    0  TRUE\n#&gt; 205                       any    0  TRUE\n#&gt; 211                     anyNA    0  TRUE\n#&gt; 220                       Arg    0  TRUE\n#&gt; 227                   as.call    0  TRUE\n#&gt; 228              as.character    0  TRUE\n#&gt; 239                as.complex    0  TRUE\n#&gt; 273                 as.double    0  TRUE\n#&gt; 276            as.environment    0  TRUE\n#&gt; 283                as.integer    0  TRUE\n#&gt; 295                as.logical    0  TRUE\n#&gt; 305                as.numeric    0  TRUE\n#&gt; 324                    as.raw    0  TRUE\n#&gt; 334                      asin    0  TRUE\n#&gt; 335                     asinh    0  TRUE\n#&gt; 341                      atan    0  TRUE\n#&gt; 343                     atanh    0  TRUE\n#&gt; 346                      attr    0  TRUE\n#&gt; 348                    attr&lt;-    0  TRUE\n#&gt; 349                attributes    0  TRUE\n#&gt; 350              attributes&lt;-    0  TRUE\n#&gt; 355                   baseenv    0  TRUE\n#&gt; 374                     break    0  TRUE\n#&gt; 375                   browser    0  TRUE\n#&gt; 384                         c    0  TRUE\n#&gt; 393                      call    0  TRUE\n#&gt; 400                   ceiling    0  TRUE\n#&gt; 413                     class    0  TRUE\n#&gt; 414                   class&lt;-    0  TRUE\n#&gt; 420       closeAllConnections    0 FALSE\n#&gt; 437                      Conj    0  TRUE\n#&gt; 438              contributors    0 FALSE\n#&gt; 439                       cos    0  TRUE\n#&gt; 440                      cosh    0  TRUE\n#&gt; 441                     cospi    0  TRUE\n#&gt; 442                 crossprod    0  TRUE\n#&gt; 443               Cstack_info    0 FALSE\n#&gt; 444                    cummax    0  TRUE\n#&gt; 445                    cummin    0  TRUE\n#&gt; 446                   cumprod    0  TRUE\n#&gt; 447                    cumsum    0  TRUE\n#&gt; 456                      date    0 FALSE\n#&gt; 460                   declare    0  TRUE\n#&gt; 461  default.stringsAsFactors    0 FALSE\n#&gt; 478                   digamma    0  TRUE\n#&gt; 479                       dim    0  TRUE\n#&gt; 481                     dim&lt;-    0  TRUE\n#&gt; 482                  dimnames    0  TRUE\n#&gt; 484                dimnames&lt;-    0  TRUE\n#&gt; 513                  emptyenv    0  TRUE\n#&gt; 514                enc2native    0  TRUE\n#&gt; 515                  enc2utf8    0  TRUE\n#&gt; 523             environment&lt;-    0  TRUE\n#&gt; 530                      Exec    0  TRUE\n#&gt; 532                       exp    0  TRUE\n#&gt; 534                     expm1    0  TRUE\n#&gt; 535                expression    0  TRUE\n#&gt; 536            extSoftVersion    0 FALSE\n#&gt; 563                     floor    0  TRUE\n#&gt; 566                       for    0  TRUE\n#&gt; 568              forceAndCall    0  TRUE\n#&gt; 591                  function    0  TRUE\n#&gt; 592                     gamma    0  TRUE\n#&gt; 594                   gc.time    0  TRUE\n#&gt; 600         getAllConnections    0 FALSE\n#&gt; 608             geterrmessage    0 FALSE\n#&gt; 611             getLoadedDLLs    0 FALSE\n#&gt; 621               getRversion    0 FALSE\n#&gt; 623      getTaskCallbackNames    0 FALSE\n#&gt; 626                     getwd    0 FALSE\n#&gt; 629                 globalenv    0  TRUE\n#&gt; 642                 iconvlist    0 FALSE\n#&gt; 647                        if    0  TRUE\n#&gt; 649                        Im    0  TRUE\n#&gt; 655               interactive    0  TRUE\n#&gt; 660                 invisible    0  TRUE\n#&gt; 663                  is.array    0  TRUE\n#&gt; 664                 is.atomic    0  TRUE\n#&gt; 665                   is.call    0  TRUE\n#&gt; 666              is.character    0  TRUE\n#&gt; 667                is.complex    0  TRUE\n#&gt; 669                 is.double    0  TRUE\n#&gt; 671            is.environment    0  TRUE\n#&gt; 672             is.expression    0  TRUE\n#&gt; 674                 is.finite    0  TRUE\n#&gt; 676               is.function    0  TRUE\n#&gt; 677               is.infinite    0  TRUE\n#&gt; 679                is.integer    0  TRUE\n#&gt; 680               is.language    0  TRUE\n#&gt; 681                   is.list    0  TRUE\n#&gt; 683                is.logical    0  TRUE\n#&gt; 684                 is.matrix    0  TRUE\n#&gt; 685                     is.na    0  TRUE\n#&gt; 693                   is.name    0  TRUE\n#&gt; 694                    is.nan    0  TRUE\n#&gt; 696                   is.null    0  TRUE\n#&gt; 697                is.numeric    0  TRUE\n#&gt; 702                 is.object    0  TRUE\n#&gt; 705               is.pairlist    0  TRUE\n#&gt; 708                      is.R    0 FALSE\n#&gt; 709                    is.raw    0  TRUE\n#&gt; 710              is.recursive    0  TRUE\n#&gt; 711                 is.single    0  TRUE\n#&gt; 712                 is.symbol    0  TRUE\n#&gt; 728                      isS4    0  TRUE\n#&gt; 742                 l10n_info    0 FALSE\n#&gt; 743                La_library    0 FALSE\n#&gt; 744                La_version    0 FALSE\n#&gt; 751           lazyLoadDBfetch    0  TRUE\n#&gt; 754                    length    0  TRUE\n#&gt; 756                  length&lt;-    0  TRUE\n#&gt; 765                  levels&lt;-    0  TRUE\n#&gt; 768                    lgamma    0  TRUE\n#&gt; 769            libcurlVersion    0 FALSE\n#&gt; 773                   licence    0 FALSE\n#&gt; 774                   license    0 FALSE\n#&gt; 775                      list    0  TRUE\n#&gt; 781          loadedNamespaces    0 FALSE\n#&gt; 782      loadingNamespaceInfo    0 FALSE\n#&gt; 787                       log    0  TRUE\n#&gt; 788                     log10    0  TRUE\n#&gt; 789                     log1p    0  TRUE\n#&gt; 790                      log2    0  TRUE\n#&gt; 813                       max    0  TRUE\n#&gt; 825            memory.profile    0 FALSE\n#&gt; 831                       min    0  TRUE\n#&gt; 832                   missing    0  TRUE\n#&gt; 833                       Mod    0  TRUE\n#&gt; 846                     names    0  TRUE\n#&gt; 848                   names&lt;-    0  TRUE\n#&gt; 855                     nargs    0  TRUE\n#&gt; 861                      next    0  TRUE\n#&gt; 870                  nullfile    0 FALSE\n#&gt; 875                    nzchar    0  TRUE\n#&gt; 877                  oldClass    0  TRUE\n#&gt; 878                oldClass&lt;-    0  TRUE\n#&gt; 880                   on.exit    0  TRUE\n#&gt; 913               pcre_config    0 FALSE\n#&gt; 922                pos.to.env    0  TRUE\n#&gt; 965                 proc.time    0  TRUE\n#&gt; 966                      prod    0  TRUE\n#&gt; 989                     quote    0  TRUE\n#&gt; 990             R_compiled_by    0 FALSE\n#&gt; 993                 R.Version    0 FALSE\n#&gt; 994                     range    0  TRUE\n#&gt; 1009                       Re    0  TRUE\n#&gt; 1028                      rep    0  TRUE\n#&gt; 1037                   repeat    0  TRUE\n#&gt; 1044               retracemem    0  TRUE\n#&gt; 1045                   return    0  TRUE\n#&gt; 1053                    round    0  TRUE\n#&gt; 1079                   search    0 FALSE\n#&gt; 1080              searchpaths    0 FALSE\n#&gt; 1084                seq_along    0  TRUE\n#&gt; 1085                  seq_len    0  TRUE\n#&gt; 1088                  seq.int    0  TRUE\n#&gt; 1104                     sign    0  TRUE\n#&gt; 1106                   signif    0  TRUE\n#&gt; 1112                      sin    0  TRUE\n#&gt; 1114                     sinh    0  TRUE\n#&gt; 1117                    sinpi    0  TRUE\n#&gt; 1144                     sqrt    0  TRUE\n#&gt; 1150          standardGeneric    0  TRUE\n#&gt; 1152                   stderr    0 FALSE\n#&gt; 1153                    stdin    0 FALSE\n#&gt; 1154                   stdout    0 FALSE\n#&gt; 1158           storage.mode&lt;-    0  TRUE\n#&gt; 1174               substitute    0  TRUE\n#&gt; 1179                      sum    0  TRUE\n#&gt; 1209                   switch    0  TRUE\n#&gt; 1211                sys.calls    0 FALSE\n#&gt; 1213                 Sys.Date    0 FALSE\n#&gt; 1215               sys.frames    0 FALSE\n#&gt; 1219               Sys.getpid    0 FALSE\n#&gt; 1221                 Sys.info    0 FALSE\n#&gt; 1223           Sys.localeconv    0 FALSE\n#&gt; 1224               sys.nframe    0 FALSE\n#&gt; 1225              sys.on.exit    0 FALSE\n#&gt; 1227              sys.parents    0 FALSE\n#&gt; 1236               sys.status    0 FALSE\n#&gt; 1237                 Sys.time    0 FALSE\n#&gt; 1251                 Tailcall    0  TRUE\n#&gt; 1252                      tan    0  TRUE\n#&gt; 1253                     tanh    0  TRUE\n#&gt; 1254                    tanpi    0  TRUE\n#&gt; 1257               tcrossprod    0  TRUE\n#&gt; 1269                 tracemem    0  TRUE\n#&gt; 1274                 trigamma    0  TRUE\n#&gt; 1276                    trunc    0  TRUE\n#&gt; 1285           unCfillPOSIXlt    0  TRUE\n#&gt; 1286                  unclass    0  TRUE\n#&gt; 1310               untracemem    0  TRUE\n#&gt; 1315                UseMethod    0  TRUE\n#&gt; 1331                    while    0  TRUE\n#&gt; 1348                    xtfrm    0  TRUE\n\n\nAnswers:\n\nscan() has the most arguments, 22\nmost (but not all) are primitive functions (204 of 254)\nthe ls() in the original code could be expanded to search all packages\n\nAR Solutions: Let’s look at each sub-question separately:\n\nTo find the function with the most arguments, we first compute the length of formals().\n\n\nlibrary(purrr)\n\nn_args &lt;- funs %&gt;%\n  map(formals) %&gt;%\n  map_int(length)\n\nThen we sort n_args in decreasing order and look at its first entries.\n\nn_args %&gt;%\n  sort(decreasing = TRUE) %&gt;%\n  head()\n#&gt; scan format.default source\n#&gt; 22 16 16\n#&gt; formatC library merge.data.frame\n#&gt; 15 13 13\n\n\nWe can further use n_args to find the number of functions with no arguments:\n\n\nsum(n_args == 0)\n\n#&gt; [1] 258\n\n\nHowever, this over counts because formals() returns NULL for primitive functions, and length(NULL) is 0. To fix this, we can first remove the primitive functions:\n\nn_args2 &lt;- funs %&gt;%\n  discard(is.primitive) %&gt;%\n  map(formals) %&gt;%\n  map_int(length)\n\nsum(n_args2 == 0)\n\n#&gt; [1] 48\n\n\nIndeed, most of the functions with no arguments are actually primitive functions.\n\nTo find all primitive functions, we can change the predicate in Filter() from is.function() to is.primitive():\n\n\nfuns &lt;- Filter(is.primitive, objs)\nlength(funs)\n\n#&gt; [1] 210\n\n\n\n\nWhat are the three important components of a function?\n\nAnswer: the formals(), body() and environment().\nAR Solutions: These components are the function’s body(), formals() and environment(). However, as mentioned in Advanced R:\n\nThere is one exception to the rule that functions have three components. Primitive functions, like sum(), call C code directly with .Primitive() and contain no R code. Therefore, their formals(), body(), and environment() are all NULL.\n\n\n\nWhen does printing a function not show the environment it was created in?\n\nAnswer: when it is created in the global environment.\nAR Solutions: Primitive functions and functions created in the global environment do not print their environment.\n\n\n\n6.4.5 Exercises\n\nWhat does the following code return? Why? Describe how each of the three c’s is interpreted.\n\n\nc &lt;- 10\nc(c = c)\n\n#&gt;  c \n#&gt; 10\n\n\nAnswer: a named vector, c 10. The first and final c is a variable. The second c is a function name. the third c is a name.\nAR Solutions: This code returns a named numeric vector of length one — with one element of the value 10 and the name \"c\". The first c represents the c() function, the second c is interpreted as a (quoted) name and the third c as a value.\n\n\nWhat are the four principles that govern how R looks for values?\n\nAnswer: name masking, functions versus variables, a fresh start, dynamic lookup.\nAR Solutions: R’s lexical scoping rules are based on these four principles: - Name masking - Functions vs. variables - A fresh start - Dynamic lookup\n\n\nWhat does the following function return? Make a prediction before running the code yourself.\n\n\nf &lt;- function(x) {\n  f &lt;- function(x) { # return value of this is 101\n    f &lt;- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n\n#&gt; [1] 202\n\n\nAnswer: 202. Correct!\nAR Solutions: Within this nested function two more functions also named f are defined and called. Because the functions are each executed in their own environment R will look up and use the functions defined last in these environments. The innermost f() is called last, though it is the first function to return a value. Therefore, the order of the calculation passes “from the inside to the outside” and the function returns ((10 ^ 2) + 1) * 2, i.e. 202.\n\n\n\n6.5.4 Exercises\n\nWhat important property of && makes x_ok() work?\n\n\nx_ok &lt;- function(x) {\n  !is.null(x) && length(x) == 1 && x &gt; 0\n}\n\nx_ok(NULL)\n\n#&gt; [1] FALSE\n\nx_ok(1)\n\n#&gt; [1] TRUE\n\nx_ok(1:3)\n\n#&gt; [1] FALSE\n\n\nAnswer: From the && docs, “The longer forms evaluates left to right, proceeding only until the result is determined.”\nWhat is different with this code? Why is this behaviour undesirable here?\n\nx_ok &lt;- function(x) {\n  !is.null(x) & length(x) == 1 & x &gt; 0\n}\n\nx_ok(NULL)\n\n#&gt; logical(0)\n\nx_ok(1)\n\n#&gt; [1] TRUE\n\nx_ok(1:3)\n\n#&gt; [1] FALSE FALSE FALSE\n\n\nAnswer: “The shorter forms performs elementwise comparisons in much the same way as arithmetic operators.” This is undesirable because the intent of the function is to return TRUE or FALSE.\nAR Solutions: In summary: && short-circuits which means that if the left-hand side is FALSE it doesn’t evaluate the right-hand side (because it doesn’t matter). Similarly, if the left-hand side of || is TRUE it doesn’t evaluate the right-hand side.\nWe expect x_ok() to validate its input via certain criteria: it must not be NULL, have length 1 and be greater than 0. Meaningful outcomes for this assertion will be TRUE, FALSE or NA. The desired behaviour is reached by combining the assertions through && instead of &.\n&& does not perform elementwise comparisons; instead it uses the first element of each value only. It also uses lazy evaluation, in the sense that evaluation “proceeds only until the result is determined” (from ?Logic). This means that the RHS of && won’t be evaluated if the LHS already determines the outcome of the comparison (e.g. evaluate to FALSE). This behaviour is also known as “short-circuiting”. For some situations (x = 1) both operators will lead to the same result. But this is not always the case. For x = NULL, the &&-operator will stop after the !is.null statement and return the result. The following conditions won’t even be evaluated! (If the other conditions are also evaluated (by the use of &), the outcome would change. NULL &gt; 0 returns logical(0), which is not helpful in this case.)\nWe can also see the difference in behaviour, when we set x = 1:3. The &&-operator returns the result from length(x) == 1, which is FALSE. Using & as the logical operator leads to the (vectorised) x &gt; 0 condition being evaluated and also returned.\n\n\nWhat does this function return? Why? Which principle does it illustrate?\n\n\nf2 &lt;- function(x = z) {\n  z &lt;- 100\n  x\n}\nf2()\n\n#&gt; [1] 100\n\n\nAnswer: 100, lazy evaluation. x = z isn’t evaluated until x.\nAR Solutions: The function returns 100. The default argument (x = z) gets lazily evaluated within the function environment when x gets accessed. At this time z has already been bound to the value 100. The illustrated principle here is lazy evaluation.\n\n\nWhat does this function return? Why? Which principle does it illustrate?\n\n\ny &lt;- 10\n# styler: off\nf1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { # nolint: semicolon_linter.\n  # styler: on\n  c(x, y)\n}\nf1()\n\n#&gt; [1] 2 1\n\ny\n\n#&gt; [1] 10\n\n\nAnswer: c(2, 1). default arguments.\nAR Solutions: The function returns c(2, 1) which is due to name masking. When x is accessed within c(), the promise x = {y &lt;- 1; 2} is evaluated inside f1()’s environment. y gets bound to the value 1 and the return value of {() (2) gets assigned to x. When y gets accessed next within c(), it has already the value 1 and R doesn’t need to look it up any further. Therefore, the promise y = 0 won’t be evaluated. Also, as y is assigned within f1()’s environment, the value of the global variable y is left untouched.\n\n\nIn hist(), the default value of xlim is range(breaks), the default value for breaks is \"Sturges\", and\n\n\nrange(\"Sturges\")\n\n#&gt; [1] \"Sturges\" \"Sturges\"\n\n\nExplain how hist() works to get a correct xlim value.\nAnswer: from the docs, “Note that xlim is not used to define the histogram (breaks), but only for plotting (when plot = TRUE).” So, the breakpoints are calculated when the object is created, and xlim is calculated when the histogram is plotted, in the second step.\nAR Solutions: The xlim argument of hist() defines the range of the histogram’s x-axis. In order to provide a valid axis xlim must contain a numeric vector of exactly two unique values. Consequently, for the default xlim = range(breaks)), breaks must evaluate to a vector with at least two unique values.\nDuring execution hist() overwrites the breaks argument. The breaks argument is quite flexible and allows the users to provide the breakpoints directly or compute them in several ways. Therefore, the specific behaviour depends highly on the input. But hist ensures that breaks evaluates to a numeric vector containing at least two unique elements before xlim is computed.\n\n\nExplain why this function works. Why is it confusing?\n\n\nshow_time &lt;- function(x = stop(\"Error!\")) {\n  stop &lt;- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n\n#&gt; [1] \"2025-10-01 21:51:26 CDT\"\n\n\nAnswer: stop is redefined before x is evaluated. This is a confusing use of lazy evaluation.\nAR Solutions: Before show_time() accesses x (default stop(\"Error\")), the stop() function is masked by function(...) Sys.time(). As default arguments are evaluated in the function environment, print(x) will be evaluated as print(Sys.time()).\nThis function is confusing because its behaviour changes when x’s value is supplied directly. Now the value from the calling environment will be used and the overwriting of stop() won’t affect x anymore.\n\n\nHow many arguments are required when calling library()?\n\nAnswer: zero. library() uses missing() to return the list of available packages if there are no arguments.\nAR Solutions: library() doesn’t require any arguments. When called without arguments library() invisibly returns a list of class libraryIQR, which contains a results matrix with one row and three columns per installed package. These columns contain entries for the name of the package (“Package”), the path to the package (“LibPath”) and the title of the package (“Title”). library() also has its own print method (print.libraryIQR()), which displays this information conveniently in its own window.\nThis behaviour is also documented under the details section of library()’s help page (?library):\n\nIf library is called with no package or help argument, it lists all available packages in the libraries specified by lib.loc, and returns the corresponding information in an object of class “libraryIQR”. (The structure of this class may change in future versions.) Use .packages(all = TRUE) to obtain just the names of all available packages, and installed.packages() for even more information.\n\nBecause the package and help argument from library() do not show a default value, it’s easy to overlook the possibility to call library() without these arguments. (Instead of providing NULLs as default values library() uses missing() to check if these arguments were provided.)\n\n\n\n6.6.1 Exercises\n\nExplain the following results:\n\n\nsum(1, 2, 3)\n\n#&gt; [1] 6\n\nmean(1, 2, 3)\n\n#&gt; [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n\n#&gt; [1] 7\n\nmean(1, 2, 3, na.omit = TRUE)\n\n#&gt; [1] 1\n\n\nAnswer:\n\n“sum() returns the sum of all the values present in its arguments.” The first example is straightforward. In the second sum example, na.omit isn’t a valid argument (na.rm is), so the TRUE value is passed to ..., coerced to 1, and included in the sum.\nmean() takes a single parameter, and passes on remaining arguments to .... In both cases, the arguments after the 1 are silently dropped. The correct form would be mean(c(1, 2, 3)).\n\nAR Solutions: Let’s inspect the arguments and their order for both functions. For sum() these are ... and na.rm:\n\nstr(sum)\n\n#&gt; function (..., na.rm = FALSE)\n\n\nFor the ... argument sum() expects numeric, complex, or logical vector input (see ?sum). Unfortunately, when ... is used, misspelled arguments (!) like na.omit won’t raise an error (in case of no further input checks). So instead, na.omit is treated as a logical and becomes part of the ... argument. It will be coerced to 1 and be part of the sum. All other arguments are left unchanged. Therefore sum(1, 2, 3) returns 6 and sum(1, 2, 3, na.omit = TRUE) returns 7.\nIn contrast, the generic function mean() expects x, trim, na.rm and ... for its default method.\n\nstr(mean.default)\n\n#&gt; function (x, trim = 0, na.rm = FALSE, ...)\n\n\nAs na.omit is not one of mean()’s named arguments (x; and no candidate for partial matching), na.omit again becomes part of the ... argument. However, in contrast to sum() the elements of ... are not “part” of the mean. The other supplied arguments are matched by their order, i.e. x = 1, trim = 2 and na.rm = 3. As x is of length 1 and not NA, the settings of trim and na.rm do not affect the calculation of the mean. Both calls (mean(1, 2, 3) and mean(1, 2, 3, na.omit = TRUE)) return 1.\n\n\nExplain how to find the documentation for the named arguments in the following function call:\n\n\n\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\n\n\n\n\n\n\n\n\nAnswer: in other functions, specifically par() and plot.default().\nAR Solutions: First we type ?plot in the console and check the “Usage” section which contains:\nplot(x, y, ...)\nThe arguments we want to learn more about (col, pch, xlab, col.lab) are part of the ... argument. There we can find information for the xlab argument and a recommendation to visit ?par for the other arguments. Under ?par we type “col” into the search bar, which leads us to the section “Color Specification”. We also search for the pch argument, which leads to the recommendation to check ?points. Finally, col.lab is also directly documented within ?par.\n\n\nWhy does plot(1:10, col = \"red\") only colour the points, not the axes or labels? Read the source code of plot.default() to find out.\n\nlocalAxis &lt;- function(..., col, bg, pch, cex, lty, lwd) Axis(...)\nlocalBox &lt;- function(..., col, bg, pch, cex, lty, lwd) box(...)\nlocalWindow &lt;- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)\nlocalTitle &lt;- function(..., col, bg, pch, cex, lty, lwd) title(...)\nAnswer: plot.default() discards col and several other arguments when calling Axis(), box(), plot.window(), and title().\nAR Solutions: To learn about the internals of plot.default() we add browser() to the first line of the code and interactively run plot(1:10, col = \"red\"). This way we can see how the plot is built and learn where the axes are added. This leads us to the function call\n\nlocalTitle(main = main, sub = sub, xlab = xlab, ylab = ylab, ...)\n\nThe localTitle() function was defined in the first lines of plot.default() as:\n\nlocalTitle &lt;- function(..., col, bg, pch, cex, lty, lwd) title(...)\n\nThe call to localTitle() passes the col parameter as part of the ... argument to title(). ?title tells us that the title() function specifies four parts of the plot: Main (title of the plot), sub (sub-title of the plot) and both axis labels. Therefore, it would introduce ambiguity inside title() to use col directly. Instead, one has the option to supply col via the ... argument, via col.lab or as part of xlab in the form xlab = list(c(\"index\"), col = \"red\") (similar for ylab).\n\n\n\n6.7.5 Exercises\n\nWhat does load() return? Why don’t you normally see these values?\n\nAnswer: from the docs, load() returns “A character vector of the names of objects created, invisibly.”\nAR Solutions: load() loads objects saved to disk in .Rdata files by save(). When run successfully, load() invisibly returns a character vector containing the names of the newly loaded objects. To print these names to the console, one can set the argument verbose to TRUE or surround the call in parentheses to trigger R’s auto-printing mechanism.\n\n\nWhat does write.table() return? What would be more useful?\n\nAnswer: it returns invisible(NULL). Returning the written table or the argument x would be more useful.\nAR Solutions: write.table() writes an object, usually a data frame or a matrix, to disk. The function invisibly returns NULL. It would be more useful if write.table() would (invisibly) return the input data, x. This would allow to save intermediate results and directly take on further processing steps without breaking the flow of the code (i.e. breaking it into different lines). One package which uses this pattern is the {readr} package, which is part of the tidyverse-ecosystem.\n\n\nHow does the chdir parameter of source() compare to with_dir()? Why might you prefer one to the other?\n\nAnswer: both temporarily change the working directory. chdir is preferable since this is expected behavior for the function, unless you need to set a working directory other than the directory containing file.\nAR Solutions: with_dir() takes a path for a working directory (dir) as its first argument. This is the directory where the provided code (code) should be executed. Therefore, the current working directory is changed in with_dir() via setwd(). Then, on.exit() ensures that the modification of the working directory is reset to the initial value when the function exits. By passing the path explicitly, the user has full control over the directory to execute the code in.\nIn source() the code is passed via the file argument (a path to a file). The chdir argument specifies if the working directory should be changed to the directory containing the file. The default for chdir is FALSE, so you don’t have to provide a value. However, as you can only provide TRUE or FALSE, you are also less flexible in choosing the working directory for the code execution.\n\n\nWrite a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code works).\n\n\nwith_png &lt;- function(code, ...) {\n  png(...)\n  on.exit(dev.off(), add = TRUE, after = TRUE)\n  force(code)\n}\n\nwith_png(\n  plot(1:10),\n  filename = \"rendered/withpng-example.png\",\n  # use 3 times default resolution which is close to retina display ppi (218-254 depending on model)\n  # https://support.apple.com/en-us/HT202471\n  width = 480 * 3, height = 480 * 3, res = 72 * 3\n)\n\n\n\n\nwith_png output\n\n\nAnswer: code example above.\nAR Solutions: To control the graphics device we use pdf() and dev.off(). To ensure a clean termination on.exit() is used.\n\nplot_pdf &lt;- function(code) {\n  pdf(\"test.pdf\")\n  on.exit(dev.off(), add = TRUE)\n  code\n}\n\n\n\nWe can use on.exit() to implement a simple version of capture.output().\n\n\ncapture.output2 &lt;- function(code) {\n  temp &lt;- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n  force(code)\n  readLines(temp)\n}\n\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n\n#&gt; [1] \"a\" \"b\" \"c\"\n\n\nCompare capture.output() to capture.output2(). How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas so they’re easier to understand?\nAnswer: capture.output2() has fewer features and uses two separate calls to on.exit(). It simply returns the output (by line) from the executed code, and highlights the key idea, using sink() to capture output to a temporary file.\nAR Solutions: Using body(capture.output) we inspect the source code of the original capture.output() function: The implementation for capture.output() is quite a bit longer (39 lines vs. 7 lines).\nIn capture_output2() the code is simply forced, and the output is caught via sink() in a temporary file. An additional feature of capture_output() is that one can also capture messages by setting type = \"message\". As this is internally forwarded to sink(), this behaviour (and also sink()’s split argument) could be easily introduced within capture_output2() as well.\nThe main difference is that capture.output() calls print.\n\n\n\n6.8.6 Exercises\n\nRewrite the following code snippets into prefix form:\n\n\n1 + 2 + 3\n\n#&gt; [1] 6\n\n`+`(`+`(1, 2), 3)\n\n#&gt; [1] 6\n\n1 + (2 + 3)\n\n#&gt; [1] 6\n\n`+`(1, `+`(2, 3))\n\n#&gt; [1] 6\n\nfxn &lt;- function(x, n) if (length(x) &lt;= 5) x[[5]] else x[[n]]\nfxn(1:5, 2)\n\n#&gt; [1] 5\n\nfxn(1:10, 2)\n\n#&gt; [1] 2\n\nfxn2 &lt;- function(x, n) `if`(`&lt;=`(length(x), 5), `[[`(x, 5), `[[`(x, n))\nfxn2(1:5, 2)\n\n#&gt; [1] 5\n\nfxn2(1:10, 2)\n\n#&gt; [1] 2\n\n\nAnswer: inline above.\nAR Solutions: Let’s rewrite the expressions to match the exact syntax from the code above. Because prefix functions already define the execution order, we may omit the parentheses in the second expression.\n\n`+`(`+`(1, 2), 3)\n`+`(1, `(`(`+`(2, 3)))\n`+`(1, `+`(2, 3))\n`if`(`&lt;=`(length(x), 5), `[[`(x, 5), `[[`(x, n))\n\n\n\nClarify the following list of odd function calls:\n\n\nx &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))\ny &lt;- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\n\nAnswers: improved code below.\n\nx &lt;- sample(c(1:10, NA), 20, replace = TRUE)\ny &lt;- runif(20)\ncor(x, y, use = \"pairwise.complete.obs\", method = \"kendall\")\n\n#&gt; [1] 0\n\n\nAR Solutions: None of these functions provides a ... argument. Therefore, the function arguments are first matched exactly, then via partial matching and finally by position. This leads us to the following explicit function calls:\n\nx &lt;- sample(c(1:10, NA), size = 20, replace = TRUE)\ny &lt;- runif(20, min = 0, max = 1)\ncor(x, y, use = \"pairwise.complete.obs\", method = \"kendall\")\n\n\n\nExplain why the following code fails:\n\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\n\ntry(modify(get(\"x\"), 1) &lt;- 10)\n\n#&gt; Error in modify(get(\"x\"), 1) &lt;- 10 : \n#&gt;   target of assignment expands to non-language object\n\n#&gt; Error: target of assignment expands to non-language object\n\nAnswer: as explained on stack overflow, the error is caused when assigning to an object directly, instead of a name that refers to the object (like x).\nAR Solutions: First, let’s define x and recall the definition of modify() from Advanced R:\n\nx &lt;- 1:3\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\n\nR internally transforms the code, and the transformed code reproduces the error above:\n\nget(\"x\") &lt;- `modify&lt;-`(get(\"x\"), 1, 10)\n#&gt; Error in get(\"x\") &lt;- `modify&lt;-`(get(\"x\"), 1, 10) :\n#&gt;   target of assignment expands to non-language object\n\nThe error occurs during the assignment because no corresponding replacement function, i.e. get&lt;-, exists for get(). To confirm this, we reproduce the error via the following simplified example.\n\nget(\"x\") &lt;- 2\n#&gt; Error in get(\"x\") &lt;- 2 :\n#&gt;   target of assignment expands to non-language object\n\n\n\nCreate a replacement function that modifies a random location in a vector.\n\n\n`modrand&lt;-` &lt;- function(x, value) {\n  x[sample(length(x), 1)] &lt;- value\n  x\n}\n\nv &lt;- 1:20\nmodrand(v) &lt;- NA\nv\n\n#&gt;  [1]  1  2  3  4  5  6  7  8 NA 10 11 12 13 14 15 16 17 18 19 20\n\n\nAnswer: code above.\nAR Solutions: Let’s define random&lt;- like this:\n\n`random&lt;-` &lt;- function(x, value) {\n  idx &lt;- sample(length(x), 1)\n  x[idx] &lt;- value\n  x\n}\n\n\n\nWrite your own version of + that pastes its inputs together if they are character vectors but behaves as usual otherwise. In other words, make this code work:\n\n\n`+` &lt;- function(x, y) {\n  if (is.character(x) && is.character(y)) {\n    return(paste0(x, y))\n  }\n  base::`+`(x, y)\n}\n\n1 + 2\n\n#&gt; [1] 3\n\n#&gt; [1] 3\n\n\"a\" + \"b\"\n\n#&gt; [1] \"ab\"\n\n#&gt; [1] \"ab\"\n\nrm(`+`)\n\nAnswer: code above.\nAR Solutions: To achieve this behaviour, we need to override the + operator. We need to take care to not use the + operator itself inside of the function definition, as this would lead to an undesired infinite recursion. We also add b = 0L as a default value to keep the behaviour of + as a unary operator, i.e. to keep + 1 working and not throwing an error.\n\n`+` &lt;- function(a, b = 0L) {\n  if (is.character(a) && is.character(b)) {\n    paste0(a, b)\n  } else {\n    base::`+`(a, b)\n  }\n}\n# Test\n+1\n\n#&gt; [1] 1\n\n1 + 2\n\n#&gt; [1] 3\n\n\"a\" + \"b\"\n\n#&gt; [1] \"ab\"\n\n# Return back to the original `+` operator\nrm(`+`)\n\n\n\nCreate a list of all the replacement functions found in the base package. Which ones are primitive functions? (Hint: use apropos().)\n\n\n# all replacement functions in base\nfun_args2[endsWith(fun_args2$name, \"&lt;-\"), ]$name\n\n#&gt;  [1] \".rowNamesDF&lt;-\"    \"[[&lt;-\"             \"[&lt;-\"              \"@&lt;-\"             \n#&gt;  [5] \"&lt;-\"               \"&lt;&lt;-\"              \"$&lt;-\"              \"attr&lt;-\"          \n#&gt;  [9] \"attributes&lt;-\"     \"body&lt;-\"           \"class&lt;-\"          \"colnames&lt;-\"      \n#&gt; [13] \"comment&lt;-\"        \"diag&lt;-\"           \"dim&lt;-\"            \"dimnames&lt;-\"      \n#&gt; [17] \"Encoding&lt;-\"       \"environment&lt;-\"    \"formals&lt;-\"        \"is.na&lt;-\"         \n#&gt; [21] \"length&lt;-\"         \"levels&lt;-\"         \"mode&lt;-\"           \"mostattributes&lt;-\"\n#&gt; [25] \"names&lt;-\"          \"oldClass&lt;-\"       \"parent.env&lt;-\"     \"regmatches&lt;-\"    \n#&gt; [29] \"row.names&lt;-\"      \"rownames&lt;-\"       \"split&lt;-\"          \"storage.mode&lt;-\"  \n#&gt; [33] \"substr&lt;-\"         \"substring&lt;-\"      \"units&lt;-\"\n\n# all replacement primitive functions in base\nfun_args2[endsWith(fun_args2$name, \"&lt;-\") & fun_args2$prim, ]$name\n\n#&gt;  [1] \"[[&lt;-\"           \"[&lt;-\"            \"@&lt;-\"            \"&lt;-\"            \n#&gt;  [5] \"&lt;&lt;-\"            \"$&lt;-\"            \"attr&lt;-\"         \"attributes&lt;-\"  \n#&gt;  [9] \"class&lt;-\"        \"dim&lt;-\"          \"dimnames&lt;-\"     \"environment&lt;-\" \n#&gt; [13] \"length&lt;-\"       \"levels&lt;-\"       \"names&lt;-\"        \"oldClass&lt;-\"    \n#&gt; [17] \"storage.mode&lt;-\"\n\n\nAnswer: while you could use apropos(\"&lt;-\"), I leveraged the existing code from 6.2.5 #5.\nAR Solutions: The hint suggests to look for functions with a specific naming pattern: Replacement functions conventionally end on “&lt;-”. We can search for these objects by supplying the regular expression \"&lt;-$\" to apropos(). apropos() also allows to return the position on the search path (search()) for each of its matches via setting where = TRUE. Finally, we can set mode = function to narrow down our search to relevant objects only. This gives us the following statement to begin with:\n\nrepls &lt;- apropos(\"&lt;-\", where = TRUE, mode = \"function\")\nhead(repls, 30)\n\n#&gt;                     14                     14                     14 \n#&gt;        \".rowNamesDF&lt;-\"                 \"[[&lt;-\"      \"[[&lt;-.data.frame\" \n#&gt;                     14                     14                     14 \n#&gt;          \"[[&lt;-.factor\" \"[[&lt;-.numeric_version\"         \"[[&lt;-.POSIXlt\" \n#&gt;                     14                     14                     14 \n#&gt;                  \"[&lt;-\"       \"[&lt;-.data.frame\"             \"[&lt;-.Date\" \n#&gt;                     14                     14                     14 \n#&gt;         \"[&lt;-.difftime\"           \"[&lt;-.factor\"  \"[&lt;-.numeric_version\" \n#&gt;                     14                     14                     14 \n#&gt;          \"[&lt;-.POSIXct\"          \"[&lt;-.POSIXlt\"                  \"@&lt;-\" \n#&gt;                      3                     14                     14 \n#&gt;                \"%@%&lt;-\"                   \"&lt;-\"                  \"&lt;&lt;-\" \n#&gt;                     14                     14                     14 \n#&gt;                  \"$&lt;-\"       \"$&lt;-.data.frame\"          \"$&lt;-.POSIXlt\" \n#&gt;                     12                     14                     14 \n#&gt;                 \"as&lt;-\"               \"attr&lt;-\"         \"attributes&lt;-\" \n#&gt;                     12                     14                     14 \n#&gt;               \"body&lt;-\"               \"body&lt;-\"              \"class&lt;-\" \n#&gt;                     12                     14                     14 \n#&gt;             \"coerce&lt;-\"           \"colnames&lt;-\"            \"comment&lt;-\"\n\n\nTo restrict repl to names of replacement functions from the {base} package, we select only matches containing the relevant position on the search path.\n\nrepls_base &lt;- repls[names(repls) == length(search())]\nrepls_base\n\n#&gt;                        14                        14                        14 \n#&gt;           \".rowNamesDF&lt;-\"                    \"[[&lt;-\"         \"[[&lt;-.data.frame\" \n#&gt;                        14                        14                        14 \n#&gt;             \"[[&lt;-.factor\"    \"[[&lt;-.numeric_version\"            \"[[&lt;-.POSIXlt\" \n#&gt;                        14                        14                        14 \n#&gt;                     \"[&lt;-\"          \"[&lt;-.data.frame\"                \"[&lt;-.Date\" \n#&gt;                        14                        14                        14 \n#&gt;            \"[&lt;-.difftime\"              \"[&lt;-.factor\"     \"[&lt;-.numeric_version\" \n#&gt;                        14                        14                        14 \n#&gt;             \"[&lt;-.POSIXct\"             \"[&lt;-.POSIXlt\"                     \"@&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;                      \"&lt;-\"                     \"&lt;&lt;-\"                     \"$&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;          \"$&lt;-.data.frame\"             \"$&lt;-.POSIXlt\"                  \"attr&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;            \"attributes&lt;-\"                  \"body&lt;-\"                 \"class&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;              \"colnames&lt;-\"               \"comment&lt;-\"                  \"diag&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;                   \"dim&lt;-\"              \"dimnames&lt;-\"   \"dimnames&lt;-.data.frame\" \n#&gt;                        14                        14                        14 \n#&gt;              \"Encoding&lt;-\"           \"environment&lt;-\"               \"formals&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;                 \"is.na&lt;-\"         \"is.na&lt;-.default\"          \"is.na&lt;-.factor\" \n#&gt;                        14                        14                        14 \n#&gt; \"is.na&lt;-.numeric_version\"                \"length&lt;-\"           \"length&lt;-.Date\" \n#&gt;                        14                        14                        14 \n#&gt;       \"length&lt;-.difftime\"         \"length&lt;-.factor\"        \"length&lt;-.POSIXct\" \n#&gt;                        14                        14                        14 \n#&gt;        \"length&lt;-.POSIXlt\"                \"levels&lt;-\"         \"levels&lt;-.factor\" \n#&gt;                        14                        14                        14 \n#&gt;                  \"mode&lt;-\"        \"mostattributes&lt;-\"                 \"names&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;         \"names&lt;-.POSIXlt\"              \"oldClass&lt;-\"            \"parent.env&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;            \"regmatches&lt;-\"             \"row.names&lt;-\"  \"row.names&lt;-.data.frame\" \n#&gt;                        14                        14                        14 \n#&gt;     \"row.names&lt;-.default\"              \"rownames&lt;-\"                 \"split&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;      \"split&lt;-.data.frame\"         \"split&lt;-.default\"          \"storage.mode&lt;-\" \n#&gt;                        14                        14                        14 \n#&gt;                \"substr&lt;-\"             \"substring&lt;-\"                 \"units&lt;-\" \n#&gt;                        14 \n#&gt;        \"units&lt;-.difftime\"\n\n\nTo find out which of these functions are primitives, we first search for these functions via mget() and then subset the result using Filter() and is.primitive().\n\nrepls_base_prim &lt;- mget(repls_base, envir = baseenv()) %&gt;%\n  Filter(is.primitive, .) %&gt;%\n  names()\nrepls_base_prim\n\n#&gt;  [1] \"[[&lt;-\"           \"[&lt;-\"            \"@&lt;-\"            \"&lt;-\"            \n#&gt;  [5] \"&lt;&lt;-\"            \"$&lt;-\"            \"attr&lt;-\"         \"attributes&lt;-\"  \n#&gt;  [9] \"class&lt;-\"        \"dim&lt;-\"          \"dimnames&lt;-\"     \"environment&lt;-\" \n#&gt; [13] \"length&lt;-\"       \"levels&lt;-\"       \"names&lt;-\"        \"oldClass&lt;-\"    \n#&gt; [17] \"storage.mode&lt;-\"\n\n\nOverall the base package contains 63 replacement functions of which 17 are primitive functions.\n\n\nWhat are valid names for user-created infix functions?\n\nAnswer: they must begin and end with %, and can contain any sequence of characters except %.\n\n\nCreate an infix xor() operator.\n\n\n`%xor%` &lt;- function(x, y) xor(x, y)\n\nxor(0, 0)\n\n#&gt; [1] FALSE\n\nxor(1, 0)\n\n#&gt; [1] TRUE\n\nxor(1, 1)\n\n#&gt; [1] FALSE\n\n0 %xor% 0\n\n#&gt; [1] FALSE\n\n1 %xor% 0\n\n#&gt; [1] TRUE\n\n1 %xor% 1\n\n#&gt; [1] FALSE\n\n\nAnswer: code above.\nAR Solutions: We could create an infix %xor% like this:\n\n`%xor%` &lt;- function(a, b) {\n  xor(a, b)\n}\nTRUE %xor% TRUE\n\n#&gt; [1] FALSE\n\nFALSE %xor% TRUE\n\n#&gt; [1] TRUE\n\n\n\n\nCreate infix versions of the set functions intersect(), union(), and setdiff(). You might call them %n%, %u%, and %/% to match conventions from mathematics.\n\n\n`%n%` &lt;- function(x, y) intersect(x, y)\n`%u%` &lt;- function(x, y) union(x, y)\n`%s%` &lt;- function(x, y) setdiff(x, y)\n\n# taken from docs examples\n(x &lt;- c(sort(sample(1:20, 9)), NA))\n\n#&gt;  [1]  1  4  5  6  7 11 15 17 19 NA\n\n(y &lt;- c(sort(sample(3:23, 7)), NA))\n\n#&gt; [1]  9 10 12 15 17 19 21 NA\n\nx %u% y\n\n#&gt;  [1]  1  4  5  6  7 11 15 17 19 NA  9 10 12 21\n\nx %n% y\n\n#&gt; [1] 15 17 19 NA\n\nx %s% y\n\n#&gt; [1]  1  4  5  6  7 11\n\ny %s% x\n\n#&gt; [1]  9 10 12 21\n\n\nAnswer: code above.\nAR Solutions: These infix operators could be defined in the following way. (%/% is chosen instead of %\\%, because \\ serves as an escape character.)\n\n`%n%` &lt;- function(a, b) {\n  intersect(a, b)\n}\n\n`%u%` &lt;- function(a, b) {\n  union(a, b)\n}\n\n`%/%` &lt;- function(a, b) {\n  setdiff(a, b)\n}\n\nx &lt;- c(\"a\", \"b\", \"d\")\ny &lt;- c(\"a\", \"c\", \"d\")\n\nx %u% y\n\n#&gt; [1] \"a\" \"b\" \"d\" \"c\"\n\nx %n% y\n\n#&gt; [1] \"a\" \"d\"\n\nx %/% y\n\n#&gt; [1] \"b\"",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#environments",
    "href": "analysis/advanced-r-1.html#environments",
    "title": "Advanced R (Foundations)",
    "section": "7 Environments",
    "text": "7 Environments\nThe environment is the data structure that powers scoping. This chapter dives deep into environments, describing their structure in depth, and using them to improve your understanding of the four scoping rules described in Section 6.4. Understanding environments is not necessary for day-to-day use of R. But they are important to understand because they power many important R features like lexical scoping, namespaces, and R6 classes, and interact with evaluation to give you powerful tools for making domain specific languages, like dplyr and ggplot2.\n\nrm(list = ls())\n\n\n7.2.7 Exercises\n\nList three ways in which an environment differs from a list.\n\nAnswer:\n\nEvery name in an environment must be unique\nEnvironment names are not ordered\nEnvironments have parents (except the empty environment)\nEnvironments are not copied when modified\n\nAR Solutions: The most important differences between environments and lists are:\n\nenvironments have reference semantics (i.e. they don’t copy-on-modify)\nenvironments have parents\nthe contents of an environment must have unique names\nthe contents of an environment are not ordered\n(environments can only be compared via identical(); not with ==)\n(environments can contain themselves)\n\n\n\nCreate an environment as illustrated by this picture.\n\n\n\ne1 &lt;- env()\ne1$loop &lt;- e1\n\nAnswer: code above.\nAR Solutions: Let’s create an environment that contains itself.\n\ne1 &lt;- env()\ne1$loop &lt;- e1\n\n# Print the environment\nenv_print(e1)\n\n#&gt; &lt;environment: 0x106abc300&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • loop: &lt;env&gt;\n\n# Verify that it contains itself\nlobstr::ref(e1)\n\n#&gt; █ [1:0x106abc300] &lt;env&gt; \n#&gt; └─loop = [1:0x106abc300]\n\n\n\n\nCreate a pair of environments as illustrated by this picture.\n\n\n\ne2 &lt;- env()\ne3 &lt;- env()\n\ne2$loop &lt;- e3\ne3$dedoop &lt;- e2\n\nAnswer: code above.\nAR Solutions: These two environments contain each other:\n\ne1 &lt;- env()\ne2 &lt;- env()\n\ne1$loop &lt;- e2\ne2$dedoop &lt;- e1\n\nlobstr::ref(e1)\n\n#&gt; █ [1:0x124ad71e0] &lt;env&gt; \n#&gt; └─loop = █ [2:0x124b00408] &lt;env&gt; \n#&gt;          └─dedoop = [1:0x124ad71e0]\n\nlobstr::ref(e2)\n\n#&gt; █ [1:0x124b00408] &lt;env&gt; \n#&gt; └─dedoop = █ [2:0x124ad71e0] &lt;env&gt; \n#&gt;            └─loop = [1:0x124b00408]\n\n\n\n\nExplain why e[[1]] and e[c(\"a\", \"b\")] don’t make sense when e is an environment.\n\nAnswer: environment names are not ordered, and aren’t copied when modified, so they aren’t subsettable.\nAR Solutions: The first option doesn’t make sense, because elements of an environment are not ordered. The second option would return two objects at the same time. What data structure would they be contained inside?\n\n\nCreate a version of env_poke() that will only bind new names, never re-bind old names. Some programming languages only do this, and are known as single assignment languages.\n\n\nenv_poke_new &lt;- function(env, nm, value) {\n  if (!is.environment(env)) stop(\"env is not an enviornment\")\n  if (nm %in% names(env)) stop(\"nm '\", nm, \"' already bound\")\n  env[[nm]] &lt;- value\n}\n\ne_test &lt;- env(a = NULL, b = 2, c = \"three\")\n\nenv_poke_new(e_test, \"d\", \"success\")\ntry(env_poke_new(e_test, \"a\", \"fail\"))\n\n#&gt; Error in env_poke_new(e_test, \"a\", \"fail\") : nm 'a' already bound\n\nenv_print(e_test)\n\n#&gt; &lt;environment: 0x123cced60&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;NULL&gt;\n#&gt; • b: &lt;dbl&gt;\n#&gt; • c: &lt;chr&gt;\n#&gt; • d: &lt;chr&gt;\n\n\nAnswer: code above.\nAR Solutions: As described in Advanced R rlang::env_poke() takes a name (as string) and a value to assign (or reassign) a binding in an environment.\n\ne3 &lt;- new.env()\n\nenv_poke(e3, \"a\", 100)\ne3$a\n\n#&gt; [1] 100\n\nenv_poke(e3, \"a\", 200)\ne3$a\n\n#&gt; [1] 200\n\n\nSo, we want env_poke2() to test, if the supplied name is already present in the given environment. This can be checked via env_has(). If this is the case, an (informative) error is thrown.\n\nenv_poke2 &lt;- function(env, name, value) {\n  if (env_has(env, name)) {\n    abort(paste0(\"\\\"\", name, \"\\\" is already assigned to a value.\"))\n  }\n\n  env_poke(env, name, value)\n  invisible(env)\n}\n\n# Test\nenv_poke2(e3, \"b\", 100)\ne3$b\n\n#&gt; [1] 100\n\ntry(env_poke2(e3, \"b\", 200))\n\n#&gt; Error in env_poke2(e3, \"b\", 200) : \"b\" is already assigned to a value.\n\n\n\n\nWhat does this function do? How does it differ from &lt;&lt;- and why might you prefer it?\n\n\nrm(a)\n\n#&gt; Warning in rm(a): object 'a' not found\n\nrebind &lt;- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\ntry(rebind(\"a\", 10))\n\n#&gt; Error : Can't find `a`\n\n(a &lt;- 5)\n\n#&gt; [1] 5\n\nrebind(\"a\", 10)\na\n\n#&gt; [1] 10\n\n\nAnswer: &lt;&lt;- will assign a value to the name in the global environment if the name is not found, rebind() does not.\nAR Solutions: The primary difference between rebind() and &lt;&lt;- is that rebind() will only carry out an assignment when it finds an existing binding; unlike &lt;&lt;- it will never create a new one in the global environment. This behaviour of &lt;&lt;- is usually undesirable because global variables introduce non-obvious dependencies between functions.\n\n\n\n7.3.1 Exercises\n\nModify where() to return all environments that contain a binding for name. Carefully think through what type of object the function will need to return.\n\n\nwhere &lt;- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n\nx &lt;- 5\ntry(where(\"yyy\"))\n\n#&gt; Error : Can't find yyy\n\nwhere(\"x\")\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nwhere(\"mean\")\n\n#&gt; &lt;environment: base&gt;\n\nall_where &lt;- function(name, env = caller_env(), found = list()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    found\n  } else if (env_has(env, name)) {\n    # Success case\n    all_where(name, env_parent(env), append(env, found, after = 0))\n  } else {\n    # Recursive case\n    all_where(name, env_parent(env), found)\n  }\n}\n\nall_where(\"x\")\n\n#&gt; [[1]]\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nlocal({\n  x &lt;- 10\n  all_where(\"x\")\n})\n\n#&gt; [[1]]\n#&gt; &lt;environment: 0x1248460a8&gt;\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nAnswer: code above.\nAR Solutions: where() searches (recursively) for a given name within a given environment and its ancestors. If where() finds the name in one of these environments, it returns the environment’s name. Otherwise, it throws an error.\nOur modified version of where() will always recurse until it reaches the empty environment. No matter if it has already found the name or not. Along the way, it will check each environment for the given name. Finally, it will return a list of environments where the binding was found; if no binding was found, the list will be empty.\nPlease also note how the list is initialised via the default argument, when the function is called for the first time. This is a bit confusing, which is why it’s common to wrap a recursive function inside another, more user friendly, function.\n\nwhere2 &lt;- function(name, env = caller_env(), results = list()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    results\n  } else {\n    # Recursive case\n    if (env_has(env, name)) {\n      results &lt;- c(results, env)\n    }\n    where2(name, env_parent(env), results)\n  }\n}\n# Test\ne1a &lt;- env(empty_env(), a = 1, b = 2)\ne1b &lt;- env(e1a, b = 10, c = 11)\ne1c &lt;- env(e1b, a = 12, d = 13)\nwhere2(\"a\", e1c)\n\n#&gt; [[1]]\n#&gt; &lt;environment: 0x1108ad350&gt;\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;environment: 0x110bb6308&gt;\n\n\n\n\nWrite a function called fget() that finds only function objects. It should have two arguments, name and env, and should obey the regular scoping rules for functions: if there’s an object with a matching name that’s not a function, look in the parent. For an added challenge, also add an inherits argument which controls whether the function recurses up the parents or only looks in one environment.\n\n\nfget &lt;- function(name, env = caller_env(), inherits = TRUE) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name) && is.function(env[[name]])) {\n    # Success case\n    env\n  } else if (inherits) {\n    # Recursive case\n    fget(name, env_parent(env))\n  } else {\n    stop(\"Can't find \", name, call. = FALSE)\n  }\n}\n\ntry(fget(\"x\"))\n\n#&gt; Error : Can't find x\n\nfget(\"print\")\n\n#&gt; &lt;environment: base&gt;\n\ntry(fget(\"print\", inherits = FALSE))\n\n#&gt; Error : Can't find print\n\nfget(\"all_where\", inherits = FALSE)\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nAnswer: code above.\nAR Solutions: We follow a similar approach to the previous exercise. This time we additionally check if the found object is a function and implement an argument to turn off the recursion, if desired.\n\nfget &lt;- function(name, env = caller_env(), inherits = TRUE) {\n  # Base case\n  if (env_has(env, name)) {\n    obj &lt;- env_get(env, name)\n    if (is.function(obj)) {\n      return(obj)\n    }\n  }\n  if (identical(env, emptyenv()) || !inherits) {\n    stop(\"Could not find a function called \\\"\", name, \"\\\".\",\n      call. = FALSE\n    )\n  }\n\n  # Recursive Case\n  fget(name, env_parent(env))\n}\n\n# Test\nmean &lt;- 10\nfget(\"mean\", inherits = TRUE)\n\n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x1132915c8&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n\n\n\n\n7.4.5 Exercises\n\nHow is search_envs() different from env_parents(global_env())?\n\nAnswer: search_envs() includes the global environment. env_parents(global_env()) doesn’t include the global environment and also returns the empty environment (the top parent).\nAR Solutions: search_envs() returns all the environments on the search path, which is “a chain of environments containing exported functions of attached packages” (from ?search_envs). Every time you attach a new package, this search path will grow. The search path ends with the base-environment. The global environment is included, because functions present in the global environment will always be part of the search path.\nenv_parents(global_env()) will list all the ancestors of the global environment, therefore the global environment itself is not included. This also includes the “ultimate ancestor”, the empty environment. This environment is not considered part of the search path because it contains no objects.\n\n\nDraw a diagram that shows the enclosing environments of this function:\n\n\nf1 &lt;- function(x1) {\n  f2 &lt;- function(x2) {\n    f3 &lt;- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)\n\nAnswer: No.\n\n\nWrite an enhanced version of str() that provides more information about functions. Show where the function was found and what environment it was defined in.\n\n\ne_str &lt;- function(object, ...) {\n  str(object, ...)\n  if (is.function(object)) {\n    message(\"fn_env():\")\n    print(fn_env(object))\n    message(\"environment():\")\n    print(environment(object))\n  }\n}\n\ne_str(print)\n\n#&gt; function (x, ...)\n\n\n#&gt; fn_env():\n\n\n#&gt; &lt;environment: namespace:base&gt;\n\n\n#&gt; environment():\n\n\n#&gt; &lt;environment: namespace:base&gt;\n\ne_str(fget)\n\n#&gt; function (name, env = caller_env(), inherits = TRUE)\n\n\n#&gt; fn_env():\n\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n#&gt; environment():\n\n\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nAnswer: code above.\nAR Solutions: To solve this problem, we need to write a function that takes the name of a function and looks for that function returning both the function and the environment that it was found in.\n\nfget2 &lt;- function(name, env = caller_env()) {\n  # Base case\n  if (env_has(env, name)) {\n    obj &lt;- env_get(env, name)\n    if (is.function(obj)) {\n      return(list(fun = obj, env = env))\n    }\n  }\n  if (identical(env, emptyenv())) {\n    stop(\"Could not find a function called \\\"\", name, \"\\\"\",\n      call. = FALSE\n    )\n  }\n  # Recursive Case\n  fget2(name, env_parent(env))\n}\n\nfstr &lt;- function(fun_name, env = caller_env()) {\n  if (!is.character(fun_name) && length(fun_name) == 1) {\n    stop(\"`fun_name` must be a string.\", call. = FALSE)\n  }\n  fun_env &lt;- fget2(fun_name, env)\n  list(\n    where = fun_env$env,\n    enclosing = fn_env(fun_env$fun)\n  )\n}\n\n# Test\nfstr(\"mean\")\n\n#&gt; $where\n#&gt; &lt;environment: base&gt;\n#&gt; \n#&gt; $enclosing\n#&gt; &lt;environment: namespace:base&gt;\n\n\nOnce you have learned about tidy evaluation, you could rewrite fstr() to use enquo() so that you’d call it more like str(), i.e. fstr(sum).\n\n\n\n7.5.5 Exercises\n\nWrite a function that lists all the variables defined in the environment in which it was called. It should return the same results as ls().\n\n\nmy_ls &lt;- function() {\n  vars &lt;- sort(names(parent.frame()))\n  vars[!startsWith(vars, \".\")]\n}\n\nls()\n\n#&gt;  [1] \"a\"            \"all_where\"    \"e_str\"        \"e_test\"       \"e1\"          \n#&gt;  [6] \"e1a\"          \"e1b\"          \"e1c\"          \"e2\"           \"e3\"          \n#&gt; [11] \"env_poke_new\" \"env_poke2\"    \"fget\"         \"fget2\"        \"fstr\"        \n#&gt; [16] \"mean\"         \"my_ls\"        \"rebind\"       \"where\"        \"where2\"      \n#&gt; [21] \"x\"\n\nmy_ls()\n\n#&gt;  [1] \"a\"            \"all_where\"    \"e_str\"        \"e_test\"       \"e1\"          \n#&gt;  [6] \"e1a\"          \"e1b\"          \"e1c\"          \"e2\"           \"e3\"          \n#&gt; [11] \"env_poke_new\" \"env_poke2\"    \"fget\"         \"fget2\"        \"fstr\"        \n#&gt; [16] \"mean\"         \"my_ls\"        \"rebind\"       \"where\"        \"where2\"      \n#&gt; [21] \"x\"\n\n\nAnswer: code above.\nAR Solutions: We can implement this dynamic scoping behaviour by explicitly referencing the caller environment. Please note that this approach returns also variables starting with a dot, an option that ls() usually requires.\n\nls2 &lt;- function(env = caller_env()) {\n  sort(env_names(env))\n}\n\n# Test in global environment\nls(all.names = TRUE)\n\n#&gt;  [1] \".main\"               \".QuartoInlineRender\" \".Random.seed\"       \n#&gt;  [4] \"a\"                   \"all_where\"           \"e_str\"              \n#&gt;  [7] \"e_test\"              \"e1\"                  \"e1a\"                \n#&gt; [10] \"e1b\"                 \"e1c\"                 \"e2\"                 \n#&gt; [13] \"e3\"                  \"env_poke_new\"        \"env_poke2\"          \n#&gt; [16] \"fget\"                \"fget2\"               \"fstr\"               \n#&gt; [19] \"ls2\"                 \"mean\"                \"my_ls\"              \n#&gt; [22] \"rebind\"              \"where\"               \"where2\"             \n#&gt; [25] \"x\"\n\nls2()\n\n#&gt;  [1] \".main\"               \".QuartoInlineRender\" \".Random.seed\"       \n#&gt;  [4] \"a\"                   \"all_where\"           \"e_str\"              \n#&gt;  [7] \"e_test\"              \"e1\"                  \"e1a\"                \n#&gt; [10] \"e1b\"                 \"e1c\"                 \"e2\"                 \n#&gt; [13] \"e3\"                  \"env_poke_new\"        \"env_poke2\"          \n#&gt; [16] \"fget\"                \"fget2\"               \"fstr\"               \n#&gt; [19] \"ls2\"                 \"mean\"                \"my_ls\"              \n#&gt; [22] \"rebind\"              \"where\"               \"where2\"             \n#&gt; [25] \"x\"\n\n# Test in \"sandbox\" environment\ne1 &lt;- env(a = 1, b = 2)\nls(e1)\n\n#&gt; [1] \"a\" \"b\"\n\nls2(e1)\n\n#&gt; [1] \"a\" \"b\"",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "analysis/advanced-r-1.html#conditions",
    "href": "analysis/advanced-r-1.html#conditions",
    "title": "Advanced R (Foundations)",
    "section": "8 Conditions",
    "text": "8 Conditions\nThe condition system provides a paired set of tools that allow the author of a function to indicate that something unusual is happening, and the user of that function to deal with it. The function author signals conditions with functions like stop() (for errors), warning() (for warnings), and message() (for messages), then the function user can handle them with functions like tryCatch() and withCallingHandlers(). Understanding the condition system is important because you’ll often need to play both roles: signalling conditions from the functions you create, and handle conditions signalled by the functions you call.\nR offers a very powerful condition system based on ideas from Common Lisp. Like R’s approach to object-oriented programming, it is rather different to currently popular programming languages so it is easy to misunderstand, and there has been relatively little written about how to use it effectively. Historically, this has meant that few people (myself included) have taken full advantage of its power. The goal of this chapter is to remedy that situation. Here you will learn about the big ideas of R’s condition system, as well as learning a bunch of practical tools that will make your code stronger.\nI found two resources particularly useful when writing this chapter. You may also want to read them if you want to learn more about the inspirations and motivations for the system:\n\nA prototype of a condition system for R by Robert Gentleman and Luke Tierney. This describes an early version of R’s condition system. While the implementation has changed somewhat since this document was written, it provides a good overview of how the pieces fit together, and some motivation for its design.\nBeyond exception handling: conditions and restarts by Peter Seibel. This describes exception handling in Lisp, which happens to be very similar to R’s approach. It provides useful motivation and more sophisticated examples. I have provided an R translation of the chapter at http://adv-r.had.co.nz/beyond-exception-handling.html.\n\nI also found it helpful to work through the underlying C code that implements these ideas. If you’re interested in understanding how it all works, you might find my notes to be useful.\n\nrm(list = ls())\n\n\n8.2.4 Exercises\n\nWrite a wrapper around file.remove() that throws an error if the file to be deleted does not exist.\n\n\nsafe_file_remove &lt;- function(...) {\n  if (!file.exists(...)) stop(\"file '\", ..., \"' does not exist\")\n  file.remove(...)\n}\n\ntmp &lt;- tempfile()\n\nfile.create(tmp)\n\n#&gt; [1] TRUE\n\nsafe_file_remove(tmp)\n\n#&gt; [1] TRUE\n\nfile.remove(tmp)\n\n#&gt; Warning in file.remove(tmp): cannot remove file\n#&gt; '/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//RtmptXyDvy/filea2b03262dba4',\n#&gt; reason 'No such file or directory'\n\n\n#&gt; [1] FALSE\n\ntry(safe_file_remove(tmp))\n\n#&gt; Error in safe_file_remove(tmp) : \n#&gt;   file '/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//RtmptXyDvy/filea2b03262dba4' does not exist\n\n\nAnswer: code above.\nAR Solutions: We prefer the following solution for its clarity and simplicity:\n\nfile_remove_strict &lt;- function(path) {\n  if (!file.exists(path)) {\n    stop(\"Can't delete the file \\\"\", path,\n      \"\\\" because it doesn't exist.\",\n      call. = FALSE\n    )\n  }\n  file.remove(path)\n}\n\n# Test\nsaveRDS(mtcars, \"mtcars.rds\")\nfile_remove_strict(\"mtcars.rds\")\n\n#&gt; [1] TRUE\n\ntry(file_remove_strict(\"mtcars.rds\"))\n\n#&gt; Error : Can't delete the file \"mtcars.rds\" because it doesn't exist.\n\n\n\n\nWhat does the appendLF argument to message() do? How is it related to cat()?\n\nAnswer: appendLF controls whether or not a newline is added to the message; by default, cat() does not add a newline.\nAR Solutions: The appendLF argument automatically appends a new line to the message.\nComparable behaviour regarding line breaks for cat() can be achieved via setting its sep argument to \"\\n\".\n\n\n\n8.4.5 Exercises\n\nWhat extra information does the condition generated by abort() contain compared to the condition generated by stop() i.e. what’s the difference between these two objects? Read the help for ?abort to learn more.\n\n\ncatch_cnd(stop(\"An error\"))\n\n#&gt; &lt;simpleError in force(expr): An error&gt;\n\ncatch_cnd(abort(\"An error\"))\n\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! An error\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆\n\n\nAnswer: abort() includes the error message and backtrace in the condition object. abort() uses the custom class rlang_error.\nAR Solutions: In contrast to stop(), which contains the call, abort() stores the whole backtrace generated by rlang::trace_back(). This is a lot of extra data!\n\n\nPredict the results of evaluating the following code\n\n\nshow_condition &lt;- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\")) #&gt; \"error\"\n\n#&gt; [1] \"error\"\n\nshow_condition(10) #&gt; 10 [NULL]\n\n#&gt; NULL\n\nshow_condition(warning(\"?!\")) #&gt; \"warning\"\n\n#&gt; [1] \"warning\"\n\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n#&gt; [1] \"message\"\n\n#&gt; 10\n#&gt; \"message\"\n#&gt; \"warning\"\n\nAnswer: predictions in comments. The prediction for show_condition(10) was incorrect; the correct answer is NULL as that’s what’s returned when there is no condition. The final prediction was also incorrect; the tryCatch() call stops further execution when the message() is caught.\nAR Solutions: The first three examples are straightforward:\n\nshow_condition(stop(\"!\")) # stop raises an error\n\n#&gt; [1] \"error\"\n\nshow_condition(10) # no condition is signalled\n\n#&gt; NULL\n\nshow_condition(warning(\"?!\")) # warning raises a warning\n\n#&gt; [1] \"warning\"\n\n\nThe last example is the most interesting and makes us aware of the exiting qualities of tryCatch(); it will terminate the evaluation of the code as soon as it is called.\n\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n#&gt; [1] \"message\"\n\n\n\n\nExplain the results of running this code:\n\n\nwithCallingHandlers(\n  message = function(cnd) message(\"b\"), # handler 1\n  withCallingHandlers(\n    message = function(cnd) message(\"a\"), # handler 2\n    message(\"c\")\n  )\n)\n\n#&gt; b\n\n\n#&gt; a\n\n\n#&gt; b\n\n\n#&gt; c\n\n\nAnswer:\n\nmessage(\"c\") is caught, handler 2 is called\nin handler 2, message(\"a\") is caught and handler 1 is called\nhandler 1 writes message b\ncode resumes and handler 2 writes message a\nmessage(\"c\") propagates to the parent, is caught, and handler 1 is called\nhandler 1 writes message b\ncode resumes and the code writes message c\n\nAR Solutions: It’s a little tricky to untangle the flow here: First, message(\"c\") is run, and it’s caught by (1). It then calls message(\"a\"), which is caught by (2), which calls message(\"b\"). message(\"b\") isn’t caught by anything, so we see a b on the console, followed by a. But why do we get another b before we see c? That’s because we haven’t handled the message, so it bubbles up to the outer calling handler.\n\n\nRead the source code for catch_cnd() and explain how it works.\n\n\ncatch_cnd\n\n#&gt; function (expr, classes = \"condition\") \n#&gt; {\n#&gt;     stopifnot(is_character(classes))\n#&gt;     handlers &lt;- rep_named(classes, list(identity))\n#&gt;     eval_bare(rlang::expr(tryCatch(!!!handlers, {\n#&gt;         force(expr)\n#&gt;         return(NULL)\n#&gt;     })))\n#&gt; }\n#&gt; &lt;bytecode: 0x113506cd0&gt;\n#&gt; &lt;environment: namespace:rlang&gt;\n\ncatch_cnd(stop(\"error\"))\n\n#&gt; &lt;simpleError in force(expr): error&gt;\n\n# replicate the core functionality\ntryCatch(condition = function(x) x, force(stop(\"error\")))\n\n#&gt; &lt;simpleError in force(stop(\"error\")): error&gt;\n\n\nAnswer: catch_cnd() uses tryCatch() to catch any condition and return itself using identity().\nAR Solutions: At the time Advanced R was written, the source for catch_cnd() was a little simpler:\n\ncatch_cnd &lt;- function(expr) {\n  tryCatch(\n    condition = function(cnd) cnd,\n    {\n      force(expr)\n      return(NULL)\n    }\n  )\n}\n\ncatch_cnd() is a simple wrapper around tryCatch(). If a condition is signalled, it’s caught and returned. If no condition is signalled, execution proceeds sequentially and the function returns NULL.\nThe current version of catch_cnd() is a little more complex because it allows you to specify which classes of condition you want to capture. This requires some manual code generation because the interface of tryCatch() provides condition classes as argument names.\n\n\nHow could you rewrite show_condition() to use a single handler?\n\n\nshow_condition2 &lt;- function(code) {\n  tryCatch(\n    condition = function(cnd) {\n      if (is_error(cnd)) {\n        return(\"error\")\n      }\n      if (is_warning(cnd)) {\n        return(\"warning\")\n      }\n      if (is_message(cnd)) {\n        return(\"message\")\n      }\n    },\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition2(stop(\"!\"))\n\n#&gt; [1] \"error\"\n\nshow_condition2(10)\n\n#&gt; NULL\n\nshow_condition2(warning(\"?!\"))\n\n#&gt; [1] \"warning\"\n\nshow_condition2({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n#&gt; [1] \"message\"\n\n\nAnswer: code above.\nAR Solutions: show_condition() was defined in one of the previous questions. Let’s use the condition argument of tryCatch() as shown in rlang::catch_cond() above for our re-implementation:\n\nshow_condition2 &lt;- function(code) {\n  tryCatch(\n    condition = function(cnd) {\n      if (inherits(cnd, \"error\")) {\n        return(\"error\")\n      }\n      if (inherits(cnd, \"warning\")) {\n        return(\"warning\")\n      }\n      if (inherits(cnd, \"message\")) {\n        return(\"message\")\n      }\n    },\n    {\n      code\n      NULL\n    }\n  )\n}\n\n# Test\nshow_condition2(stop(\"!\"))\n\n#&gt; [1] \"error\"\n\nshow_condition2(10)\n\n#&gt; NULL\n\nshow_condition2(warning(\"?!\"))\n\n#&gt; [1] \"warning\"\n\nshow_condition2({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\n#&gt; [1] \"message\"\n\n\ntryCatch() executes the code and captures any condition raised. The function provided as the condition handles this condition. In this case it dispatches on the class of the condition.\n\n\n\n8.5.4 Exercises\n\nInside a package, it’s occasionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with requireNamespace(\"pkg\", quietly = FALSE)) and if not, throws a custom condition that includes the package name in the metadata.\n\n\nmy_check_installed &lt;- function(pkg) {\n  if (!requireNamespace(pkg, quietly = TRUE)) {\n    abort(\n      \"error_not_found\",\n      message = paste0(\"package '\", pkg, \"' not found\"),\n      pkg = pkg\n    )\n  }\n}\n\nmy_check_installed(\"rlang\")\n# NOTE: this code causes renv::dependencies() to mistakenly report package 'pkg' as a dependency\n# requireNamespace(\"pkg\", quietly = FALSE)\n# err &lt;- catch_cnd(my_check_installed(\"pkg\"))\n# err\n# err$pkg\ntry(my_check_installed(\"pkg\"))\n\n#&gt; Error in my_check_installed(\"pkg\") : package 'pkg' not found\n\n\nAnswer: code above. The question specifies to use quietly = FALSE, but this approach makes more sense (to me). The alternative is to catch the ‘Failed with error:’ message which seems less reliable.\n\nmy_check_installed2 &lt;- function(pkg) {\n  tryCatch(\n    condition = function(cnd) {\n      abort(\n        \"error_not_found\",\n        message = paste0(\"package '\", pkg, \"' not found\"),\n        pkg = pkg\n      )\n    },\n    requireNamespace(pkg, quietly = FALSE)\n  )\n}\n\nmy_check_installed2(\"rlang\")\ntry(my_check_installed2(\"pkg\"))\n\n#&gt; Error in value[[3L]](cond) : package 'pkg' not found\n\n\nThe alternative version, my_check_installed2() works but its Backtrace is harder to read.\nAR Solutions: We use rlang::abort() to supply error metadata:\n\ncheck_installed &lt;- function(package) {\n  if (!requireNamespace(package, quietly = FALSE)) {\n    abort(\n      \"error_pkg_not_found\",\n      message = paste0(\"package '\", package, \"' not installed.\"),\n      package = package\n    )\n  }\n  TRUE\n}\ncheck_installed(\"rlang\")\n\n#&gt; [1] TRUE\n\ntry(check_installed(\"ggplot3\"))\n\n#&gt; Loading required namespace: ggplot3\n\n\n#&gt; Error in check_installed(\"ggplot3\") : package 'ggplot3' not installed.\n\n\n\n\nInside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?\n\nAnswer: return custom error objects that aren’t dependent on the error text (like in 8.5.3)\nAR Solutions: Instead of returning an error it might be preferable to throw a customised condition and place a standardised error message inside the metadata. Then the downstream package could check for the class of the condition, rather than inspecting the message.\n\n\n\n8.6.6 Exercises\n\nCreate suppressConditions() that works like suppressMessages() and suppressWarnings() but suppresses everything. Think carefully about how you should handle errors.\n\n\nsuppressConditions &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) invisible(cnd),\n    withCallingHandlers(\n      condition = function(cnd) {\n        cnd_muffle(cnd)\n      },\n      expr\n    )\n  )\n}\n\nsup &lt;- suppressConditions({\n  message(\"processing...\")\n  warning(\"something went wrong\")\n  print(\"still running\")\n  stop(\"error\")\n  print(\"this shouldn't run\")\n})\n\n#&gt; [1] \"still running\"\n\nstr(sup)\n\n#&gt; List of 2\n#&gt;  $ message: chr \"error\"\n#&gt;  $ call   : language withCallingHandlers(condition = function(cnd) {     cnd_muffle(cnd) ...\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n\nAnswer: code above. Errors are not printed, but are returned, invisibly.\nAR Solutions: In general, we would like to catch errors, since they contain important information for debugging. To suppress the error message and hide the returned error object from the console, we handle errors within a tryCatch() and return the error object invisibly:\n\nsuppressErrors &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) invisible(cnd),\n    interrupt = function(cnd) {\n      stop(\"Terminated by the user.\",\n        call. = FALSE\n      )\n    },\n    expr\n  )\n}\n\nAfter we defined the error handling, we can just combine it with the other handlers to create suppressConditions():\n\nsuppressConditions &lt;- function(expr) {\n  suppressErrors(suppressWarnings(suppressMessages(expr)))\n}\n\nTo test the new function, we apply it to a set of conditions and inspect the returned error object.\n\n# The messages/warnings/conditions are suppressed successfully\nerror_obj &lt;- suppressConditions({\n  message(\"message\")\n  warning(\"warning\")\n  abort(\"error\")\n})\nerror_obj\n\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! error\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆\n\n\n\n\nCompare the following two implementations of message2error(). What is the main advantage of withCallingHandlers() in this scenario? (Hint: look carefully at the traceback.)\n\n\nmessage2error &lt;- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\n\nmessage2error2 &lt;- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\n\nAnswer: message2error() shows the invocation of message() in the traceback, but message2error2() does not.\nAR Solutions: Both functions differ in the way conditions are handled. withCallingHandlers() creates a calling handler, which is executed from within the signalling function. This makes it possible to record a detailed call stack, which helps us identify the signalling condition.\ntryCatch() defines an exiting handler, which means that the signalling function is terminated as soon as a condition is raised. It also returns control to the context where tryCatch() was called.\nIn this example the use of withCallingHandlers() returns more information than the use of tryCatch(). This allows us to determine the exact call that raised the condition.\n\nmessage2error1 &lt;- function(code) {\n  withCallingHandlers(code, message = function(e) stop(\"error\"))\n}\n\nmessage2error1({\n  1\n  message(\"hidden error\")\n  NULL\n})\n#&gt; Error in (function (e) : error\ntraceback()\n#&gt; 9: stop(\"error\") at #2\n#&gt; 8: (function (e)\n#&gt;    stop(\"error\"))(list(message = \"hidden error\\n\",\n#&gt;      call = message(\"hidden error\")))\n#&gt; 7: signalCondition(cond)\n#&gt; 6: doWithOneRestart(return(expr), restart)\n#&gt; 5: withOneRestart(expr, restarts[[1L]])\n#&gt; 4: withRestarts({\n#&gt;        signalCondition(cond)\n#&gt;        defaultHandler(cond)\n#&gt;    }, muffleMessage = function() NULL)\n#&gt; 3: message(\"hidden error\") at #1\n#&gt; 2: withCallingHandlers(code,\n#&gt;      message = function(e) stop(\"error\")) at #2\n#&gt; 1: message2error1({\n#&gt;        1\n#&gt;        message(\"hidden error\")\n#&gt;        NULL\n#&gt;    })\n\n\nmessage2error2 &lt;- function(code) {\n  tryCatch(code, message = function(e) (stop(\"error\")))\n}\n\nmessage2error2({\n  1\n  stop(\"hidden error\")\n  NULL\n})\n#&gt; Error in value[[3L]](cond) : error\ntraceback()\n#&gt; 6: stop(\"error\") at #2\n#&gt; 5: value[[3L]](cond)\n#&gt; 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt; 3: tryCatchList(expr, classes, parentenv, handlers)\n#&gt; 2: tryCatch(code, message = function(e) (stop(\"error\"))) at #2\n#&gt; 1: message2error2({\n#&gt;        1\n#&gt;        message(\"hidden error\")\n#&gt;        NULL\n#&gt;    })\n\n\n\nHow would you modify the catch_cnds() definition if you wanted to recreate the original intermingling of warnings and messages?\n\nAnswer: as noted in Advanced R Solutions, “It looks like Hadley wrote a part of the chapter after the exercises, as the catch_cnds() function defined in the chapter already solves this problem by storing all messages and warnings in their original order within a list.”\n\n\nWhy is catching interrupts dangerous? Run this code to find out.\n\n\nbottles_of_beer &lt;- function(i = 99) {\n  message(\n    \"There are \", i, \" bottles of beer on the wall, \",\n    i, \" bottles of beer.\"\n  )\n  while (i &gt; 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i &lt;&lt;- i - 1\n        if (i &gt; 0) {\n          message(\n            \"Take one down, pass it around, \", i,\n            \" bottle\", if (i &gt; 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \",\n    \"no more bottles of beer.\"\n  )\n}\n\nAnswer: this prevents user interrupts (control-c) from halting the code, which in this case can be pretty annoying if run with the defaults, requiring 99 interrupts (or just “Restart R”).\nAR Solutions: When running the bottles_of_beer() function in your console, the output should look somehow like the following:\n\nbottles_of_beer()\n#&gt; There are 99 bottles of beer on the wall, 99 bottles of beer.\n#&gt; Take one down, pass it around, 98 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 97 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 96 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 95 bottles of beer on the wall.\n#&gt;\n\nAt this point you’ll probably recognise how hard it is to get the number of bottles down from 99 to 0. There’s no way to break out of the function because we’re capturing the interrupt that you’d usually use!",
    "crumbs": [
      "Changelog",
      "Advanced R (Foundations)"
    ]
  },
  {
    "objectID": "NEWS.html",
    "href": "NEWS.html",
    "title": "rtraining 1.3.0",
    "section": "",
    "text": "Added FizzBuzz: My implementation of FizzBuzz in R, using a vector function"
  },
  {
    "objectID": "NEWS.html#new-features",
    "href": "NEWS.html#new-features",
    "title": "rtraining 1.3.0",
    "section": "New Features",
    "text": "New Features\n\nmajor update: build-site has been replaced with an R function, build_analysis_site(), which retains all of the functionality of the old shell script. It is still considered Experimental, due to lack of test coverage and some features that are not implemented, but should work for projects with limited pkgdown customization. The update also includes a function to convert notebooks to html_document, to_document().\nbuild_analysis_site() will be migrated to rdev in a future release"
  },
  {
    "objectID": "NEWS.html#new-content",
    "href": "NEWS.html#new-content",
    "title": "rtraining 1.3.0",
    "section": "New Content",
    "text": "New Content\n\nR Setup Log: added notes on the package layout I use for “analysis” packages (will be converted to an rdev vignette in a future release)\nR Setup Log: added notes on my R Workflow\nR Training Log: updated with notes on my current book, R Packages"
  },
  {
    "objectID": "NEWS.html#new-contentfeatures",
    "href": "NEWS.html#new-contentfeatures",
    "title": "rtraining 1.3.0",
    "section": "New Content/Features",
    "text": "New Content/Features\n\nci(): run continuous integration tests locally: lint, R CMD check, and style (off by default).\ncheck_renv(): convenience function that runs renv status(), clean(), and optionally update() (on by default)."
  },
  {
    "objectID": "NEWS.html#new-contentfeatures-1",
    "href": "NEWS.html#new-contentfeatures-1",
    "title": "rtraining 1.3.0",
    "section": "New Content/Features",
    "text": "New Content/Features\n\nR Setup Log Notebook (r-setup-log.Rmd): My notes on my personal R setup\nminor updates to R Training Log\nstyle_all(): style all .R and .Rmd files in a project using styler\nlint_all(): lint all .R and .Rmd files in a project using lintr\nadd GitHub Actions for continuous integration testing"
  },
  {
    "objectID": "NEWS.html#new-contentfeatures-2",
    "href": "NEWS.html#new-contentfeatures-2",
    "title": "rtraining 1.3.0",
    "section": "New Content/Features",
    "text": "New Content/Features\n\nR Training Log Notebook (r-training-log.Rmd): Notes on learning R and RStudio\ntools/setup-r: shell script to install development packages to site repository on macOS + Homebrew\nbuild-site: build a website from a collection of R Notebooks (html_notebook) in notebooks/"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "rtraining",
    "section": "",
    "text": "R Training: My notes and experiences learning R and RStudio, bundled as an R package (work-in-progress), and published to GitHub Pages using Quarto.\nFeel free to use and/or fork this project!"
  },
  {
    "objectID": "index.html#notebooks",
    "href": "index.html#notebooks",
    "title": "rtraining",
    "section": "Notebooks",
    "text": "Notebooks\nNotebooks in this package:"
  }
]