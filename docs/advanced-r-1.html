<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2022-06-12" />

<title>Advanced R Workbook (Foundations)</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link href="site_libs/bootstrap-5.1.3/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-5.1.3/bootstrap.bundle.min.js"></script>
<script src="site_libs/bs3compat-0.4.0/transition.js"></script>
<script src="site_libs/bs3compat-0.4.0/tabs.js"></script>
<script src="site_libs/bs3compat-0.4.0/bs3compat.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">rtraining notebooks</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="reference/index.html">Reference</a>
</li>
<li>
  <a href="news/index.html">Changelog</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="FaultTree.html">FaultTree.widget Test</a>
    </li>
    <li>
      <a href="advanced-r-1.html">Advanced R Workbook (Foundations)</a>
    </li>
    <li>
      <a href="advanced-r-2.html">Advanced R Workbook (Functional programming)</a>
    </li>
    <li>
      <a href="r-setup-log.html">R Setup Log</a>
    </li>
    <li>
      <a href="r-training-log.html">R Training Log</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/jabenninghoff/rtraining/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Advanced R Workbook (Foundations)</h1>
<h4 class="date">2022-06-12</h4>

</div>


<p>Workbook for completing quizzes and exercises from the “Foundations”
chapters of <a href="https://adv-r.hadley.nz/index.html">Advanced R</a>,
second edition, with comparisons to solutions from <a
href="https://advanced-r-solutions.rbind.io">Advanced R
Solutions</a>.</p>
<pre class="r"><code>library(lobstr)
library(bench)
library(rlang)

# from https://github.com/hadley/adv-r/blob/master/common.R
knitr::opts_chunk$set(
  comment = &quot;#&gt;&quot;,
  fig.align = &quot;center&quot;
)

knitr::knit_hooks$set(
  small_mar = function(before, options, envir) {
    if (before) {
      par(mar = c(4.1, 4.1, 0.5, 0.5)) # nolint: undesirable_function_linter.
    }
  }
)</code></pre>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This workbook includes answers and solutions to the quizzes and
exercises from <a href="https://adv-r.hadley.nz/index.html">Advanced
R</a> and <a href="https://advanced-r-solutions.rbind.io">Advanced R
Solutions</a>, organized by chapter. It includes excerpts from both
books, copied here.</p>
<p><strong>WARNING, SPOILERS!</strong> If you haven’t read Advanced R
and intend to complete the quizzes and exercises, don’t read this
notebook. It contains my (potentially wrong) answers to both.</p>
</div>
<div id="names-and-values" class="section level1">
<h1>2 Names and values</h1>
<p>In R, it is important to understand the distinction between an object
and its name. Doing so will help you:</p>
<ul>
<li>More accurately predict the performance and memory usage of your
code.</li>
<li>Write faster code by avoiding accidental copies, a major source of
slow code.</li>
<li>Better understand R’s functional programming tools.</li>
</ul>
<p>The goal of this chapter is to help you understand the distinction
between names and values, and when R will copy an object.</p>
<div id="quiz" class="section level2">
<h2>2 Quiz</h2>
<ol style="list-style-type: decimal">
<li>Given the following data frame, how do I create a new column called
“3” that contains the sum of <code>1</code> and <code>2</code>? You may
only use <code>$</code>, not <code>[[</code>. What makes <code>1</code>,
<code>2</code>, and <code>3</code> challenging as variable names?</li>
</ol>
<pre class="r"><code>df &lt;- data.frame(runif(3), runif(3))
names(df) &lt;- c(1, 2)</code></pre>
<p>Answer: use the following code.</p>
<pre class="r"><code>df2 &lt;- data.frame(df, df$`1` + df$`2`)
names(df2) &lt;- c(1, 2, 3)</code></pre>
<p>Using numbers as names is problematic due to them being interpreted
as numeric constants by default.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>In the following code, how much memory does <code>y</code>
occupy?</li>
</ol>
<pre class="r"><code>x &lt;- runif(1e6)
y &lt;- list(x, x, x)</code></pre>
<p>Answer: 3 times the size of x, 24 MB. Note: this is incorrect, as
shown by <code>obj_size</code> and <code>obj_addr</code>:</p>
<pre class="r"><code>obj_size(x)</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code>obj_size(y)</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code>obj_addr(y[[1]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb69e38000&quot;</code></pre>
<pre class="r"><code>obj_addr(y[[2]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb69e38000&quot;</code></pre>
<pre class="r"><code>obj_addr(y[[3]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb69e38000&quot;</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>On which line does <code>a</code> get copied in the following
example?</li>
</ol>
<pre class="r"><code>a &lt;- c(1, 5, 3, 2)
obj_addr(a)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb7b034528&quot;</code></pre>
<pre class="r"><code>b &lt;- a
obj_addr(b)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb7b034528&quot;</code></pre>
<pre class="r"><code>b[[1]] &lt;- 10
obj_addr(b)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb7c321018&quot;</code></pre>
<p>Answer: the third line (copy-on-write). [copy-on-modify]</p>
</div>
<div id="exercises" class="section level2">
<h2>2.2.2 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Explain the relationship between <code>a</code>, <code>b</code>,
<code>c</code> and <code>d</code> in the following code:</li>
</ol>
<pre class="r"><code>a &lt;- 1:10
b &lt;- a
c &lt;- b
d &lt;- 1:10</code></pre>
<p>Answer: a, b, and c all point to the same object (1:10). d points to
an identical object at a different address.</p>
<p>AR Solutions: <code>a</code>, <code>b</code>, and <code>c</code>
point to the same object (with the same address in memory). This object
has the value <code>1:10</code>. <code>d</code> points to a different
object with the same value.</p>
<pre class="r"><code>obj_addr(a)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4ab695e0&quot;</code></pre>
<pre class="r"><code>obj_addr(b)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4ab695e0&quot;</code></pre>
<pre class="r"><code>obj_addr(c)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4ab695e0&quot;</code></pre>
<pre class="r"><code>obj_addr(d)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4aa01a30&quot;</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>The following code accesses the mean function in multiple ways. Do
they all point to the same underlying function object? Verify this with
<code>lobstr::obj_addr()</code>.</li>
</ol>
<pre class="r"><code>mean
base::mean
get(&quot;mean&quot;)
evalq(mean)
match.fun(&quot;mean&quot;)</code></pre>
<p>Check the <code>obj_addr</code>:</p>
<pre class="r"><code>obj_addr(mean)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4efda408&quot;</code></pre>
<pre class="r"><code>obj_addr(base::mean)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4efda408&quot;</code></pre>
<pre class="r"><code>obj_addr(get(&quot;mean&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4efda408&quot;</code></pre>
<pre class="r"><code>obj_addr(evalq(mean))</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4efda408&quot;</code></pre>
<pre class="r"><code>obj_addr(match.fun(&quot;mean&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb4efda408&quot;</code></pre>
<p>Answer: they do.</p>
<p>AR Solutions: Yes, they point to the same object. We confirm this by
inspecting the address of the underlying function object.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>By default, base R data import functions, like
<code>read.csv()</code>, will automatically convert non-syntactic names
to syntactic ones. Why might this be problematic? What option allows you
to suppress this behaviour?</li>
</ol>
<p>Answer: this could introduce problematic names, like <code>1</code>.
Setting <code>check.names = FALSE</code> suppresses this behavior.</p>
<p>AR Solutions: Column names are often data, and the underlying
<code>make.names()</code> transformation is non-invertible, so the
default behaviour corrupts data. To avoid this, set
<code>check.names = FALSE</code>.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What rules does <code>make.names()</code> use to convert
non-syntactic names into syntactic ones?</li>
</ol>
<p>Answer: from <code>?make.names</code>:</p>
<blockquote>
<p>The character “X” is prepended if necessary. All invalid characters
are translated to “.”. A missing value is translated to “NA”. Names
which match R keywords have a dot appended to them. Duplicated values
are altered by make.unique.</p>
</blockquote>
<p>AR Solutions: A valid name must start with a letter or a dot (not
followed by a number) and may further contain numbers and underscores
(<code>"_"</code>s are allowed since R version 1.9.0).</p>
<p>Three main mechanisms ensure syntactically valid names (see
<code>?make.names</code>):</p>
<ol style="list-style-type: decimal">
<li>Names that do not start with a letter or a dot will be prepended
with an <code>"X"</code>. The same holds for names that begin with a dot
followed by a number.</li>
<li>Additionally, non-valid characters are replaced by a dot.</li>
<li>Reserved R keywords (see <code>?reserved</code>) are suffixed by a
dot.</li>
</ol>
<p>Interestingly, some of these transformations are influenced by the
current locale. From <code>?make.names</code>:</p>
<blockquote>
<p>The definition of a letter depends on the current locale, but only
ASCII digits are considered to be digits.</p>
</blockquote>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>I slightly simplified the rules that govern syntactic names. Why is
<code>.123e1</code> not a syntactic name? Read <code>?make.names</code>
for the full details.</li>
</ol>
<p>Answer: from <code>?make.names</code>:</p>
<blockquote>
<p>A syntactically valid name consists of letters, numbers and the dot
or underline characters and starts with a letter or the dot not followed
by a number. Names such as “.2way” are not valid, and neither are the
reserved words.</p>
</blockquote>
<p>AR Solutions: <code>.123e1</code> is not a syntactic name, because it
starts with one dot which is followed by a number. This makes it a
double, <code>1.23</code>.</p>
<hr />
</div>
<div id="exercises-1" class="section level2">
<h2>2.3.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Why is <code>tracemem(1:10)</code> not useful?</li>
</ol>
<p>Answer: this is tracing an ‘immutable’ object which will always have
the same address.</p>
<p>AR Solutions: When <code>1:10</code> is called an object with an
address in memory is created, but it is not bound to a name. Therefore,
the object cannot be called or manipulated from R. As no copies will be
made, it is not useful to track the object for copying.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Explain why <code>tracemem()</code> shows two copies when you run
this code. Hint: carefully look at the difference between this code and
the code shown earlier in the section.</li>
</ol>
<pre class="r"><code>rm(list = ls())
x &lt;- c(1L, 2L, 3L)
tracemem(x)</code></pre>
<pre><code>#&gt; [1] &quot;&lt;0x7fbb7b11efc8&gt;&quot;</code></pre>
<pre class="r"><code>x[[3]] &lt;- 4</code></pre>
<pre><code>#&gt; tracemem[0x7fbb7b11efc8 -&gt; 0x7fbb7b17dbc8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; withCallingHandlers suppressMessages render_one FUN lapply sapply &lt;Anonymous&gt; &lt;Anonymous&gt; build_analysis_site stage_release 
#&gt; tracemem[0x7fbb7b17dbc8 -&gt; 0x7fbb4c65d368]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; withCallingHandlers suppressMessages render_one FUN lapply sapply &lt;Anonymous&gt; &lt;Anonymous&gt; build_analysis_site stage_release</code></pre>
<pre class="r"><code>untracemem(x)</code></pre>
<p>Answer: unclear. The behavior in R 4.2.0 seems to have changed, since
this code shows two copies:</p>
<pre class="r"><code>rm(list = ls())
x &lt;- c(1, 2, 3)
tracemem(x)</code></pre>
<pre><code>#&gt; [1] &quot;&lt;0x7fbb897de248&gt;&quot;</code></pre>
<pre class="r"><code>y &lt;- x
y[[3]] &lt;- 4L</code></pre>
<pre><code>#&gt; tracemem[0x7fbb897de248 -&gt; 0x7fbb7f38a9e8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; withCallingHandlers suppressMessages render_one FUN lapply sapply &lt;Anonymous&gt; &lt;Anonymous&gt; build_analysis_site stage_release</code></pre>
<pre class="r"><code>y[[3]] &lt;- 5L
untracemem(x)</code></pre>
<p>AR Solutions: Initially the vector <code>x</code> has integer type.
The replacement call assigns a double to the third element of
<code>x</code>, which triggers copy-on-modify.</p>
<pre class="r"><code>x &lt;- c(1L, 2L, 3L)
tracemem(x)
#&gt; &lt;0x66a4a70&gt;

x[[3]] &lt;- 4
#&gt; tracemem[0x55eec7b3af38 -&gt; 0x55eec774cc18]:</code></pre>
<p>We can avoid the copy by sub-assigning an integer instead of a
double:</p>
<pre class="r"><code>x &lt;- c(1L, 2L, 3L)
tracemem(x)
#&gt; &lt;0x55eec6940ae0&gt;

x[[3]] &lt;- 4L</code></pre>
<p>Please be aware that running this code in RStudio will result in
additional copies because of the reference from the environment
pane.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Sketch out the relationship between the following objects:</li>
</ol>
<pre class="r"><code>a &lt;- 1:10
b &lt;- list(a, a)
c &lt;- list(b, a, 1:10)

print(&quot;first object&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;first object&quot;</code></pre>
<pre class="r"><code>obj_addr(a)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb881afa60&quot;</code></pre>
<pre class="r"><code>obj_addr(b[[1]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb881afa60&quot;</code></pre>
<pre class="r"><code>obj_addr(b[[2]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb881afa60&quot;</code></pre>
<pre class="r"><code>obj_addr(c[[2]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb881afa60&quot;</code></pre>
<pre class="r"><code>print(&quot;second object&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;second object&quot;</code></pre>
<pre class="r"><code>obj_addr(b)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb7b402148&quot;</code></pre>
<pre class="r"><code>obj_addr(c[[1]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb7b402148&quot;</code></pre>
<pre class="r"><code>print(&quot;third object&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;third object&quot;</code></pre>
<pre class="r"><code>obj_addr(c)</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb88411108&quot;</code></pre>
<pre class="r"><code>print(&quot;fourth object (?)&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;fourth object (?)&quot;</code></pre>
<pre class="r"><code>obj_addr(c[[3]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7fbb7f40ae80&quot;</code></pre>
<p>Answer: four different objects with multiple names.</p>
<p>AR Solutions: <code>a</code> contains a reference to an address with
the value <code>1:10</code>. <code>b</code> contains a list of two
references to the same address as <code>a</code>. <code>c</code>
contains a list of <code>b</code> (containing two references to
<code>a</code>), <code>a</code> (containing the same reference again)
and a reference pointing to a different address containing the same
value (<code>1:10</code>).</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What happens when you run this code? Draw a picture.</li>
</ol>
<pre class="r"><code>x &lt;- list(1:10)

x[[2]] &lt;- x

ref(x)</code></pre>
<pre><code>#&gt; █ [1:0x7fbb7b3afc08] &lt;list&gt; 
#&gt; ├─[2:0x7fbb88c0fe00] &lt;int&gt; 
#&gt; └─█ [3:0x7fbb7f5b8858] &lt;list&gt; 
#&gt;   └─[2:0x7fbb88c0fe00]</code></pre>
<p>Initially x is a list of one element, an int vector 1:10. Then a
second list element is added, which points to the original int
vector.</p>
<p>AR Solutions: The initial reference tree of <code>x</code> shows that
the name <code>x</code> binds to a list object. This object contains a
reference to the integer vector <code>1:10</code>. When <code>x</code>
is assigned to an element of itself, copy-on-modify takes place and the
list is copied to a new address in memory. The list object previously
bound to <code>x</code> is now referenced in the newly created list
object. It is no longer bound to a name. The integer vector is
referenced twice.</p>
<hr />
</div>
<div id="exercises-2" class="section level2">
<h2>2.4.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>In the following example, why are <code>object.size(y)</code> and
<code>obj_size(y)</code> so radically different? Consult the
documentation of <code>object.size()</code>.</li>
</ol>
<pre class="r"><code>y &lt;- rep(list(runif(1e4)), 100)

object.size(y)</code></pre>
<pre><code>#&gt; 8005648 bytes</code></pre>
<pre class="r"><code>obj_size(y)</code></pre>
<pre><code>#&gt; 80.90 kB</code></pre>
<p>Answer: <code>object.size()</code> “does not detect if elements of a
list are shared”, which is the case here. That is, it does not detect
the list has been replicated 100 times, and overestimates by a factor of
100 compared to <code>object_size()</code>.</p>
<p>AR Solutions: <code>object.size()</code> doesn’t account for shared
elements within lists. Therefore, the results differ by a factor of ~
100.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Take the following list. Why is its size somewhat misleading?</li>
</ol>
<pre class="r"><code>funs &lt;- list(mean, sd, var)
obj_size(funs)</code></pre>
<pre><code>#&gt; 17.55 kB</code></pre>
<p>Answer: it doesn’t seem misleading to me, but the list includes the
function objects, not the return values. Also, it calculates the size
discarding the overlap between the functions. Per the code below, there
is some:</p>
<pre class="r"><code>obj_size(mean) + obj_size(sd) + obj_size(var)</code></pre>
<pre><code>#&gt; 18.08 kB</code></pre>
<p>AR Solutions: All three functions are built-in to R as part of the
<code>{base}</code> and <code>{stats}</code> packages and hence always
available. So, what does it mean to measure the size of something that’s
already included in R?</p>
<p>(There’s typically a more general question about what you want to
know when you ask for the size of something — do you want to know how
much data you’d need to send to communicate the object to someone else
(e.g. serialise it), or do you want to know how much memory you’d free
if you deleted it?)</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Predict the output of the following code:</li>
</ol>
<pre class="r"><code>a &lt;- runif(1e6)
obj_size(a) # 8,000,048 B ~ 8MB</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code># correct: from example above, runif(1e6) ~= 8MB

b &lt;- list(a, a)
obj_size(b) # slightly larger than obj_size(a)</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code># correct: two lists containing numeric vectors
obj_size(a, b) # slightly larger than obj_size(b)</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code># wrong: a is entirely contained within b

b[[1]][[1]] &lt;- 10
obj_size(b) # copy of b, same size</code></pre>
<pre><code>#&gt; 16.00 MB</code></pre>
<pre class="r"><code># wrong: double, since R copies an entire column, this adds the size of runif(1e6)
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)</code></pre>
<pre><code>#&gt; 16.00 MB</code></pre>
<pre class="r"><code># wrong: a is still entirely contained with b

b[[2]][[1]] &lt;- 10
obj_size(b) # copy of b, same size</code></pre>
<pre><code>#&gt; 16.00 MB</code></pre>
<pre class="r"><code># wrong: same size since it&#39;s still 2 numeric vectors of 1e6 length
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)</code></pre>
<pre><code>#&gt; 24.00 MB</code></pre>
<pre class="r"><code># wrong: there is no longer any overlap, so the size of obj_size(a, b) = obj_size(a) = obj_size(b)</code></pre>
<p>Answer: answers inline.</p>
<p>AR Solutions:</p>
<p><code>a &lt;- runif(1e6)</code>:</p>
<ul>
<li>In R (on most platforms) a length-0 vector has 48 bytes of
overhead.</li>
<li>A single double takes up an additional 8 bytes of memory.</li>
<li>So, a 1 million double should take up 8,000,048 bytes.</li>
</ul>
<p>For <code>b &lt;- list(a, a)</code> both list elements contain
references to the same memory address. Therefore, no additional memory
is required for the second list element. The list itself requires 64
bytes, 48 bytes for an empty list and 8 bytes for each element
(<code>obj_size(vector("list", 2))</code>). This lets us predict
8,000,048 B + 64 B = 8,000,112 B.</p>
<p><code>b[[1]][[1]] &lt;- 10</code>: When we modify the first element
of <code>b[[1]]</code> copy-on-modify occurs. Both elements will still
have the same size (8,000,040 B), but the first one gets a new address
in memory. As <code>b</code>’s elements don’t share references anymore,
its object size adds up to the sum of the elements and the length-2
list: 8,000,048 B + 8,000,048 B + 64 B = 16,000,160 B (16 MB). The
second element of <code>b</code> still references the same address as
<code>a</code>, so the combined size of <code>a</code> and
<code>b</code> is the same as <code>b</code>.</p>
<p><code>b[[2]][[1]] &lt;- 10</code>: When we modify the second element
of <code>b</code>, this element will also point to a new memory address.
This does not affect the size of the list. However, as <code>b</code>
doesn’t share references with <code>a</code> anymore, the memory usage
of the combined objects increases.</p>
<hr />
</div>
<div id="exercises-3" class="section level2">
<h2>2.5.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Explain why the following code doesn’t create a circular list.</li>
</ol>
<pre class="r"><code>x &lt;- list()
x[[1]] &lt;- x</code></pre>
<p>Answer: the name x is assigned to the empty list, and then the first
element of x is mapped to the object that x points to, the empty
list.</p>
<p>AR Solutions: In this situation copy-on-modify prevents the creation
of a circular list. Let us step through the details:</p>
<pre class="r"><code>x &lt;- list() # creates initial object
obj_addr(x)
#&gt; [1] &quot;0x55862f23ab80&quot;
tracemem(x)
#&gt; [1] &quot;&lt;0x55862f23ab80&gt;&quot;
x[[1]] &lt;- x # Copy-on-modify triggers new copy
#&gt; tracemem[0x55862f23ab80 -&gt; 0x55862e8ce028]:
obj_addr(x) # copied object has new memory address
#&gt; [1] &quot;0x55862e8ce028&quot;
obj_addr(x[[1]]) # list element contains old memory address
#&gt; [1] &quot;0x55862f23ab80&quot;</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Wrap the two methods for subtracting medians into two functions,
then use the ‘bench’ package <span class="citation">[@bench]</span> to
carefully compare their speeds. How does performance change as the
number of columns increase?</li>
</ol>
<pre class="r"><code>x_medians &lt;- function(ncol) {
  x &lt;- data.frame(matrix(runif(5 * 1e4), ncol = ncol))
  medians &lt;- vapply(x, median, numeric(1))
  return(list(x = x, medians = medians))
}

df_medians &lt;- function(x, medians) {
  # subtract medians using data.frame method
  for (i in seq_along(medians)) {
    x[[i]] &lt;- x[[i]] - medians[[i]]
  }
  x
}

ls_medians &lt;- function(x, medians) {
  y &lt;- as.list(x)

  for (i in seq_along(medians)) {
    y[[i]] &lt;- y[[i]] - medians[[i]]
  }
  y
}

# confirm they both work
xm &lt;- x_medians(5)
head(df_medians(xm$x, xm$medians), 10)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["X1"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["X2"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["X3"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["X4"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["X5"],"name":[5],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.321589645","2":"-0.003017779","3":"-0.006020197","4":"-0.18789368","5":"0.01929394","_rn_":"1"},{"1":"0.310928724","2":"-0.231090758","3":"0.338661135","4":"0.24729057","5":"-0.27057070","_rn_":"2"},{"1":"0.422449584","2":"-0.118703532","3":"0.182468895","4":"-0.48556426","5":"-0.36398196","_rn_":"3"},{"1":"0.068526022","2":"0.238503590","3":"-0.215728244","4":"0.38548729","5":"-0.38047769","_rn_":"4"},{"1":"0.388790895","2":"0.047986717","3":"0.495923664","4":"0.21576548","5":"0.42277138","_rn_":"5"},{"1":"-0.053153779","2":"0.014988329","3":"0.490665312","4":"0.23822842","5":"-0.42144444","_rn_":"6"},{"1":"-0.333559593","2":"0.225109969","3":"0.247473425","4":"-0.38301045","5":"0.02190820","_rn_":"7"},{"1":"-0.231943389","2":"-0.252655278","3":"0.092811359","4":"0.08356977","5":"0.22662885","_rn_":"8"},{"1":"-0.003125183","2":"0.348475199","3":"-0.314883398","4":"-0.39012190","5":"-0.40578083","_rn_":"9"},{"1":"-0.036849812","2":"0.398017651","3":"-0.320962810","4":"0.38013026","5":"0.11764866","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>head(as.data.frame(ls_medians(xm$x, xm$medians)), 10)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["X1"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["X2"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["X3"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["X4"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["X5"],"name":[5],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.321589645","2":"-0.003017779","3":"-0.006020197","4":"-0.18789368","5":"0.01929394","_rn_":"1"},{"1":"0.310928724","2":"-0.231090758","3":"0.338661135","4":"0.24729057","5":"-0.27057070","_rn_":"2"},{"1":"0.422449584","2":"-0.118703532","3":"0.182468895","4":"-0.48556426","5":"-0.36398196","_rn_":"3"},{"1":"0.068526022","2":"0.238503590","3":"-0.215728244","4":"0.38548729","5":"-0.38047769","_rn_":"4"},{"1":"0.388790895","2":"0.047986717","3":"0.495923664","4":"0.21576548","5":"0.42277138","_rn_":"5"},{"1":"-0.053153779","2":"0.014988329","3":"0.490665312","4":"0.23822842","5":"-0.42144444","_rn_":"6"},{"1":"-0.333559593","2":"0.225109969","3":"0.247473425","4":"-0.38301045","5":"0.02190820","_rn_":"7"},{"1":"-0.231943389","2":"-0.252655278","3":"0.092811359","4":"0.08356977","5":"0.22662885","_rn_":"8"},{"1":"-0.003125183","2":"0.348475199","3":"-0.314883398","4":"-0.39012190","5":"-0.40578083","_rn_":"9"},{"1":"-0.036849812","2":"0.398017651","3":"-0.320962810","4":"0.38013026","5":"0.11764866","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># benchmark
mark(df_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 df_medians(xm$x, xm$medians)   87.6µs    212µs     4417.     391KB     2.30</code></pre>
<pre class="r"><code>mark(ls_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 ls_medians(xm$x, xm$medians)   38.8µs    154µs     7502.     391KB     2.01</code></pre>
<pre class="r"><code>mark(as.data.frame(ls_medians(xm$x, xm$medians))) # as.data.frame introduces significant overhead</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                       min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                                  &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 as.data.frame(ls_medians(xm$x, xm$medians))    236µs    294µs     3097.     391KB     5.02</code></pre>
<p>Answer: with 5 columns, the list method is about twice as fast.</p>
<pre class="r"><code>xm &lt;- x_medians(10)
mark(df_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 df_medians(xm$x, xm$medians)    143µs    200µs     4449.     391KB     5.68</code></pre>
<pre class="r"><code>mark(ls_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 ls_medians(xm$x, xm$medians)     49µs    173µs     6834.     391KB        0</code></pre>
<pre class="r"><code>xm &lt;- x_medians(20)
mark(df_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 df_medians(xm$x, xm$medians)    288µs    441µs     2128.     400KB     17.3</code></pre>
<pre class="r"><code>mark(ls_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 ls_medians(xm$x, xm$medians)   65.9µs    200µs     4633.     392KB        0</code></pre>
<p>With 10 columns, the list method is 3 times as fast. With 20, the
list method is 5 times as fast. So, the list method is near constant
time regardless of columns, whereas the data.frame method scales
linearly with the number of columns.</p>
<p>AR Solutions:</p>
<p>When working directly with the data frame, the execution time grows
quadratically with the number of columns in the input data. This is
because (e.g.) the first column must be copied n times, the second
column n-1 times, and so on. When working with a list, the execution
time increases only linearly.</p>
<p>Obviously in the long run, linear growth creates shorter run-times,
but there is some cost to this strategy — we have to convert between
data structures with as.list() and list2DF(). Even though this is fast
and probably doesn’t hurt much, the improved approach doesn’t really pay
off in this scenario until we get to a data frame that is about 300
columns wide (with the exact value depending on the characteristics of
the system running the code).</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What happens if you attempt to use <code>tracemem()</code> on an
environment?</li>
</ol>
<pre class="r"><code>e &lt;- rlang::env()
try(tracemem(e))</code></pre>
<pre><code>#&gt; Error in tracemem(e) : 
#&gt;   &#39;tracemem&#39; is not useful for promise and environment objects</code></pre>
<p>Answer: it throws an error!</p>
<p>AR Solutions: <code>tracemem()</code> cannot be used to mark and
trace environments.</p>
<p>The error occurs because “it is not useful to trace NULL,
environments, promises, weak references, or external pointer objects, as
these are not duplicated” (see <code>?tracemem</code>). Environments are
always modified in place.</p>
<hr />
</div>
</div>
<div id="vectors" class="section level1">
<h1>3 Vectors</h1>
<p>This chapter discusses the most important family of data types in
base R: vectors. While you’ve probably already used many (if not all) of
the different types of vectors, you may not have thought deeply about
how they’re interrelated. In this chapter, I won’t cover individual
vectors types in too much detail, but I will show you how all the types
fit together as a whole. If you need more details, you can find them in
R’s documentation.</p>
<p>Vectors come in two flavours: atomic vectors and lists. They differ
in terms of their elements’ types: for atomic vectors, all elements must
have the same type; for lists, elements can have different types. While
not a vector, <code>NULL</code> is closely related to vectors and often
serves the role of a generic zero length vector. This diagram, which
we’ll be expanding on throughout this chapter, illustrates the basic
relationships:</p>
<p>Every vector can also have <strong>attributes</strong>, which you can
think of as a named list of arbitrary metadata. Two attributes are
particularly important. The <strong>dimension</strong> attribute turns
vectors into matrices and arrays and the <strong>class</strong>
attribute powers the S3 object system. While you’ll learn how to use S3
in Chapter 13, here you’ll learn about some of the most important S3
vectors: factors, date and times, data frames, and tibbles. And while 2D
structures like matrices and data frames are not necessarily what come
to mind when you think of vectors, you’ll also learn why R considers
them to be vectors.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-4" class="section level2">
<h2>3.2.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How do you create raw and complex scalars? (See <code>?raw</code>
and <code>?complex</code>.)</li>
</ol>
<p>Answer: using either <code>raw()</code>, <code>complex()</code>, or
<code>as.raw()</code>, <code>as.complex()</code>.</p>
<p>AR Solutions: In R, scalars are represented as vectors of length one.
However, there’s no built-in syntax like there is for logicals,
integers, doubles, and character vectors to create individual raw and
complex values. Instead, you have to create them by calling a function.
For raw vectors you can use either <code>as.raw()</code> or
<code>charToRaw()</code> to create them from numeric or character
values.</p>
<p>In the case of complex numbers, real and imaginary parts may be
provided directly to the <code>complex()</code> constructor. You can
create purely imaginary numbers (e.g.) <code>1i</code>, but there is no
way to create complex numbers without <code>+</code>
(e.g. <code>1i + 1</code>).</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Test your knowledge of the vector coercion rules by predicting the
output of the following uses of <code>c()</code>:</li>
</ol>
<pre class="r"><code>c(1, FALSE) # 1.0, 0.0 - double</code></pre>
<pre><code>#&gt; [1] 1 0</code></pre>
<pre class="r"><code>c(&quot;a&quot;, 1) # &quot;a&quot;, &quot;1&quot; - character</code></pre>
<pre><code>#&gt; [1] &quot;a&quot; &quot;1&quot;</code></pre>
<pre class="r"><code>c(TRUE, 1L) # 1L, 1L - integer</code></pre>
<pre><code>#&gt; [1] 1 1</code></pre>
<pre class="r"><code>typeof(c(1, FALSE))</code></pre>
<pre><code>#&gt; [1] &quot;double&quot;</code></pre>
<pre class="r"><code>typeof(c(&quot;a&quot;, 1))</code></pre>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
<pre class="r"><code>typeof(c(TRUE, 1L))</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<p>Answer: guesses inline. [correct!]</p>
<p>AR Solutions:</p>
<pre class="r"><code>c(1, FALSE) # will be coerced to double    -&gt; 1 0
c(&quot;a&quot;, 1) # will be coerced to character -&gt; &quot;a&quot; &quot;1&quot;
c(TRUE, 1L) # will be coerced to integer   -&gt; 1 1</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Why is <code>1 == "1"</code> true? Why is <code>-1 &lt; FALSE</code>
true? Why is <code>"one" &lt; 2</code> false?</li>
</ol>
<p>Answers:</p>
<ul>
<li><code>1 == "1"</code>: the 1 is coerced to “1”</li>
<li><code>-1 &lt; FALSE</code>: FALSE is coerced to 0</li>
<li>`“one” &lt; 2: the 2 is coerced to “2”</li>
</ul>
<p>AR Solutions: These comparisons are carried out by operator-functions
(<code>==</code>, <code>&lt;</code>), which coerce their arguments to a
common type. In the examples above, these types will be character,
double and character: <code>1</code> will be coerced to
<code>"1"</code>, <code>FALSE</code> is represented as <code>0</code>
and <code>2</code> turns into <code>"2"</code> (and numbers precede
letters in lexicographic order (may depend on locale)).</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Why is the default missing value, <code>NA</code>, a logical vector?
What’s special about logical vectors? (Hint: think about
<code>c(FALSE, NA_character_)</code>.)</li>
</ol>
<p>Answer: NA must be logical so that it can exist in a logical
vector.</p>
<p>AR Solutions: The presence of missing values shouldn’t affect the
type of an object. Recall that there is a type-hierarchy for coercion
from character → double → integer → logical. When combining
<code>NA</code>s with other atomic types, the <code>NA</code>s will be
coerced to integer (<code>NA_integer_</code>), double
(<code>NA_real_</code>) or character (<code>NA_character_</code>) and
not the other way round. If <code>NA</code> were a character and added
to a set of other values all of these would be coerced to character as
well.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Precisely what do <code>is.atomic()</code>,
<code>is.numeric()</code>, and <code>is.vector()</code> test for?</li>
</ol>
<p>Answers:</p>
<ul>
<li><code>is.atomic(x)</code>: tests if x is an atomic vector (logical,
integer, numeric, complex, character, and raw) - is <code>FALSE</code>
for lists</li>
<li><code>is.numeric(x)</code>: tests if x is an atomic numeric
vector</li>
<li><code>is.vector(x, mode = "any")</code>: tests if x is an atomic
vector OR a list or expression</li>
</ul>
<p>AR Solutions: The documentation states that:</p>
<ul>
<li><code>is.atomic()</code> tests if an object is an atomic vector (as
defined in <em>Advanced R</em>) or is <code>NULL</code> (!).</li>
<li><code>is.numeric()</code> tests if an object has type integer or
double and is not of class <code>factor</code>, <code>Date</code>,
<code>POSIXt</code> or <code>difftime</code>.</li>
<li><code>is.vector()</code> tests if an object is a vector (as defined
in <em>Advanced R</em>) or an expression and has no attributes, apart
from names.</li>
</ul>
<p>Atomic vectors are defined in <em>Advanced R</em> as objects of type
logical, integer, double, complex, character or raw. Vectors are defined
as atomic vectors or lists.</p>
<hr />
</div>
<div id="exercises-5" class="section level2">
<h2>3.3.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How is <code>setNames()</code> implemented? How is
<code>unname()</code> implemented? Read the source code.</li>
</ol>
<pre class="r"><code>setNames</code></pre>
<pre><code>#&gt; function (object = nm, nm) 
#&gt; {
#&gt;     names(object) &lt;- nm
#&gt;     object
#&gt; }
#&gt; &lt;bytecode: 0x7fbb491c1510&gt;
#&gt; &lt;environment: namespace:stats&gt;</code></pre>
<pre class="r"><code>unname</code></pre>
<pre><code>#&gt; function (obj, force = FALSE) 
#&gt; {
#&gt;     if (!is.null(names(obj))) 
#&gt;         names(obj) &lt;- NULL
#&gt;     if (!is.null(dimnames(obj)) &amp;&amp; (force || !is.data.frame(obj))) 
#&gt;         dimnames(obj) &lt;- NULL
#&gt;     obj
#&gt; }
#&gt; &lt;bytecode: 0x7fbb9f011de8&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<p>Answer: using <code>names()</code>, and <code>dimnames()</code> for
<code>unname()</code>.</p>
<p>AR Solutions:</p>
<p>Because the data argument comes first, <code>setNames()</code> also
works well with the magrittr-pipe operator. When no first argument is
given, the result is a named vector (this is rather untypical as
required arguments usually come first):</p>
<p><code>unname()</code> removes existing names (or dimnames) by setting
them to <code>NULL</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What does <code>dim()</code> return when applied to a 1-dimensional
vector? When might you use <code>NROW()</code> or
<code>NCOL()</code>?</li>
</ol>
<pre class="r"><code>dim(1:3)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>nrow(1:12)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>NROW(1:12)</code></pre>
<pre><code>#&gt; [1] 12</code></pre>
<pre class="r"><code>ncol(1:12)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>NCOL(1:12)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<p>Answers: <code>NULL</code>. <code>NROW</code> and <code>NCOL</code>
are useful when comparing <code>NULL</code> dimensional vectors with
matrices and arrays.</p>
<p>AR Solutions: From <code>?nrow</code>:</p>
<blockquote>
<p><code>dim()</code> will return <code>NULL</code> when applied to a 1d
vector.</p>
</blockquote>
<p>One may want to use <code>NROW()</code> or <code>NCOL()</code> to
handle atomic vectors, lists and NULL values in the same way as one
column matrices or data frames.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>How would you describe the following three objects? What makes them
different from <code>1:5</code>?</li>
</ol>
<pre class="r"><code>x1 &lt;- array(1:5, c(1, 1, 5))
x2 &lt;- array(1:5, c(1, 5, 1))
x3 &lt;- array(1:5, c(5, 1, 1))

x1</code></pre>
<pre><code>#&gt; , , 1
#&gt; 
#&gt;      [,1]
#&gt; [1,]    1
#&gt; 
#&gt; , , 2
#&gt; 
#&gt;      [,1]
#&gt; [1,]    2
#&gt; 
#&gt; , , 3
#&gt; 
#&gt;      [,1]
#&gt; [1,]    3
#&gt; 
#&gt; , , 4
#&gt; 
#&gt;      [,1]
#&gt; [1,]    4
#&gt; 
#&gt; , , 5
#&gt; 
#&gt;      [,1]
#&gt; [1,]    5</code></pre>
<pre class="r"><code>x2</code></pre>
<pre><code>#&gt; , , 1
#&gt; 
#&gt;      [,1] [,2] [,3] [,4] [,5]
#&gt; [1,]    1    2    3    4    5</code></pre>
<pre class="r"><code>x3</code></pre>
<pre><code>#&gt; , , 1
#&gt; 
#&gt;      [,1]
#&gt; [1,]    1
#&gt; [2,]    2
#&gt; [3,]    3
#&gt; [4,]    4
#&gt; [5,]    5</code></pre>
<p>Answer: They have a 3-dimensional structure, arranged in different
ways, along the z, x, and y axis.</p>
<p>AR Solutions: These are all “one dimensional”. If you imagine a 3d
cube, <code>x1</code> is in the x-dimension, <code>x2</code> is in the
y-dimension, and <code>x3</code> is in the z-dimension. In contrast to
<code>1:5</code>, <code>x1</code>, <code>x2</code> and <code>x3</code>
have a <code>dim</code> attribute.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>An early draft used this code to illustrate
<code>structure()</code>:</li>
</ol>
<pre class="r"><code>structure(1:5, comment = &quot;my attribute&quot;)</code></pre>
<pre><code>#&gt; [1] 1 2 3 4 5</code></pre>
<pre><code>But when you print that object you don&#39;t see the comment attribute.
Why? Is the attribute missing, or is there something else special about
it? (Hint: try using help.)</code></pre>
<pre class="r"><code>factor(&quot;green&quot;, levels = c(&quot;red&quot;, &quot;amber&quot;, &quot;green&quot;))</code></pre>
<pre><code>#&gt; [1] green
#&gt; Levels: red amber green</code></pre>
<pre class="r"><code>dput(factor(&quot;green&quot;, levels = c(&quot;red&quot;, &quot;amber&quot;, &quot;green&quot;)))</code></pre>
<pre><code>#&gt; structure(3L, levels = c(&quot;red&quot;, &quot;amber&quot;, &quot;green&quot;), class = &quot;factor&quot;)</code></pre>
<p>Answer: print doesn’t display the attributes for arbitrary
structures, only defined classes, like factors (for example, above).</p>
<p>AR Solutions: The documentation states (see
<code>?comment</code>):</p>
<blockquote>
<p>Contrary to other attributes, the comment is not printed (by print or
print.default).</p>
</blockquote>
<p>Also, from <code>?attributes</code>:</p>
<blockquote>
<p>Note that some attributes (namely class, comment, dim, dimnames,
names, row.names and tsp) are treated specially and have restrictions on
the values which can be set.</p>
</blockquote>
<hr />
</div>
<div id="exercises-6" class="section level2">
<h2>3.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What sort of object does <code>table()</code> return? What is its
type? What attributes does it have? How does the dimensionality change
as you tabulate more variables?</li>
</ol>
<pre class="r"><code>a &lt;- letters[1:3]
a_table &lt;- table(a, sample(a))
a_table</code></pre>
<pre><code>#&gt;    
#&gt; a   a b c
#&gt;   a 0 1 0
#&gt;   b 1 0 0
#&gt;   c 0 0 1</code></pre>
<pre class="r"><code>typeof(a_table)</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>attributes(a_table)</code></pre>
<pre><code>#&gt; $dim
#&gt; [1] 3 3
#&gt; 
#&gt; $dimnames
#&gt; $dimnames$a
#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
#&gt; 
#&gt; $dimnames[[2]]
#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
#&gt; 
#&gt; 
#&gt; $class
#&gt; [1] &quot;table&quot;</code></pre>
<pre class="r"><code>b &lt;- letters[1:4]
b_table &lt;- table(b, sample(b))
b_table</code></pre>
<pre><code>#&gt;    
#&gt; b   a b c d
#&gt;   a 0 0 0 1
#&gt;   b 0 1 0 0
#&gt;   c 0 0 1 0
#&gt;   d 1 0 0 0</code></pre>
<pre class="r"><code>attributes(b_table)</code></pre>
<pre><code>#&gt; $dim
#&gt; [1] 4 4
#&gt; 
#&gt; $dimnames
#&gt; $dimnames$b
#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;
#&gt; 
#&gt; $dimnames[[2]]
#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;
#&gt; 
#&gt; 
#&gt; $class
#&gt; [1] &quot;table&quot;</code></pre>
<p>Answer: an object of class “table”, an array of integer values, with
type “integer”. Attributes listed above, the dimensionality is always n
by n, where n is the number of variables tabulated.</p>
<p>AR Solutions: <code>table()</code> returns a contingency table of its
input variables. It is implemented as an integer vector with class
<code>table</code> and dimensions (which makes it act like an array).
Its attributes are <code>dim</code> (dimensions) and
<code>dimnames</code> (one name for each input column). The dimensions
correspond to the number of unique values (factor levels) in each input
variable.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What happens to a factor when you modify its levels?</li>
</ol>
<pre class="r"><code>f1 &lt;- factor(letters)
f1</code></pre>
<pre><code>#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z</code></pre>
<pre class="r"><code>levels(f1) &lt;- rev(levels(f1))
f1</code></pre>
<pre><code>#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a
#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a</code></pre>
<p>Answer: <del>the factor will remain the same, but the attributes will
change.</del> the factor and its levels are reversed.</p>
<p>AR Solutions: The underlying integer values stay the same, but the
levels are changed, making it look like the data has changed.</p>
<pre class="r"><code>f1 &lt;- factor(letters)
f1</code></pre>
<pre><code>#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z</code></pre>
<pre class="r"><code>as.integer(f1)</code></pre>
<pre><code>#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</code></pre>
<pre class="r"><code>levels(f1) &lt;- rev(levels(f1))
f1</code></pre>
<pre><code>#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a
#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does this code do? How do <code>f2</code> and <code>f3</code>
differ from <code>f1</code>?</li>
</ol>
<pre class="r"><code>f2 &lt;- rev(factor(letters))
f2</code></pre>
<pre><code>#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a
#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z</code></pre>
<pre class="r"><code>f3 &lt;- factor(letters, levels = rev(letters))
f3</code></pre>
<pre><code>#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a</code></pre>
<p>Answer: both create a reversed list of letters. f3 also has reversed
levels but f2 does not. (correct!)</p>
<p>AR Solutions: For <code>f2</code> and <code>f3</code> either the
order of the factor elements <em>or</em> its levels are being reversed.
For <code>f1</code> both transformations are occurring.</p>
<hr />
</div>
<div id="exercises-7" class="section level2">
<h2>3.5.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>List all the ways that a list differs from an atomic vector.</li>
</ol>
<p>Answers:</p>
<ul>
<li>Each element can be a different type</li>
<li>Each element is a reference to an object</li>
<li>List size can be smaller since elements are references</li>
<li>Lists can contain other lists</li>
</ul>
<p>AR Solutions: To summarise:</p>
<ul>
<li>Atomic vectors are always homogeneous (all elements must be of the
same type). Lists may be heterogeneous (the elements can be of different
types) as described in the <a
href="https://adv-r.hadley.nz/vectors-chap.html#introduction">introduction
of the vectors chapter</a>.</li>
<li>Atomic vectors point to one address in memory, while lists contain a
separate reference for each element. (This was described in the list
sections of the <a
href="https://adv-r.hadley.nz/vectors-chap.html#lists">vectors</a> and
the <a
href="https://adv-r.hadley.nz/names-values.html#list-references">names
and values</a> chapters.)</li>
<li>Subsetting with out-of-bounds and <code>NA</code> values leads to
different output. For example, <code>[</code> returns <code>NA</code>
for atomics and <code>NULL</code> for lists. (This is described in more
detail within the <a
href="https://adv-r.hadley.nz/subsetting.html">subsetting
chapter</a>.)</li>
</ul>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Why do you need to use <code>unlist()</code> to convert a list to an
atomic vector? Why doesn’t <code>as.vector()</code> work?</li>
</ol>
<pre class="r"><code>is.vector(list(1:4))</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>dput(as.vector(list(1:4)))</code></pre>
<pre><code>#&gt; list(1:4)</code></pre>
<p>Answer: a list is considered a vector by
<code>as.vector()</code>.</p>
<p>AR Solutions: A list is already a vector, though not an atomic
one!</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Compare and contrast <code>c()</code> and <code>unlist()</code> when
combining a date and date-time into a single vector.</li>
</ol>
<pre class="r"><code>d &lt;- list(date = as.Date(&quot;2022-06-25&quot;), datetime = as.POSIXct(&quot;2022-06-25 09:59:40 CDT&quot;))
dput(d)</code></pre>
<pre><code>#&gt; list(date = structure(19168, class = &quot;Date&quot;), datetime = structure(1656169180, class = c(&quot;POSIXct&quot;, 
#&gt; &quot;POSIXt&quot;), tzone = &quot;&quot;))</code></pre>
<pre class="r"><code>dput(c(d)) # nolint: unneeded_concatenation_linter.</code></pre>
<pre><code>#&gt; list(date = structure(19168, class = &quot;Date&quot;), datetime = structure(1656169180, class = c(&quot;POSIXct&quot;, 
#&gt; &quot;POSIXt&quot;), tzone = &quot;&quot;))</code></pre>
<pre class="r"><code>dput(unlist(d))</code></pre>
<pre><code>#&gt; c(date = 19168, datetime = 1656169180)</code></pre>
<p>Answer: <code>c()</code> preserves the list structure.
<code>unlist()</code> converts both to <code>double</code>.</p>
<p>AR Solutions: Date and date-time objects are both built upon doubles.
While dates store the number of days since the reference date 1970-01-01
(also known as “the Epoch”) in days, date-time-objects (POSIXct) store
the time difference to this date in seconds.</p>
<pre class="r"><code>date &lt;- as.Date(&quot;1970-01-02&quot;)
dttm_ct &lt;- as.POSIXct(&quot;1970-01-01 01:00&quot;, tz = &quot;UTC&quot;)
# Internal representations
unclass(date)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>unclass(dttm_ct)</code></pre>
<pre><code>#&gt; [1] 3600
#&gt; attr(,&quot;tzone&quot;)
#&gt; [1] &quot;UTC&quot;</code></pre>
<p>As the <code>c()</code> generic only dispatches on its first
argument, combining date and date-time objects via <code>c()</code>
could lead to surprising results in older R versions (pre R 4.0.0):</p>
<pre class="r"><code># Output in R version 3.6.2
c(date, dttm_ct) # equal to c.Date(date, dttm_ct)
#&gt; [1] &quot;1970-01-02&quot; &quot;1979-11-10&quot;
c(dttm_ct, date) # equal to c.POSIXct(date, dttm_ct)
#&gt; [1] &quot;1970-01-01 02:00:00 CET&quot; &quot;1970-01-01 01:00:01 CET&quot;</code></pre>
<p>In the first statement above <code>c.Date()</code> is executed, which
incorrectly treats the underlying double of <code>dttm_ct</code> (3600)
as days instead of seconds. Conversely, when <code>c.POSIXct()</code> is
called on a date, one day is counted as one second only.</p>
<p>We can highlight these mechanics by the following code:</p>
<pre class="r"><code># Output in R version 3.6.2
unclass(c(date, dttm_ct)) # internal representation
#&gt; [1] 1 3600
date + 3599
#&gt; &quot;1979-11-10&quot;</code></pre>
<p>As of R 4.0.0 these issues have been resolved and both methods now
convert their input first into <code>POSIXct</code> and
<code>Date</code>, respectively.</p>
<pre class="r"><code>c(dttm_ct, date)</code></pre>
<pre><code>#&gt; [1] &quot;1970-01-01 01:00:00 UTC&quot; &quot;1970-01-02 00:00:00 UTC&quot;</code></pre>
<pre class="r"><code>unclass(c(dttm_ct, date))</code></pre>
<pre><code>#&gt; [1]  3600 86400
#&gt; attr(,&quot;tzone&quot;)
#&gt; [1] &quot;UTC&quot;</code></pre>
<pre class="r"><code>c(date, dttm_ct)</code></pre>
<pre><code>#&gt; [1] &quot;1970-01-02&quot; &quot;1970-01-01&quot;</code></pre>
<pre class="r"><code>unclass(c(date, dttm_ct))</code></pre>
<pre><code>#&gt; [1] 1 0</code></pre>
<p>However, as <code>c()</code> strips the time zone (and other
attributes) of <code>POSIXct</code> objects, some caution is still
recommended.</p>
<pre class="r"><code>(dttm_ct &lt;- as.POSIXct(&quot;1970-01-01 01:00&quot;, tz = &quot;HST&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;1970-01-01 01:00:00 HST&quot;</code></pre>
<pre class="r"><code>attributes(c(dttm_ct)) # nolint: unneeded_concatenation_linter.</code></pre>
<pre><code>#&gt; $class
#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; 
#&gt; 
#&gt; $tzone
#&gt; [1] &quot;HST&quot;</code></pre>
<p>A package that deals with these kinds of problems in more depth and
provides a structural solution for them is the <a
href="https://github.com/r-lib/vctrs"><code>vctrs</code> package</a>
which is also used throughout the tidyverse.</p>
<p>Let’s look at <code>unlist()</code>, which operates on list
input.</p>
<pre class="r"><code># Attributes are stripped
unlist(list(date, dttm_ct))</code></pre>
<pre><code>#&gt; [1]     1 39600</code></pre>
<p>We see again that dates and date-times are internally stored as
doubles. Unfortunately, this is all we are left with, when unlist strips
the attributes of the list.</p>
<p>To summarise: <code>c()</code> coerces types and strips time zones.
Errors may have occurred in older R versions because of inappropriate
method dispatch/immature methods. <code>unlist()</code> strips
attributes.</p>
<hr />
</div>
<div id="exercises-8" class="section level2">
<h2>3.6.8 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Can you have a data frame with zero rows? What about zero
columns?</li>
</ol>
<pre class="r"><code># from data.frame() examples:
df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9)

df</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"7"},{"1":"2","2":"5","3":"8"},{"1":"3","2":"6","3":"9"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[, FALSE]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[],"data":[],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[FALSE, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["int"],"align":["right"]}],"data":[],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[FALSE, FALSE]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[],"data":[],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: yes!</p>
<p>AR Solutions: Yes, you can create these data frames easily; either
during creation or via subsetting. Even both dimensions can be zero.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What happens if you attempt to set rownames that are not
unique?</li>
</ol>
<pre class="r"><code>rownames(df)</code></pre>
<pre><code>#&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</code></pre>
<pre class="r"><code>try(rownames(df) &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;))</code></pre>
<pre><code>#&gt; Warning: non-unique value when setting &#39;row.names&#39;: &#39;a&#39;</code></pre>
<pre><code>#&gt; Error in `.rowNamesDF&lt;-`(x, value = value) : 
#&gt;   duplicate &#39;row.names&#39; are not allowed</code></pre>
<p>Answer: error, duplicates not allowed.</p>
<p>AR Solutions: Matrices can have duplicated row names, so this does
not cause problems.</p>
<p>Data frames, however, require unique rownames and you get different
results depending on how you attempt to set them. If you set them
directly or via <code>row.names()</code>, you get an error. If you use
subsetting, <code>[</code> automatically deduplicates.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>If <code>df</code> is a data frame, what can you say about
<code>t(df)</code>, and <code>t(t(df))</code>? Perform some experiments,
making sure to try different column types.</li>
</ol>
<pre class="r"><code>t(df)</code></pre>
<pre><code>#&gt;   [,1] [,2] [,3]
#&gt; x    1    2    3
#&gt; y    4    5    6
#&gt; z    7    8    9</code></pre>
<pre class="r"><code>t(t(df))</code></pre>
<pre><code>#&gt;      x y z
#&gt; [1,] 1 4 7
#&gt; [2,] 2 5 8
#&gt; [3,] 3 6 9</code></pre>
<pre class="r"><code>df2 &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), z = 4L:6L, stringsAsFactors = FALSE)
df2</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["chr"],"align":["left"]},{"label":["z"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"a","3":"4"},{"1":"2","2":"b","3":"5"},{"1":"3","2":"c","3":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>t(df2)</code></pre>
<pre><code>#&gt;   [,1] [,2] [,3]
#&gt; x &quot;1&quot;  &quot;2&quot;  &quot;3&quot; 
#&gt; y &quot;a&quot;  &quot;b&quot;  &quot;c&quot; 
#&gt; z &quot;4&quot;  &quot;5&quot;  &quot;6&quot;</code></pre>
<pre class="r"><code>t(t(df2))</code></pre>
<pre><code>#&gt;      x   y   z  
#&gt; [1,] &quot;1&quot; &quot;a&quot; &quot;4&quot;
#&gt; [2,] &quot;2&quot; &quot;b&quot; &quot;5&quot;
#&gt; [3,] &quot;3&quot; &quot;c&quot; &quot;6&quot;</code></pre>
<p>Answer: <code>t()</code> coerces the vector types, so
<code>t(t(df))</code> is the same as <code>df</code> only when all
columns are the same type.</p>
<p>AR Solutions: Both of <code>t(df)</code> and <code>t(t(df))</code>
will return matrices:</p>
<pre class="r"><code>df &lt;- data.frame(x = 1:3, y = letters[1:3])
is.matrix(df)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>is.matrix(t(df))</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>is.matrix(t(t(df)))</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<p>The dimensions will respect the typical transposition rules:</p>
<pre class="r"><code>dim(df)</code></pre>
<pre><code>#&gt; [1] 3 2</code></pre>
<pre class="r"><code>dim(t(df))</code></pre>
<pre><code>#&gt; [1] 2 3</code></pre>
<pre class="r"><code>dim(t(t(df)))</code></pre>
<pre><code>#&gt; [1] 3 2</code></pre>
<p>Because the output is a matrix, every column is coerced to the same
type. (It is implemented within <code>t.data.frame()</code> via
<code>as.matrix()</code> which is described below).</p>
<pre class="r"><code>df</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["chr"],"align":["left"]}],"data":[{"1":"1","2":"a"},{"1":"2","2":"b"},{"1":"3","2":"c"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>t(df)</code></pre>
<pre><code>#&gt;   [,1] [,2] [,3]
#&gt; x &quot;1&quot;  &quot;2&quot;  &quot;3&quot; 
#&gt; y &quot;a&quot;  &quot;b&quot;  &quot;c&quot;</code></pre>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What does <code>as.matrix()</code> do when applied to a data frame
with columns of different types? How does it differ from
<code>data.matrix()</code>?</li>
</ol>
<pre class="r"><code>as.matrix(df)</code></pre>
<pre><code>#&gt;      x   y  
#&gt; [1,] &quot;1&quot; &quot;a&quot;
#&gt; [2,] &quot;2&quot; &quot;b&quot;
#&gt; [3,] &quot;3&quot; &quot;c&quot;</code></pre>
<pre class="r"><code>as.matrix(df2)</code></pre>
<pre><code>#&gt;      x   y   z  
#&gt; [1,] &quot;1&quot; &quot;a&quot; &quot;4&quot;
#&gt; [2,] &quot;2&quot; &quot;b&quot; &quot;5&quot;
#&gt; [3,] &quot;3&quot; &quot;c&quot; &quot;6&quot;</code></pre>
<pre class="r"><code>data.matrix(df2)</code></pre>
<pre><code>#&gt;      x y z
#&gt; [1,] 1 1 4
#&gt; [2,] 2 2 5
#&gt; [3,] 3 3 6</code></pre>
<pre class="r"><code>as.data.frame(data.matrix(df2))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"4"},{"1":"2","2":"2","3":"5"},{"1":"3","2":"3","3":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>as.data.frame(data.matrix(data.frame(x = 1:3, y = c(0, 0.5, 1), z = 4:6)))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["z"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"0.0","3":"4"},{"1":"2","2":"0.5","3":"5"},{"1":"3","2":"1.0","3":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: <code>as.matrix()</code> coerces all elements to the same
type. <code>data.matrix()</code> coerces elements to either integer
(when possible) or double (when not).</p>
<p>AR Solutions: The type of the result of <code>as.matrix</code>
depends on the types of the input columns (see
<code>?as.matrix</code>):</p>
<blockquote>
<p>The method for data frames will return a character matrix if there is
only atomic columns and any non-(numeric/logical/complex) column,
applying as.vector to factors and format to other non-character columns.
Otherwise the usual coercion hierarchy (logical &lt; integer &lt; double
&lt; complex) will be used, e.g. all-logical data frames will be coerced
to a logical matrix, mixed logical-integer will give an integer matrix,
etc.</p>
</blockquote>
<p>On the other hand, <code>data.matrix</code> will always return a
numeric matrix (see <code>?data.matrix()</code>).</p>
<blockquote>
<p>Return the matrix obtained by converting all the variables in a data
frame to numeric mode and then binding them together as the columns of a
matrix. Factors and ordered factors are replaced by their internal
codes. […] Character columns are first converted to factors and then to
integers.</p>
</blockquote>
<p>We can illustrate and compare the mechanics of these functions using
a concrete example. <code>as.matrix()</code> makes it possible to
retrieve most of the original information from the data frame but leaves
us with characters. To retrieve all information from
<code>data.matrix()</code>’s output, we would need a lookup table for
each column.</p>
<hr />
</div>
</div>
<div id="subsetting" class="section level1">
<h1>4 Subsetting</h1>
<p>R’s subsetting operators are fast and powerful. Mastering them allows
you to succinctly perform complex operations in a way that few other
languages can match. Subsetting in R is easy to learn but hard to master
because you need to internalise a number of interrelated concepts:</p>
<ul>
<li><p>There are six ways to subset atomic vectors.</p></li>
<li><p>There are three subsetting operators, <code>[[</code>,
<code>[</code>, and <code>$</code>.</p></li>
<li><p>Subsetting operators interact differently with different vector
types (e.g., atomic vectors, lists, factors, matrices, and data
frames).</p></li>
<li><p>Subsetting can be combined with assignment.</p></li>
</ul>
<p>Subsetting is a natural complement to <code>str()</code>. While
<code>str()</code> shows you all the pieces of any object (its
structure), subsetting allows you to pull out the pieces that you’re
interested in. For large, complex objects, I highly recommend using the
interactive RStudio Viewer, which you can activate with
<code>View(my_object)</code>.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-9" class="section level2">
<h2>4.2.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Fix each of the following common data frame subsetting errors:</li>
</ol>
<pre class="r"><code># nolint start: commented_code_linter.
# mtcars[mtcars$cyl = 4, ]
mtcars[mtcars$cyl == 4, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># use `==`              (instead of `=`)

# mtcars[-1:4, ]
mtcars[-(1:4), ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"18.7","2":"8","3":"360.0","4":"175","5":"3.15","6":"3.440","7":"17.02","8":"0","9":"0","10":"3","11":"2","_rn_":"Hornet Sportabout"},{"1":"18.1","2":"6","3":"225.0","4":"105","5":"2.76","6":"3.460","7":"20.22","8":"1","9":"0","10":"3","11":"1","_rn_":"Valiant"},{"1":"14.3","2":"8","3":"360.0","4":"245","5":"3.21","6":"3.570","7":"15.84","8":"0","9":"0","10":"3","11":"4","_rn_":"Duster 360"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"19.2","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.30","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280"},{"1":"17.8","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.90","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"16.4","2":"8","3":"275.8","4":"180","5":"3.07","6":"4.070","7":"17.40","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SE"},{"1":"17.3","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.730","7":"17.60","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SL"},{"1":"15.2","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.780","7":"18.00","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SLC"},{"1":"10.4","2":"8","3":"472.0","4":"205","5":"2.93","6":"5.250","7":"17.98","8":"0","9":"0","10":"3","11":"4","_rn_":"Cadillac Fleetwood"},{"1":"10.4","2":"8","3":"460.0","4":"215","5":"3.00","6":"5.424","7":"17.82","8":"0","9":"0","10":"3","11":"4","_rn_":"Lincoln Continental"},{"1":"14.7","2":"8","3":"440.0","4":"230","5":"3.23","6":"5.345","7":"17.42","8":"0","9":"0","10":"3","11":"4","_rn_":"Chrysler Imperial"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"15.5","2":"8","3":"318.0","4":"150","5":"2.76","6":"3.520","7":"16.87","8":"0","9":"0","10":"3","11":"2","_rn_":"Dodge Challenger"},{"1":"15.2","2":"8","3":"304.0","4":"150","5":"3.15","6":"3.435","7":"17.30","8":"0","9":"0","10":"3","11":"2","_rn_":"AMC Javelin"},{"1":"13.3","2":"8","3":"350.0","4":"245","5":"3.73","6":"3.840","7":"15.41","8":"0","9":"0","10":"3","11":"4","_rn_":"Camaro Z28"},{"1":"19.2","2":"8","3":"400.0","4":"175","5":"3.08","6":"3.845","7":"17.05","8":"0","9":"0","10":"3","11":"2","_rn_":"Pontiac Firebird"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"15.8","2":"8","3":"351.0","4":"264","5":"4.22","6":"3.170","7":"14.50","8":"0","9":"1","10":"5","11":"4","_rn_":"Ford Pantera L"},{"1":"19.7","2":"6","3":"145.0","4":"175","5":"3.62","6":"2.770","7":"15.50","8":"0","9":"1","10":"5","11":"6","_rn_":"Ferrari Dino"},{"1":"15.0","2":"8","3":"301.0","4":"335","5":"3.54","6":"3.570","7":"14.60","8":"0","9":"1","10":"5","11":"8","_rn_":"Maserati Bora"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># use `-(1:4)`          (instead of `-1:4`)

# mtcars[mtcars$cyl &lt;= 5]
mtcars[mtcars$cyl &lt;= 5, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># `,` is missing

# mtcars[mtcars$cyl == 4 | 6, ]
mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.620","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4"},{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.875","7":"17.02","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4 Wag"},{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"21.4","2":"6","3":"258.0","4":"110","5":"3.08","6":"3.215","7":"19.44","8":"1","9":"0","10":"3","11":"1","_rn_":"Hornet 4 Drive"},{"1":"18.1","2":"6","3":"225.0","4":"105","5":"2.76","6":"3.460","7":"20.22","8":"1","9":"0","10":"3","11":"1","_rn_":"Valiant"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"19.2","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.30","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280"},{"1":"17.8","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.90","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"19.7","2":"6","3":"145.0","4":"175","5":"3.62","6":"2.770","7":"15.50","8":"0","9":"1","10":"5","11":"6","_rn_":"Ferrari Dino"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># use `mtcars$cyl == 6` (instead of `6`)
#  or `%in% c(4, 6)`    (instead of `== 4 | 6`)

# nolint end</code></pre>
<p>Answer: fixed!</p>
<p>AR solutions: see the comments below the fixed code.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Why does the following code yield five missing values? (Hint: why is
it different from <code>x[NA_real_]</code>?)</li>
</ol>
<pre class="r"><code>x &lt;- 1:5
x[NA]</code></pre>
<pre><code>#&gt; [1] NA NA NA NA NA</code></pre>
<pre class="r"><code>x[NA_real_]</code></pre>
<pre><code>#&gt; [1] NA</code></pre>
<pre class="r"><code>x[TRUE]</code></pre>
<pre><code>#&gt; [1] 1 2 3 4 5</code></pre>
<p>Answer: NA is a logical constant of length 1.</p>
<p>AR Solutions: In contrast to <code>NA_real</code>, <code>NA</code>
has logical type and logical vectors are recycled to the same length as
the vector being subset, i.e. <code>x[NA]</code> is recycled to
<code>x[c(NA, NA, NA, NA, NA)]</code>.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does <code>upper.tri()</code> return? How does subsetting a
matrix with it work? Do we need any additional subsetting rules to
describe its behaviour?</li>
</ol>
<pre class="r"><code>x &lt;- outer(1:5, 1:5, FUN = &quot;*&quot;)
x</code></pre>
<pre><code>#&gt;      [,1] [,2] [,3] [,4] [,5]
#&gt; [1,]    1    2    3    4    5
#&gt; [2,]    2    4    6    8   10
#&gt; [3,]    3    6    9   12   15
#&gt; [4,]    4    8   12   16   20
#&gt; [5,]    5   10   15   20   25</code></pre>
<pre class="r"><code>x[upper.tri(x)]</code></pre>
<pre><code>#&gt;  [1]  2  3  6  4  8 12  5 10 15 20</code></pre>
<p>Answer: <code>upper.tri()</code> returns a matrix of logicals, which
can be used to subset the upper triangle. This is subsetting by matrix,
which is new.</p>
<p>AR Solutions: <code>upper.tri(x)</code> returns a logical matrix,
which contains <code>TRUE</code> values above the diagonal and
<code>FALSE</code> values everywhere else. In <code>upper.tri()</code>
the positions for <code>TRUE</code> and <code>FALSE</code> values are
determined by comparing <code>x</code>’s row and column indices via
<code>.row(dim(x)) &lt; .col(dim(x))</code>.</p>
<p>When subsetting with logical matrices, all elements that correspond
to <code>TRUE</code> will be selected. Matrices extend vectors with a
dimension attribute, so the vector forms of subsetting can be used
(including logical subsetting). We should take care, that the dimensions
of the subsetting matrix match the object of interest — otherwise
unintended selections due to vector recycling may occur. Please also
note, that this form of subsetting returns a vector instead of a matrix,
as the subsetting alters the dimensions of the object.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Why does <code>mtcars[1:20]</code> return an error? How does it
differ from the similar <code>mtcars[1:20, ]</code>?</li>
</ol>
<pre class="r"><code>try(mtcars[1:20])</code></pre>
<pre><code>#&gt; Error in `[.data.frame`(mtcars, 1:20) : undefined columns selected</code></pre>
<pre class="r"><code>mtcars[1:20, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.620","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4"},{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.875","7":"17.02","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4 Wag"},{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"21.4","2":"6","3":"258.0","4":"110","5":"3.08","6":"3.215","7":"19.44","8":"1","9":"0","10":"3","11":"1","_rn_":"Hornet 4 Drive"},{"1":"18.7","2":"8","3":"360.0","4":"175","5":"3.15","6":"3.440","7":"17.02","8":"0","9":"0","10":"3","11":"2","_rn_":"Hornet Sportabout"},{"1":"18.1","2":"6","3":"225.0","4":"105","5":"2.76","6":"3.460","7":"20.22","8":"1","9":"0","10":"3","11":"1","_rn_":"Valiant"},{"1":"14.3","2":"8","3":"360.0","4":"245","5":"3.21","6":"3.570","7":"15.84","8":"0","9":"0","10":"3","11":"4","_rn_":"Duster 360"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"19.2","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.30","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280"},{"1":"17.8","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.90","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"16.4","2":"8","3":"275.8","4":"180","5":"3.07","6":"4.070","7":"17.40","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SE"},{"1":"17.3","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.730","7":"17.60","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SL"},{"1":"15.2","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.780","7":"18.00","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SLC"},{"1":"10.4","2":"8","3":"472.0","4":"205","5":"2.93","6":"5.250","7":"17.98","8":"0","9":"0","10":"3","11":"4","_rn_":"Cadillac Fleetwood"},{"1":"10.4","2":"8","3":"460.0","4":"215","5":"3.00","6":"5.424","7":"17.82","8":"0","9":"0","10":"3","11":"4","_rn_":"Lincoln Continental"},{"1":"14.7","2":"8","3":"440.0","4":"230","5":"3.23","6":"5.345","7":"17.42","8":"0","9":"0","10":"3","11":"4","_rn_":"Chrysler Imperial"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: <code>mtcars[1:20]</code> selects the first 20 columns, but
there are only 11. <code>mtcars[1:20, ]</code> selects the first 20 rows
of 32.</p>
<p>AR Solutions: When subsetting a data frame with a single vector, it
behaves the same way as subsetting a list of columns. So,
<code>mtcars[1:20]</code> would return a data frame containing the first
20 columns of the dataset. However, as <code>mtcars</code> has only 11
columns, the index will be out of bounds and an error is thrown.
<code>mtcars[1:20, ]</code> is subsetted with two vectors, so 2d
subsetting kicks in, and the first index refers to rows.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Implement your own function that extracts the diagonal entries from
a matrix (it should behave like <code>diag(x)</code> where
<code>x</code> is a matrix).</li>
</ol>
<pre class="r"><code>m &lt;- matrix(ncol = 3, byrow = TRUE, c(
  1, 4, 7,
  2, 5, 8,
  3, 6, 9
))
m</code></pre>
<pre><code>#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    4    7
#&gt; [2,]    2    5    8
#&gt; [3,]    3    6    9</code></pre>
<pre class="r"><code>diag(m)</code></pre>
<pre><code>#&gt; [1] 1 5 9</code></pre>
<pre class="r"><code>my_diag &lt;- function(x) {
  diag_element &lt;- function(n, x) {
    x[n, n]
  }
  vapply(seq_len(nrow(m)), diag_element, 1, x)
}
my_diag(m)</code></pre>
<pre><code>#&gt; [1] 1 5 9</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: The elements in the diagonal of a matrix have the same
row- and column indices. This characteristic can be used to create a
suitable numeric matrix used for subsetting.</p>
<pre class="r"><code>diag2 &lt;- function(x) {
  n &lt;- min(nrow(x), ncol(x))
  idx &lt;- cbind(seq_len(n), seq_len(n))
  x[idx]
}
# Let&#39;s check if it works
(x &lt;- matrix(1:30, 5))</code></pre>
<pre><code>#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]
#&gt; [1,]    1    6   11   16   21   26
#&gt; [2,]    2    7   12   17   22   27
#&gt; [3,]    3    8   13   18   23   28
#&gt; [4,]    4    9   14   19   24   29
#&gt; [5,]    5   10   15   20   25   30</code></pre>
<pre class="r"><code>diag(x)</code></pre>
<pre><code>#&gt; [1]  1  7 13 19 25</code></pre>
<pre class="r"><code>diag2(x)</code></pre>
<pre><code>#&gt; [1]  1  7 13 19 25</code></pre>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>What does <code>df[is.na(df)] &lt;- 0</code> do? How does it
work?</li>
</ol>
<p>Answer: sets the <code>NA</code> values in <code>df</code> to
<code>0</code>, by first selecting <code>NA</code> values then assigning
<code>0</code>.</p>
<pre class="r"><code>df &lt;- data.frame(x = c(1, 2, NA), y = c(4, NA, 6), z = c(NA, 8, 9))
df</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["z"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"NA"},{"1":"2","2":"NA","3":"8"},{"1":"NA","2":"6","3":"9"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[is.na(df)] &lt;- 0
df</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["z"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"0"},{"1":"2","2":"0","3":"8"},{"1":"0","2":"6","3":"9"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Correct!</p>
<p>AR Solutions: This expression replaces the <code>NA</code>s in
<code>df</code> with <code>0</code>. Here <code>is.na(df)</code> returns
a logical matrix that encodes the position of the missing values in
<code>df</code>. Subsetting and assignment are then combined to replace
only the missing values.</p>
<hr />
</div>
<div id="exercises-10" class="section level2">
<h2>4.3.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Brainstorm as many ways as possible to extract the third value from
the <code>cyl</code> variable in the <code>mtcars</code> dataset.</li>
</ol>
<pre class="r"><code>mtcars$cyl[3]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars$cyl[[3]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[[&quot;cyl&quot;]][[3]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[3, 2]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[[3, 2]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[[&quot;Datsun 710&quot;, &quot;cyl&quot;]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[-c(1:2, 4:32), -c(1, 3:11)]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<p>Answer: code above (some variations omitted). There are many
more.</p>
<p>AR Solutions: Base R already provides an abundance of
possibilities:</p>
<pre class="r"><code># Select column first
mtcars$cyl[[3]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[, &quot;cyl&quot;][[3]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[[&quot;cyl&quot;]][[3]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>with(mtcars, cyl[[3]])</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code># Select row first
mtcars[3, ]$cyl</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[3, &quot;cyl&quot;]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[3, ][, &quot;cyl&quot;]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[3, ][[&quot;cyl&quot;]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code># Select simultaneously
mtcars[3, 2]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[[c(2, 3)]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Given a linear model, e.g.,
<code>mod &lt;- lm(mpg ~ wt, data = mtcars)</code>, extract the residual
degrees of freedom. Then extract the R squared from the model summary
(<code>summary(mod)</code>)</li>
</ol>
<pre class="r"><code>mod &lt;- lm(mpg ~ wt, data = mtcars)
mod$df.residual</code></pre>
<pre><code>#&gt; [1] 30</code></pre>
<pre class="r"><code>mod_sum &lt;- summary(mod)
mod_sum$r.squared</code></pre>
<pre><code>#&gt; [1] 0.7528328</code></pre>
<pre class="r"><code>mod_sum</code></pre>
<pre><code>#&gt; 
#&gt; Call:
#&gt; lm(formula = mpg ~ wt, data = mtcars)
#&gt; 
#&gt; Residuals:
#&gt;     Min      1Q  Median      3Q     Max 
#&gt; -4.5432 -2.3647 -0.1252  1.4096  6.8727 
#&gt; 
#&gt; Coefficients:
#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    
#&gt; (Intercept)  37.2851     1.8776  19.858  &lt; 2e-16 ***
#&gt; wt           -5.3445     0.5591  -9.559 1.29e-10 ***
#&gt; ---
#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
#&gt; 
#&gt; Residual standard error: 3.046 on 30 degrees of freedom
#&gt; Multiple R-squared:  0.7528, Adjusted R-squared:  0.7446 
#&gt; F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: <code>mod</code> is of type list, which opens up
several possibilities. We use <code>$</code> or <code>[[</code> to
extract a single element:</p>
<pre class="r"><code>mod &lt;- lm(mpg ~ wt, data = mtcars)

mod$df.residual</code></pre>
<pre><code>#&gt; [1] 30</code></pre>
<pre class="r"><code>mod[[&quot;df.residual&quot;]]</code></pre>
<pre><code>#&gt; [1] 30</code></pre>
<p>The same also applies to <code>summary(mod)</code>, so we could use,
e.g.:</p>
<pre class="r"><code>summary(mod)$r.squared</code></pre>
<pre><code>#&gt; [1] 0.7528328</code></pre>
<p>(Tip: The <a
href="https://github.com/tidymodels/broom"><code>broom</code>
package</a> provides a very useful approach to work with models in a
tidy way.)</p>
<hr />
</div>
<div id="exercises-11" class="section level2">
<h2>4.5.9 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How would you randomly permute the columns of a data frame? (This is
an important technique in random forests.) Can you simultaneously
permute the rows and columns in one step?</li>
</ol>
<pre class="r"><code>df &lt;- data.frame(x = 1:5, y = 5:1, z = letters[1:5], row.names = 1:5)

df[, sample(ncol(df))]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["y"],"name":[1],"type":["int"],"align":["right"]},{"label":["x"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"5","2":"1","3":"a","_rn_":"1"},{"1":"4","2":"2","3":"b","_rn_":"2"},{"1":"3","2":"3","3":"c","_rn_":"3"},{"1":"2","2":"4","3":"d","_rn_":"4"},{"1":"1","2":"5","3":"e","_rn_":"5"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[sample(nrow(df)), sample(ncol(df))]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["z"],"name":[2],"type":["chr"],"align":["left"]},{"label":["y"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"a","3":"5","_rn_":"1"},{"1":"2","2":"b","3":"4","_rn_":"2"},{"1":"3","2":"c","3":"3","_rn_":"3"},{"1":"5","2":"e","3":"1","_rn_":"5"},{"1":"4","2":"d","3":"2","_rn_":"4"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: using <code>sample()</code>. Yes!</p>
<p>AR Solutions: This can be achieved by combining <code>[</code> and
<code>sample()</code>:</p>
<pre class="r"><code># Permute columns
mtcars[sample(ncol(mtcars))]

# Permute columns and rows in one step
mtcars[sample(nrow(mtcars)), sample(ncol(mtcars))]</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>How would you select a random sample of <code>m</code> rows from a
data frame? What if the sample had to be contiguous (i.e., with an
initial row, a final row, and every row in between)?</li>
</ol>
<pre class="r"><code>sample_rows &lt;- function(df, m, contiguous = FALSE) {
  if (m &gt; nrow(df)) {
    stop(&quot;sample size &#39;&quot;, m, &quot;&#39; is larger than the number of rows, &#39;&quot;, nrow(df), &quot;&#39;&quot;)
  }
  if (contiguous) {
    first_row &lt;- sample(nrow(df) - m + 1, 1)
    last_row &lt;- first_row + m - 1
    return(df[first_row:last_row, ])
  }
  df[sample(nrow(df), m), ]
}

sample_rows(df, 3)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"2","2":"4","3":"b","_rn_":"2"},{"1":"4","2":"2","3":"d","_rn_":"4"},{"1":"3","2":"3","3":"c","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>sample_rows(df, 3, contiguous = TRUE)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"3","2":"3","3":"c","_rn_":"3"},{"1":"4","2":"2","3":"d","_rn_":"4"},{"1":"5","2":"1","3":"e","_rn_":"5"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>try(sample_rows(df, 6))</code></pre>
<pre><code>#&gt; Error in sample_rows(df, 6) : 
#&gt;   sample size &#39;6&#39; is larger than the number of rows, &#39;5&#39;</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: Selecting <code>m</code> random rows from a data frame
can be achieved through subsetting.</p>
<pre class="r"><code>m &lt;- 10
mtcars[sample(nrow(mtcars), m), ]</code></pre>
<p>Holding successive lines together as a blocked sample requires only a
certain amount of caution in order to obtain the correct start and end
index.</p>
<pre class="r"><code>start &lt;- sample(nrow(mtcars) - m + 1, 1)
end &lt;- start + m - 1
mtcars[start:end, , drop = FALSE]</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>How could you put the columns in a data frame in alphabetical
order?</li>
</ol>
<pre class="r"><code>mtcars[sort(colnames(mtcars))]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["am"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["mpg"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"6","4":"160.0","5":"3.90","6":"4","7":"110","8":"21.0","9":"16.46","10":"0","11":"2.620","_rn_":"Mazda RX4"},{"1":"1","2":"4","3":"6","4":"160.0","5":"3.90","6":"4","7":"110","8":"21.0","9":"17.02","10":"0","11":"2.875","_rn_":"Mazda RX4 Wag"},{"1":"1","2":"1","3":"4","4":"108.0","5":"3.85","6":"4","7":"93","8":"22.8","9":"18.61","10":"1","11":"2.320","_rn_":"Datsun 710"},{"1":"0","2":"1","3":"6","4":"258.0","5":"3.08","6":"3","7":"110","8":"21.4","9":"19.44","10":"1","11":"3.215","_rn_":"Hornet 4 Drive"},{"1":"0","2":"2","3":"8","4":"360.0","5":"3.15","6":"3","7":"175","8":"18.7","9":"17.02","10":"0","11":"3.440","_rn_":"Hornet Sportabout"},{"1":"0","2":"1","3":"6","4":"225.0","5":"2.76","6":"3","7":"105","8":"18.1","9":"20.22","10":"1","11":"3.460","_rn_":"Valiant"},{"1":"0","2":"4","3":"8","4":"360.0","5":"3.21","6":"3","7":"245","8":"14.3","9":"15.84","10":"0","11":"3.570","_rn_":"Duster 360"},{"1":"0","2":"2","3":"4","4":"146.7","5":"3.69","6":"4","7":"62","8":"24.4","9":"20.00","10":"1","11":"3.190","_rn_":"Merc 240D"},{"1":"0","2":"2","3":"4","4":"140.8","5":"3.92","6":"4","7":"95","8":"22.8","9":"22.90","10":"1","11":"3.150","_rn_":"Merc 230"},{"1":"0","2":"4","3":"6","4":"167.6","5":"3.92","6":"4","7":"123","8":"19.2","9":"18.30","10":"1","11":"3.440","_rn_":"Merc 280"},{"1":"0","2":"4","3":"6","4":"167.6","5":"3.92","6":"4","7":"123","8":"17.8","9":"18.90","10":"1","11":"3.440","_rn_":"Merc 280C"},{"1":"0","2":"3","3":"8","4":"275.8","5":"3.07","6":"3","7":"180","8":"16.4","9":"17.40","10":"0","11":"4.070","_rn_":"Merc 450SE"},{"1":"0","2":"3","3":"8","4":"275.8","5":"3.07","6":"3","7":"180","8":"17.3","9":"17.60","10":"0","11":"3.730","_rn_":"Merc 450SL"},{"1":"0","2":"3","3":"8","4":"275.8","5":"3.07","6":"3","7":"180","8":"15.2","9":"18.00","10":"0","11":"3.780","_rn_":"Merc 450SLC"},{"1":"0","2":"4","3":"8","4":"472.0","5":"2.93","6":"3","7":"205","8":"10.4","9":"17.98","10":"0","11":"5.250","_rn_":"Cadillac Fleetwood"},{"1":"0","2":"4","3":"8","4":"460.0","5":"3.00","6":"3","7":"215","8":"10.4","9":"17.82","10":"0","11":"5.424","_rn_":"Lincoln Continental"},{"1":"0","2":"4","3":"8","4":"440.0","5":"3.23","6":"3","7":"230","8":"14.7","9":"17.42","10":"0","11":"5.345","_rn_":"Chrysler Imperial"},{"1":"1","2":"1","3":"4","4":"78.7","5":"4.08","6":"4","7":"66","8":"32.4","9":"19.47","10":"1","11":"2.200","_rn_":"Fiat 128"},{"1":"1","2":"2","3":"4","4":"75.7","5":"4.93","6":"4","7":"52","8":"30.4","9":"18.52","10":"1","11":"1.615","_rn_":"Honda Civic"},{"1":"1","2":"1","3":"4","4":"71.1","5":"4.22","6":"4","7":"65","8":"33.9","9":"19.90","10":"1","11":"1.835","_rn_":"Toyota Corolla"},{"1":"0","2":"1","3":"4","4":"120.1","5":"3.70","6":"3","7":"97","8":"21.5","9":"20.01","10":"1","11":"2.465","_rn_":"Toyota Corona"},{"1":"0","2":"2","3":"8","4":"318.0","5":"2.76","6":"3","7":"150","8":"15.5","9":"16.87","10":"0","11":"3.520","_rn_":"Dodge Challenger"},{"1":"0","2":"2","3":"8","4":"304.0","5":"3.15","6":"3","7":"150","8":"15.2","9":"17.30","10":"0","11":"3.435","_rn_":"AMC Javelin"},{"1":"0","2":"4","3":"8","4":"350.0","5":"3.73","6":"3","7":"245","8":"13.3","9":"15.41","10":"0","11":"3.840","_rn_":"Camaro Z28"},{"1":"0","2":"2","3":"8","4":"400.0","5":"3.08","6":"3","7":"175","8":"19.2","9":"17.05","10":"0","11":"3.845","_rn_":"Pontiac Firebird"},{"1":"1","2":"1","3":"4","4":"79.0","5":"4.08","6":"4","7":"66","8":"27.3","9":"18.90","10":"1","11":"1.935","_rn_":"Fiat X1-9"},{"1":"1","2":"2","3":"4","4":"120.3","5":"4.43","6":"5","7":"91","8":"26.0","9":"16.70","10":"0","11":"2.140","_rn_":"Porsche 914-2"},{"1":"1","2":"2","3":"4","4":"95.1","5":"3.77","6":"5","7":"113","8":"30.4","9":"16.90","10":"1","11":"1.513","_rn_":"Lotus Europa"},{"1":"1","2":"4","3":"8","4":"351.0","5":"4.22","6":"5","7":"264","8":"15.8","9":"14.50","10":"0","11":"3.170","_rn_":"Ford Pantera L"},{"1":"1","2":"6","3":"6","4":"145.0","5":"3.62","6":"5","7":"175","8":"19.7","9":"15.50","10":"0","11":"2.770","_rn_":"Ferrari Dino"},{"1":"1","2":"8","3":"8","4":"301.0","5":"3.54","6":"5","7":"335","8":"15.0","9":"14.60","10":"0","11":"3.570","_rn_":"Maserati Bora"},{"1":"1","2":"2","3":"4","4":"121.0","5":"4.11","6":"4","7":"109","8":"21.4","9":"18.60","10":"1","11":"2.780","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: using <code>sort(colnames)</code>.</p>
<p>AR Solutions: We combine <code>[</code> with <code>order()</code> or
<code>sort()</code>:</p>
<pre class="r"><code>mtcars[order(names(mtcars))]
mtcars[sort(names(mtcars))]</code></pre>
<hr />
</div>
</div>
<div id="control-flow" class="section level1">
<h1>5 Control flow</h1>
<p>There are two primary tools of control flow: choices and loops.
Choices, like <code>if</code> statements and <code>switch()</code>
calls, allow you to run different code depending on the input. Loops,
like <code>for</code> and <code>while</code>, allow you to repeatedly
run code, typically with changing options. I’d expect that you’re
already familiar with the basics of these functions so I’ll briefly
cover some technical details and then introduce some useful, but lesser
known, features.</p>
<p>The condition system (messages, warnings, and errors), which you’ll
learn about in Chapter 8, also provides non-local control flow.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-12" class="section level2">
<h2>5.2.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What type of vector does each of the following calls to
<code>ifelse()</code> return? Read the documentation and write down the
rules in your own words.</li>
</ol>
<pre class="r"><code>ifelse(TRUE, 1, &quot;no&quot;)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>typeof(ifelse(TRUE, 1, &quot;no&quot;)) # double</code></pre>
<pre><code>#&gt; [1] &quot;double&quot;</code></pre>
<pre class="r"><code>ifelse(FALSE, 1, &quot;no&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;no&quot;</code></pre>
<pre class="r"><code>typeof(ifelse(FALSE, 1, &quot;no&quot;)) # character</code></pre>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
<pre class="r"><code>ifelse(NA, 1, &quot;no&quot;)</code></pre>
<pre><code>#&gt; [1] NA</code></pre>
<pre class="r"><code>typeof(ifelse(NA, 1, &quot;no&quot;)) # logical</code></pre>
<pre><code>#&gt; [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>ifelse(NULL, 1, &quot;no&quot;)</code></pre>
<pre><code>#&gt; logical(0)</code></pre>
<p>Answer:</p>
<ul>
<li>if <code>test</code> is true, return a vector of the same length as
<code>test</code> (1) populated with “yes” - here 1 is a double, 1L
would be integer</li>
<li>if <code>test</code> is false, return a vector of the same length as
<code>test</code> (1) populated with “no” - here “no” is a
character</li>
<li>if <code>test</code> is <code>NA</code>, return <code>NA</code>, and
if <code>test</code> is <code>NULL</code>, return
<code>logical(0)</code></li>
</ul>
<p>AR Solutions: The arguments of <code>ifelse()</code> are named
<code>test</code>, <code>yes</code> and <code>no</code>. In general,
<code>ifelse()</code> returns the entry for <code>yes</code> when
<code>test</code> is <code>TRUE</code>, the entry for <code>no</code>
when <code>test</code> is <code>FALSE</code> and <code>NA</code> when
<code>test</code> is <code>NA</code>. Therefore, the expressions above
return vectors of type <code>double</code> (<code>1</code>),
<code>character</code> (<code>"no"</code>) and <code>logical</code>
(<code>NA</code>).</p>
<p>To be a little more precise, we will cite the part of the
documentation on the return value of <code>ifelse()</code>:</p>
<blockquote>
<p>A vector of the same length and attributes (including dimensions and
“class”) as test and data values from the values of yes or no. The mode
of the answer will be coerced from logical to accommodate first any
values taken from yes and then any values taken from no.</p>
</blockquote>
<p>This is surprising because it uses the type of <code>test</code>. In
practice this means, that <code>test</code> is first converted to
logical and if the result is neither <code>TRUE</code> nor
<code>FALSE</code>, simply <code>as.logical(test)</code> is
returned.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Why does the following code work?</li>
</ol>
<pre class="r"><code>x &lt;- 1:10
if (length(x)) &quot;not empty&quot; else &quot;empty&quot;</code></pre>
<pre><code>#&gt; [1] &quot;not empty&quot;</code></pre>
<pre class="r"><code>x &lt;- numeric()
if (length(x)) &quot;not empty&quot; else &quot;empty&quot;</code></pre>
<pre><code>#&gt; [1] &quot;empty&quot;</code></pre>
<p>Answer: in the first example, <code>length(x)</code> is nonzero,
which evaluates to <code>TRUE</code>. In the second example,
<code>numeric()</code> returns a vector of length 0 (the default),
<code>length(x)</code> is zero, which evaluates to
<code>FALSE</code>.</p>
<p>AR Solutions: <code>if()</code> expects a logical condition, but also
accepts a numeric vector where <code>0</code> is treated as
<code>FALSE</code> and all other numbers are treated as
<code>TRUE</code>. Numerical missing values (including <code>NaN</code>)
lead to an error in the same way that a logical missing,
<code>NA</code>, does.</p>
<hr />
</div>
<div id="exercises-13" class="section level2">
<h2>5.3.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Why does this code succeed without errors or warnings?</li>
</ol>
<pre class="r"><code>x &lt;- numeric() # x is numeric(0)
out &lt;- vector(&quot;list&quot;, length(x)) # out is list(0)
for (i in 1:length(x)) { # nolint: seq_linter. i is 1, then 0.
  out[i] &lt;- x[i]^2 # when i = 1 x[1] is NA, sets out[1] to NA. when i = 0 nothing happens
}
out</code></pre>
<pre><code>#&gt; [[1]]
#&gt; [1] NA</code></pre>
<p>Answer: in addition to notes above, <code>out[0]</code> and
<code>x[0]</code> return a zero-length vector.</p>
<p>AR Solutions: This loop is a delicate issue, and we have to consider
a few points to explain why it is evaluated without raising any errors
or warnings.</p>
<p>The beginning of this code smell is the statement
<code>1:length(x)</code> which creates the index of the for loop. As
<code>x</code> has length 0 <code>1:length(x)</code> counts down from 1
to 0. This issue is typically avoided via usage of
<code>seq_along(x)</code> or similar helpers which would just generate
<code>integer(0)</code> in this case.</p>
<p>As we use <code>[&lt;-</code> and <code>[</code> for indexing
0-length vectors at their first and zeroth position, we need to be aware
of their subsetting behaviour for out-of-bounds and zero indices.</p>
<p>During the first iteration <code>x[1]</code> will generate an
<code>NA</code> (out-of-bounds indexing for atomics). The resulting
<code>NA</code> (from squaring) will be assigned to the empty length-1
list <code>out[1]</code> (out-of-bounds indexing for lists).</p>
<p>In the next iteration, <code>x[0]</code> will return
<code>numeric(0)</code> (zero indexing for atomics). Again, squaring
doesn’t change the value and <code>numeric(0)</code> is assigned to
<code>out[0]</code> (zero indexing for lists). Assigning a 0-length
vector to a 0-length subset works but doesn’t change the object.</p>
<p>Overall, the code works, because each step includes valid R
operations (even though the result may not be what the user
intended).</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>When the following code is evaluated, what can you say about the
vector being iterated?</li>
</ol>
<pre class="r"><code>xs &lt;- c(1, 2, 3)
for (x in xs) {
  xs &lt;- c(xs, x * 2)
}
xs</code></pre>
<pre><code>#&gt; [1] 1 2 3 2 4 6</code></pre>
<p>Answer: <code>x</code> iterates from 1 to 3, and is not affected by
changes to <code>xs</code> during the loop, while <code>xs</code> is
updated.</p>
<p>AR Solution: In this loop <code>x</code> takes on the values of the
initial <code>xs</code> (<code>1</code>, <code>2</code> and
<code>3</code>), indicating that it is evaluated just once in the
beginning of the loop, not after each iteration. (Otherwise, we would
run into an infinite loop.)</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does the following code tell you about when the index is
updated?</li>
</ol>
<pre class="r"><code>for (i in 1:3) {
  i &lt;- i * 2
  print(i)
}</code></pre>
<pre><code>#&gt; [1] 2
#&gt; [1] 4
#&gt; [1] 6</code></pre>
<p>Answer: the index is updated at the beginning of each loop.</p>
<p>AR Solutions: In a for loop the index is updated in the beginning of
each iteration. Therefore, reassigning the index symbol during one
iteration doesn’t affect the following iterations. (Again, we would
otherwise run into an infinite loop.)</p>
<hr />
</div>
</div>
<div id="functions" class="section level1">
<h1>6 Functions</h1>
<p>If you’re reading this book, you’ve probably already created many R
functions and know how to use them to reduce duplication in your code.
In this chapter, you’ll learn how to turn that informal, working
knowledge into more rigorous, theoretical understanding. And while
you’ll see some interesting tricks and techniques along the way, keep in
mind that what you’ll learn here will be important for understanding the
more advanced topics discussed later in the book.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="quiz-1" class="section level2">
<h2>6 Quiz</h2>
<p>Answer the following questions to see if you can safely skip this
chapter.</p>
<ol style="list-style-type: decimal">
<li><p>What are the three components of a function? a: arguments, code,
return value [body, arguments, environment]</p></li>
<li><p>What does the following code return? a: 11 [correct!]</p></li>
</ol>
<pre class="r"><code>x &lt;- 10
f1 &lt;- function(x) {
  function() {
    x + 10
  }
}
f1(1)()</code></pre>
<pre><code>#&gt; [1] 11</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>How would you usually write this code? a: <code>1 + 2 * 3</code>
[correct! … <code>1 + (2 * 3)</code>]</li>
</ol>
<pre class="r"><code>`+`(1, `*`(2, 3))</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>How could you make this call easier to read?
<code>mean(c(1:10, NA), na.rm = TRUE)</code> [correct!]</li>
</ol>
<pre class="r"><code>mean(, TRUE, x = c(1:10, NA)) # nolint: missing_argument_linter.</code></pre>
<ol start="5" style="list-style-type: decimal">
<li>Does the following code throw an error when executed? Why or why
not? a: no, due to lazy evaluation, the <code>stop()</code> is never run
[correct! … second argument is never used]</li>
</ol>
<pre class="r"><code>f2 &lt;- function(a, b) {
  a * 10
}
f2(10, stop(&quot;This is an error!&quot;))</code></pre>
<pre><code>#&gt; [1] 100</code></pre>
<ol start="6" style="list-style-type: decimal">
<li><p>What is an infix function? How do you write it? What’s a
replacement function? How do you write it? a:
<code>function(x) x</code>. ??? [see 6.8.3 and 6.8.4]</p></li>
<li><p>How do you ensure that cleanup action occurs regardless of how a
function exits? a: ??? [<code>on.exit()</code>]</p></li>
</ol>
</div>
<div id="exercises-14" class="section level2">
<h2>6.2.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Given a name, like <code>"mean"</code>, <code>match.fun()</code>
lets you find a function. Given a function, can you find its name? Why
doesn’t that make sense in R?</li>
</ol>
<p>Answer: a function is an object and could have multiple names
pointing to it.</p>
<p>AR Solutions: In R there is no one-to-one mapping between functions
and names. A name always points to a single object, but an object may
have zero, one or many names.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>It’s possible (although typically not useful) to call an anonymous
function. Which of the two approaches below is correct? Why?</li>
</ol>
<pre class="r"><code>function(x) 3()</code></pre>
<pre><code>#&gt; function(x) 3()
#&gt; &lt;environment: 0x7fbb88618330&gt;</code></pre>
<pre class="r"><code>(function(x) 3)()</code></pre>
<pre><code>#&gt; [1] 3</code></pre>
<p>Answer: The second is correct, as the first is the form of defining a
function.</p>
<p>AR Solutions: The second approach is correct.</p>
<p>The anonymous function <code>function(x) 3</code> is surrounded by a
pair of parentheses before it is called by <code>()</code>. These extra
parentheses separate the function call from the anonymous function’s
body. Without them a function with the invalid body <code>3()</code> is
returned, which throws an error when we call it.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>A good rule of thumb is that an anonymous function should fit on one
line and shouldn’t need to use <code>{}</code>. Review your code. Where
could you have used an anonymous function instead of a named function?
Where should you have used a named function instead of an anonymous
function?</li>
</ol>
<p>Answer: in <code>rdev::build_analysis_site()</code>,
<code>analysis_menu_item()</code> is properly written as a named
function, where <code>get_component()</code> could be written as an
anonymous function, with <code>dir_check_copy()</code> and
<code>dir_check_delete()</code> potentially either.</p>
<p>AR Solutions: The use of anonymous functions allows concise and
elegant code in certain situations. However, they miss a descriptive
name and when re-reading the code, it can take a while to figure out
what they do. That’s why it’s helpful to give long and complex functions
a descriptive name. It may be worthwhile to take a look at your own
projects or other people’s code to reflect on this part of your coding
style.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What function allows you to tell if an object is a function? What
function allows you to tell if a function is a primitive function?</li>
</ol>
<p>Answer: <code>is.function()</code> and
<code>is.primitive()</code>.</p>
<p>AR Solutions: Use <code>is.function()</code> to test if an object is
a function. Consider using <code>is.primitive()</code> to test
specifically for primitive functions.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>This code makes a list of all functions in the base package.</li>
</ol>
<pre class="r"><code>objs &lt;- mget(ls(&quot;package:base&quot;, all = TRUE), inherits = TRUE)</code></pre>
<pre><code>#&gt; Warning in ls(&quot;package:base&quot;, all = TRUE): partial argument match of &#39;all&#39; to &#39;all.names&#39;</code></pre>
<pre class="r"><code>funs &lt;- Filter(is.function, objs)</code></pre>
<p>Use it to answer the following questions:</p>
<ol style="list-style-type: lower-alpha">
<li>Which base function has the most arguments?</li>
<li>How many base functions have no arguments? What’s special about
those functions?</li>
<li>How could you adapt the code to find all primitive functions?</li>
</ol>
<pre class="r"><code>fun_args &lt;- data.frame(
  name = names(funs),
  args = unname(vapply(funs, function(x) length(formals(x)), 1L))
)
head(fun_args[order(fun_args$args, decreasing = TRUE), ], 10)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["args"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"scan","2":"22","_rn_":"1056"},{"1":"format.default","2":"16","_rn_":"564"},{"1":"source","2":"16","_rn_":"1109"},{"1":"formatC","2":"15","_rn_":"577"},{"1":"library","2":"13","_rn_":"755"},{"1":"merge.data.frame","2":"13","_rn_":"812"},{"1":"prettyNum","2":"13","_rn_":"907"},{"1":"system2","2":"11","_rn_":"1219"},{"1":"print.default","2":"10","_rn_":"915"},{"1":"save","2":"10","_rn_":"1051"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>fun_args[fun_args$args == 0, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["args"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"-","2":"0","_rn_":"1"},{"1":":","2":"0","_rn_":"4"},{"1":"::","2":"0","_rn_":"5"},{"1":":::","2":"0","_rn_":"6"},{"1":"!","2":"0","_rn_":"7"},{"1":"!=","2":"0","_rn_":"10"},{"1":"...elt","2":"0","_rn_":"13"},{"1":"...length","2":"0","_rn_":"14"},{"1":"...names","2":"0","_rn_":"15"},{"1":".C","2":"0","_rn_":"20"},{"1":".cache_class","2":"0","_rn_":"21"},{"1":".Call","2":"0","_rn_":"22"},{"1":".Call.graphics","2":"0","_rn_":"23"},{"1":".class2","2":"0","_rn_":"24"},{"1":".External","2":"0","_rn_":"41"},{"1":".External.graphics","2":"0","_rn_":"42"},{"1":".External2","2":"0","_rn_":"43"},{"1":".First.sys","2":"0","_rn_":"44"},{"1":".Fortran","2":"0","_rn_":"46"},{"1":".Internal","2":"0","_rn_":"54"},{"1":".isMethodsDispatchOn","2":"0","_rn_":"55"},{"1":".NotYetImplemented","2":"0","_rn_":"66"},{"1":".OptRequireMethods","2":"0","_rn_":"68"},{"1":".Primitive","2":"0","_rn_":"74"},{"1":".primTrace","2":"0","_rn_":"75"},{"1":".primUntrace","2":"0","_rn_":"76"},{"1":".standard_regexps","2":"0","_rn_":"87"},{"1":".subset","2":"0","_rn_":"88"},{"1":".subset2","2":"0","_rn_":"89"},{"1":".tryResumeInterrupt","2":"0","_rn_":"92"},{"1":"(","2":"0","_rn_":"94"},{"1":"[","2":"0","_rn_":"95"},{"1":"[[","2":"0","_rn_":"113"},{"1":"[[<-","2":"0","_rn_":"120"},{"1":"[<-","2":"0","_rn_":"125"},{"1":"{","2":"0","_rn_":"133"},{"1":"@","2":"0","_rn_":"134"},{"1":"@<-","2":"0","_rn_":"135"},{"1":"*","2":"0","_rn_":"136"},{"1":"/","2":"0","_rn_":"138"},{"1":"&","2":"0","_rn_":"140"},{"1":"&&","2":"0","_rn_":"143"},{"1":"%*%","2":"0","_rn_":"144"},{"1":"%/%","2":"0","_rn_":"145"},{"1":"%%","2":"0","_rn_":"146"},{"1":"^","2":"0","_rn_":"150"},{"1":"+","2":"0","_rn_":"151"},{"1":"<","2":"0","_rn_":"154"},{"1":"<-","2":"0","_rn_":"155"},{"1":"<<-","2":"0","_rn_":"156"},{"1":"<=","2":"0","_rn_":"157"},{"1":"=","2":"0","_rn_":"158"},{"1":"==","2":"0","_rn_":"159"},{"1":">","2":"0","_rn_":"160"},{"1":">=","2":"0","_rn_":"161"},{"1":"|","2":"0","_rn_":"162"},{"1":"||","2":"0","_rn_":"165"},{"1":"~","2":"0","_rn_":"166"},{"1":"$","2":"0","_rn_":"167"},{"1":"$<-","2":"0","_rn_":"170"},{"1":"abs","2":"0","_rn_":"173"},{"1":"acos","2":"0","_rn_":"174"},{"1":"acosh","2":"0","_rn_":"175"},{"1":"all","2":"0","_rn_":"182"},{"1":"any","2":"0","_rn_":"199"},{"1":"anyNA","2":"0","_rn_":"205"},{"1":"Arg","2":"0","_rn_":"214"},{"1":"as.call","2":"0","_rn_":"220"},{"1":"as.character","2":"0","_rn_":"221"},{"1":"as.complex","2":"0","_rn_":"232"},{"1":"as.double","2":"0","_rn_":"266"},{"1":"as.environment","2":"0","_rn_":"269"},{"1":"as.integer","2":"0","_rn_":"276"},{"1":"as.logical","2":"0","_rn_":"288"},{"1":"as.numeric","2":"0","_rn_":"298"},{"1":"as.raw","2":"0","_rn_":"317"},{"1":"asin","2":"0","_rn_":"327"},{"1":"asinh","2":"0","_rn_":"328"},{"1":"atan","2":"0","_rn_":"334"},{"1":"atanh","2":"0","_rn_":"336"},{"1":"attr","2":"0","_rn_":"339"},{"1":"attr<-","2":"0","_rn_":"341"},{"1":"attributes","2":"0","_rn_":"342"},{"1":"attributes<-","2":"0","_rn_":"343"},{"1":"baseenv","2":"0","_rn_":"347"},{"1":"break","2":"0","_rn_":"366"},{"1":"browser","2":"0","_rn_":"367"},{"1":"c","2":"0","_rn_":"376"},{"1":"call","2":"0","_rn_":"385"},{"1":"ceiling","2":"0","_rn_":"392"},{"1":"class","2":"0","_rn_":"404"},{"1":"class<-","2":"0","_rn_":"405"},{"1":"closeAllConnections","2":"0","_rn_":"411"},{"1":"Conj","2":"0","_rn_":"428"},{"1":"contributors","2":"0","_rn_":"429"},{"1":"cos","2":"0","_rn_":"430"},{"1":"cosh","2":"0","_rn_":"431"},{"1":"cospi","2":"0","_rn_":"432"},{"1":"Cstack_info","2":"0","_rn_":"434"},{"1":"cummax","2":"0","_rn_":"435"},{"1":"cummin","2":"0","_rn_":"436"},{"1":"cumprod","2":"0","_rn_":"437"},{"1":"cumsum","2":"0","_rn_":"438"},{"1":"date","2":"0","_rn_":"447"},{"1":"default.stringsAsFactors","2":"0","_rn_":"451"},{"1":"digamma","2":"0","_rn_":"468"},{"1":"dim","2":"0","_rn_":"469"},{"1":"dim<-","2":"0","_rn_":"471"},{"1":"dimnames","2":"0","_rn_":"472"},{"1":"dimnames<-","2":"0","_rn_":"474"},{"1":"emptyenv","2":"0","_rn_":"503"},{"1":"enc2native","2":"0","_rn_":"504"},{"1":"enc2utf8","2":"0","_rn_":"505"},{"1":"environment<-","2":"0","_rn_":"513"},{"1":"exp","2":"0","_rn_":"521"},{"1":"expm1","2":"0","_rn_":"523"},{"1":"expression","2":"0","_rn_":"524"},{"1":"extSoftVersion","2":"0","_rn_":"525"},{"1":"floor","2":"0","_rn_":"552"},{"1":"for","2":"0","_rn_":"555"},{"1":"forceAndCall","2":"0","_rn_":"557"},{"1":"function","2":"0","_rn_":"580"},{"1":"gamma","2":"0","_rn_":"581"},{"1":"gc.time","2":"0","_rn_":"583"},{"1":"getAllConnections","2":"0","_rn_":"589"},{"1":"geterrmessage","2":"0","_rn_":"597"},{"1":"getLoadedDLLs","2":"0","_rn_":"600"},{"1":"getRversion","2":"0","_rn_":"610"},{"1":"getTaskCallbackNames","2":"0","_rn_":"612"},{"1":"getwd","2":"0","_rn_":"615"},{"1":"globalenv","2":"0","_rn_":"618"},{"1":"iconvlist","2":"0","_rn_":"630"},{"1":"if","2":"0","_rn_":"635"},{"1":"Im","2":"0","_rn_":"637"},{"1":"interactive","2":"0","_rn_":"643"},{"1":"invisible","2":"0","_rn_":"648"},{"1":"is.array","2":"0","_rn_":"651"},{"1":"is.atomic","2":"0","_rn_":"652"},{"1":"is.call","2":"0","_rn_":"653"},{"1":"is.character","2":"0","_rn_":"654"},{"1":"is.complex","2":"0","_rn_":"655"},{"1":"is.double","2":"0","_rn_":"657"},{"1":"is.environment","2":"0","_rn_":"659"},{"1":"is.expression","2":"0","_rn_":"660"},{"1":"is.finite","2":"0","_rn_":"662"},{"1":"is.function","2":"0","_rn_":"663"},{"1":"is.infinite","2":"0","_rn_":"664"},{"1":"is.integer","2":"0","_rn_":"665"},{"1":"is.language","2":"0","_rn_":"666"},{"1":"is.list","2":"0","_rn_":"667"},{"1":"is.logical","2":"0","_rn_":"669"},{"1":"is.matrix","2":"0","_rn_":"670"},{"1":"is.na","2":"0","_rn_":"671"},{"1":"is.name","2":"0","_rn_":"679"},{"1":"is.nan","2":"0","_rn_":"680"},{"1":"is.null","2":"0","_rn_":"681"},{"1":"is.numeric","2":"0","_rn_":"682"},{"1":"is.object","2":"0","_rn_":"687"},{"1":"is.pairlist","2":"0","_rn_":"690"},{"1":"is.R","2":"0","_rn_":"693"},{"1":"is.raw","2":"0","_rn_":"694"},{"1":"is.recursive","2":"0","_rn_":"695"},{"1":"is.single","2":"0","_rn_":"696"},{"1":"is.symbol","2":"0","_rn_":"697"},{"1":"isS4","2":"0","_rn_":"713"},{"1":"l10n_info","2":"0","_rn_":"727"},{"1":"La_library","2":"0","_rn_":"728"},{"1":"La_version","2":"0","_rn_":"729"},{"1":"lazyLoadDBfetch","2":"0","_rn_":"736"},{"1":"length","2":"0","_rn_":"739"},{"1":"length<-","2":"0","_rn_":"741"},{"1":"levels<-","2":"0","_rn_":"750"},{"1":"lgamma","2":"0","_rn_":"753"},{"1":"libcurlVersion","2":"0","_rn_":"754"},{"1":"licence","2":"0","_rn_":"758"},{"1":"license","2":"0","_rn_":"759"},{"1":"list","2":"0","_rn_":"760"},{"1":"loadedNamespaces","2":"0","_rn_":"766"},{"1":"loadingNamespaceInfo","2":"0","_rn_":"767"},{"1":"log","2":"0","_rn_":"772"},{"1":"log10","2":"0","_rn_":"773"},{"1":"log1p","2":"0","_rn_":"774"},{"1":"log2","2":"0","_rn_":"775"},{"1":"max","2":"0","_rn_":"798"},{"1":"memory.profile","2":"0","_rn_":"810"},{"1":"min","2":"0","_rn_":"816"},{"1":"missing","2":"0","_rn_":"817"},{"1":"Mod","2":"0","_rn_":"818"},{"1":"names","2":"0","_rn_":"827"},{"1":"names<-","2":"0","_rn_":"829"},{"1":"nargs","2":"0","_rn_":"836"},{"1":"next","2":"0","_rn_":"842"},{"1":"nullfile","2":"0","_rn_":"851"},{"1":"nzchar","2":"0","_rn_":"856"},{"1":"oldClass","2":"0","_rn_":"858"},{"1":"oldClass<-","2":"0","_rn_":"859"},{"1":"on.exit","2":"0","_rn_":"861"},{"1":"pcre_config","2":"0","_rn_":"894"},{"1":"pos.to.env","2":"0","_rn_":"903"},{"1":"proc.time","2":"0","_rn_":"946"},{"1":"prod","2":"0","_rn_":"947"},{"1":"quote","2":"0","_rn_":"970"},{"1":"R.Version","2":"0","_rn_":"973"},{"1":"range","2":"0","_rn_":"974"},{"1":"Re","2":"0","_rn_":"987"},{"1":"rep","2":"0","_rn_":"1006"},{"1":"repeat","2":"0","_rn_":"1015"},{"1":"retracemem","2":"0","_rn_":"1022"},{"1":"return","2":"0","_rn_":"1023"},{"1":"round","2":"0","_rn_":"1031"},{"1":"search","2":"0","_rn_":"1057"},{"1":"searchpaths","2":"0","_rn_":"1058"},{"1":"seq_along","2":"0","_rn_":"1062"},{"1":"seq_len","2":"0","_rn_":"1063"},{"1":"seq.int","2":"0","_rn_":"1066"},{"1":"sign","2":"0","_rn_":"1082"},{"1":"signif","2":"0","_rn_":"1084"},{"1":"sin","2":"0","_rn_":"1090"},{"1":"sinh","2":"0","_rn_":"1092"},{"1":"sinpi","2":"0","_rn_":"1095"},{"1":"sqrt","2":"0","_rn_":"1119"},{"1":"standardGeneric","2":"0","_rn_":"1125"},{"1":"stderr","2":"0","_rn_":"1127"},{"1":"stdin","2":"0","_rn_":"1128"},{"1":"stdout","2":"0","_rn_":"1129"},{"1":"storage.mode<-","2":"0","_rn_":"1133"},{"1":"substitute","2":"0","_rn_":"1149"},{"1":"sum","2":"0","_rn_":"1154"},{"1":"switch","2":"0","_rn_":"1183"},{"1":"sys.calls","2":"0","_rn_":"1185"},{"1":"Sys.Date","2":"0","_rn_":"1187"},{"1":"sys.frames","2":"0","_rn_":"1189"},{"1":"Sys.getpid","2":"0","_rn_":"1193"},{"1":"Sys.info","2":"0","_rn_":"1195"},{"1":"Sys.localeconv","2":"0","_rn_":"1197"},{"1":"sys.nframe","2":"0","_rn_":"1198"},{"1":"sys.on.exit","2":"0","_rn_":"1199"},{"1":"sys.parents","2":"0","_rn_":"1201"},{"1":"sys.status","2":"0","_rn_":"1210"},{"1":"Sys.time","2":"0","_rn_":"1211"},{"1":"tan","2":"0","_rn_":"1225"},{"1":"tanh","2":"0","_rn_":"1226"},{"1":"tanpi","2":"0","_rn_":"1227"},{"1":"tracemem","2":"0","_rn_":"1242"},{"1":"trigamma","2":"0","_rn_":"1247"},{"1":"trunc","2":"0","_rn_":"1249"},{"1":"unclass","2":"0","_rn_":"1258"},{"1":"untracemem","2":"0","_rn_":"1282"},{"1":"UseMethod","2":"0","_rn_":"1286"},{"1":"while","2":"0","_rn_":"1302"},{"1":"xtfrm","2":"0","_rn_":"1319"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># check if all functions with 0 arguments are primitive
fun_args2 &lt;- data.frame(
  name = names(funs),
  args = unname(vapply(funs, function(x) length(formals(x)), 1L)),
  prim = unname(vapply(funs, is.primitive, TRUE))
)
fun_args2[fun_args2$args == 0, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["args"],"name":[2],"type":["int"],"align":["right"]},{"label":["prim"],"name":[3],"type":["lgl"],"align":["right"]}],"data":[{"1":"-","2":"0","3":"TRUE","_rn_":"1"},{"1":":","2":"0","3":"TRUE","_rn_":"4"},{"1":"::","2":"0","3":"TRUE","_rn_":"5"},{"1":":::","2":"0","3":"TRUE","_rn_":"6"},{"1":"!","2":"0","3":"TRUE","_rn_":"7"},{"1":"!=","2":"0","3":"TRUE","_rn_":"10"},{"1":"...elt","2":"0","3":"TRUE","_rn_":"13"},{"1":"...length","2":"0","3":"TRUE","_rn_":"14"},{"1":"...names","2":"0","3":"TRUE","_rn_":"15"},{"1":".C","2":"0","3":"TRUE","_rn_":"20"},{"1":".cache_class","2":"0","3":"TRUE","_rn_":"21"},{"1":".Call","2":"0","3":"TRUE","_rn_":"22"},{"1":".Call.graphics","2":"0","3":"TRUE","_rn_":"23"},{"1":".class2","2":"0","3":"TRUE","_rn_":"24"},{"1":".External","2":"0","3":"TRUE","_rn_":"41"},{"1":".External.graphics","2":"0","3":"TRUE","_rn_":"42"},{"1":".External2","2":"0","3":"TRUE","_rn_":"43"},{"1":".First.sys","2":"0","3":"FALSE","_rn_":"44"},{"1":".Fortran","2":"0","3":"TRUE","_rn_":"46"},{"1":".Internal","2":"0","3":"TRUE","_rn_":"54"},{"1":".isMethodsDispatchOn","2":"0","3":"TRUE","_rn_":"55"},{"1":".NotYetImplemented","2":"0","3":"FALSE","_rn_":"66"},{"1":".OptRequireMethods","2":"0","3":"FALSE","_rn_":"68"},{"1":".Primitive","2":"0","3":"TRUE","_rn_":"74"},{"1":".primTrace","2":"0","3":"TRUE","_rn_":"75"},{"1":".primUntrace","2":"0","3":"TRUE","_rn_":"76"},{"1":".standard_regexps","2":"0","3":"FALSE","_rn_":"87"},{"1":".subset","2":"0","3":"TRUE","_rn_":"88"},{"1":".subset2","2":"0","3":"TRUE","_rn_":"89"},{"1":".tryResumeInterrupt","2":"0","3":"FALSE","_rn_":"92"},{"1":"(","2":"0","3":"TRUE","_rn_":"94"},{"1":"[","2":"0","3":"TRUE","_rn_":"95"},{"1":"[[","2":"0","3":"TRUE","_rn_":"113"},{"1":"[[<-","2":"0","3":"TRUE","_rn_":"120"},{"1":"[<-","2":"0","3":"TRUE","_rn_":"125"},{"1":"{","2":"0","3":"TRUE","_rn_":"133"},{"1":"@","2":"0","3":"TRUE","_rn_":"134"},{"1":"@<-","2":"0","3":"TRUE","_rn_":"135"},{"1":"*","2":"0","3":"TRUE","_rn_":"136"},{"1":"/","2":"0","3":"TRUE","_rn_":"138"},{"1":"&","2":"0","3":"TRUE","_rn_":"140"},{"1":"&&","2":"0","3":"TRUE","_rn_":"143"},{"1":"%*%","2":"0","3":"TRUE","_rn_":"144"},{"1":"%/%","2":"0","3":"TRUE","_rn_":"145"},{"1":"%%","2":"0","3":"TRUE","_rn_":"146"},{"1":"^","2":"0","3":"TRUE","_rn_":"150"},{"1":"+","2":"0","3":"TRUE","_rn_":"151"},{"1":"<","2":"0","3":"TRUE","_rn_":"154"},{"1":"<-","2":"0","3":"TRUE","_rn_":"155"},{"1":"<<-","2":"0","3":"TRUE","_rn_":"156"},{"1":"<=","2":"0","3":"TRUE","_rn_":"157"},{"1":"=","2":"0","3":"TRUE","_rn_":"158"},{"1":"==","2":"0","3":"TRUE","_rn_":"159"},{"1":">","2":"0","3":"TRUE","_rn_":"160"},{"1":">=","2":"0","3":"TRUE","_rn_":"161"},{"1":"|","2":"0","3":"TRUE","_rn_":"162"},{"1":"||","2":"0","3":"TRUE","_rn_":"165"},{"1":"~","2":"0","3":"TRUE","_rn_":"166"},{"1":"$","2":"0","3":"TRUE","_rn_":"167"},{"1":"$<-","2":"0","3":"TRUE","_rn_":"170"},{"1":"abs","2":"0","3":"TRUE","_rn_":"173"},{"1":"acos","2":"0","3":"TRUE","_rn_":"174"},{"1":"acosh","2":"0","3":"TRUE","_rn_":"175"},{"1":"all","2":"0","3":"TRUE","_rn_":"182"},{"1":"any","2":"0","3":"TRUE","_rn_":"199"},{"1":"anyNA","2":"0","3":"TRUE","_rn_":"205"},{"1":"Arg","2":"0","3":"TRUE","_rn_":"214"},{"1":"as.call","2":"0","3":"TRUE","_rn_":"220"},{"1":"as.character","2":"0","3":"TRUE","_rn_":"221"},{"1":"as.complex","2":"0","3":"TRUE","_rn_":"232"},{"1":"as.double","2":"0","3":"TRUE","_rn_":"266"},{"1":"as.environment","2":"0","3":"TRUE","_rn_":"269"},{"1":"as.integer","2":"0","3":"TRUE","_rn_":"276"},{"1":"as.logical","2":"0","3":"TRUE","_rn_":"288"},{"1":"as.numeric","2":"0","3":"TRUE","_rn_":"298"},{"1":"as.raw","2":"0","3":"TRUE","_rn_":"317"},{"1":"asin","2":"0","3":"TRUE","_rn_":"327"},{"1":"asinh","2":"0","3":"TRUE","_rn_":"328"},{"1":"atan","2":"0","3":"TRUE","_rn_":"334"},{"1":"atanh","2":"0","3":"TRUE","_rn_":"336"},{"1":"attr","2":"0","3":"TRUE","_rn_":"339"},{"1":"attr<-","2":"0","3":"TRUE","_rn_":"341"},{"1":"attributes","2":"0","3":"TRUE","_rn_":"342"},{"1":"attributes<-","2":"0","3":"TRUE","_rn_":"343"},{"1":"baseenv","2":"0","3":"TRUE","_rn_":"347"},{"1":"break","2":"0","3":"TRUE","_rn_":"366"},{"1":"browser","2":"0","3":"TRUE","_rn_":"367"},{"1":"c","2":"0","3":"TRUE","_rn_":"376"},{"1":"call","2":"0","3":"TRUE","_rn_":"385"},{"1":"ceiling","2":"0","3":"TRUE","_rn_":"392"},{"1":"class","2":"0","3":"TRUE","_rn_":"404"},{"1":"class<-","2":"0","3":"TRUE","_rn_":"405"},{"1":"closeAllConnections","2":"0","3":"FALSE","_rn_":"411"},{"1":"Conj","2":"0","3":"TRUE","_rn_":"428"},{"1":"contributors","2":"0","3":"FALSE","_rn_":"429"},{"1":"cos","2":"0","3":"TRUE","_rn_":"430"},{"1":"cosh","2":"0","3":"TRUE","_rn_":"431"},{"1":"cospi","2":"0","3":"TRUE","_rn_":"432"},{"1":"Cstack_info","2":"0","3":"FALSE","_rn_":"434"},{"1":"cummax","2":"0","3":"TRUE","_rn_":"435"},{"1":"cummin","2":"0","3":"TRUE","_rn_":"436"},{"1":"cumprod","2":"0","3":"TRUE","_rn_":"437"},{"1":"cumsum","2":"0","3":"TRUE","_rn_":"438"},{"1":"date","2":"0","3":"FALSE","_rn_":"447"},{"1":"default.stringsAsFactors","2":"0","3":"FALSE","_rn_":"451"},{"1":"digamma","2":"0","3":"TRUE","_rn_":"468"},{"1":"dim","2":"0","3":"TRUE","_rn_":"469"},{"1":"dim<-","2":"0","3":"TRUE","_rn_":"471"},{"1":"dimnames","2":"0","3":"TRUE","_rn_":"472"},{"1":"dimnames<-","2":"0","3":"TRUE","_rn_":"474"},{"1":"emptyenv","2":"0","3":"TRUE","_rn_":"503"},{"1":"enc2native","2":"0","3":"TRUE","_rn_":"504"},{"1":"enc2utf8","2":"0","3":"TRUE","_rn_":"505"},{"1":"environment<-","2":"0","3":"TRUE","_rn_":"513"},{"1":"exp","2":"0","3":"TRUE","_rn_":"521"},{"1":"expm1","2":"0","3":"TRUE","_rn_":"523"},{"1":"expression","2":"0","3":"TRUE","_rn_":"524"},{"1":"extSoftVersion","2":"0","3":"FALSE","_rn_":"525"},{"1":"floor","2":"0","3":"TRUE","_rn_":"552"},{"1":"for","2":"0","3":"TRUE","_rn_":"555"},{"1":"forceAndCall","2":"0","3":"TRUE","_rn_":"557"},{"1":"function","2":"0","3":"TRUE","_rn_":"580"},{"1":"gamma","2":"0","3":"TRUE","_rn_":"581"},{"1":"gc.time","2":"0","3":"TRUE","_rn_":"583"},{"1":"getAllConnections","2":"0","3":"FALSE","_rn_":"589"},{"1":"geterrmessage","2":"0","3":"FALSE","_rn_":"597"},{"1":"getLoadedDLLs","2":"0","3":"FALSE","_rn_":"600"},{"1":"getRversion","2":"0","3":"FALSE","_rn_":"610"},{"1":"getTaskCallbackNames","2":"0","3":"FALSE","_rn_":"612"},{"1":"getwd","2":"0","3":"FALSE","_rn_":"615"},{"1":"globalenv","2":"0","3":"TRUE","_rn_":"618"},{"1":"iconvlist","2":"0","3":"FALSE","_rn_":"630"},{"1":"if","2":"0","3":"TRUE","_rn_":"635"},{"1":"Im","2":"0","3":"TRUE","_rn_":"637"},{"1":"interactive","2":"0","3":"TRUE","_rn_":"643"},{"1":"invisible","2":"0","3":"TRUE","_rn_":"648"},{"1":"is.array","2":"0","3":"TRUE","_rn_":"651"},{"1":"is.atomic","2":"0","3":"TRUE","_rn_":"652"},{"1":"is.call","2":"0","3":"TRUE","_rn_":"653"},{"1":"is.character","2":"0","3":"TRUE","_rn_":"654"},{"1":"is.complex","2":"0","3":"TRUE","_rn_":"655"},{"1":"is.double","2":"0","3":"TRUE","_rn_":"657"},{"1":"is.environment","2":"0","3":"TRUE","_rn_":"659"},{"1":"is.expression","2":"0","3":"TRUE","_rn_":"660"},{"1":"is.finite","2":"0","3":"TRUE","_rn_":"662"},{"1":"is.function","2":"0","3":"TRUE","_rn_":"663"},{"1":"is.infinite","2":"0","3":"TRUE","_rn_":"664"},{"1":"is.integer","2":"0","3":"TRUE","_rn_":"665"},{"1":"is.language","2":"0","3":"TRUE","_rn_":"666"},{"1":"is.list","2":"0","3":"TRUE","_rn_":"667"},{"1":"is.logical","2":"0","3":"TRUE","_rn_":"669"},{"1":"is.matrix","2":"0","3":"TRUE","_rn_":"670"},{"1":"is.na","2":"0","3":"TRUE","_rn_":"671"},{"1":"is.name","2":"0","3":"TRUE","_rn_":"679"},{"1":"is.nan","2":"0","3":"TRUE","_rn_":"680"},{"1":"is.null","2":"0","3":"TRUE","_rn_":"681"},{"1":"is.numeric","2":"0","3":"TRUE","_rn_":"682"},{"1":"is.object","2":"0","3":"TRUE","_rn_":"687"},{"1":"is.pairlist","2":"0","3":"TRUE","_rn_":"690"},{"1":"is.R","2":"0","3":"FALSE","_rn_":"693"},{"1":"is.raw","2":"0","3":"TRUE","_rn_":"694"},{"1":"is.recursive","2":"0","3":"TRUE","_rn_":"695"},{"1":"is.single","2":"0","3":"TRUE","_rn_":"696"},{"1":"is.symbol","2":"0","3":"TRUE","_rn_":"697"},{"1":"isS4","2":"0","3":"TRUE","_rn_":"713"},{"1":"l10n_info","2":"0","3":"FALSE","_rn_":"727"},{"1":"La_library","2":"0","3":"FALSE","_rn_":"728"},{"1":"La_version","2":"0","3":"FALSE","_rn_":"729"},{"1":"lazyLoadDBfetch","2":"0","3":"TRUE","_rn_":"736"},{"1":"length","2":"0","3":"TRUE","_rn_":"739"},{"1":"length<-","2":"0","3":"TRUE","_rn_":"741"},{"1":"levels<-","2":"0","3":"TRUE","_rn_":"750"},{"1":"lgamma","2":"0","3":"TRUE","_rn_":"753"},{"1":"libcurlVersion","2":"0","3":"FALSE","_rn_":"754"},{"1":"licence","2":"0","3":"FALSE","_rn_":"758"},{"1":"license","2":"0","3":"FALSE","_rn_":"759"},{"1":"list","2":"0","3":"TRUE","_rn_":"760"},{"1":"loadedNamespaces","2":"0","3":"FALSE","_rn_":"766"},{"1":"loadingNamespaceInfo","2":"0","3":"FALSE","_rn_":"767"},{"1":"log","2":"0","3":"TRUE","_rn_":"772"},{"1":"log10","2":"0","3":"TRUE","_rn_":"773"},{"1":"log1p","2":"0","3":"TRUE","_rn_":"774"},{"1":"log2","2":"0","3":"TRUE","_rn_":"775"},{"1":"max","2":"0","3":"TRUE","_rn_":"798"},{"1":"memory.profile","2":"0","3":"FALSE","_rn_":"810"},{"1":"min","2":"0","3":"TRUE","_rn_":"816"},{"1":"missing","2":"0","3":"TRUE","_rn_":"817"},{"1":"Mod","2":"0","3":"TRUE","_rn_":"818"},{"1":"names","2":"0","3":"TRUE","_rn_":"827"},{"1":"names<-","2":"0","3":"TRUE","_rn_":"829"},{"1":"nargs","2":"0","3":"TRUE","_rn_":"836"},{"1":"next","2":"0","3":"TRUE","_rn_":"842"},{"1":"nullfile","2":"0","3":"FALSE","_rn_":"851"},{"1":"nzchar","2":"0","3":"TRUE","_rn_":"856"},{"1":"oldClass","2":"0","3":"TRUE","_rn_":"858"},{"1":"oldClass<-","2":"0","3":"TRUE","_rn_":"859"},{"1":"on.exit","2":"0","3":"TRUE","_rn_":"861"},{"1":"pcre_config","2":"0","3":"FALSE","_rn_":"894"},{"1":"pos.to.env","2":"0","3":"TRUE","_rn_":"903"},{"1":"proc.time","2":"0","3":"TRUE","_rn_":"946"},{"1":"prod","2":"0","3":"TRUE","_rn_":"947"},{"1":"quote","2":"0","3":"TRUE","_rn_":"970"},{"1":"R.Version","2":"0","3":"FALSE","_rn_":"973"},{"1":"range","2":"0","3":"TRUE","_rn_":"974"},{"1":"Re","2":"0","3":"TRUE","_rn_":"987"},{"1":"rep","2":"0","3":"TRUE","_rn_":"1006"},{"1":"repeat","2":"0","3":"TRUE","_rn_":"1015"},{"1":"retracemem","2":"0","3":"TRUE","_rn_":"1022"},{"1":"return","2":"0","3":"TRUE","_rn_":"1023"},{"1":"round","2":"0","3":"TRUE","_rn_":"1031"},{"1":"search","2":"0","3":"FALSE","_rn_":"1057"},{"1":"searchpaths","2":"0","3":"FALSE","_rn_":"1058"},{"1":"seq_along","2":"0","3":"TRUE","_rn_":"1062"},{"1":"seq_len","2":"0","3":"TRUE","_rn_":"1063"},{"1":"seq.int","2":"0","3":"TRUE","_rn_":"1066"},{"1":"sign","2":"0","3":"TRUE","_rn_":"1082"},{"1":"signif","2":"0","3":"TRUE","_rn_":"1084"},{"1":"sin","2":"0","3":"TRUE","_rn_":"1090"},{"1":"sinh","2":"0","3":"TRUE","_rn_":"1092"},{"1":"sinpi","2":"0","3":"TRUE","_rn_":"1095"},{"1":"sqrt","2":"0","3":"TRUE","_rn_":"1119"},{"1":"standardGeneric","2":"0","3":"TRUE","_rn_":"1125"},{"1":"stderr","2":"0","3":"FALSE","_rn_":"1127"},{"1":"stdin","2":"0","3":"FALSE","_rn_":"1128"},{"1":"stdout","2":"0","3":"FALSE","_rn_":"1129"},{"1":"storage.mode<-","2":"0","3":"TRUE","_rn_":"1133"},{"1":"substitute","2":"0","3":"TRUE","_rn_":"1149"},{"1":"sum","2":"0","3":"TRUE","_rn_":"1154"},{"1":"switch","2":"0","3":"TRUE","_rn_":"1183"},{"1":"sys.calls","2":"0","3":"FALSE","_rn_":"1185"},{"1":"Sys.Date","2":"0","3":"FALSE","_rn_":"1187"},{"1":"sys.frames","2":"0","3":"FALSE","_rn_":"1189"},{"1":"Sys.getpid","2":"0","3":"FALSE","_rn_":"1193"},{"1":"Sys.info","2":"0","3":"FALSE","_rn_":"1195"},{"1":"Sys.localeconv","2":"0","3":"FALSE","_rn_":"1197"},{"1":"sys.nframe","2":"0","3":"FALSE","_rn_":"1198"},{"1":"sys.on.exit","2":"0","3":"FALSE","_rn_":"1199"},{"1":"sys.parents","2":"0","3":"FALSE","_rn_":"1201"},{"1":"sys.status","2":"0","3":"FALSE","_rn_":"1210"},{"1":"Sys.time","2":"0","3":"FALSE","_rn_":"1211"},{"1":"tan","2":"0","3":"TRUE","_rn_":"1225"},{"1":"tanh","2":"0","3":"TRUE","_rn_":"1226"},{"1":"tanpi","2":"0","3":"TRUE","_rn_":"1227"},{"1":"tracemem","2":"0","3":"TRUE","_rn_":"1242"},{"1":"trigamma","2":"0","3":"TRUE","_rn_":"1247"},{"1":"trunc","2":"0","3":"TRUE","_rn_":"1249"},{"1":"unclass","2":"0","3":"TRUE","_rn_":"1258"},{"1":"untracemem","2":"0","3":"TRUE","_rn_":"1282"},{"1":"UseMethod","2":"0","3":"TRUE","_rn_":"1286"},{"1":"while","2":"0","3":"TRUE","_rn_":"1302"},{"1":"xtfrm","2":"0","3":"TRUE","_rn_":"1319"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answers:</p>
<ol style="list-style-type: lower-alpha">
<li><code>scan()</code> has the most arguments, 22</li>
<li>most (but not all) are primitive functions (204 of 254)</li>
<li>the <code>ls()</code> in the original code could be expanded to
search all packages</li>
</ol>
<p>AR Solutions: Let’s look at each sub-question separately:</p>
<ol style="list-style-type: lower-alpha">
<li>To find the function with the most arguments, we first compute the
length of <code>formals()</code>.</li>
</ol>
<pre class="r"><code>library(purrr)

n_args &lt;- funs %&gt;%
  map(formals) %&gt;%
  map_int(length)</code></pre>
<p>Then we sort <code>n_args</code> in decreasing order and look at its
first entries.</p>
<pre class="r"><code>n_args %&gt;%
  sort(decreasing = TRUE) %&gt;%
  head()
#&gt; scan format.default source
#&gt; 22 16 16
#&gt; formatC library merge.data.frame
#&gt; 15 13 13</code></pre>
<ol start="2" style="list-style-type: lower-alpha">
<li>We can further use <code>n_args</code> to find the number of
functions with no arguments:</li>
</ol>
<pre class="r"><code>sum(n_args == 0)</code></pre>
<pre><code>#&gt; [1] 251</code></pre>
<p>However, this over counts because <code>formals()</code> returns
<code>NULL</code> for primitive functions, and <code>length(NULL)</code>
is 0. To fix this, we can first remove the primitive functions:</p>
<pre class="r"><code>n_args2 &lt;- funs %&gt;%
  discard(is.primitive) %&gt;%
  map(formals) %&gt;%
  map_int(length)

sum(n_args2 == 0)</code></pre>
<pre><code>#&gt; [1] 47</code></pre>
<p>Indeed, most of the functions with no arguments are actually
primitive functions.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>To find all primitive functions, we can change the predicate in
<code>Filter()</code> from <code>is.function()</code> to
<code>is.primitive()</code>:</li>
</ol>
<pre class="r"><code>funs &lt;- Filter(is.primitive, objs)
length(funs)</code></pre>
<pre><code>#&gt; [1] 204</code></pre>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>What are the three important components of a function?</li>
</ol>
<p>Answer: the <code>formals()</code>, <code>body()</code> and
<code>environment()</code>.</p>
<p>AR Solutions: These components are the function’s
<code>body()</code>, <code>formals()</code> and
<code>environment()</code>. However, as mentioned in <em>Advanced
R</em>:</p>
<blockquote>
<p>There is one exception to the rule that functions have three
components. Primitive functions, like <code>sum()</code>, call C code
directly with <code>.Primitive()</code> and contain no R code.
Therefore, their <code>formals()</code>, <code>body()</code>, and
<code>environment()</code> are all <code>NULL</code>.</p>
</blockquote>
<hr />
<ol start="7" style="list-style-type: decimal">
<li>When does printing a function not show the environment it was
created in?</li>
</ol>
<p>Answer: when it is created in the global environment.</p>
<p>AR Solutions: Primitive functions and functions created in the global
environment do not print their environment.</p>
<hr />
</div>
<div id="exercises-15" class="section level2">
<h2>6.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What does the following code return? Why? Describe how each of the
three <code>c</code>’s is interpreted.</li>
</ol>
<pre class="r"><code>c &lt;- 10
c(c = c)</code></pre>
<pre><code>#&gt;  c 
#&gt; 10</code></pre>
<p>Answer: a named vector, <code>c 10</code>. The first and final c is a
variable. The second c is a function name. the third c is a name.</p>
<p>AR Solutions: This code returns a named numeric vector of length one
— with one element of the value <code>10</code> and the name
<code>"c"</code>. The first <code>c</code> represents the
<code>c()</code> function, the second <code>c</code> is interpreted as a
(quoted) name and the third <code>c</code> as a value.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What are the four principles that govern how R looks for
values?</li>
</ol>
<p>Answer: name masking, functions versus variables, a fresh start,
dynamic lookup.</p>
<p>AR Solutions: R’s <a
href="https://adv-r.hadley.nz/functions.html#lexical-scoping">lexical
scoping</a> rules are based on these four principles: - <a
href="https://adv-r.hadley.nz/functions.html#name-masking">Name
masking</a> - <a
href="https://adv-r.hadley.nz/functions.html#functions-versus-variables">Functions
vs. variables</a> - <a
href="https://adv-r.hadley.nz/functions.html#fresh-start">A fresh
start</a> - <a
href="https://adv-r.hadley.nz/functions.html#dynamic-lookup">Dynamic
lookup</a></p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does the following function return? Make a prediction before
running the code yourself.</li>
</ol>
<pre class="r"><code>f &lt;- function(x) {
  f &lt;- function(x) { # return value of this is 101
    f &lt;- function() {
      x^2
    }
    f() + 1
  }
  f(x) * 2
}
f(10)</code></pre>
<pre><code>#&gt; [1] 202</code></pre>
<p>Answer: 202. Correct!</p>
<p>AR Solutions: Within this nested function two more functions also
named <code>f</code> are defined and called. Because the functions are
each executed in their own environment R will look up and use the
functions defined last in these environments. The innermost
<code>f()</code> is called last, though it is the first function to
return a value. Therefore, the order of the calculation passes “from the
inside to the outside” and the function returns
<code>((10 ^ 2) + 1) * 2</code>, i.e. 202.</p>
<hr />
</div>
<div id="exercises-16" class="section level2">
<h2>6.5.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What important property of <code>&amp;&amp;</code> makes
<code>x_ok()</code> work?</li>
</ol>
<pre class="r"><code>x_ok &lt;- function(x) {
  !is.null(x) &amp;&amp; length(x) == 1 &amp;&amp; x &gt; 0
}

x_ok(NULL)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>x_ok(1)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>x_ok(1:3)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<p>Answer: From the <code>&amp;&amp;</code> docs, “The longer forms
evaluates left to right, proceeding only until the result is
determined.”</p>
<p>What is different with this code? Why is this behaviour undesirable
here?</p>
<pre class="r"><code>x_ok &lt;- function(x) {
  !is.null(x) &amp; length(x) == 1 &amp; x &gt; 0
}

x_ok(NULL)</code></pre>
<pre><code>#&gt; logical(0)</code></pre>
<pre class="r"><code>x_ok(1)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>x_ok(1:3)</code></pre>
<pre><code>#&gt; [1] FALSE FALSE FALSE</code></pre>
<p>Answer: “The shorter forms performs elementwise comparisons in much
the same way as arithmetic operators.” This is undesirable because the
intent of the function is to return <code>TRUE</code> or
<code>FALSE</code>.</p>
<p>AR Solutions: In summary: <code>&amp;&amp;</code> short-circuits
which means that if the left-hand side is <code>FALSE</code> it doesn’t
evaluate the right-hand side (because it doesn’t matter). Similarly, if
the left-hand side of <code>||</code> is <code>TRUE</code> it doesn’t
evaluate the right-hand side.</p>
<p>We expect <code>x_ok()</code> to validate its input via certain
criteria: it must not be <code>NULL</code>, have length <code>1</code>
and be greater than <code>0</code>. Meaningful outcomes for this
assertion will be <code>TRUE</code>, <code>FALSE</code> or
<code>NA</code>. The desired behaviour is reached by combining the
assertions through <code>&amp;&amp;</code> instead of
<code>&amp;</code>.</p>
<p><code>&amp;&amp;</code> does not perform elementwise comparisons;
instead it uses the first element of each value only. It also uses lazy
evaluation, in the sense that evaluation “proceeds only until the result
is determined” (from <code>?Logic</code>). This means that the RHS of
<code>&amp;&amp;</code> won’t be evaluated if the LHS already determines
the outcome of the comparison (e.g. evaluate to <code>FALSE</code>).
This behaviour is also known as “short-circuiting”. For some situations
(<code>x = 1</code>) both operators will lead to the same result. But
this is not always the case. For <code>x = NULL</code>, the
<code>&amp;&amp;</code>-operator will stop after the
<code>!is.null</code> statement and return the result. The following
conditions won’t even be evaluated! (If the other conditions are also
evaluated (by the use of <code>&amp;</code>), the outcome would change.
<code>NULL &gt; 0</code> returns <code>logical(0)</code>, which is not
helpful in this case.)</p>
<p>We can also see the difference in behaviour, when we set
<code>x = 1:3</code>. The <code>&amp;&amp;</code>-operator returns the
result from <code>length(x) == 1</code>, which is <code>FALSE</code>.
Using <code>&amp;</code> as the logical operator leads to the
(vectorised) <code>x &gt; 0</code> condition being evaluated and also
returned.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What does this function return? Why? Which principle does it
illustrate?</li>
</ol>
<pre class="r"><code>f2 &lt;- function(x = z) {
  z &lt;- 100
  x
}
f2()</code></pre>
<pre><code>#&gt; [1] 100</code></pre>
<p>Answer: 100, lazy evaluation. <code>x = z</code> isn’t evaluated
until <code>x</code>.</p>
<p>AR Solutions: The function returns 100. The default argument
(<code>x = z</code>) gets lazily evaluated within the function
environment when <code>x</code> gets accessed. At this time
<code>z</code> has already been bound to the value <code>100</code>. The
illustrated principle here is <em>lazy evaluation</em>.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does this function return? Why? Which principle does it
illustrate?</li>
</ol>
<pre class="r"><code>y &lt;- 10
# styler: off
f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { # nolint brace_linter, semicolon_linter.
  # styler: on
  c(x, y)
}
f1()</code></pre>
<pre><code>#&gt; [1] 2 1</code></pre>
<pre class="r"><code>y</code></pre>
<pre><code>#&gt; [1] 10</code></pre>
<p>Answer: <code>c(2, 1)</code>. default arguments.</p>
<p>AR Solutions: The function returns <code>c(2, 1)</code> which is due
to <em>name masking</em>. When <code>x</code> is accessed within
<code>c()</code>, the promise <code>x = {y &lt;- 1; 2}</code> is
evaluated inside <code>f1()</code>’s environment. <code>y</code> gets
bound to the value <code>1</code> and the return value of
<code>{()</code> (<code>2</code>) gets assigned to <code>x</code>. When
<code>y</code> gets accessed next within <code>c()</code>, it has
already the value <code>1</code> and R doesn’t need to look it up any
further. Therefore, the promise <code>y = 0</code> won’t be evaluated.
Also, as <code>y</code> is assigned within <code>f1()</code>’s
environment, the value of the global variable <code>y</code> is left
untouched.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>In <code>hist()</code>, the default value of <code>xlim</code> is
<code>range(breaks)</code>, the default value for <code>breaks</code> is
<code>"Sturges"</code>, and</li>
</ol>
<pre class="r"><code>range(&quot;Sturges&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;Sturges&quot; &quot;Sturges&quot;</code></pre>
<p>Explain how <code>hist()</code> works to get a correct
<code>xlim</code> value.</p>
<p>Answer: from the docs, “Note that <code>xlim</code> is <em>not</em>
used to define the histogram (breaks), but only for plotting (when
<code>plot = TRUE</code>).” So, the breakpoints are calculated when the
object is created, and <code>xlim</code> is calculated when the
histogram is plotted, in the second step.</p>
<p>AR Solutions: The <code>xlim</code> argument of <code>hist()</code>
defines the range of the histogram’s x-axis. In order to provide a valid
axis <code>xlim</code> must contain a numeric vector of exactly two
unique values. Consequently, for the default
<code>xlim = range(breaks)</code>), <code>breaks</code> must evaluate to
a vector with at least two unique values.</p>
<p>During execution <code>hist()</code> overwrites the
<code>breaks</code> argument. The <code>breaks</code> argument is quite
flexible and allows the users to provide the breakpoints directly or
compute them in several ways. Therefore, the specific behaviour depends
highly on the input. But <code>hist</code> ensures that
<code>breaks</code> evaluates to a numeric vector containing at least
two unique elements before <code>xlim</code> is computed.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Explain why this function works. Why is it confusing?</li>
</ol>
<pre class="r"><code>show_time &lt;- function(x = stop(&quot;Error!&quot;)) {
  stop &lt;- function(...) Sys.time()
  print(x)
}
show_time()</code></pre>
<pre><code>#&gt; [1] &quot;2022-07-31 11:56:14 CDT&quot;</code></pre>
<p>Answer: <code>stop</code> is redefined before <code>x</code> is
evaluated. This is a confusing use of lazy evaluation.</p>
<p>AR Solutions: Before <code>show_time()</code> accesses <code>x</code>
(default <code>stop("Error")</code>), the <code>stop()</code> function
is masked by <code>function(...) Sys.time()</code>. As default arguments
are evaluated in the function environment, <code>print(x)</code> will be
evaluated as <code>print(Sys.time())</code>.</p>
<p>This function is confusing because its behaviour changes when
<code>x</code>’s value is supplied directly. Now the value from the
calling environment will be used and the overwriting of
<code>stop()</code> won’t affect <code>x</code> anymore.</p>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>How many arguments are required when calling
<code>library()</code>?</li>
</ol>
<p>Answer: zero. <code>library()</code> uses <code>missing()</code> to
return the list of available packages if there are no arguments.</p>
<p>AR Solutions: <code>library()</code> doesn’t require any arguments.
When called without arguments <code>library()</code> invisibly returns a
list of class <code>libraryIQR</code>, which contains a results matrix
with one row and three columns per installed package. These columns
contain entries for the name of the package (“Package”), the path to the
package (“LibPath”) and the title of the package (“Title”).
<code>library()</code> also has its own print method
(<code>print.libraryIQR()</code>), which displays this information
conveniently in its own window.</p>
<p>This behaviour is also documented under the details section of
<code>library()</code>’s help page (<code>?library</code>):</p>
<blockquote>
<p>If library is called with no package or help argument, it lists all
available packages in the libraries specified by lib.loc, and returns
the corresponding information in an object of class “libraryIQR”. (The
structure of this class may change in future versions.) Use
.packages(all = TRUE) to obtain just the names of all available
packages, and installed.packages() for even more information.</p>
</blockquote>
<p>Because the <code>package</code> and <code>help</code> argument from
<code>library()</code> do not show a default value, it’s easy to
overlook the possibility to call <code>library()</code> without these
arguments. (Instead of providing <code>NULL</code>s as default values
<code>library()</code> uses <code>missing()</code> to check if these
arguments were provided.)</p>
<hr />
</div>
<div id="exercises-17" class="section level2">
<h2>6.6.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Explain the following results:</li>
</ol>
<pre class="r"><code>sum(1, 2, 3)</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>mean(1, 2, 3)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>sum(1, 2, 3, na.omit = TRUE)</code></pre>
<pre><code>#&gt; [1] 7</code></pre>
<pre class="r"><code>mean(1, 2, 3, na.omit = TRUE)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<p>Answer:</p>
<ul>
<li>“<code>sum()</code> returns the sum of all the values present in its
arguments.” The first example is straightforward. In the second sum
example, <code>na.omit</code> isn’t a valid argument (<code>na.rm</code>
is), so the <code>TRUE</code> value is passed to <code>...</code>,
coerced to 1, and included in the sum.</li>
<li><code>mean()</code> takes a single parameter, and passes on
remaining arguments to <code>...</code>. In both cases, the arguments
after the <code>1</code> are silently dropped. The correct form would be
<code>mean(c(1, 2, 3))</code>.</li>
</ul>
<p>AR Solutions: Let’s inspect the arguments and their order for both
functions. For <code>sum()</code> these are <code>...</code> and
<code>na.rm</code>:</p>
<pre class="r"><code>str(sum)</code></pre>
<pre><code>#&gt; function (..., na.rm = FALSE)</code></pre>
<p>For the <code>...</code> argument <code>sum()</code> expects numeric,
complex, or logical vector input (see <code>?sum</code>). Unfortunately,
when <code>...</code> is used, misspelled arguments (!) like
<code>na.omit</code> won’t raise an error (in case of no further input
checks). So instead, <code>na.omit</code> is treated as a logical and
becomes part of the <code>...</code> argument. It will be coerced to
<code>1</code> and be part of the sum. All other arguments are left
unchanged. Therefore <code>sum(1, 2, 3)</code> returns <code>6</code>
and <code>sum(1, 2, 3, na.omit = TRUE)</code> returns
<code>7</code>.</p>
<p>In contrast, the generic function <code>mean()</code> expects
<code>x</code>, <code>trim</code>, <code>na.rm</code> and
<code>...</code> for its default method.</p>
<pre class="r"><code>str(mean.default)</code></pre>
<pre><code>#&gt; function (x, trim = 0, na.rm = FALSE, ...)</code></pre>
<p>As <code>na.omit</code> is not one of <code>mean()</code>’s named
arguments (<code>x</code>; and no candidate for partial matching),
<code>na.omit</code> again becomes part of the <code>...</code>
argument. However, in contrast to <code>sum()</code> the elements of
<code>...</code> are not “part” of the mean. The other supplied
arguments are matched by their order, i.e. <code>x = 1</code>,
<code>trim = 2</code> and <code>na.rm = 3</code>. As <code>x</code> is
of length 1 and not <code>NA</code>, the settings of <code>trim</code>
and <code>na.rm</code> do not affect the calculation of the mean. Both
calls (<code>mean(1, 2, 3)</code> and
<code>mean(1, 2, 3, na.omit = TRUE)</code>) return <code>1</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Explain how to find the documentation for the named arguments in the
following function call:</li>
</ol>
<!-- TODO: bugfix: the figure below renders incorrectly,
     possibly due to https://github.com/rstudio/rstudio/issues/4521
     see also: https://github.com/hadley/adv-r/blob/master/common.R
     and: https://yihui.org/knitr/options/#plots
     workaround: use {r, fig.asp = 1}.
     {r, fig.asp = 1, fig.width = 3} looks correct in RStudio, but doesn't render properly for
     build_analysis_site(). {r, fig.asp = 1} works with build_analysis_site() but is not sized
     properly in RStudio. {r, fig.asp = 1} is the best option for now.
  -->
<pre class="r"><code>plot(1:10, col = &quot;red&quot;, pch = 20, xlab = &quot;x&quot;, col.lab = &quot;blue&quot;)</code></pre>
<p><img src="advanced-r-1_files/figure-html/unnamed-chunk-102-1.png" width="768" style="display: block; margin: auto;" /></p>
<p>Answer: in other functions, specifically <code>par()</code> and
<code>plot.default()</code>.</p>
<p>AR Solutions: First we type <code>?plot</code> in the console and
check the “Usage” section which contains:</p>
<pre class="r"><code>plot(x, y, ...)</code></pre>
<p>The arguments we want to learn more about (<code>col</code>,
<code>pch</code>, <code>xlab</code>, <code>col.lab</code>) are part of
the <code>...</code> argument. There we can find information for the
<code>xlab</code> argument and a recommendation to visit
<code>?par</code> for the other arguments. Under <code>?par</code> we
type “col” into the search bar, which leads us to the section “Color
Specification”. We also search for the <code>pch</code> argument, which
leads to the recommendation to check <code>?points</code>. Finally,
<code>col.lab</code> is also directly documented within
<code>?par</code>.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Why does <code>plot(1:10, col = "red")</code> only colour the
points, not the axes or labels? Read the source code of
<code>plot.default()</code> to find out.</li>
</ol>
<pre class="r"><code>localAxis &lt;- function(..., col, bg, pch, cex, lty, lwd) Axis(...)
localBox &lt;- function(..., col, bg, pch, cex, lty, lwd) box(...)
localWindow &lt;- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)
localTitle &lt;- function(..., col, bg, pch, cex, lty, lwd) title(...)</code></pre>
<p>Answer: <code>plot.default()</code> discards <code>col</code> and
several other arguments when calling <code>Axis()</code>,
<code>box()</code>, <code>plot.window()</code>, and
<code>title()</code>.</p>
<p>AR Solutions: To learn about the internals of
<code>plot.default()</code> we add <code>browser()</code> to the first
line of the code and interactively run
<code>plot(1:10, col = "red")</code>. This way we can see how the plot
is built and learn where the axes are added. This leads us to the
function call</p>
<pre class="r"><code>localTitle(main = main, sub = sub, xlab = xlab, ylab = ylab, ...)</code></pre>
<p>The <code>localTitle()</code> function was defined in the first lines
of <code>plot.default()</code> as:</p>
<pre class="r"><code>localTitle &lt;- function(..., col, bg, pch, cex, lty, lwd) title(...) # nolint: object_name_linter.</code></pre>
<p>The call to <code>localTitle()</code> passes the <code>col</code>
parameter as part of the <code>...</code> argument to
<code>title()</code>. <code>?title</code> tells us that the
<code>title()</code> function specifies four parts of the plot: Main
(title of the plot), sub (sub-title of the plot) and both axis labels.
Therefore, it would introduce ambiguity inside <code>title()</code> to
use <code>col</code> directly. Instead, one has the option to supply
<code>col</code> via the <code>...</code> argument, via
<code>col.lab</code> or as part of <code>xlab</code> in the form
<code>xlab = list(c("index"), col = "red")</code> (similar for
<code>ylab</code>).</p>
<hr />
</div>
<div id="exercises-18" class="section level2">
<h2>6.7.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What does <code>load()</code> return? Why don’t you normally see
these values?</li>
</ol>
<p>Answer: from the docs, <code>load()</code> returns “A character
vector of the names of objects created, invisibly.”</p>
<p>AR Solutions: <code>load()</code> loads objects saved to disk in
<code>.Rdata</code> files by <code>save()</code>. When run successfully,
<code>load()</code> invisibly returns a character vector containing the
names of the newly loaded objects. To print these names to the console,
one can set the argument <code>verbose</code> to <code>TRUE</code> or
surround the call in parentheses to trigger R’s auto-printing
mechanism.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What does <code>write.table()</code> return? What would be more
useful?</li>
</ol>
<p>Answer: it returns <code>invisible(NULL)</code>. Returning the
written table or the argument <code>x</code> would be more useful.</p>
<p>AR Solutions: <code>write.table()</code> writes an object, usually a
data frame or a matrix, to disk. The function invisibly returns
<code>NULL</code>. It would be more useful if <code>write.table()</code>
would (invisibly) return the input data, <code>x</code>. This would
allow to save intermediate results and directly take on further
processing steps without breaking the flow of the code (i.e. breaking it
into different lines). One package which uses this pattern is the
<code>{readr}</code> package, which is part of the <a
href="https://www.tidyverse.org/">tidyverse-ecosystem</a>.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>How does the <code>chdir</code> parameter of <code>source()</code>
compare to <code>with_dir()</code>? Why might you prefer one to the
other?</li>
</ol>
<p>Answer: both temporarily change the working directory.
<code>chdir</code> is preferable since this is expected behavior for the
function, unless you need to set a working directory other than the
directory containing <code>file</code>.</p>
<p>AR Solutions: <code>with_dir()</code> takes a path for a working
directory (<code>dir</code>) as its first argument. This is the
directory where the provided code (<code>code</code>) should be
executed. Therefore, the current working directory is changed in
<code>with_dir()</code> via <code>setwd()</code>. Then,
<code>on.exit()</code> ensures that the modification of the working
directory is reset to the initial value when the function exits. By
passing the path explicitly, the user has full control over the
directory to execute the code in.</p>
<p>In <code>source()</code> the code is passed via the <code>file</code>
argument (a path to a file). The <code>chdir</code> argument specifies
if the working directory should be changed to the directory containing
the file. The default for <code>chdir</code> is <code>FALSE</code>, so
you don’t have to provide a value. However, as you can only provide
<code>TRUE</code> or <code>FALSE</code>, you are also less flexible in
choosing the working directory for the code execution.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Write a function that opens a graphics device, runs the supplied
code, and closes the graphics device (always, regardless of whether or
not the plotting code works).</li>
</ol>
<pre class="r"><code>with_png &lt;- function(code, ...) {
  png(...)
  on.exit(dev.off(), add = TRUE, after = TRUE)
  force(code)
}

with_png(
  plot(1:10),
  filename = &quot;rendered/withpng-example.png&quot;,
  # use 3 times default resolution which is close to retina display ppi (218-254 depending on model)
  # https://support.apple.com/en-us/HT202471
  width = 480 * 3, height = 480 * 3, res = 72 * 3
)</code></pre>
<div class="figure">
<img src="rendered/withpng-example.png" alt="" />
<p class="caption">with_png output</p>
</div>
<p>Answer: code example above.</p>
<p>AR Solutions: To control the graphics device we use
<code>pdf()</code> and <code>dev.off()</code>. To ensure a clean
termination <code>on.exit()</code> is used.</p>
<pre class="r"><code>plot_pdf &lt;- function(code) {
  pdf(&quot;test.pdf&quot;)
  on.exit(dev.off(), add = TRUE)
  code
}</code></pre>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>We can use <code>on.exit()</code> to implement a simple version of
<code>capture.output()</code>.</li>
</ol>
<pre class="r"><code># nolint start: object_name_linter, undesirable_function_linter.
capture.output2 &lt;- function(code) {
  temp &lt;- tempfile()
  on.exit(file.remove(temp), add = TRUE, after = TRUE)
  sink(temp)
  on.exit(sink(), add = TRUE, after = TRUE)
  force(code)
  readLines(temp)
}
# nolint end
capture.output2(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\n&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<p>Compare <code>capture.output()</code> to
<code>capture.output2()</code>. How do the functions differ? What
features have I removed to make the key ideas easier to see? How have I
rewritten the key ideas so they’re easier to understand?</p>
<p>Answer: <code>capture.output2()</code> has fewer features and uses
two separate calls to <code>on.exit()</code>. It simply returns the
output (by line) from the executed code, and highlights the key idea,
using <code>sink()</code> to capture output to a temporary file.</p>
<p>AR Solutions: Using <code>body(capture.output)</code> we inspect the
source code of the original <code>capture.output()</code> function: The
implementation for <code>capture.output()</code> is quite a bit longer
(39 lines vs. 7 lines).</p>
<p>In <code>capture_output2()</code> the code is simply forced, and the
output is caught via <code>sink()</code> in a temporary file. An
additional feature of <code>capture_output()</code> is that one can also
capture messages by setting <code>type = "message"</code>. As this is
internally forwarded to <code>sink()</code>, this behaviour (and also
<code>sink()</code>’s <code>split</code> argument) could be easily
introduced within <code>capture_output2()</code> as well.</p>
<p>The main difference is that <code>capture.output()</code> calls
print.</p>
<hr />
</div>
<div id="exercises-19" class="section level2">
<h2>6.8.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Rewrite the following code snippets into prefix form:</li>
</ol>
<pre class="r"><code>1 + 2 + 3</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>`+`(`+`(1, 2), 3)</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>1 + (2 + 3)</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>`+`(1, `+`(2, 3))</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>fxn &lt;- function(x, n) if (length(x) &lt;= 5) x[[5]] else x[[n]]
fxn(1:5, 2)</code></pre>
<pre><code>#&gt; [1] 5</code></pre>
<pre class="r"><code>fxn(1:10, 2)</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<pre class="r"><code>fxn2 &lt;- function(x, n) `if`(`&lt;=`(length(x), 5), `[[`(x, 5), `[[`(x, n))
fxn2(1:5, 2)</code></pre>
<pre><code>#&gt; [1] 5</code></pre>
<pre class="r"><code>fxn2(1:10, 2)</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<p>Answer: inline above.</p>
<p>AR Solutions: Let’s rewrite the expressions to match the exact syntax
from the code above. Because prefix functions already define the
execution order, we may omit the parentheses in the second
expression.</p>
<pre class="r"><code>`+`(`+`(1, 2), 3)
`+`(1, `(`(`+`(2, 3)))
`+`(1, `+`(2, 3))
`if`(`&lt;=`(length(x), 5), `[[`(x, 5), `[[`(x, n))</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Clarify the following list of odd function calls:</li>
</ol>
<pre class="r"><code>x &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))
y &lt;- runif(min = 0, max = 1, 20)
cor(m = &quot;k&quot;, y = y, u = &quot;p&quot;, x = x)</code></pre>
<p>Answers: improved code below.</p>
<pre class="r"><code>x &lt;- sample(c(1:10, NA), 20, replace = TRUE)
y &lt;- runif(20)
cor(x, y, use = &quot;pairwise.complete.obs&quot;, method = &quot;kendall&quot;)</code></pre>
<pre><code>#&gt; [1] 0.01879447</code></pre>
<p>AR Solutions: None of these functions provides a <code>...</code>
argument. Therefore, the function arguments are first matched exactly,
then via partial matching and finally by position. This leads us to the
following explicit function calls:</p>
<pre class="r"><code>x &lt;- sample(c(1:10, NA), size = 20, replace = TRUE)
y &lt;- runif(20, min = 0, max = 1)
cor(x, y, use = &quot;pairwise.complete.obs&quot;, method = &quot;kendall&quot;)</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Explain why the following code fails:</li>
</ol>
<pre class="r"><code>`modify&lt;-` &lt;- function(x, position, value) {
  x[position] &lt;- value
  x
}

try(modify(get(&quot;x&quot;), 1) &lt;- 10)</code></pre>
<pre><code>#&gt; Error in modify(get(&quot;x&quot;), 1) &lt;- 10 : 
#&gt;   target of assignment expands to non-language object</code></pre>
<pre class="r"><code>#&gt; Error: target of assignment expands to non-language object</code></pre>
<p>Answer: as explained on <a
href="https://stackoverflow.com/questions/27662162/error-in-my-code-target-of-assignment-expands-to-non-language-object">stack
overflow</a>, the error is caused when assigning to an object directly,
instead of a name that refers to the object (like <code>x</code>).</p>
<p>AR Solutions: First, let’s define <code>x</code> and recall the
definition of <code>modify()</code> from <em>Advanced R</em>:</p>
<pre class="r"><code>x &lt;- 1:3

`modify&lt;-` &lt;- function(x, position, value) {
  x[position] &lt;- value
  x
}</code></pre>
<p>R internally transforms the code, and the transformed code reproduces
the error above:</p>
<pre class="r"><code>get(&quot;x&quot;) &lt;- `modify&lt;-`(get(&quot;x&quot;), 1, 10)
#&gt; Error in get(&quot;x&quot;) &lt;- `modify&lt;-`(get(&quot;x&quot;), 1, 10) :
#&gt;   target of assignment expands to non-language object</code></pre>
<p>The error occurs during the assignment because no corresponding
replacement function, i.e. <code>get&lt;-</code>, exists for
<code>get()</code>. To confirm this, we reproduce the error via the
following simplified example.</p>
<pre class="r"><code>get(&quot;x&quot;) &lt;- 2
#&gt; Error in get(&quot;x&quot;) &lt;- 2 :
#&gt;   target of assignment expands to non-language object</code></pre>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Create a replacement function that modifies a random location in a
vector.</li>
</ol>
<pre class="r"><code>`modrand&lt;-` &lt;- function(x, value) {
  x[sample(length(x), 1)] &lt;- value
  x
}

v &lt;- 1:20
modrand(v) &lt;- NA
v</code></pre>
<pre><code>#&gt;  [1]  1  2 NA  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: Let’s define <code>random&lt;-</code> like this:</p>
<pre class="r"><code>`random&lt;-` &lt;- function(x, value) {
  idx &lt;- sample(length(x), 1)
  x[idx] &lt;- value
  x
}</code></pre>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Write your own version of <code>+</code> that pastes its inputs
together if they are character vectors but behaves as usual otherwise.
In other words, make this code work:</li>
</ol>
<pre class="r"><code>`+` &lt;- function(x, y) {
  if (is.character(x) &amp;&amp; is.character(y)) {
    return(paste0(x, y))
  }
  base::`+`(x, y)
}

1 + 2</code></pre>
<pre><code>#&gt; [1] 3</code></pre>
<pre class="r"><code>#&gt; [1] 3

&quot;a&quot; + &quot;b&quot;</code></pre>
<pre><code>#&gt; [1] &quot;ab&quot;</code></pre>
<pre class="r"><code>#&gt; [1] &quot;ab&quot;

rm(`+`)</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: To achieve this behaviour, we need to override the
<code>+</code> operator. We need to take care to not use the
<code>+</code> operator itself inside of the function definition, as
this would lead to an undesired infinite recursion. We also add
<code>b = 0L</code> as a default value to keep the behaviour of
<code>+</code> as a unary operator, i.e. to keep <code>+ 1</code>
working and not throwing an error.</p>
<pre class="r"><code>`+` &lt;- function(a, b = 0L) {
  if (is.character(a) &amp;&amp; is.character(b)) {
    paste0(a, b)
  } else {
    base::`+`(a, b)
  }
}
# Test
+1</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>1 + 2</code></pre>
<pre><code>#&gt; [1] 3</code></pre>
<pre class="r"><code>&quot;a&quot; + &quot;b&quot;</code></pre>
<pre><code>#&gt; [1] &quot;ab&quot;</code></pre>
<pre class="r"><code># Return back to the original `+` operator
rm(`+`)</code></pre>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>Create a list of all the replacement functions found in the base
package. Which ones are primitive functions? (Hint: use
<code>apropos()</code>.)</li>
</ol>
<pre class="r"><code># all replacement functions in base
fun_args2[endsWith(fun_args2$name, &quot;&lt;-&quot;), ]$name</code></pre>
<pre><code>#&gt;  [1] &quot;.rowNamesDF&lt;-&quot;    &quot;[[&lt;-&quot;             &quot;[&lt;-&quot;              &quot;@&lt;-&quot;              &quot;&lt;-&quot;              
#&gt;  [6] &quot;&lt;&lt;-&quot;              &quot;$&lt;-&quot;              &quot;attr&lt;-&quot;           &quot;attributes&lt;-&quot;     &quot;body&lt;-&quot;          
#&gt; [11] &quot;class&lt;-&quot;          &quot;colnames&lt;-&quot;       &quot;comment&lt;-&quot;        &quot;diag&lt;-&quot;           &quot;dim&lt;-&quot;           
#&gt; [16] &quot;dimnames&lt;-&quot;       &quot;Encoding&lt;-&quot;       &quot;environment&lt;-&quot;    &quot;formals&lt;-&quot;        &quot;is.na&lt;-&quot;         
#&gt; [21] &quot;length&lt;-&quot;         &quot;levels&lt;-&quot;         &quot;mode&lt;-&quot;           &quot;mostattributes&lt;-&quot; &quot;names&lt;-&quot;         
#&gt; [26] &quot;oldClass&lt;-&quot;       &quot;parent.env&lt;-&quot;     &quot;regmatches&lt;-&quot;     &quot;row.names&lt;-&quot;      &quot;rownames&lt;-&quot;      
#&gt; [31] &quot;split&lt;-&quot;          &quot;storage.mode&lt;-&quot;   &quot;substr&lt;-&quot;         &quot;substring&lt;-&quot;      &quot;units&lt;-&quot;</code></pre>
<pre class="r"><code># all replacement primitive functions in base
fun_args2[endsWith(fun_args2$name, &quot;&lt;-&quot;) &amp; fun_args2$prim, ]$name</code></pre>
<pre><code>#&gt;  [1] &quot;[[&lt;-&quot;           &quot;[&lt;-&quot;            &quot;@&lt;-&quot;            &quot;&lt;-&quot;             &quot;&lt;&lt;-&quot;           
#&gt;  [6] &quot;$&lt;-&quot;            &quot;attr&lt;-&quot;         &quot;attributes&lt;-&quot;   &quot;class&lt;-&quot;        &quot;dim&lt;-&quot;         
#&gt; [11] &quot;dimnames&lt;-&quot;     &quot;environment&lt;-&quot;  &quot;length&lt;-&quot;       &quot;levels&lt;-&quot;       &quot;names&lt;-&quot;       
#&gt; [16] &quot;oldClass&lt;-&quot;     &quot;storage.mode&lt;-&quot;</code></pre>
<p>Answer: while you could use <code>apropos("&lt;-")</code>, I
leveraged the existing code from 6.2.5 #5.</p>
<p>AR Solutions: The hint suggests to look for functions with a specific
naming pattern: Replacement functions conventionally end on “&lt;-”. We
can search for these objects by supplying the regular expression
<code>"&lt;-$"</code> to <code>apropos()</code>. <code>apropos()</code>
also allows to return the position on the search path
(<code>search()</code>) for each of its matches via setting
<code>where = TRUE</code>. Finally, we can set
<code>mode = function</code> to narrow down our search to relevant
objects only. This gives us the following statement to begin with:</p>
<pre class="r"><code>repls &lt;- apropos(&quot;&lt;-&quot;, where = TRUE, mode = &quot;function&quot;)
head(repls, 30)</code></pre>
<pre><code>#&gt;                     35                     35                     35                     35 
#&gt;        &quot;.rowNamesDF&lt;-&quot;                 &quot;[[&lt;-&quot;      &quot;[[&lt;-.data.frame&quot;          &quot;[[&lt;-.factor&quot; 
#&gt;                     35                     35                     35                     35 
#&gt; &quot;[[&lt;-.numeric_version&quot;         &quot;[[&lt;-.POSIXlt&quot;                  &quot;[&lt;-&quot;       &quot;[&lt;-.data.frame&quot; 
#&gt;                     35                     35                     35                     35 
#&gt;             &quot;[&lt;-.Date&quot;         &quot;[&lt;-.difftime&quot;           &quot;[&lt;-.factor&quot;  &quot;[&lt;-.numeric_version&quot; 
#&gt;                     35                     35                     35                     16 
#&gt;          &quot;[&lt;-.POSIXct&quot;          &quot;[&lt;-.POSIXlt&quot;                  &quot;@&lt;-&quot;                &quot;%@%&lt;-&quot; 
#&gt;                     35                     35                     35                     35 
#&gt;                   &quot;&lt;-&quot;                  &quot;&lt;&lt;-&quot;                  &quot;$&lt;-&quot;       &quot;$&lt;-.data.frame&quot; 
#&gt;                     32                     35                     35                     32 
#&gt;                 &quot;as&lt;-&quot;               &quot;attr&lt;-&quot;         &quot;attributes&lt;-&quot;               &quot;body&lt;-&quot; 
#&gt;                     35                     35                     32                     35 
#&gt;               &quot;body&lt;-&quot;              &quot;class&lt;-&quot;             &quot;coerce&lt;-&quot;           &quot;colnames&lt;-&quot; 
#&gt;                     35                     21 
#&gt;            &quot;comment&lt;-&quot;          &quot;contrasts&lt;-&quot;</code></pre>
<p>To restrict <code>repl</code> to names of replacement functions from
the <code>{base}</code> package, we select only matches containing the
relevant position on the search path.</p>
<pre class="r"><code>repls_base &lt;- repls[names(repls) == length(search())]
repls_base</code></pre>
<pre><code>#&gt;                        35                        35                        35 
#&gt;           &quot;.rowNamesDF&lt;-&quot;                    &quot;[[&lt;-&quot;         &quot;[[&lt;-.data.frame&quot; 
#&gt;                        35                        35                        35 
#&gt;             &quot;[[&lt;-.factor&quot;    &quot;[[&lt;-.numeric_version&quot;            &quot;[[&lt;-.POSIXlt&quot; 
#&gt;                        35                        35                        35 
#&gt;                     &quot;[&lt;-&quot;          &quot;[&lt;-.data.frame&quot;                &quot;[&lt;-.Date&quot; 
#&gt;                        35                        35                        35 
#&gt;            &quot;[&lt;-.difftime&quot;              &quot;[&lt;-.factor&quot;     &quot;[&lt;-.numeric_version&quot; 
#&gt;                        35                        35                        35 
#&gt;             &quot;[&lt;-.POSIXct&quot;             &quot;[&lt;-.POSIXlt&quot;                     &quot;@&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;                      &quot;&lt;-&quot;                     &quot;&lt;&lt;-&quot;                     &quot;$&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;          &quot;$&lt;-.data.frame&quot;                  &quot;attr&lt;-&quot;            &quot;attributes&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;                  &quot;body&lt;-&quot;                 &quot;class&lt;-&quot;              &quot;colnames&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;               &quot;comment&lt;-&quot;                  &quot;diag&lt;-&quot;                   &quot;dim&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;              &quot;dimnames&lt;-&quot;   &quot;dimnames&lt;-.data.frame&quot;              &quot;Encoding&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;           &quot;environment&lt;-&quot;               &quot;formals&lt;-&quot;                 &quot;is.na&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;         &quot;is.na&lt;-.default&quot;          &quot;is.na&lt;-.factor&quot; &quot;is.na&lt;-.numeric_version&quot; 
#&gt;                        35                        35                        35 
#&gt;                &quot;length&lt;-&quot;           &quot;length&lt;-.Date&quot;       &quot;length&lt;-.difftime&quot; 
#&gt;                        35                        35                        35 
#&gt;         &quot;length&lt;-.factor&quot;        &quot;length&lt;-.POSIXct&quot;        &quot;length&lt;-.POSIXlt&quot; 
#&gt;                        35                        35                        35 
#&gt;                &quot;levels&lt;-&quot;         &quot;levels&lt;-.factor&quot;                  &quot;mode&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;        &quot;mostattributes&lt;-&quot;                 &quot;names&lt;-&quot;         &quot;names&lt;-.POSIXlt&quot; 
#&gt;                        35                        35                        35 
#&gt;              &quot;oldClass&lt;-&quot;            &quot;parent.env&lt;-&quot;            &quot;regmatches&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;             &quot;row.names&lt;-&quot;  &quot;row.names&lt;-.data.frame&quot;     &quot;row.names&lt;-.default&quot; 
#&gt;                        35                        35                        35 
#&gt;              &quot;rownames&lt;-&quot;                 &quot;split&lt;-&quot;      &quot;split&lt;-.data.frame&quot; 
#&gt;                        35                        35                        35 
#&gt;         &quot;split&lt;-.default&quot;          &quot;storage.mode&lt;-&quot;                &quot;substr&lt;-&quot; 
#&gt;                        35                        35                        35 
#&gt;             &quot;substring&lt;-&quot;                 &quot;units&lt;-&quot;        &quot;units&lt;-.difftime&quot;</code></pre>
<p>To find out which of these functions are primitives, we first search
for these functions via <code>mget()</code> and then subset the result
using <code>Filter()</code> and <code>is.primitive()</code>.</p>
<pre class="r"><code>repls_base_prim &lt;- mget(repls_base, envir = baseenv()) %&gt;%
  Filter(is.primitive, .) %&gt;%
  names()
repls_base_prim</code></pre>
<pre><code>#&gt;  [1] &quot;[[&lt;-&quot;           &quot;[&lt;-&quot;            &quot;@&lt;-&quot;            &quot;&lt;-&quot;             &quot;&lt;&lt;-&quot;           
#&gt;  [6] &quot;$&lt;-&quot;            &quot;attr&lt;-&quot;         &quot;attributes&lt;-&quot;   &quot;class&lt;-&quot;        &quot;dim&lt;-&quot;         
#&gt; [11] &quot;dimnames&lt;-&quot;     &quot;environment&lt;-&quot;  &quot;length&lt;-&quot;       &quot;levels&lt;-&quot;       &quot;names&lt;-&quot;       
#&gt; [16] &quot;oldClass&lt;-&quot;     &quot;storage.mode&lt;-&quot;</code></pre>
<p>Overall the <code>base</code> package contains 63 replacement
functions of which 17 are primitive functions.</p>
<hr />
<ol start="7" style="list-style-type: decimal">
<li>What are valid names for user-created infix functions?</li>
</ol>
<p>Answer: they must begin and end with <code>%</code>, and can contain
any sequence of characters except <code>%</code>.</p>
<hr />
<ol start="8" style="list-style-type: decimal">
<li>Create an infix <code>xor()</code> operator.</li>
</ol>
<pre class="r"><code>`%xor%` &lt;- function(x, y) xor(x, y)

xor(0, 0)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>xor(1, 0)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>xor(1, 1)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>0 %xor% 0</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>1 %xor% 0</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>1 %xor% 1</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: We could create an infix <code>%xor%</code> like
this:</p>
<pre class="r"><code>`%xor%` &lt;- function(a, b) {
  xor(a, b)
}
TRUE %xor% TRUE</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>FALSE %xor% TRUE</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<hr />
<ol start="9" style="list-style-type: decimal">
<li>Create infix versions of the set functions <code>intersect()</code>,
<code>union()</code>, and <code>setdiff()</code>. You might call them
<code>%n%</code>, <code>%u%</code>, and <code>%/%</code> to match
conventions from mathematics.</li>
</ol>
<pre class="r"><code>`%n%` &lt;- function(x, y) intersect(x, y)
`%u%` &lt;- function(x, y) union(x, y)
`%s%` &lt;- function(x, y) setdiff(x, y)

# taken from docs examples
(x &lt;- c(sort(sample(1:20, 9)), NA))</code></pre>
<pre><code>#&gt;  [1]  7  9 12 13 14 15 16 17 19 NA</code></pre>
<pre class="r"><code>(y &lt;- c(sort(sample(3:23, 7)), NA))</code></pre>
<pre><code>#&gt; [1]  7  9 10 14 15 18 23 NA</code></pre>
<pre class="r"><code>x %u% y</code></pre>
<pre><code>#&gt;  [1]  7  9 12 13 14 15 16 17 19 NA 10 18 23</code></pre>
<pre class="r"><code>x %n% y</code></pre>
<pre><code>#&gt; [1]  7  9 14 15 NA</code></pre>
<pre class="r"><code>x %s% y</code></pre>
<pre><code>#&gt; [1] 12 13 16 17 19</code></pre>
<pre class="r"><code>y %s% x</code></pre>
<pre><code>#&gt; [1] 10 18 23</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: These infix operators could be defined in the following
way. (<code>%/%</code> is chosen instead of <code>%\%</code>, because
<code>\</code> serves as an escape character.)</p>
<pre class="r"><code>`%n%` &lt;- function(a, b) {
  intersect(a, b)
}

`%u%` &lt;- function(a, b) {
  union(a, b)
}

`%/%` &lt;- function(a, b) {
  setdiff(a, b)
}

x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;)
y &lt;- c(&quot;a&quot;, &quot;c&quot;, &quot;d&quot;)

x %u% y</code></pre>
<pre><code>#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;c&quot;</code></pre>
<pre class="r"><code>x %n% y</code></pre>
<pre><code>#&gt; [1] &quot;a&quot; &quot;d&quot;</code></pre>
<pre class="r"><code>x %/% y</code></pre>
<pre><code>#&gt; [1] &quot;b&quot;</code></pre>
<hr />
</div>
</div>
<div id="environments" class="section level1">
<h1>7 Environments</h1>
<p>The environment is the data structure that powers scoping. This
chapter dives deep into environments, describing their structure in
depth, and using them to improve your understanding of the four scoping
rules described in Section 6.4. Understanding environments is not
necessary for day-to-day use of R. But they are important to understand
because they power many important R features like lexical scoping,
namespaces, and R6 classes, and interact with evaluation to give you
powerful tools for making domain specific languages, like dplyr and
ggplot2.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-20" class="section level2">
<h2>7.2.7 Exercises</h2>
<ol style="list-style-type: decimal">
<li>List three ways in which an environment differs from a list.</li>
</ol>
<p>Answer:</p>
<ul>
<li>Every name in an environment must be unique</li>
<li>Environment names are not ordered</li>
<li>Environments have parents (except the empty environment)</li>
<li>Environments are not copied when modified</li>
</ul>
<p>AR Solutions: The most important differences between environments and
lists are:</p>
<ul>
<li>environments have reference semantics (i.e. they don’t
copy-on-modify)</li>
<li>environments have parents</li>
<li>the contents of an environment must have unique names</li>
<li>the contents of an environment are not ordered</li>
<li>(environments can only be compared via <code>identical()</code>; not
with <code>==</code>)</li>
<li>(environments can contain themselves)</li>
</ul>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Create an environment as illustrated by this picture.</li>
</ol>
<p><img src="assets/recursive-1.png" /></p>
<pre class="r"><code>e1 &lt;- env()
e1$loop &lt;- e1</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: Let’s create an environment that contains itself.</p>
<pre class="r"><code>e1 &lt;- env()
e1$loop &lt;- e1

# Print the environment
env_print(e1)</code></pre>
<pre><code>#&gt; &lt;environment: 0x7fbb7f2c2528&gt;
#&gt; Parent: &lt;environment: 0x7fbb88618330&gt;
#&gt; Bindings:
#&gt; • loop: &lt;env&gt;</code></pre>
<pre class="r"><code># Verify that it contains itself
lobstr::ref(e1)</code></pre>
<pre><code>#&gt; █ [1:0x7fbb7f2c2528] &lt;env&gt; 
#&gt; └─loop = [1:0x7fbb7f2c2528]</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Create a pair of environments as illustrated by this picture.</li>
</ol>
<p><img src="assets/recursive-2.png" /></p>
<pre class="r"><code>e2 &lt;- env()
e3 &lt;- env()

e2$loop &lt;- e3
e3$dedoop &lt;- e2</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: These two environments contain each other:</p>
<pre class="r"><code>e1 &lt;- env()
e2 &lt;- env()

e1$loop &lt;- e2
e2$dedoop &lt;- e1

lobstr::ref(e1)</code></pre>
<pre><code>#&gt; █ [1:0x7fbb88cbe228] &lt;env&gt; 
#&gt; └─loop = █ [2:0x7fbb8a746098] &lt;env&gt; 
#&gt;          └─dedoop = [1:0x7fbb88cbe228]</code></pre>
<pre class="r"><code>lobstr::ref(e2)</code></pre>
<pre><code>#&gt; █ [1:0x7fbb8a746098] &lt;env&gt; 
#&gt; └─dedoop = █ [2:0x7fbb88cbe228] &lt;env&gt; 
#&gt;            └─loop = [1:0x7fbb8a746098]</code></pre>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Explain why <code>e[[1]]</code> and <code>e[c("a", "b")]</code>
don’t make sense when <code>e</code> is an environment.</li>
</ol>
<p>Answer: environment names are not ordered, and aren’t copied when
modified, so they aren’t subsettable.</p>
<p>AR Solutions: The first option doesn’t make sense, because elements
of an environment are not ordered. The second option would return two
objects at the same time. What data structure would they be contained
inside?</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Create a version of <code>env_poke()</code> that will only bind new
names, never re-bind old names. Some programming languages only do this,
and are known as <a
href="https://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment">single
assignment languages</a>.</li>
</ol>
<pre class="r"><code>env_poke_new &lt;- function(env, nm, value) {
  if (!is.environment(env)) stop(&quot;env is not an enviornment&quot;)
  if (nm %in% names(env)) stop(&quot;nm &#39;&quot;, nm, &quot;&#39; already bound&quot;)
  env[[nm]] &lt;- value
}

e_test &lt;- env(a = NULL, b = 2, c = &quot;three&quot;)

env_poke_new(e_test, &quot;d&quot;, &quot;success&quot;)
try(env_poke_new(e_test, &quot;a&quot;, &quot;fail&quot;))</code></pre>
<pre><code>#&gt; Error in env_poke_new(e_test, &quot;a&quot;, &quot;fail&quot;) : nm &#39;a&#39; already bound</code></pre>
<pre class="r"><code>env_print(e_test)</code></pre>
<pre><code>#&gt; &lt;environment: 0x7fbb8a53cd80&gt;
#&gt; Parent: &lt;environment: 0x7fbb88618330&gt;
#&gt; Bindings:
#&gt; • a: &lt;NULL&gt;
#&gt; • b: &lt;dbl&gt;
#&gt; • c: &lt;chr&gt;
#&gt; • d: &lt;chr&gt;</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: As described in <em>Advanced R</em>
<code>rlang::env_poke()</code> takes a name (as string) and a value to
assign (or reassign) a binding in an environment.</p>
<pre class="r"><code>e3 &lt;- new.env()

env_poke(e3, &quot;a&quot;, 100)
e3$a</code></pre>
<pre><code>#&gt; [1] 100</code></pre>
<pre class="r"><code>env_poke(e3, &quot;a&quot;, 200)
e3$a</code></pre>
<pre><code>#&gt; [1] 200</code></pre>
<p>So, we want <code>env_poke2()</code> to test, if the supplied name is
already present in the given environment. This can be checked via
<code>env_has()</code>. If this is the case, an (informative) error is
thrown.</p>
<pre class="r"><code>env_poke2 &lt;- function(env, name, value) {
  if (env_has(env, name)) {
    abort(paste0(&quot;\&quot;&quot;, name, &quot;\&quot; is already assigned to a value.&quot;))
  }

  env_poke(env, name, value)
  invisible(env)
}

# Test
env_poke2(e3, &quot;b&quot;, 100)
e3$b</code></pre>
<pre><code>#&gt; [1] 100</code></pre>
<pre class="r"><code>try(env_poke2(e3, &quot;b&quot;, 200))</code></pre>
<pre><code>#&gt; Error in env_poke2(e3, &quot;b&quot;, 200) : &quot;b&quot; is already assigned to a value.</code></pre>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>What does this function do? How does it differ from
<code>&lt;&lt;-</code> and why might you prefer it?</li>
</ol>
<pre class="r"><code>rm(a)</code></pre>
<pre><code>#&gt; Warning in rm(a): object &#39;a&#39; not found</code></pre>
<pre class="r"><code>rebind &lt;- function(name, value, env = caller_env()) {
  if (identical(env, empty_env())) {
    stop(&quot;Can&#39;t find `&quot;, name, &quot;`&quot;, call. = FALSE)
  } else if (env_has(env, name)) {
    env_poke(env, name, value)
  } else {
    rebind(name, value, env_parent(env))
  }
}
try(rebind(&quot;a&quot;, 10))</code></pre>
<pre><code>#&gt; Error : Can&#39;t find `a`</code></pre>
<pre class="r"><code>(a &lt;- 5)</code></pre>
<pre><code>#&gt; [1] 5</code></pre>
<pre class="r"><code>rebind(&quot;a&quot;, 10)
a</code></pre>
<pre><code>#&gt; [1] 10</code></pre>
<p>Answer: <code>&lt;&lt;-</code> will assign a value to the name in the
global environment if the name is not found, <code>rebind()</code> does
not.</p>
<p>AR Solutions: The primary difference between <code>rebind()</code>
and <code>&lt;&lt;-</code> is that <code>rebind()</code> will only carry
out an assignment when it finds an existing binding; unlike
<code>&lt;&lt;-</code> it will never create a new one in the global
environment. This behaviour of <code>&lt;&lt;-</code> is usually
undesirable because global variables introduce non-obvious dependencies
between functions.</p>
<hr />
</div>
<div id="exercises-21" class="section level2">
<h2>7.3.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Modify <code>where()</code> to return <em>all</em> environments that
contain a binding for <code>name</code>. Carefully think through what
type of object the function will need to return.</li>
</ol>
<pre class="r"><code>where &lt;- function(name, env = caller_env()) {
  if (identical(env, empty_env())) {
    # Base case
    stop(&quot;Can&#39;t find &quot;, name, call. = FALSE)
  } else if (env_has(env, name)) {
    # Success case
    env
  } else {
    # Recursive case
    where(name, env_parent(env))
  }
}

x &lt;- 5
try(where(&quot;yyy&quot;))</code></pre>
<pre><code>#&gt; Error : Can&#39;t find yyy</code></pre>
<pre class="r"><code>where(&quot;x&quot;)</code></pre>
<pre><code>#&gt; &lt;environment: 0x7fbb88618330&gt;</code></pre>
<pre class="r"><code>where(&quot;mean&quot;)</code></pre>
<pre><code>#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>all_where &lt;- function(name, env = caller_env(), found = list()) {
  if (identical(env, empty_env())) {
    # Base case
    found
  } else if (env_has(env, name)) {
    # Success case
    all_where(name, env_parent(env), append(env, found, after = 0))
  } else {
    # Recursive case
    all_where(name, env_parent(env), found)
  }
}

all_where(&quot;x&quot;)</code></pre>
<pre><code>#&gt; [[1]]
#&gt; &lt;environment: 0x7fbb88618330&gt;</code></pre>
<pre class="r"><code>local({
  x &lt;- 10
  all_where(&quot;x&quot;)
})</code></pre>
<pre><code>#&gt; [[1]]
#&gt; &lt;environment: 0x7fbb4ca56a80&gt;
#&gt; 
#&gt; [[2]]
#&gt; &lt;environment: 0x7fbb88618330&gt;</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: <code>where()</code> searches (recursively) for a given
name within a given environment and its ancestors. If
<code>where()</code> finds the name in one of these environments, it
returns the environment’s name. Otherwise, it throws an error.</p>
<p>Our modified version of <code>where()</code> will always recurse
until it reaches the empty environment. No matter if it has already
found the name or not. Along the way, it will check each environment for
the given <code>name</code>. Finally, it will return a list of
environments where the binding was found; if no binding was found, the
list will be empty.</p>
<p>Please also note how the list is initialised via the default
argument, when the function is called for the first time. This is a bit
confusing, which is why it’s common to wrap a recursive function inside
another, more user friendly, function.</p>
<pre class="r"><code>where2 &lt;- function(name, env = caller_env(), results = list()) {
  if (identical(env, empty_env())) {
    # Base case
    results
  } else {
    # Recursive case
    if (env_has(env, name)) {
      results &lt;- c(results, env)
    }
    where2(name, env_parent(env), results)
  }
}
# Test
e1a &lt;- env(empty_env(), a = 1, b = 2)
e1b &lt;- env(e1a, b = 10, c = 11)
e1c &lt;- env(e1b, a = 12, d = 13)
where2(&quot;a&quot;, e1c)</code></pre>
<pre><code>#&gt; [[1]]
#&gt; &lt;environment: 0x7fbb4f0890e8&gt;
#&gt; 
#&gt; [[2]]
#&gt; &lt;environment: 0x7fbb4f0f7388&gt;</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Write a function called <code>fget()</code> that finds only function
objects. It should have two arguments, <code>name</code> and
<code>env</code>, and should obey the regular scoping rules for
functions: if there’s an object with a matching name that’s not a
function, look in the parent. For an added challenge, also add an
<code>inherits</code> argument which controls whether the function
recurses up the parents or only looks in one environment.</li>
</ol>
<pre class="r"><code>fget &lt;- function(name, env = caller_env(), inherits = TRUE) {
  if (identical(env, empty_env())) {
    # Base case
    stop(&quot;Can&#39;t find &quot;, name, call. = FALSE)
  } else if (env_has(env, name) &amp;&amp; is.function(env[[name]])) {
    # Success case
    env
  } else if (inherits) {
    # Recursive case
    fget(name, env_parent(env))
  } else {
    stop(&quot;Can&#39;t find &quot;, name, call. = FALSE)
  }
}

try(fget(&quot;x&quot;))</code></pre>
<pre><code>#&gt; Error : Can&#39;t find x</code></pre>
<pre class="r"><code>fget(&quot;print&quot;)</code></pre>
<pre><code>#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>try(fget(&quot;print&quot;, inherits = FALSE))</code></pre>
<pre><code>#&gt; Error : Can&#39;t find print</code></pre>
<pre class="r"><code>fget(&quot;all_where&quot;, inherits = FALSE)</code></pre>
<pre><code>#&gt; &lt;environment: 0x7fbb88618330&gt;</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: We follow a similar approach to the previous exercise.
This time we additionally check if the found object is a function and
implement an argument to turn off the recursion, if desired.</p>
<pre class="r"><code>fget &lt;- function(name, env = caller_env(), inherits = TRUE) {
  # Base case
  if (env_has(env, name)) {
    obj &lt;- env_get(env, name)
    if (is.function(obj)) {
      return(obj)
    }
  }
  if (identical(env, emptyenv()) || !inherits) {
    stop(&quot;Could not find a function called \&quot;&quot;, name, &quot;\&quot;.&quot;,
      call. = FALSE
    )
  }

  # Recursive Case
  fget(name, env_parent(env))
}

# Test
mean &lt;- 10
fget(&quot;mean&quot;, inherits = TRUE)</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; UseMethod(&quot;mean&quot;)
#&gt; &lt;bytecode: 0x7fbb4efda360&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<hr />
</div>
<div id="exercises-22" class="section level2">
<h2>7.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How is <code>search_envs()</code> different from
<code>env_parents(global_env())</code>?</li>
</ol>
<p>Answer: <code>search_envs()</code> includes the global environment.
<code>env_parents(global_env())</code> doesn’t include the global
environment and also returns the empty environment (the top parent).</p>
<p>AR Solutions: <code>search_envs()</code> returns all the environments
on the search path, which is “a chain of environments containing
exported functions of attached packages” (from
<code>?search_envs</code>). Every time you attach a new package, this
search path will grow. The search path ends with the base-environment.
The global environment is included, because functions present in the
global environment will always be part of the search path.</p>
<p><code>env_parents(global_env())</code> will list all the ancestors of
the global environment, therefore the global environment itself is not
included. This also includes the “ultimate ancestor”, the empty
environment. This environment is not considered part of the search path
because it contains no objects.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Draw a diagram that shows the enclosing environments of this
function:</li>
</ol>
<pre class="r"><code>f1 &lt;- function(x1) {
  f2 &lt;- function(x2) {
    f3 &lt;- function(x3) {
      x1 + x2 + x3
    }
    f3(3)
  }
  f2(2)
}
f1(1)</code></pre>
<p>Answer: No.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Write an enhanced version of <code>str()</code> that provides more
information about functions. Show where the function was found and what
environment it was defined in.</li>
</ol>
<pre class="r"><code>e_str &lt;- function(object, ...) {
  str(object, ...)
  if (is.function(object)) {
    message(&quot;fn_env():&quot;)
    print(fn_env(object))
    message(&quot;environment():&quot;)
    print(environment(object))
  }
}

e_str(print)</code></pre>
<pre><code>#&gt; function (x, ...)</code></pre>
<pre><code>#&gt; fn_env():</code></pre>
<pre><code>#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre><code>#&gt; environment():</code></pre>
<pre><code>#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>e_str(fget)</code></pre>
<pre><code>#&gt; function (name, env = caller_env(), inherits = TRUE)  
#&gt;  - attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 1 9 17 1 9 1 1 17
#&gt;   ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7fbb4d187ae8&gt;</code></pre>
<pre><code>#&gt; fn_env():</code></pre>
<pre><code>#&gt; &lt;environment: 0x7fbb88618330&gt;</code></pre>
<pre><code>#&gt; environment():</code></pre>
<pre><code>#&gt; &lt;environment: 0x7fbb88618330&gt;</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: To solve this problem, we need to write a function that
takes the name of a function and looks for that function returning both
the function and the environment that it was found in.</p>
<pre class="r"><code>fget2 &lt;- function(name, env = caller_env()) {
  # Base case
  if (env_has(env, name)) {
    obj &lt;- env_get(env, name)
    if (is.function(obj)) {
      return(list(fun = obj, env = env))
    }
  }
  if (identical(env, emptyenv())) {
    stop(&quot;Could not find a function called \&quot;&quot;, name, &quot;\&quot;&quot;,
      call. = FALSE
    )
  }
  # Recursive Case
  fget2(name, env_parent(env))
}

fstr &lt;- function(fun_name, env = caller_env()) {
  if (!is.character(fun_name) &amp;&amp; length(fun_name) == 1) {
    stop(&quot;`fun_name` must be a string.&quot;, call. = FALSE)
  }
  fun_env &lt;- fget2(fun_name, env)
  list(
    where = fun_env$env,
    enclosing = fn_env(fun_env$fun)
  )
}

# Test
fstr(&quot;mean&quot;)</code></pre>
<pre><code>#&gt; $where
#&gt; &lt;environment: namespace:base&gt;
#&gt; 
#&gt; $enclosing
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<p>Once you have learned about tidy evaluation, you could rewrite
<code>fstr()</code> to use <code>enquo()</code> so that you’d call it
more like <code>str()</code>, i.e. <code>fstr(sum)</code>.</p>
<hr />
</div>
<div id="exercises-23" class="section level2">
<h2>7.5.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Write a function that lists all the variables defined in the
environment in which it was called. It should return the same results as
<code>ls()</code>.</li>
</ol>
<pre class="r"><code>my_ls &lt;- function() {
  vars &lt;- sort(names(parent.frame()))
  vars[!startsWith(vars, &quot;.&quot;)]
}

ls()</code></pre>
<pre><code>#&gt;  [1] &quot;a&quot;            &quot;all_where&quot;    &quot;e_str&quot;        &quot;e_test&quot;       &quot;e1&quot;           &quot;e1a&quot;         
#&gt;  [7] &quot;e1b&quot;          &quot;e1c&quot;          &quot;e2&quot;           &quot;e3&quot;           &quot;env_poke_new&quot; &quot;env_poke2&quot;   
#&gt; [13] &quot;fget&quot;         &quot;fget2&quot;        &quot;fstr&quot;         &quot;mean&quot;         &quot;my_ls&quot;        &quot;rebind&quot;      
#&gt; [19] &quot;where&quot;        &quot;where2&quot;       &quot;x&quot;</code></pre>
<pre class="r"><code>my_ls()</code></pre>
<pre><code>#&gt;  [1] &quot;a&quot;            &quot;all_where&quot;    &quot;e_str&quot;        &quot;e_test&quot;       &quot;e1&quot;           &quot;e1a&quot;         
#&gt;  [7] &quot;e1b&quot;          &quot;e1c&quot;          &quot;e2&quot;           &quot;e3&quot;           &quot;env_poke_new&quot; &quot;env_poke2&quot;   
#&gt; [13] &quot;fget&quot;         &quot;fget2&quot;        &quot;fstr&quot;         &quot;mean&quot;         &quot;my_ls&quot;        &quot;rebind&quot;      
#&gt; [19] &quot;where&quot;        &quot;where2&quot;       &quot;x&quot;</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: We can implement this dynamic scoping behaviour by
explicitly referencing the caller environment. Please note that this
approach returns also variables starting with a dot, an option that
<code>ls()</code> usually requires.</p>
<pre class="r"><code>ls2 &lt;- function(env = caller_env()) {
  sort(env_names(env))
}

# Test in global environment
ls(all.names = TRUE)</code></pre>
<pre><code>#&gt;  [1] &quot;a&quot;            &quot;all_where&quot;    &quot;e_str&quot;        &quot;e_test&quot;       &quot;e1&quot;           &quot;e1a&quot;         
#&gt;  [7] &quot;e1b&quot;          &quot;e1c&quot;          &quot;e2&quot;           &quot;e3&quot;           &quot;env_poke_new&quot; &quot;env_poke2&quot;   
#&gt; [13] &quot;fget&quot;         &quot;fget2&quot;        &quot;fstr&quot;         &quot;ls2&quot;          &quot;mean&quot;         &quot;my_ls&quot;       
#&gt; [19] &quot;rebind&quot;       &quot;where&quot;        &quot;where2&quot;       &quot;x&quot;</code></pre>
<pre class="r"><code>ls2()</code></pre>
<pre><code>#&gt;  [1] &quot;a&quot;            &quot;all_where&quot;    &quot;e_str&quot;        &quot;e_test&quot;       &quot;e1&quot;           &quot;e1a&quot;         
#&gt;  [7] &quot;e1b&quot;          &quot;e1c&quot;          &quot;e2&quot;           &quot;e3&quot;           &quot;env_poke_new&quot; &quot;env_poke2&quot;   
#&gt; [13] &quot;fget&quot;         &quot;fget2&quot;        &quot;fstr&quot;         &quot;ls2&quot;          &quot;mean&quot;         &quot;my_ls&quot;       
#&gt; [19] &quot;rebind&quot;       &quot;where&quot;        &quot;where2&quot;       &quot;x&quot;</code></pre>
<pre class="r"><code># Test in &quot;sandbox&quot; environment
e1 &lt;- env(a = 1, b = 2)
ls(e1)</code></pre>
<pre><code>#&gt; [1] &quot;a&quot; &quot;b&quot;</code></pre>
<pre class="r"><code>ls2(e1)</code></pre>
<pre><code>#&gt; [1] &quot;a&quot; &quot;b&quot;</code></pre>
<hr />
</div>
</div>
<div id="conditions" class="section level1">
<h1>8 Conditions</h1>
<p>The <strong>condition</strong> system provides a paired set of tools
that allow the author of a function to indicate that something unusual
is happening, and the user of that function to deal with it. The
function author <strong>signals</strong> conditions with functions like
<code>stop()</code> (for errors), <code>warning()</code> (for warnings),
and <code>message()</code> (for messages), then the function user can
handle them with functions like <code>tryCatch()</code> and
<code>withCallingHandlers()</code>. Understanding the condition system
is important because you’ll often need to play both roles: signalling
conditions from the functions you create, and handle conditions
signalled by the functions you call.</p>
<p>R offers a very powerful condition system based on ideas from Common
Lisp. Like R’s approach to object-oriented programming, it is rather
different to currently popular programming languages so it is easy to
misunderstand, and there has been relatively little written about how to
use it effectively. Historically, this has meant that few people (myself
included) have taken full advantage of its power. The goal of this
chapter is to remedy that situation. Here you will learn about the big
ideas of R’s condition system, as well as learning a bunch of practical
tools that will make your code stronger.</p>
<p>I found two resources particularly useful when writing this chapter.
You may also want to read them if you want to learn more about the
inspirations and motivations for the system:</p>
<ul>
<li><p><a
href="https://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html"><em>A
prototype of a condition system for R</em></a> by Robert Gentleman and
Luke Tierney. This describes an early version of R’s condition system.
While the implementation has changed somewhat since this document was
written, it provides a good overview of how the pieces fit together, and
some motivation for its design.</p></li>
<li><p><a
href="https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html"><em>Beyond
exception handling: conditions and restarts</em></a> by Peter Seibel.
This describes exception handling in Lisp, which happens to be very
similar to R’s approach. It provides useful motivation and more
sophisticated examples. I have provided an R translation of the chapter
at <a href="http://adv-r.had.co.nz/beyond-exception-handling.html"
class="uri">http://adv-r.had.co.nz/beyond-exception-handling.html</a>.</p></li>
</ul>
<p>I also found it helpful to work through the underlying C code that
implements these ideas. If you’re interested in understanding how it all
works, you might find <a
href="https://gist.github.com/hadley/4278d0a6d3a10e42533d59905fbed0ac">my
notes</a> to be useful.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-24" class="section level2">
<h2>8.2.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Write a wrapper around <code>file.remove()</code> that throws an
error if the file to be deleted does not exist.</li>
</ol>
<pre class="r"><code>safe_file_remove &lt;- function(...) {
  if (!file.exists(...)) stop(&quot;file &#39;&quot;, ..., &quot;&#39; does not exist&quot;)
  file.remove(...)
}

tmp &lt;- tempfile()

file.create(tmp)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>safe_file_remove(tmp)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>file.remove(tmp)</code></pre>
<pre><code>#&gt; Warning in file.remove(tmp): cannot remove file &#39;/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//
#&gt; RtmpBzrC2m/file13e427fc1a02c&#39;, reason &#39;No such file or directory&#39;</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>try(safe_file_remove(tmp))</code></pre>
<pre><code>#&gt; Error in safe_file_remove(tmp) : 
#&gt;   file &#39;/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//RtmpBzrC2m/file13e427fc1a02c&#39; does not exist</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: We prefer the following solution for its clarity and
simplicity:</p>
<pre class="r"><code>file_remove_strict &lt;- function(path) {
  if (!file.exists(path)) {
    stop(&quot;Can&#39;t delete the file \&quot;&quot;, path,
      &quot;\&quot; because it doesn&#39;t exist.&quot;,
      call. = FALSE
    )
  }
  file.remove(path)
}

# Test
saveRDS(mtcars, &quot;mtcars.rds&quot;)
file_remove_strict(&quot;mtcars.rds&quot;)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>try(file_remove_strict(&quot;mtcars.rds&quot;))</code></pre>
<pre><code>#&gt; Error : Can&#39;t delete the file &quot;mtcars.rds&quot; because it doesn&#39;t exist.</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What does the <code>appendLF</code> argument to
<code>message()</code> do? How is it related to <code>cat()</code>?</li>
</ol>
<p>Answer: <code>appendLF</code> controls whether or not a newline is
added to the message; by default, <code>cat()</code> does not add a
newline.</p>
<p>AR Solutions: The <code>appendLF</code> argument automatically
appends a new line to the message.</p>
<p>Comparable behaviour regarding line breaks for <code>cat()</code> can
be achieved via setting its <code>sep</code> argument to
<code>"\n"</code>.</p>
<hr />
</div>
<div id="exercises-25" class="section level2">
<h2>8.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What extra information does the condition generated by
<code>abort()</code> contain compared to the condition generated by
<code>stop()</code> i.e. what’s the difference between these two
objects? Read the help for <code>?abort</code> to learn more.</li>
</ol>
<pre class="r"><code>catch_cnd(stop(&quot;An error&quot;))</code></pre>
<pre><code>#&gt; &lt;simpleError in force(expr): An error&gt;</code></pre>
<pre class="r"><code>catch_cnd(abort(&quot;An error&quot;))</code></pre>
<pre><code>#&gt; &lt;error/rlang_error&gt;
#&gt; Error:
#&gt; ! An error
#&gt; ---
#&gt; Backtrace:</code></pre>
<p>Answer: <code>abort()</code> includes the error message and backtrace
in the condition object. <code>abort()</code> uses the custom class
<code>rlang_error</code>.</p>
<p>AR Solutions: In contrast to <code>stop()</code>, which contains the
call, <code>abort()</code> stores the whole backtrace generated by
<code>rlang::trace_back()</code>. This is a lot of extra data!</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Predict the results of evaluating the following code</li>
</ol>
<pre class="r"><code>show_condition &lt;- function(code) {
  tryCatch(
    error = function(cnd) &quot;error&quot;,
    warning = function(cnd) &quot;warning&quot;,
    message = function(cnd) &quot;message&quot;,
    {
      code
      NULL
    }
  )
}

show_condition(stop(&quot;!&quot;)) #&gt; &quot;error&quot;</code></pre>
<pre><code>#&gt; [1] &quot;error&quot;</code></pre>
<pre class="r"><code>show_condition(10) #&gt; 10 [NULL]</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>show_condition(warning(&quot;?!&quot;)) #&gt; &quot;warning&quot;</code></pre>
<pre><code>#&gt; [1] &quot;warning&quot;</code></pre>
<pre class="r"><code>show_condition({
  10
  message(&quot;?&quot;)
  warning(&quot;?!&quot;)
})</code></pre>
<pre><code>#&gt; [1] &quot;message&quot;</code></pre>
<pre class="r"><code>#&gt; 10
#&gt; &quot;message&quot;
#&gt; &quot;warning&quot;</code></pre>
<p>Answer: predictions in comments. The prediction for
<code>show_condition(10)</code> was incorrect; the correct answer is
<code>NULL</code> as that’s what’s returned when there is no condition.
The final prediction was also incorrect; the <code>tryCatch()</code>
call stops further execution when the <code>message()</code> is
caught.</p>
<p>AR Solutions: The first three examples are straightforward:</p>
<pre class="r"><code>show_condition(stop(&quot;!&quot;)) # stop raises an error</code></pre>
<pre><code>#&gt; [1] &quot;error&quot;</code></pre>
<pre class="r"><code>show_condition(10) # no condition is signalled</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>show_condition(warning(&quot;?!&quot;)) # warning raises a warning</code></pre>
<pre><code>#&gt; [1] &quot;warning&quot;</code></pre>
<p>The last example is the most interesting and makes us aware of the
exiting qualities of <code>tryCatch()</code>; it will terminate the
evaluation of the code as soon as it is called.</p>
<pre class="r"><code>show_condition({
  10
  message(&quot;?&quot;)
  warning(&quot;?!&quot;)
})</code></pre>
<pre><code>#&gt; [1] &quot;message&quot;</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Explain the results of running this code:</li>
</ol>
<pre class="r"><code>withCallingHandlers(
  message = function(cnd) message(&quot;b&quot;), # handler 1
  withCallingHandlers(
    message = function(cnd) message(&quot;a&quot;), # handler 2
    message(&quot;c&quot;)
  )
)</code></pre>
<pre><code>#&gt; b</code></pre>
<pre><code>#&gt; a</code></pre>
<pre><code>#&gt; b</code></pre>
<pre><code>#&gt; c</code></pre>
<p>Answer:</p>
<ol style="list-style-type: decimal">
<li><code>message("c")</code> is caught, handler 2 is called</li>
<li>in handler 2, <code>message("a")</code> is caught and handler 1 is
called</li>
<li>handler 1 writes message <code>b</code></li>
<li>code resumes and handler 2 writes message <code>a</code></li>
<li><code>message("c")</code> propagates to the parent, is caught, and
handler 1 is called</li>
<li>handler 1 writes message <code>b</code></li>
<li>code resumes and the code writes message <code>c</code></li>
</ol>
<p>AR Solutions: It’s a little tricky to untangle the flow here: First,
<code>message("c")</code> is run, and it’s caught by (1). It then calls
<code>message("a")</code>, which is caught by (2), which calls
<code>message("b")</code>. <code>message("b")</code> isn’t caught by
anything, so we see a <code>b</code> on the console, followed by
<code>a</code>. But why do we get another <code>b</code> before we see
<code>c</code>? That’s because we haven’t handled the message, so it
bubbles up to the outer calling handler.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Read the source code for <code>catch_cnd()</code> and explain how it
works.</li>
</ol>
<pre class="r"><code>catch_cnd</code></pre>
<pre><code>#&gt; function (expr, classes = &quot;condition&quot;) 
#&gt; {
#&gt;     stopifnot(is_character(classes))
#&gt;     handlers &lt;- rep_named(classes, list(identity))
#&gt;     eval_bare(rlang::expr(tryCatch(!!!handlers, {
#&gt;         force(expr)
#&gt;         return(NULL)
#&gt;     })))
#&gt; }
#&gt; &lt;bytecode: 0x7fbb4fbfbb18&gt;
#&gt; &lt;environment: namespace:rlang&gt;</code></pre>
<pre class="r"><code>catch_cnd(stop(&quot;error&quot;))</code></pre>
<pre><code>#&gt; &lt;simpleError in force(expr): error&gt;</code></pre>
<pre class="r"><code># replicate the core functionality
tryCatch(condition = function(x) x, force(stop(&quot;error&quot;)))</code></pre>
<pre><code>#&gt; &lt;simpleError in force(stop(&quot;error&quot;)): error&gt;</code></pre>
<p>Answer: <code>catch_cnd()</code> uses <code>tryCatch()</code> to
catch any condition and return itself using <code>identity()</code>.</p>
<p>AR Solutions: At the time <em>Advanced R</em> was written, the source
for <code>catch_cnd()</code> was a little simpler:</p>
<pre class="r"><code>catch_cnd &lt;- function(expr) {
  tryCatch(
    condition = function(cnd) cnd,
    {
      force(expr)
      return(NULL)
    }
  )
}</code></pre>
<p><code>catch_cnd()</code> is a simple wrapper around
<code>tryCatch()</code>. If a condition is signalled, it’s caught and
returned. If no condition is signalled, execution proceeds sequentially
and the function returns <code>NULL</code>.</p>
<p>The current version of <code>catch_cnd()</code> is a little more
complex because it allows you to specify which classes of condition you
want to capture. This requires some manual code generation because the
interface of <code>tryCatch()</code> provides condition classes as
argument names.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>How could you rewrite <code>show_condition()</code> to use a single
handler?</li>
</ol>
<pre class="r"><code>show_condition2 &lt;- function(code) {
  tryCatch(
    condition = function(cnd) {
      if (is_error(cnd)) {
        return(&quot;error&quot;)
      }
      if (is_warning(cnd)) {
        return(&quot;warning&quot;)
      }
      if (is_message(cnd)) {
        return(&quot;message&quot;)
      }
    },
    {
      code
      NULL
    }
  )
}

show_condition2(stop(&quot;!&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;error&quot;</code></pre>
<pre class="r"><code>show_condition2(10)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>show_condition2(warning(&quot;?!&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;warning&quot;</code></pre>
<pre class="r"><code>show_condition2({
  10
  message(&quot;?&quot;)
  warning(&quot;?!&quot;)
})</code></pre>
<pre><code>#&gt; [1] &quot;message&quot;</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: <code>show_condition()</code> was defined in one of the
previous questions. Let’s use the <code>condition</code> argument of
<code>tryCatch()</code> as shown in <code>rlang::catch_cond()</code>
above for our re-implementation:</p>
<pre class="r"><code>show_condition2 &lt;- function(code) {
  tryCatch(
    condition = function(cnd) {
      if (inherits(cnd, &quot;error&quot;)) {
        return(&quot;error&quot;)
      }
      if (inherits(cnd, &quot;warning&quot;)) {
        return(&quot;warning&quot;)
      }
      if (inherits(cnd, &quot;message&quot;)) {
        return(&quot;message&quot;)
      }
    },
    {
      code
      NULL
    }
  )
}

# Test
show_condition2(stop(&quot;!&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;error&quot;</code></pre>
<pre class="r"><code>show_condition2(10)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>show_condition2(warning(&quot;?!&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;warning&quot;</code></pre>
<pre class="r"><code>show_condition2({
  10
  message(&quot;?&quot;)
  warning(&quot;?!&quot;)
})</code></pre>
<pre><code>#&gt; [1] &quot;message&quot;</code></pre>
<p><code>tryCatch()</code> executes the code and captures any condition
raised. The function provided as the <code>condition</code> handles this
condition. In this case it dispatches on the class of the condition.</p>
<hr />
</div>
<div id="exercises-26" class="section level2">
<h2>8.5.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Inside a package, it’s occasionally useful to check that a package
is installed before using it. Write a function that checks if a package
is installed (with
<code>requireNamespace("pkg", quietly = FALSE))</code> and if not,
throws a custom condition that includes the package name in the
metadata.</li>
</ol>
<pre class="r"><code>my_check_installed &lt;- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    abort(
      &quot;error_not_found&quot;,
      message = paste0(&quot;package &#39;&quot;, pkg, &quot;&#39; not found&quot;),
      pkg = pkg
    )
  }
}

my_check_installed(&quot;rlang&quot;)
# NOTE: this code causes renv::dependencies() to mistakenly report package &#39;pkg&#39; as a dependency
# nolint start: commented_code_linter.
# requireNamespace(&quot;pkg&quot;, quietly = FALSE)
# err &lt;- catch_cnd(my_check_installed(&quot;pkg&quot;))
# err
# err$pkg
# nolint end
try(my_check_installed(&quot;pkg&quot;))</code></pre>
<pre><code>#&gt; Error in my_check_installed(&quot;pkg&quot;) : package &#39;pkg&#39; not found</code></pre>
<p>Answer: code above. The question specifies to use
<code>quietly = FALSE</code>, but this approach makes more sense (to
me). The alternative is to catch the ‘Failed with error:’ message which
seems less reliable.</p>
<pre class="r"><code>my_check_installed2 &lt;- function(pkg) {
  tryCatch(
    condition = function(cnd) {
      abort(
        &quot;error_not_found&quot;,
        message = paste0(&quot;package &#39;&quot;, pkg, &quot;&#39; not found&quot;),
        pkg = pkg
      )
    },
    requireNamespace(pkg, quietly = FALSE)
  )
}

my_check_installed2(&quot;rlang&quot;)
try(my_check_installed2(&quot;pkg&quot;))</code></pre>
<pre><code>#&gt; Error in value[[3L]](cond) : package &#39;pkg&#39; not found</code></pre>
<p>The alternative version, <code>my_check_installed2()</code> works but
its Backtrace is harder to read.</p>
<p>AR Solutions: We use <code>rlang::abort()</code> to supply error
metadata:</p>
<pre class="r"><code>check_installed &lt;- function(package) {
  if (!requireNamespace(package, quietly = FALSE)) {
    abort(
      &quot;error_pkg_not_found&quot;,
      message = paste0(&quot;package &#39;&quot;, package, &quot;&#39; not installed.&quot;),
      package = package
    )
  }
  TRUE
}
check_installed(&quot;rlang&quot;)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>try(check_installed(&quot;ggplot3&quot;))</code></pre>
<pre><code>#&gt; Loading required namespace: ggplot3</code></pre>
<pre><code>#&gt; Error in check_installed(&quot;ggplot3&quot;) : package &#39;ggplot3&#39; not installed.</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Inside a package you often need to stop with an error when something
is not right. Other packages that depend on your package might be
tempted to check these errors in their unit tests. How could you help
these packages to avoid relying on the error message which is part of
the user interface rather than the API and might change without
notice?</li>
</ol>
<p>Answer: return custom error objects that aren’t dependent on the
error text (like in 8.5.3)</p>
<p>AR Solutions: Instead of returning an error it might be preferable to
throw a customised condition and place a standardised error message
inside the metadata. Then the downstream package could check for the
class of the condition, rather than inspecting the message.</p>
<hr />
</div>
<div id="exercises-27" class="section level2">
<h2>8.6.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Create <code>suppressConditions()</code> that works like
<code>suppressMessages()</code> and <code>suppressWarnings()</code> but
suppresses everything. Think carefully about how you should handle
errors.</li>
</ol>
<pre class="r"><code>suppressConditions &lt;- function(expr) { # nolint: object_name_linter.
  tryCatch(
    error = function(cnd) invisible(cnd),
    withCallingHandlers(
      condition = function(cnd) {
        cnd_muffle(cnd)
      },
      expr
    )
  )
}

sup &lt;- suppressConditions({
  message(&quot;processing...&quot;)
  warning(&quot;something went wrong&quot;)
  print(&quot;still running&quot;)
  stop(&quot;error&quot;)
  print(&quot;this shouldn&#39;t run&quot;)
})</code></pre>
<pre><code>#&gt; [1] &quot;still running&quot;</code></pre>
<pre class="r"><code>str(sup)</code></pre>
<pre><code>#&gt; List of 2
#&gt;  $ message: chr &quot;error&quot;
#&gt;  $ call   : language withCallingHandlers(condition = function(cnd) {     cnd_muffle(cnd) ...
#&gt;  - attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</code></pre>
<p>Answer: code above. Errors are not printed, but are returned,
invisibly.</p>
<p>AR Solutions: In general, we would like to catch errors, since they
contain important information for debugging. To suppress the error
message and hide the returned error object from the console, we handle
errors within a <code>tryCatch()</code> and return the error object
invisibly:</p>
<pre class="r"><code>suppressErrors &lt;- function(expr) { # nolint: object_name_linter.
  tryCatch(
    error = function(cnd) invisible(cnd),
    interrupt = function(cnd) {
      stop(&quot;Terminated by the user.&quot;,
        call. = FALSE
      )
    },
    expr
  )
}</code></pre>
<p>After we defined the error handling, we can just combine it with the
other handlers to create <code>suppressConditions()</code>:</p>
<pre class="r"><code>suppressConditions &lt;- function(expr) { # nolint: object_name_linter.
  suppressErrors(suppressWarnings(suppressMessages(expr)))
}</code></pre>
<p>To test the new function, we apply it to a set of conditions and
inspect the returned error object.</p>
<pre class="r"><code># The messages/warnings/conditions are suppressed successfully
error_obj &lt;- suppressConditions({
  message(&quot;message&quot;)
  warning(&quot;warning&quot;)
  abort(&quot;error&quot;)
})
error_obj</code></pre>
<pre><code>#&gt; &lt;error/rlang_error&gt;
#&gt; Error:
#&gt; ! error
#&gt; ---
#&gt; Backtrace:</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Compare the following two implementations of
<code>message2error()</code>. What is the main advantage of
<code>withCallingHandlers()</code> in this scenario? (Hint: look
carefully at the traceback.)</li>
</ol>
<pre class="r"><code>message2error &lt;- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}

message2error2 &lt;- function(code) {
  tryCatch(code, message = function(e) stop(e))
}</code></pre>
<p>Answer: <code>message2error()</code> shows the invocation of
<code>message()</code> in the traceback, but
<code>message2error2()</code> does not.</p>
<p>AR Solutions: Both functions differ in the way conditions are
handled. <code>withCallingHandlers()</code> creates a <em>calling
handler</em>, which is executed from within the signalling function.
This makes it possible to record a detailed call stack, which helps us
identify the signalling condition.</p>
<p><code>tryCatch()</code> defines an <em>exiting handler</em>, which
means that the signalling function is terminated as soon as a condition
is raised. It also returns control to the context where
<code>tryCatch()</code> was called.</p>
<p>In this example the use of <code>withCallingHandlers()</code> returns
more information than the use of <code>tryCatch()</code>. This allows us
to determine the exact call that raised the condition.</p>
<pre class="r"><code>message2error1 &lt;- function(code) {
  withCallingHandlers(code, message = function(e) stop(&quot;error&quot;))
}

message2error1({
  1
  message(&quot;hidden error&quot;)
  NULL
})
#&gt; Error in (function (e) : error
traceback()
#&gt; 9: stop(&quot;error&quot;) at #2
#&gt; 8: (function (e)
#&gt;    stop(&quot;error&quot;))(list(message = &quot;hidden error\n&quot;,
#&gt;      call = message(&quot;hidden error&quot;)))
#&gt; 7: signalCondition(cond)
#&gt; 6: doWithOneRestart(return(expr), restart)
#&gt; 5: withOneRestart(expr, restarts[[1L]])
#&gt; 4: withRestarts({
#&gt;        signalCondition(cond)
#&gt;        defaultHandler(cond)
#&gt;    }, muffleMessage = function() NULL)
#&gt; 3: message(&quot;hidden error&quot;) at #1
#&gt; 2: withCallingHandlers(code,
#&gt;      message = function(e) stop(&quot;error&quot;)) at #2
#&gt; 1: message2error1({
#&gt;        1
#&gt;        message(&quot;hidden error&quot;)
#&gt;        NULL
#&gt;    })</code></pre>
<pre class="r"><code>message2error2 &lt;- function(code) {
  tryCatch(code, message = function(e) (stop(&quot;error&quot;)))
}

message2error2({
  1
  stop(&quot;hidden error&quot;)
  NULL
})
#&gt; Error in value[[3L]](cond) : error
traceback()
#&gt; 6: stop(&quot;error&quot;) at #2
#&gt; 5: value[[3L]](cond)
#&gt; 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 3: tryCatchList(expr, classes, parentenv, handlers)
#&gt; 2: tryCatch(code, message = function(e) (stop(&quot;error&quot;))) at #2
#&gt; 1: message2error2({
#&gt;        1
#&gt;        message(&quot;hidden error&quot;)
#&gt;        NULL
#&gt;    })</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>How would you modify the <code>catch_cnds()</code> definition if you
wanted to recreate the original intermingling of warnings and
messages?</li>
</ol>
<p>Answer: as noted in <a
href="https://advanced-r-solutions.rbind.io/conditions.html#applications-1">Advanced
R Solutions</a>, “It looks like Hadley wrote a part of the chapter after
the exercises, as the <code>catch_cnds()</code> function defined in the
chapter already solves this problem by storing all messages and warnings
in their original order within a list.”</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Why is catching interrupts dangerous? Run this code to find
out.</li>
</ol>
<pre class="r"><code>bottles_of_beer &lt;- function(i = 99) {
  message(
    &quot;There are &quot;, i, &quot; bottles of beer on the wall, &quot;,
    i, &quot; bottles of beer.&quot;
  )
  while (i &gt; 0) {
    tryCatch(
      Sys.sleep(1),
      interrupt = function(err) {
        i &lt;&lt;- i - 1 # nolint: undesirable_operator_linter.
        if (i &gt; 0) {
          message(
            &quot;Take one down, pass it around, &quot;, i,
            &quot; bottle&quot;, if (i &gt; 1) &quot;s&quot;, &quot; of beer on the wall.&quot;
          )
        }
      }
    )
  }
  message(
    &quot;No more bottles of beer on the wall, &quot;,
    &quot;no more bottles of beer.&quot;
  )
}</code></pre>
<p>Answer: this prevents user interrupts (control-c) from halting the
code, which in this case can be pretty annoying if run with the
defaults, requiring 99 interrupts (or just “Restart R”).</p>
<p>AR Solutions: When running the <code>bottles_of_beer()</code>
function in your console, the output should look somehow like the
following:</p>
<pre class="r"><code>bottles_of_beer()
#&gt; There are 99 bottles of beer on the wall, 99 bottles of beer.
#&gt; Take one down, pass it around, 98 bottles of beer on the wall.
#&gt; Take one down, pass it around, 97 bottles of beer on the wall.
#&gt; Take one down, pass it around, 96 bottles of beer on the wall.
#&gt; Take one down, pass it around, 95 bottles of beer on the wall.
#&gt;</code></pre>
<p>At this point you’ll probably recognise how hard it is to get the
number of bottles down from <code>99</code> to <code>0</code>. There’s
no way to break out of the function because we’re capturing the
interrupt that you’d usually use!</p>
<hr />
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiBBZHZhbmNlZCBSIFdvcmtib29rIChGb3VuZGF0aW9ucykKZGF0ZTogJzIwMjItMDYtMTInCm91dHB1dDoKICBodG1sX2RvY3VtZW50OgogICAgdGhlbWU6CiAgICAgIHZlcnNpb246IDUKICAgIHRvYzogeWVzCiAgICB0b2NfZmxvYXQ6CiAgICAgIGNvbGxhcHNlZDogeWVzCiAgICAgIHNtb290aF9zY3JvbGw6IG5vCi0tLQoKV29ya2Jvb2sgZm9yIGNvbXBsZXRpbmcgcXVpenplcyBhbmQgZXhlcmNpc2VzIGZyb20gdGhlICJGb3VuZGF0aW9ucyIgY2hhcHRlcnMgb2YgW0FkdmFuY2VkIFJdKGh0dHBzOi8vYWR2LXIuaGFkbGV5Lm56L2luZGV4Lmh0bWwpLCBzZWNvbmQgZWRpdGlvbiwgd2l0aCBjb21wYXJpc29ucyB0byBzb2x1dGlvbnMgZnJvbSBbQWR2YW5jZWQgUiBTb2x1dGlvbnNdKGh0dHBzOi8vYWR2YW5jZWQtci1zb2x1dGlvbnMucmJpbmQuaW8pLgoKYGBge3Igc2V0dXAsIG1lc3NhZ2UgPSBGQUxTRSwgd2FybmluZyA9IEZBTFNFfQpsaWJyYXJ5KGxvYnN0cikKbGlicmFyeShiZW5jaCkKbGlicmFyeShybGFuZykKCiMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaGFkbGV5L2Fkdi1yL2Jsb2IvbWFzdGVyL2NvbW1vbi5SCmtuaXRyOjpvcHRzX2NodW5rJHNldCgKICBjb21tZW50ID0gIiM+IiwKICBmaWcuYWxpZ24gPSAiY2VudGVyIgopCgprbml0cjo6a25pdF9ob29rcyRzZXQoCiAgc21hbGxfbWFyID0gZnVuY3Rpb24oYmVmb3JlLCBvcHRpb25zLCBlbnZpcikgewogICAgaWYgKGJlZm9yZSkgewogICAgICBwYXIobWFyID0gYyg0LjEsIDQuMSwgMC41LCAwLjUpKSAjIG5vbGludDogdW5kZXNpcmFibGVfZnVuY3Rpb25fbGludGVyLgogICAgfQogIH0KKQpgYGAKCiMgSW50cm9kdWN0aW9uCgpUaGlzIHdvcmtib29rIGluY2x1ZGVzIGFuc3dlcnMgYW5kIHNvbHV0aW9ucyB0byB0aGUgcXVpenplcyBhbmQgZXhlcmNpc2VzIGZyb20gW0FkdmFuY2VkIFJdKGh0dHBzOi8vYWR2LXIuaGFkbGV5Lm56L2luZGV4Lmh0bWwpIGFuZCBbQWR2YW5jZWQgUiBTb2x1dGlvbnNdKGh0dHBzOi8vYWR2YW5jZWQtci1zb2x1dGlvbnMucmJpbmQuaW8pLCBvcmdhbml6ZWQgYnkgY2hhcHRlci4gSXQgaW5jbHVkZXMgZXhjZXJwdHMgZnJvbSBib3RoIGJvb2tzLCBjb3BpZWQgaGVyZS4KCioqV0FSTklORywgU1BPSUxFUlMhKiogSWYgeW91IGhhdmVuJ3QgcmVhZCBBZHZhbmNlZCBSIGFuZCBpbnRlbmQgdG8gY29tcGxldGUgdGhlIHF1aXp6ZXMgYW5kIGV4ZXJjaXNlcywgZG9uJ3QgcmVhZCB0aGlzIG5vdGVib29rLiBJdCBjb250YWlucyBteSAocG90ZW50aWFsbHkgd3JvbmcpIGFuc3dlcnMgdG8gYm90aC4KCiMgMiBOYW1lcyBhbmQgdmFsdWVzCgpJbiBSLCBpdCBpcyBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBhbiBvYmplY3QgYW5kIGl0cyBuYW1lLiBEb2luZyBzbyB3aWxsIGhlbHAgeW91OgoKKiBNb3JlIGFjY3VyYXRlbHkgcHJlZGljdCB0aGUgcGVyZm9ybWFuY2UgYW5kIG1lbW9yeSB1c2FnZSBvZiB5b3VyIGNvZGUuIAoqIFdyaXRlIGZhc3RlciBjb2RlIGJ5IGF2b2lkaW5nIGFjY2lkZW50YWwgY29waWVzLCBhIG1ham9yIHNvdXJjZSBvZiBzbG93IGNvZGUuIAoqIEJldHRlciB1bmRlcnN0YW5kIFIncyBmdW5jdGlvbmFsIHByb2dyYW1taW5nIHRvb2xzLgoKVGhlIGdvYWwgb2YgdGhpcyBjaGFwdGVyIGlzIHRvIGhlbHAgeW91IHVuZGVyc3RhbmQgdGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gbmFtZXMgYW5kIHZhbHVlcywgYW5kIHdoZW4gUiB3aWxsIGNvcHkgYW4gb2JqZWN0LgoKIyMgMiBRdWl6CgoxLiAgR2l2ZW4gdGhlIGZvbGxvd2luZyBkYXRhIGZyYW1lLCBob3cgZG8gSSBjcmVhdGUgYSBuZXcgY29sdW1uIGNhbGxlZCAiMyIKICAgIHRoYXQgY29udGFpbnMgdGhlIHN1bSBvZiBgMWAgYW5kIGAyYD8gWW91IG1heSBvbmx5IHVzZSBgJGAsIG5vdCBgW1tgLgogICAgV2hhdCBtYWtlcyBgMWAsIGAyYCwgYW5kIGAzYCBjaGFsbGVuZ2luZyBhcyB2YXJpYWJsZSBuYW1lcz8KCmBgYHtyfQpkZiA8LSBkYXRhLmZyYW1lKHJ1bmlmKDMpLCBydW5pZigzKSkKbmFtZXMoZGYpIDwtIGMoMSwgMikKYGBgCgpBbnN3ZXI6IHVzZSB0aGUgZm9sbG93aW5nIGNvZGUuCgpgYGB7cn0KZGYyIDwtIGRhdGEuZnJhbWUoZGYsIGRmJGAxYCArIGRmJGAyYCkKbmFtZXMoZGYyKSA8LSBjKDEsIDIsIDMpCmBgYAoKVXNpbmcgbnVtYmVycyBhcyBuYW1lcyBpcyBwcm9ibGVtYXRpYyBkdWUgdG8gdGhlbSBiZWluZyBpbnRlcnByZXRlZCBhcyBudW1lcmljIGNvbnN0YW50cyBieSBkZWZhdWx0LgoKLS0tCgoyLiAgSW4gdGhlIGZvbGxvd2luZyBjb2RlLCBob3cgbXVjaCBtZW1vcnkgZG9lcyBgeWAgb2NjdXB5PwogICAKYGBge3J9CnggPC0gcnVuaWYoMWU2KQp5IDwtIGxpc3QoeCwgeCwgeCkKYGBgCgpBbnN3ZXI6IDMgdGltZXMgdGhlIHNpemUgb2YgeCwgMjQgTUIuIE5vdGU6IHRoaXMgaXMgaW5jb3JyZWN0LCBhcyBzaG93biBieSBgb2JqX3NpemVgIGFuZCBgb2JqX2FkZHJgOgoKYGBge3J9Cm9ial9zaXplKHgpCm9ial9zaXplKHkpCm9ial9hZGRyKHlbWzFdXSkKb2JqX2FkZHIoeVtbMl1dKQpvYmpfYWRkcih5W1szXV0pCmBgYAoKLS0tCgozLiAgT24gd2hpY2ggbGluZSBkb2VzIGBhYCBnZXQgY29waWVkIGluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZT8KCmBgYHtyfQphIDwtIGMoMSwgNSwgMywgMikKb2JqX2FkZHIoYSkKCmIgPC0gYQpvYmpfYWRkcihiKQoKYltbMV1dIDwtIDEwCm9ial9hZGRyKGIpCmBgYAoKQW5zd2VyOiB0aGUgdGhpcmQgbGluZSAoY29weS1vbi13cml0ZSkuIFtjb3B5LW9uLW1vZGlmeV0KCiMjIDIuMi4yIEV4ZXJjaXNlcwoKMS4gIEV4cGxhaW4gdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGBhYCwgYGJgLCBgY2AgYW5kIGBkYCBpbiB0aGUgZm9sbG93aW5nIAogICAgY29kZToKCmBgYHtyfQphIDwtIDE6MTAKYiA8LSBhCmMgPC0gYgpkIDwtIDE6MTAKYGBgCgpBbnN3ZXI6IGEsIGIsIGFuZCBjIGFsbCBwb2ludCB0byB0aGUgc2FtZSBvYmplY3QgKDE6MTApLiBkIHBvaW50cyB0byBhbiBpZGVudGljYWwgb2JqZWN0IGF0IGEgZGlmZmVyZW50IGFkZHJlc3MuCgpBUiBTb2x1dGlvbnM6IGBhYCwgYGJgLCBhbmQgYGNgIHBvaW50IHRvIHRoZSBzYW1lIG9iamVjdCAod2l0aCB0aGUgc2FtZSBhZGRyZXNzIGluIG1lbW9yeSkuIFRoaXMgb2JqZWN0IGhhcyB0aGUgdmFsdWUgYDE6MTBgLiBgZGAgcG9pbnRzIHRvIGEgZGlmZmVyZW50IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlLgoKCmBgYHtyfQpvYmpfYWRkcihhKQpvYmpfYWRkcihiKQpvYmpfYWRkcihjKQpvYmpfYWRkcihkKQpgYGAKCi0tLQoKMi4gIFRoZSBmb2xsb3dpbmcgY29kZSBhY2Nlc3NlcyB0aGUgbWVhbiBmdW5jdGlvbiBpbiBtdWx0aXBsZSB3YXlzLiBEbyB0aGV5IGFsbCAKICAgIHBvaW50IHRvIHRoZSBzYW1lIHVuZGVybHlpbmcgZnVuY3Rpb24gb2JqZWN0PyBWZXJpZnkgdGhpcyB3aXRoIAogICAgYGxvYnN0cjo6b2JqX2FkZHIoKWAuCiAgICAKYGBge3IsIGV2YWwgPSBGQUxTRX0KbWVhbgpiYXNlOjptZWFuCmdldCgibWVhbiIpCmV2YWxxKG1lYW4pCm1hdGNoLmZ1bigibWVhbiIpCmBgYAoKQ2hlY2sgdGhlIGBvYmpfYWRkcmA6CgpgYGB7cn0Kb2JqX2FkZHIobWVhbikKb2JqX2FkZHIoYmFzZTo6bWVhbikKb2JqX2FkZHIoZ2V0KCJtZWFuIikpCm9ial9hZGRyKGV2YWxxKG1lYW4pKQpvYmpfYWRkcihtYXRjaC5mdW4oIm1lYW4iKSkKYGBgCgpBbnN3ZXI6IHRoZXkgZG8uCgpBUiBTb2x1dGlvbnM6IFllcywgdGhleSBwb2ludCB0byB0aGUgc2FtZSBvYmplY3QuIFdlIGNvbmZpcm0gdGhpcyBieSBpbnNwZWN0aW5nIHRoZSBhZGRyZXNzIG9mIHRoZSB1bmRlcmx5aW5nIGZ1bmN0aW9uIG9iamVjdC4KCi0tLQoKMy4gIEJ5IGRlZmF1bHQsIGJhc2UgUiBkYXRhIGltcG9ydCBmdW5jdGlvbnMsIGxpa2UgYHJlYWQuY3N2KClgLCB3aWxsIAogICAgYXV0b21hdGljYWxseSBjb252ZXJ0IG5vbi1zeW50YWN0aWMgbmFtZXMgdG8gc3ludGFjdGljIG9uZXMuIFdoeSBtaWdodCAKICAgIHRoaXMgYmUgcHJvYmxlbWF0aWM/IFdoYXQgb3B0aW9uIGFsbG93cyB5b3UgdG8gc3VwcHJlc3MgdGhpcyBiZWhhdmlvdXI/CgpBbnN3ZXI6IHRoaXMgY291bGQgaW50cm9kdWNlIHByb2JsZW1hdGljIG5hbWVzLCBsaWtlIGAxYC4gU2V0dGluZyBgY2hlY2submFtZXMgPSBGQUxTRWAgc3VwcHJlc3NlcyB0aGlzIGJlaGF2aW9yLgoKQVIgU29sdXRpb25zOiBDb2x1bW4gbmFtZXMgYXJlIG9mdGVuIGRhdGEsIGFuZCB0aGUgdW5kZXJseWluZyBgbWFrZS5uYW1lcygpYCB0cmFuc2Zvcm1hdGlvbiBpcyBub24taW52ZXJ0aWJsZSwgc28gdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGNvcnJ1cHRzIGRhdGEuIFRvIGF2b2lkIHRoaXMsIHNldCBgY2hlY2submFtZXMgPSBGQUxTRWAuCgotLS0KCjQuICBXaGF0IHJ1bGVzIGRvZXMgYG1ha2UubmFtZXMoKWAgdXNlIHRvIGNvbnZlcnQgbm9uLXN5bnRhY3RpYyBuYW1lcyBpbnRvCiAgICBzeW50YWN0aWMgb25lcz8KCkFuc3dlcjogZnJvbSBgP21ha2UubmFtZXNgOgoKPiBUaGUgY2hhcmFjdGVyICJYIiBpcyBwcmVwZW5kZWQgaWYgbmVjZXNzYXJ5LiBBbGwgaW52YWxpZCBjaGFyYWN0ZXJzIGFyZSB0cmFuc2xhdGVkIHRvICIuIi4gQSBtaXNzaW5nIHZhbHVlIGlzIHRyYW5zbGF0ZWQgdG8gIk5BIi4gTmFtZXMgd2hpY2ggbWF0Y2ggUiBrZXl3b3JkcyBoYXZlIGEgZG90IGFwcGVuZGVkIHRvIHRoZW0uIER1cGxpY2F0ZWQgdmFsdWVzIGFyZSBhbHRlcmVkIGJ5IG1ha2UudW5pcXVlLgoKQVIgU29sdXRpb25zOiBBIHZhbGlkIG5hbWUgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyIG9yIGEgZG90IChub3QgZm9sbG93ZWQgYnkgYSBudW1iZXIpIGFuZCBtYXkgZnVydGhlciBjb250YWluIG51bWJlcnMgYW5kIHVuZGVyc2NvcmVzIChgIl8iYHMgYXJlIGFsbG93ZWQgc2luY2UgUiB2ZXJzaW9uIDEuOS4wKS4KClRocmVlIG1haW4gbWVjaGFuaXNtcyBlbnN1cmUgc3ludGFjdGljYWxseSB2YWxpZCBuYW1lcyAoc2VlIGA/bWFrZS5uYW1lc2ApOgoKMS4gTmFtZXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIGxldHRlciBvciBhIGRvdCB3aWxsIGJlIHByZXBlbmRlZCB3aXRoIGFuIGAiWCJgLgogICBUaGUgc2FtZSBob2xkcyBmb3IgbmFtZXMgdGhhdCBiZWdpbiB3aXRoIGEgZG90IGZvbGxvd2VkIGJ5IGEgbnVtYmVyLgoyLiBBZGRpdGlvbmFsbHksIG5vbi12YWxpZCBjaGFyYWN0ZXJzIGFyZSByZXBsYWNlZCBieSBhIGRvdC4KMy4gUmVzZXJ2ZWQgUiBrZXl3b3JkcyAoc2VlIGA/cmVzZXJ2ZWRgKSBhcmUgc3VmZml4ZWQgYnkgYSBkb3QuCgpJbnRlcmVzdGluZ2x5LCBzb21lIG9mIHRoZXNlIHRyYW5zZm9ybWF0aW9ucyBhcmUgaW5mbHVlbmNlZCBieSB0aGUgY3VycmVudCBsb2NhbGUuIEZyb20gYD9tYWtlLm5hbWVzYDoKCj4gVGhlIGRlZmluaXRpb24gb2YgYSBsZXR0ZXIgZGVwZW5kcyBvbiB0aGUgY3VycmVudCBsb2NhbGUsIGJ1dCBvbmx5IEFTQ0lJIGRpZ2l0cyBhcmUgY29uc2lkZXJlZCB0byBiZSBkaWdpdHMuCgotLS0KCjUuICBJIHNsaWdodGx5IHNpbXBsaWZpZWQgdGhlIHJ1bGVzIHRoYXQgZ292ZXJuIHN5bnRhY3RpYyBuYW1lcy4gV2h5IGlzIGAuMTIzZTFgCiAgICBub3QgYSBzeW50YWN0aWMgbmFtZT8gUmVhZCBgP21ha2UubmFtZXNgIGZvciB0aGUgZnVsbCBkZXRhaWxzLgoKQW5zd2VyOiBmcm9tIGA/bWFrZS5uYW1lc2A6Cgo+IEEgc3ludGFjdGljYWxseSB2YWxpZCBuYW1lIGNvbnNpc3RzIG9mIGxldHRlcnMsIG51bWJlcnMgYW5kIHRoZSBkb3Qgb3IgdW5kZXJsaW5lIGNoYXJhY3RlcnMgYW5kIHN0YXJ0cyB3aXRoIGEgbGV0dGVyIG9yIHRoZSBkb3Qgbm90IGZvbGxvd2VkIGJ5IGEgbnVtYmVyLiBOYW1lcyBzdWNoIGFzICIuMndheSIgYXJlIG5vdCB2YWxpZCwgYW5kIG5laXRoZXIgYXJlIHRoZSByZXNlcnZlZCB3b3Jkcy4KCkFSIFNvbHV0aW9uczogYC4xMjNlMWAgaXMgbm90IGEgc3ludGFjdGljIG5hbWUsIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggb25lIGRvdCB3aGljaCBpcyBmb2xsb3dlZCBieSBhIG51bWJlci4gVGhpcyBtYWtlcyBpdCBhIGRvdWJsZSwgYDEuMjNgLgoKLS0tCgojIyAyLjMuNiBFeGVyY2lzZXMKCjEuICBXaHkgaXMgYHRyYWNlbWVtKDE6MTApYCBub3QgdXNlZnVsPwoKQW5zd2VyOiB0aGlzIGlzIHRyYWNpbmcgYW4gJ2ltbXV0YWJsZScgb2JqZWN0IHdoaWNoIHdpbGwgYWx3YXlzIGhhdmUgdGhlIHNhbWUgYWRkcmVzcy4KCkFSIFNvbHV0aW9uczogV2hlbiBgMToxMGAgaXMgY2FsbGVkIGFuIG9iamVjdCB3aXRoIGFuIGFkZHJlc3MgaW4gbWVtb3J5IGlzIGNyZWF0ZWQsIGJ1dCBpdCBpcyBub3QgYm91bmQgdG8gYSBuYW1lLiBUaGVyZWZvcmUsIHRoZSBvYmplY3QgY2Fubm90IGJlIGNhbGxlZCBvciBtYW5pcHVsYXRlZCBmcm9tIFIuIEFzIG5vIGNvcGllcyB3aWxsIGJlIG1hZGUsIGl0IGlzIG5vdCB1c2VmdWwgdG8gdHJhY2sgdGhlIG9iamVjdCBmb3IgY29weWluZy4KCi0tLQoKMi4gIEV4cGxhaW4gd2h5IGB0cmFjZW1lbSgpYCBzaG93cyB0d28gY29waWVzIHdoZW4geW91IHJ1biB0aGlzIGNvZGUuCiAgICBIaW50OiBjYXJlZnVsbHkgbG9vayBhdCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgY29kZSBhbmQgdGhlIGNvZGUgCiAgICBzaG93biBlYXJsaWVyIGluIHRoZSBzZWN0aW9uLgogICAgIApgYGB7cn0Kcm0obGlzdCA9IGxzKCkpCnggPC0gYygxTCwgMkwsIDNMKQp0cmFjZW1lbSh4KQoKeFtbM11dIDwtIDQKdW50cmFjZW1lbSh4KQpgYGAKCkFuc3dlcjogdW5jbGVhci4gVGhlIGJlaGF2aW9yIGluIFIgNC4yLjAgc2VlbXMgdG8gaGF2ZSBjaGFuZ2VkLCBzaW5jZSB0aGlzIGNvZGUgc2hvd3MgdHdvIGNvcGllczoKCmBgYHtyfQpybShsaXN0ID0gbHMoKSkKeCA8LSBjKDEsIDIsIDMpCnRyYWNlbWVtKHgpCgp5IDwtIHgKeVtbM11dIDwtIDRMCnlbWzNdXSA8LSA1TAp1bnRyYWNlbWVtKHgpCmBgYAoKQVIgU29sdXRpb25zOiBJbml0aWFsbHkgdGhlIHZlY3RvciBgeGAgaGFzIGludGVnZXIgdHlwZS4gVGhlIHJlcGxhY2VtZW50IGNhbGwgYXNzaWducyBhIGRvdWJsZSB0byB0aGUgdGhpcmQgZWxlbWVudCBvZiBgeGAsIHdoaWNoIHRyaWdnZXJzIGNvcHktb24tbW9kaWZ5LgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KeCA8LSBjKDFMLCAyTCwgM0wpCnRyYWNlbWVtKHgpCiM+IDwweDY2YTRhNzA+Cgp4W1szXV0gPC0gNAojPiB0cmFjZW1lbVsweDU1ZWVjN2IzYWYzOCAtPiAweDU1ZWVjNzc0Y2MxOF06CmBgYAoKV2UgY2FuIGF2b2lkIHRoZSBjb3B5IGJ5IHN1Yi1hc3NpZ25pbmcgYW4gaW50ZWdlciBpbnN0ZWFkIG9mIGEgZG91YmxlOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KeCA8LSBjKDFMLCAyTCwgM0wpCnRyYWNlbWVtKHgpCiM+IDwweDU1ZWVjNjk0MGFlMD4KCnhbWzNdXSA8LSA0TApgYGAKClBsZWFzZSBiZSBhd2FyZSB0aGF0IHJ1bm5pbmcgdGhpcyBjb2RlIGluIFJTdHVkaW8gd2lsbCByZXN1bHQgaW4gYWRkaXRpb25hbCBjb3BpZXMgYmVjYXVzZSBvZiB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGVudmlyb25tZW50IHBhbmUuCgotLS0KCjMuICBTa2V0Y2ggb3V0IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgZm9sbG93aW5nIG9iamVjdHM6CgpgYGB7cn0KYSA8LSAxOjEwCmIgPC0gbGlzdChhLCBhKQpjIDwtIGxpc3QoYiwgYSwgMToxMCkKCnByaW50KCJmaXJzdCBvYmplY3QiKQpvYmpfYWRkcihhKQpvYmpfYWRkcihiW1sxXV0pCm9ial9hZGRyKGJbWzJdXSkKb2JqX2FkZHIoY1tbMl1dKQoKcHJpbnQoInNlY29uZCBvYmplY3QiKQpvYmpfYWRkcihiKQpvYmpfYWRkcihjW1sxXV0pCgpwcmludCgidGhpcmQgb2JqZWN0IikKb2JqX2FkZHIoYykKCnByaW50KCJmb3VydGggb2JqZWN0ICg/KSIpCm9ial9hZGRyKGNbWzNdXSkKYGBgCgpBbnN3ZXI6IGZvdXIgZGlmZmVyZW50IG9iamVjdHMgd2l0aCBtdWx0aXBsZSBuYW1lcy4KCkFSIFNvbHV0aW9uczogYGFgIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIGFuIGFkZHJlc3Mgd2l0aCB0aGUgdmFsdWUgYDE6MTBgLiBgYmAgY29udGFpbnMgYSBsaXN0IG9mIHR3byByZWZlcmVuY2VzIHRvIHRoZSBzYW1lIGFkZHJlc3MgYXMgYGFgLiBgY2AgY29udGFpbnMgYSBsaXN0IG9mIGBiYCAoY29udGFpbmluZyB0d28gcmVmZXJlbmNlcyB0byBgYWApLCBgYWAgKGNvbnRhaW5pbmcgdGhlIHNhbWUgcmVmZXJlbmNlIGFnYWluKSBhbmQgYSByZWZlcmVuY2UgcG9pbnRpbmcgdG8gYSBkaWZmZXJlbnQgYWRkcmVzcyBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlIChgMToxMGApLgoKLS0tCgo0LiAgV2hhdCBoYXBwZW5zIHdoZW4geW91IHJ1biB0aGlzIGNvZGU/IERyYXcgYSBwaWN0dXJlLgoKYGBge3J9CnggPC0gbGlzdCgxOjEwKQoKeFtbMl1dIDwtIHgKCnJlZih4KQpgYGAKCkluaXRpYWxseSB4IGlzIGEgbGlzdCBvZiBvbmUgZWxlbWVudCwgYW4gaW50IHZlY3RvciAxOjEwLiBUaGVuIGEgc2Vjb25kIGxpc3QgZWxlbWVudCBpcyBhZGRlZCwgd2hpY2ggcG9pbnRzIHRvIHRoZSBvcmlnaW5hbCBpbnQgdmVjdG9yLgoKQVIgU29sdXRpb25zOiBUaGUgaW5pdGlhbCByZWZlcmVuY2UgdHJlZSBvZiBgeGAgc2hvd3MgdGhhdCB0aGUgbmFtZSBgeGAgYmluZHMgdG8gYSBsaXN0IG9iamVjdC4gVGhpcyBvYmplY3QgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGludGVnZXIgdmVjdG9yIGAxOjEwYC4gV2hlbiBgeGAgaXMgYXNzaWduZWQgdG8gYW4gZWxlbWVudCBvZiBpdHNlbGYsIGNvcHktb24tbW9kaWZ5IHRha2VzIHBsYWNlIGFuZCB0aGUgbGlzdCBpcyBjb3BpZWQgdG8gYSBuZXcgYWRkcmVzcyBpbiBtZW1vcnkuIFRoZSBsaXN0IG9iamVjdCBwcmV2aW91c2x5IGJvdW5kIHRvIGB4YCBpcyBub3cgcmVmZXJlbmNlZCBpbiB0aGUgbmV3bHkgY3JlYXRlZCBsaXN0IG9iamVjdC4gSXQgaXMgbm8gbG9uZ2VyIGJvdW5kIHRvIGEgbmFtZS4gVGhlIGludGVnZXIgdmVjdG9yIGlzIHJlZmVyZW5jZWQgdHdpY2UuCgotLS0KCiMjIDIuNC4xIEV4ZXJjaXNlcwoKMS4gIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgd2h5IGFyZSBgb2JqZWN0LnNpemUoeSlgIGFuZCBgb2JqX3NpemUoeSlgCiAgICBzbyByYWRpY2FsbHkgZGlmZmVyZW50PyBDb25zdWx0IHRoZSBkb2N1bWVudGF0aW9uIG9mIGBvYmplY3Quc2l6ZSgpYC4KCmBgYHtyfQp5IDwtIHJlcChsaXN0KHJ1bmlmKDFlNCkpLCAxMDApCgpvYmplY3Quc2l6ZSh5KQpvYmpfc2l6ZSh5KQpgYGAKCkFuc3dlcjogYG9iamVjdC5zaXplKClgICJkb2VzIG5vdCBkZXRlY3QgaWYgZWxlbWVudHMgb2YgYSBsaXN0IGFyZSBzaGFyZWQiLCB3aGljaCBpcyB0aGUgY2FzZSBoZXJlLiBUaGF0IGlzLCBpdCBkb2VzIG5vdCBkZXRlY3QgdGhlIGxpc3QgaGFzIGJlZW4gcmVwbGljYXRlZCAxMDAgdGltZXMsIGFuZCBvdmVyZXN0aW1hdGVzIGJ5IGEgZmFjdG9yIG9mIDEwMCBjb21wYXJlZCB0byBgb2JqZWN0X3NpemUoKWAuCgpBUiBTb2x1dGlvbnM6IGBvYmplY3Quc2l6ZSgpYCBkb2Vzbid0IGFjY291bnQgZm9yIHNoYXJlZCBlbGVtZW50cyB3aXRoaW4gbGlzdHMuIFRoZXJlZm9yZSwgdGhlIHJlc3VsdHMgZGlmZmVyIGJ5IGEgZmFjdG9yIG9mIH4gMTAwLgoKCi0tLQoKMi4gIFRha2UgdGhlIGZvbGxvd2luZyBsaXN0LiBXaHkgaXMgaXRzIHNpemUgc29tZXdoYXQgbWlzbGVhZGluZz8KCmBgYHtyfQpmdW5zIDwtIGxpc3QobWVhbiwgc2QsIHZhcikKb2JqX3NpemUoZnVucykKYGBgCgpBbnN3ZXI6IGl0IGRvZXNuJ3Qgc2VlbSBtaXNsZWFkaW5nIHRvIG1lLCBidXQgdGhlIGxpc3QgaW5jbHVkZXMgdGhlIGZ1bmN0aW9uIG9iamVjdHMsIG5vdCB0aGUgcmV0dXJuIHZhbHVlcy4gQWxzbywgaXQgY2FsY3VsYXRlcyB0aGUgc2l6ZSBkaXNjYXJkaW5nIHRoZSBvdmVybGFwIGJldHdlZW4gdGhlIGZ1bmN0aW9ucy4gUGVyIHRoZSBjb2RlIGJlbG93LCB0aGVyZSBpcyBzb21lOgoKYGBge3J9Cm9ial9zaXplKG1lYW4pICsgb2JqX3NpemUoc2QpICsgb2JqX3NpemUodmFyKQpgYGAKCkFSIFNvbHV0aW9uczogQWxsIHRocmVlIGZ1bmN0aW9ucyBhcmUgYnVpbHQtaW4gdG8gUiBhcyBwYXJ0IG9mIHRoZSBge2Jhc2V9YCBhbmQgYHtzdGF0c31gIHBhY2thZ2VzIGFuZCBoZW5jZSBhbHdheXMgYXZhaWxhYmxlLiBTbywgd2hhdCBkb2VzIGl0IG1lYW4gdG8gbWVhc3VyZSB0aGUgc2l6ZSBvZiBzb21ldGhpbmcgdGhhdCdzIGFscmVhZHkgaW5jbHVkZWQgaW4gUj8KCihUaGVyZSdzIHR5cGljYWxseSBhIG1vcmUgZ2VuZXJhbCBxdWVzdGlvbiBhYm91dCB3aGF0IHlvdSB3YW50IHRvIGtub3cgd2hlbiB5b3UgYXNrIGZvciB0aGUgc2l6ZSBvZiBzb21ldGhpbmcg4oCUIGRvIHlvdSB3YW50IHRvIGtub3cgaG93IG11Y2ggZGF0YSB5b3UnZCBuZWVkIHRvIHNlbmQgdG8gY29tbXVuaWNhdGUgdGhlIG9iamVjdCB0byBzb21lb25lIGVsc2UgKGUuZy4gc2VyaWFsaXNlIGl0KSwgb3IgZG8geW91IHdhbnQgdG8ga25vdyBob3cgbXVjaCBtZW1vcnkgeW91J2QgZnJlZSBpZiB5b3UgZGVsZXRlZCBpdD8pCgotLS0KCjMuICBQcmVkaWN0IHRoZSBvdXRwdXQgb2YgdGhlIGZvbGxvd2luZyBjb2RlOgoKYGBge3J9CmEgPC0gcnVuaWYoMWU2KQpvYmpfc2l6ZShhKSAjIDgsMDAwLDA0OCBCIH4gOE1CCiMgY29ycmVjdDogZnJvbSBleGFtcGxlIGFib3ZlLCBydW5pZigxZTYpIH49IDhNQgoKYiA8LSBsaXN0KGEsIGEpCm9ial9zaXplKGIpICMgc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gb2JqX3NpemUoYSkKIyBjb3JyZWN0OiB0d28gbGlzdHMgY29udGFpbmluZyBudW1lcmljIHZlY3RvcnMKb2JqX3NpemUoYSwgYikgIyBzbGlnaHRseSBsYXJnZXIgdGhhbiBvYmpfc2l6ZShiKQojIHdyb25nOiBhIGlzIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gYgoKYltbMV1dW1sxXV0gPC0gMTAKb2JqX3NpemUoYikgIyBjb3B5IG9mIGIsIHNhbWUgc2l6ZQojIHdyb25nOiBkb3VibGUsIHNpbmNlIFIgY29waWVzIGFuIGVudGlyZSBjb2x1bW4sIHRoaXMgYWRkcyB0aGUgc2l6ZSBvZiBydW5pZigxZTYpCm9ial9zaXplKGEsIGIpICMgc3RpbGwgbW9zdGx5IG92ZXJsYXBzLCBzbGlnaHRseSBsYXJnZXIgdGhhbiBwcmV2aW91cyBvYmpfc2l6ZShhLCBiKQojIHdyb25nOiBhIGlzIHN0aWxsIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoIGIKCmJbWzJdXVtbMV1dIDwtIDEwCm9ial9zaXplKGIpICMgY29weSBvZiBiLCBzYW1lIHNpemUKIyB3cm9uZzogc2FtZSBzaXplIHNpbmNlIGl0J3Mgc3RpbGwgMiBudW1lcmljIHZlY3RvcnMgb2YgMWU2IGxlbmd0aApvYmpfc2l6ZShhLCBiKSAjIHN0aWxsIG1vc3RseSBvdmVybGFwcywgc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gcHJldmlvdXMgb2JqX3NpemUoYSwgYikKIyB3cm9uZzogdGhlcmUgaXMgbm8gbG9uZ2VyIGFueSBvdmVybGFwLCBzbyB0aGUgc2l6ZSBvZiBvYmpfc2l6ZShhLCBiKSA9IG9ial9zaXplKGEpID0gb2JqX3NpemUoYikKYGBgCgpBbnN3ZXI6IGFuc3dlcnMgaW5saW5lLgoKQVIgU29sdXRpb25zOgoKYGEgPC0gcnVuaWYoMWU2KWA6CgotIEluIFIgKG9uIG1vc3QgcGxhdGZvcm1zKSBhIGxlbmd0aC0wIHZlY3RvciBoYXMgNDggYnl0ZXMgb2Ygb3ZlcmhlYWQuCi0gQSBzaW5nbGUgZG91YmxlIHRha2VzIHVwIGFuIGFkZGl0aW9uYWwgOCBieXRlcyBvZiBtZW1vcnkuCi0gU28sIGEgMSBtaWxsaW9uIGRvdWJsZSBzaG91bGQgdGFrZSB1cCA4LDAwMCwwNDggYnl0ZXMuCgpGb3IgYGIgPC0gbGlzdChhLCBhKWAgYm90aCBsaXN0IGVsZW1lbnRzIGNvbnRhaW4gcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBtZW1vcnkgYWRkcmVzcy4gVGhlcmVmb3JlLCBubyBhZGRpdGlvbmFsIG1lbW9yeSBpcyByZXF1aXJlZCBmb3IgdGhlIHNlY29uZCBsaXN0IGVsZW1lbnQuIFRoZSBsaXN0IGl0c2VsZiByZXF1aXJlcyA2NCBieXRlcywgNDggYnl0ZXMgZm9yIGFuIGVtcHR5IGxpc3QgYW5kIDggYnl0ZXMgZm9yIGVhY2ggZWxlbWVudCAoYG9ial9zaXplKHZlY3RvcigibGlzdCIsIDIpKWApLiBUaGlzIGxldHMgdXMgcHJlZGljdCA4LDAwMCwwNDggQiArIDY0IEIgPSA4LDAwMCwxMTIgQi4KCmBiW1sxXV1bWzFdXSA8LSAxMGA6IFdoZW4gd2UgbW9kaWZ5IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBiW1sxXV1gIGNvcHktb24tbW9kaWZ5IG9jY3Vycy4gQm90aCBlbGVtZW50cyB3aWxsIHN0aWxsIGhhdmUgdGhlIHNhbWUgc2l6ZSAoOCwwMDAsMDQwIEIpLCBidXQgdGhlIGZpcnN0IG9uZSBnZXRzIGEgbmV3IGFkZHJlc3MgaW4gbWVtb3J5LiBBcyBgYmAncyBlbGVtZW50cyBkb24ndCBzaGFyZSByZWZlcmVuY2VzIGFueW1vcmUsIGl0cyBvYmplY3Qgc2l6ZSBhZGRzIHVwIHRvIHRoZSBzdW0gb2YgdGhlIGVsZW1lbnRzIGFuZCB0aGUgbGVuZ3RoLTIgbGlzdDogOCwwMDAsMDQ4IEIgKyA4LDAwMCwwNDggQiArIDY0IEIgPSAxNiwwMDAsMTYwIEIgKDE2IE1CKS4gVGhlIHNlY29uZCBlbGVtZW50IG9mIGBiYCBzdGlsbCByZWZlcmVuY2VzIHRoZSBzYW1lIGFkZHJlc3MgYXMgYGFgLCBzbyB0aGUgY29tYmluZWQgc2l6ZSBvZiBgYWAgYW5kIGBiYCBpcyB0aGUgc2FtZSBhcyBgYmAuCgpgYltbMl1dW1sxXV0gPC0gMTBgOiBXaGVuIHdlIG1vZGlmeSB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgYGJgLCB0aGlzIGVsZW1lbnQgd2lsbCBhbHNvIHBvaW50IHRvIGEgbmV3IG1lbW9yeSBhZGRyZXNzLiBUaGlzIGRvZXMgbm90IGFmZmVjdCB0aGUgc2l6ZSBvZiB0aGUgbGlzdC4gSG93ZXZlciwgYXMgYGJgIGRvZXNuJ3Qgc2hhcmUgcmVmZXJlbmNlcyB3aXRoIGBhYCBhbnltb3JlLCB0aGUgbWVtb3J5IHVzYWdlIG9mIHRoZSBjb21iaW5lZCBvYmplY3RzIGluY3JlYXNlcy4KCi0tLQoKIyMgMi41LjMgRXhlcmNpc2VzCgoxLiAgRXhwbGFpbiB3aHkgdGhlIGZvbGxvd2luZyBjb2RlIGRvZXNuJ3QgY3JlYXRlIGEgY2lyY3VsYXIgbGlzdC4KCmBgYHtyfQp4IDwtIGxpc3QoKQp4W1sxXV0gPC0geApgYGAKCkFuc3dlcjogdGhlIG5hbWUgeCBpcyBhc3NpZ25lZCB0byB0aGUgZW1wdHkgbGlzdCwgYW5kIHRoZW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeCBpcyBtYXBwZWQgdG8gdGhlIG9iamVjdCB0aGF0IHggcG9pbnRzIHRvLCB0aGUgZW1wdHkgbGlzdC4KCkFSIFNvbHV0aW9uczogSW4gdGhpcyBzaXR1YXRpb24gY29weS1vbi1tb2RpZnkgcHJldmVudHMgdGhlIGNyZWF0aW9uIG9mIGEgY2lyY3VsYXIgbGlzdC4gTGV0IHVzIHN0ZXAgdGhyb3VnaCB0aGUgZGV0YWlsczoKCmBgYHtyLCBldmFsID0gRkFMU0V9CnggPC0gbGlzdCgpICMgY3JlYXRlcyBpbml0aWFsIG9iamVjdApvYmpfYWRkcih4KQojPiBbMV0gIjB4NTU4NjJmMjNhYjgwIgp0cmFjZW1lbSh4KQojPiBbMV0gIjwweDU1ODYyZjIzYWI4MD4iCnhbWzFdXSA8LSB4ICMgQ29weS1vbi1tb2RpZnkgdHJpZ2dlcnMgbmV3IGNvcHkKIz4gdHJhY2VtZW1bMHg1NTg2MmYyM2FiODAgLT4gMHg1NTg2MmU4Y2UwMjhdOgpvYmpfYWRkcih4KSAjIGNvcGllZCBvYmplY3QgaGFzIG5ldyBtZW1vcnkgYWRkcmVzcwojPiBbMV0gIjB4NTU4NjJlOGNlMDI4IgpvYmpfYWRkcih4W1sxXV0pICMgbGlzdCBlbGVtZW50IGNvbnRhaW5zIG9sZCBtZW1vcnkgYWRkcmVzcwojPiBbMV0gIjB4NTU4NjJmMjNhYjgwIgpgYGAKCi0tLQoKMi4gIFdyYXAgdGhlIHR3byBtZXRob2RzIGZvciBzdWJ0cmFjdGluZyBtZWRpYW5zIGludG8gdHdvIGZ1bmN0aW9ucywgdGhlbgogICAgdXNlIHRoZSAnYmVuY2gnIHBhY2thZ2UgW0BiZW5jaF0gdG8gY2FyZWZ1bGx5IGNvbXBhcmUgdGhlaXIgc3BlZWRzLiBIb3cgZG9lcwogICAgcGVyZm9ybWFuY2UgY2hhbmdlIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbmNyZWFzZT8KCmBgYHtyfQp4X21lZGlhbnMgPC0gZnVuY3Rpb24obmNvbCkgewogIHggPC0gZGF0YS5mcmFtZShtYXRyaXgocnVuaWYoNSAqIDFlNCksIG5jb2wgPSBuY29sKSkKICBtZWRpYW5zIDwtIHZhcHBseSh4LCBtZWRpYW4sIG51bWVyaWMoMSkpCiAgcmV0dXJuKGxpc3QoeCA9IHgsIG1lZGlhbnMgPSBtZWRpYW5zKSkKfQoKZGZfbWVkaWFucyA8LSBmdW5jdGlvbih4LCBtZWRpYW5zKSB7CiAgIyBzdWJ0cmFjdCBtZWRpYW5zIHVzaW5nIGRhdGEuZnJhbWUgbWV0aG9kCiAgZm9yIChpIGluIHNlcV9hbG9uZyhtZWRpYW5zKSkgewogICAgeFtbaV1dIDwtIHhbW2ldXSAtIG1lZGlhbnNbW2ldXQogIH0KICB4Cn0KCmxzX21lZGlhbnMgPC0gZnVuY3Rpb24oeCwgbWVkaWFucykgewogIHkgPC0gYXMubGlzdCh4KQoKICBmb3IgKGkgaW4gc2VxX2Fsb25nKG1lZGlhbnMpKSB7CiAgICB5W1tpXV0gPC0geVtbaV1dIC0gbWVkaWFuc1tbaV1dCiAgfQogIHkKfQoKIyBjb25maXJtIHRoZXkgYm90aCB3b3JrCnhtIDwtIHhfbWVkaWFucyg1KQpoZWFkKGRmX21lZGlhbnMoeG0keCwgeG0kbWVkaWFucyksIDEwKQpoZWFkKGFzLmRhdGEuZnJhbWUobHNfbWVkaWFucyh4bSR4LCB4bSRtZWRpYW5zKSksIDEwKQoKIyBiZW5jaG1hcmsKbWFyayhkZl9tZWRpYW5zKHhtJHgsIHhtJG1lZGlhbnMpKQptYXJrKGxzX21lZGlhbnMoeG0keCwgeG0kbWVkaWFucykpCm1hcmsoYXMuZGF0YS5mcmFtZShsc19tZWRpYW5zKHhtJHgsIHhtJG1lZGlhbnMpKSkgIyBhcy5kYXRhLmZyYW1lIGludHJvZHVjZXMgc2lnbmlmaWNhbnQgb3ZlcmhlYWQKYGBgCgpBbnN3ZXI6IHdpdGggNSBjb2x1bW5zLCB0aGUgbGlzdCBtZXRob2QgaXMgYWJvdXQgdHdpY2UgYXMgZmFzdC4KCmBgYHtyfQp4bSA8LSB4X21lZGlhbnMoMTApCm1hcmsoZGZfbWVkaWFucyh4bSR4LCB4bSRtZWRpYW5zKSkKbWFyayhsc19tZWRpYW5zKHhtJHgsIHhtJG1lZGlhbnMpKQoKeG0gPC0geF9tZWRpYW5zKDIwKQptYXJrKGRmX21lZGlhbnMoeG0keCwgeG0kbWVkaWFucykpCm1hcmsobHNfbWVkaWFucyh4bSR4LCB4bSRtZWRpYW5zKSkKYGBgCgpXaXRoIDEwIGNvbHVtbnMsIHRoZSBsaXN0IG1ldGhvZCBpcyAzIHRpbWVzIGFzIGZhc3QuIFdpdGggMjAsIHRoZSBsaXN0IG1ldGhvZCBpcyA1IHRpbWVzIGFzIGZhc3QuIFNvLCB0aGUgbGlzdCBtZXRob2QgaXMgbmVhciBjb25zdGFudCB0aW1lIHJlZ2FyZGxlc3Mgb2YgY29sdW1ucywgd2hlcmVhcyB0aGUgZGF0YS5mcmFtZSBtZXRob2Qgc2NhbGVzIGxpbmVhcmx5IHdpdGggdGhlIG51bWJlciBvZiBjb2x1bW5zLgoKQVIgU29sdXRpb25zOgoKV2hlbiB3b3JraW5nIGRpcmVjdGx5IHdpdGggdGhlIGRhdGEgZnJhbWUsIHRoZSBleGVjdXRpb24gdGltZSBncm93cyBxdWFkcmF0aWNhbGx5IHdpdGggdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBpbnB1dCBkYXRhLiBUaGlzIGlzIGJlY2F1c2UgKGUuZy4pIHRoZSBmaXJzdCBjb2x1bW4gbXVzdCBiZSBjb3BpZWQgbiB0aW1lcywgdGhlIHNlY29uZCBjb2x1bW4gbi0xIHRpbWVzLCBhbmQgc28gb24uIFdoZW4gd29ya2luZyB3aXRoIGEgbGlzdCwgdGhlIGV4ZWN1dGlvbiB0aW1lIGluY3JlYXNlcyBvbmx5IGxpbmVhcmx5LgoKT2J2aW91c2x5IGluIHRoZSBsb25nIHJ1biwgbGluZWFyIGdyb3d0aCBjcmVhdGVzIHNob3J0ZXIgcnVuLXRpbWVzLCBidXQgdGhlcmUgaXMgc29tZSBjb3N0IHRvIHRoaXMgc3RyYXRlZ3kg4oCUIHdlIGhhdmUgdG8gY29udmVydCBiZXR3ZWVuIGRhdGEgc3RydWN0dXJlcyB3aXRoIGFzLmxpc3QoKSBhbmQgbGlzdDJERigpLiBFdmVuIHRob3VnaCB0aGlzIGlzIGZhc3QgYW5kIHByb2JhYmx5IGRvZXNu4oCZdCBodXJ0IG11Y2gsIHRoZSBpbXByb3ZlZCBhcHByb2FjaCBkb2VzbuKAmXQgcmVhbGx5IHBheSBvZmYgaW4gdGhpcyBzY2VuYXJpbyB1bnRpbCB3ZSBnZXQgdG8gYSBkYXRhIGZyYW1lIHRoYXQgaXMgYWJvdXQgMzAwIGNvbHVtbnMgd2lkZSAod2l0aCB0aGUgZXhhY3QgdmFsdWUgZGVwZW5kaW5nIG9uIHRoZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgdGhlIHN5c3RlbSBydW5uaW5nIHRoZSBjb2RlKS4KCi0tLQoKMy4gIFdoYXQgaGFwcGVucyBpZiB5b3UgYXR0ZW1wdCB0byB1c2UgYHRyYWNlbWVtKClgIG9uIGFuIGVudmlyb25tZW50PwoKYGBge3J9CmUgPC0gcmxhbmc6OmVudigpCnRyeSh0cmFjZW1lbShlKSkKYGBgCgpBbnN3ZXI6IGl0IHRocm93cyBhbiBlcnJvciEKCkFSIFNvbHV0aW9uczogYHRyYWNlbWVtKClgIGNhbm5vdCBiZSB1c2VkIHRvIG1hcmsgYW5kIHRyYWNlIGVudmlyb25tZW50cy4KClRoZSBlcnJvciBvY2N1cnMgYmVjYXVzZSAiaXQgaXMgbm90IHVzZWZ1bCB0byB0cmFjZSBOVUxMLCBlbnZpcm9ubWVudHMsIHByb21pc2VzLCB3ZWFrIHJlZmVyZW5jZXMsIG9yIGV4dGVybmFsIHBvaW50ZXIgb2JqZWN0cywgYXMgdGhlc2UgYXJlIG5vdCBkdXBsaWNhdGVkIiAoc2VlIGA/dHJhY2VtZW1gKS4gRW52aXJvbm1lbnRzIGFyZSBhbHdheXMgbW9kaWZpZWQgaW4gcGxhY2UuCgotLS0KCiMgMyBWZWN0b3JzCgpUaGlzIGNoYXB0ZXIgZGlzY3Vzc2VzIHRoZSBtb3N0IGltcG9ydGFudCBmYW1pbHkgb2YgZGF0YSB0eXBlcyBpbiBiYXNlIFI6IHZlY3RvcnMuIFdoaWxlIHlvdSd2ZSBwcm9iYWJseSBhbHJlYWR5IHVzZWQgbWFueSAoaWYgbm90IGFsbCkgb2YgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiB2ZWN0b3JzLCB5b3UgbWF5IG5vdCBoYXZlIHRob3VnaHQgZGVlcGx5IGFib3V0IGhvdyB0aGV5J3JlIGludGVycmVsYXRlZC4gSW4gdGhpcyBjaGFwdGVyLCBJIHdvbid0IGNvdmVyIGluZGl2aWR1YWwgdmVjdG9ycyB0eXBlcyBpbiB0b28gbXVjaCBkZXRhaWwsIGJ1dCBJIHdpbGwgc2hvdyB5b3UgaG93IGFsbCB0aGUgdHlwZXMgZml0IHRvZ2V0aGVyIGFzIGEgd2hvbGUuIElmIHlvdSBuZWVkIG1vcmUgZGV0YWlscywgeW91IGNhbiBmaW5kIHRoZW0gaW4gUidzIGRvY3VtZW50YXRpb24uCgpWZWN0b3JzIGNvbWUgaW4gdHdvIGZsYXZvdXJzOiBhdG9taWMgdmVjdG9ycyBhbmQgbGlzdHMuIFRoZXkgZGlmZmVyIGluIHRlcm1zIG9mIHRoZWlyIGVsZW1lbnRzJyB0eXBlczogZm9yIGF0b21pYyB2ZWN0b3JzLCBhbGwgZWxlbWVudHMgbXVzdCBoYXZlIHRoZSBzYW1lIHR5cGU7IGZvciBsaXN0cywgZWxlbWVudHMgY2FuIGhhdmUgZGlmZmVyZW50IHR5cGVzLiBXaGlsZSBub3QgYSB2ZWN0b3IsIGBOVUxMYCBpcyBjbG9zZWx5IHJlbGF0ZWQgdG8gdmVjdG9ycyBhbmQgb2Z0ZW4gc2VydmVzIHRoZSByb2xlIG9mIGEgZ2VuZXJpYyB6ZXJvIGxlbmd0aCB2ZWN0b3IuIFRoaXMgZGlhZ3JhbSwgd2hpY2ggd2UnbGwgYmUgZXhwYW5kaW5nIG9uIHRocm91Z2hvdXQgdGhpcyBjaGFwdGVyLCBpbGx1c3RyYXRlcyB0aGUgYmFzaWMgcmVsYXRpb25zaGlwczoKCkV2ZXJ5IHZlY3RvciBjYW4gYWxzbyBoYXZlIF9fYXR0cmlidXRlc19fLCB3aGljaCB5b3UgY2FuIHRoaW5rIG9mIGFzIGEgbmFtZWQgbGlzdCBvZiBhcmJpdHJhcnkgbWV0YWRhdGEuIFR3byBhdHRyaWJ1dGVzIGFyZSBwYXJ0aWN1bGFybHkgaW1wb3J0YW50LiBUaGUgX19kaW1lbnNpb25fXyBhdHRyaWJ1dGUgdHVybnMgdmVjdG9ycyBpbnRvIG1hdHJpY2VzIGFuZCBhcnJheXMgYW5kIHRoZSBfX2NsYXNzX18gYXR0cmlidXRlIHBvd2VycyB0aGUgUzMgb2JqZWN0IHN5c3RlbS4gV2hpbGUgeW91J2xsIGxlYXJuIGhvdyB0byB1c2UgUzMgaW4gQ2hhcHRlciAxMywgaGVyZSB5b3UnbGwgbGVhcm4gYWJvdXQgc29tZSBvZiB0aGUgbW9zdCBpbXBvcnRhbnQgUzMgdmVjdG9yczogZmFjdG9ycywgZGF0ZSBhbmQgdGltZXMsIGRhdGEgZnJhbWVzLCBhbmQgdGliYmxlcy4gQW5kIHdoaWxlIDJEIHN0cnVjdHVyZXMgbGlrZSBtYXRyaWNlcyBhbmQgZGF0YSBmcmFtZXMgYXJlIG5vdCBuZWNlc3NhcmlseSB3aGF0IGNvbWUgdG8gbWluZCB3aGVuIHlvdSB0aGluayBvZiB2ZWN0b3JzLCB5b3UnbGwgYWxzbyBsZWFybiB3aHkgUiBjb25zaWRlcnMgdGhlbSB0byBiZSB2ZWN0b3JzLgoKYGBge3J9CnJtKGxpc3QgPSBscygpKQpgYGAKCiMjIDMuMi41IEV4ZXJjaXNlcwoKMS4gSG93IGRvIHlvdSBjcmVhdGUgcmF3IGFuZCBjb21wbGV4IHNjYWxhcnM/IChTZWUgYD9yYXdgIGFuZCAKICAgYD9jb21wbGV4YC4pCgpBbnN3ZXI6IHVzaW5nIGVpdGhlciBgcmF3KClgLCBgY29tcGxleCgpYCwgb3IgYGFzLnJhdygpYCwgYGFzLmNvbXBsZXgoKWAuCgpBUiBTb2x1dGlvbnM6IEluIFIsIHNjYWxhcnMgYXJlIHJlcHJlc2VudGVkIGFzIHZlY3RvcnMgb2YgbGVuZ3RoIG9uZS4gSG93ZXZlciwgdGhlcmUncyBubyBidWlsdC1pbiBzeW50YXggbGlrZSB0aGVyZSBpcyBmb3IgbG9naWNhbHMsIGludGVnZXJzLCBkb3VibGVzLCBhbmQgY2hhcmFjdGVyIHZlY3RvcnMgdG8gY3JlYXRlIGluZGl2aWR1YWwgcmF3IGFuZCBjb21wbGV4IHZhbHVlcy4gSW5zdGVhZCwgeW91IGhhdmUgdG8gY3JlYXRlIHRoZW0gYnkgY2FsbGluZyBhIGZ1bmN0aW9uLiBGb3IgcmF3IHZlY3RvcnMgeW91IGNhbiB1c2UgZWl0aGVyIGBhcy5yYXcoKWAgb3IgYGNoYXJUb1JhdygpYCB0byBjcmVhdGUgdGhlbSBmcm9tIG51bWVyaWMgb3IgY2hhcmFjdGVyIHZhbHVlcy4KCkluIHRoZSBjYXNlIG9mIGNvbXBsZXggbnVtYmVycywgcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnRzIG1heSBiZSBwcm92aWRlZCBkaXJlY3RseSB0byB0aGUgYGNvbXBsZXgoKWAgY29uc3RydWN0b3IuIFlvdSBjYW4gY3JlYXRlIHB1cmVseSBpbWFnaW5hcnkgbnVtYmVycyAoZS5nLikgYDFpYCwgYnV0IHRoZXJlIGlzIG5vIHdheSB0byBjcmVhdGUgY29tcGxleCBudW1iZXJzIHdpdGhvdXQgYCtgIChlLmcuIGAxaSArIDFgKS4KCi0tLQoKMi4gVGVzdCB5b3VyIGtub3dsZWRnZSBvZiB0aGUgdmVjdG9yIGNvZXJjaW9uIHJ1bGVzIGJ5IHByZWRpY3RpbmcgdGhlIG91dHB1dCBvZgogICB0aGUgZm9sbG93aW5nIHVzZXMgb2YgYGMoKWA6CgpgYGB7cn0KYygxLCBGQUxTRSkgIyAxLjAsIDAuMCAtIGRvdWJsZQpjKCJhIiwgMSkgIyAiYSIsICIxIiAtIGNoYXJhY3RlcgpjKFRSVUUsIDFMKSAjIDFMLCAxTCAtIGludGVnZXIKCnR5cGVvZihjKDEsIEZBTFNFKSkKdHlwZW9mKGMoImEiLCAxKSkKdHlwZW9mKGMoVFJVRSwgMUwpKQpgYGAKCkFuc3dlcjogZ3Vlc3NlcyBpbmxpbmUuIFtjb3JyZWN0IV0KCkFSIFNvbHV0aW9uczoKCmBgYHtyLCBldmFsID0gRkFMU0V9CmMoMSwgRkFMU0UpICMgd2lsbCBiZSBjb2VyY2VkIHRvIGRvdWJsZSAgICAtPiAxIDAKYygiYSIsIDEpICMgd2lsbCBiZSBjb2VyY2VkIHRvIGNoYXJhY3RlciAtPiAiYSIgIjEiCmMoVFJVRSwgMUwpICMgd2lsbCBiZSBjb2VyY2VkIHRvIGludGVnZXIgICAtPiAxIDEKYGBgCgotLS0KCjMuIFdoeSBpcyBgMSA9PSAiMSJgIHRydWU/IFdoeSBpcyBgLTEgPCBGQUxTRWAgdHJ1ZT8gV2h5IGlzIGAib25lIiA8IDJgIGZhbHNlPwoKQW5zd2VyczoKCi0gYDEgPT0gIjEiYDogdGhlIDEgaXMgY29lcmNlZCB0byAiMSIKLSBgLTEgPCBGQUxTRWA6IEZBTFNFIGlzIGNvZXJjZWQgdG8gMAotIGAib25lIiA8IDI6IHRoZSAyIGlzIGNvZXJjZWQgdG8gIjIiCgoKQVIgU29sdXRpb25zOiBUaGVzZSBjb21wYXJpc29ucyBhcmUgY2FycmllZCBvdXQgYnkgb3BlcmF0b3ItZnVuY3Rpb25zIChgPT1gLCBgPGApLCB3aGljaCBjb2VyY2UgdGhlaXIgYXJndW1lbnRzIHRvIGEgY29tbW9uIHR5cGUuIEluIHRoZSBleGFtcGxlcyBhYm92ZSwgdGhlc2UgdHlwZXMgd2lsbCBiZSBjaGFyYWN0ZXIsIGRvdWJsZSBhbmQgY2hhcmFjdGVyOiBgMWAgd2lsbCBiZSBjb2VyY2VkIHRvIGAiMSJgLCBgRkFMU0VgIGlzIHJlcHJlc2VudGVkIGFzIGAwYCBhbmQgYDJgIHR1cm5zIGludG8gYCIyImAgKGFuZCBudW1iZXJzIHByZWNlZGUgbGV0dGVycyBpbiBsZXhpY29ncmFwaGljIG9yZGVyIChtYXkgZGVwZW5kIG9uIGxvY2FsZSkpLgoKLS0tCgo0LiBXaHkgaXMgdGhlIGRlZmF1bHQgbWlzc2luZyB2YWx1ZSwgYE5BYCwgYSBsb2dpY2FsIHZlY3Rvcj8gV2hhdCdzIHNwZWNpYWwKICAgYWJvdXQgbG9naWNhbCB2ZWN0b3JzPyAoSGludDogdGhpbmsgYWJvdXQgYGMoRkFMU0UsIE5BX2NoYXJhY3Rlcl8pYC4pCgpBbnN3ZXI6IE5BIG11c3QgYmUgbG9naWNhbCBzbyB0aGF0IGl0IGNhbiBleGlzdCBpbiBhIGxvZ2ljYWwgdmVjdG9yLgoKQVIgU29sdXRpb25zOiBUaGUgcHJlc2VuY2Ugb2YgbWlzc2luZyB2YWx1ZXMgc2hvdWxkbid0IGFmZmVjdCB0aGUgdHlwZSBvZiBhbiBvYmplY3QuIFJlY2FsbCB0aGF0IHRoZXJlIGlzIGEgdHlwZS1oaWVyYXJjaHkgZm9yIGNvZXJjaW9uIGZyb20gY2hhcmFjdGVyIOKGkiBkb3VibGUg4oaSIGludGVnZXIg4oaSIGxvZ2ljYWwuIFdoZW4gY29tYmluaW5nIGBOQWBzICB3aXRoIG90aGVyIGF0b21pYyB0eXBlcywgdGhlIGBOQWBzIHdpbGwgYmUgY29lcmNlZCB0byBpbnRlZ2VyIChgTkFfaW50ZWdlcl9gKSwgZG91YmxlIChgTkFfcmVhbF9gKSBvciBjaGFyYWN0ZXIgKGBOQV9jaGFyYWN0ZXJfYCkgYW5kIG5vdCB0aGUgb3RoZXIgd2F5IHJvdW5kLiAgSWYgYE5BYCB3ZXJlIGEgY2hhcmFjdGVyIGFuZCBhZGRlZCB0byBhIHNldCBvZiBvdGhlciB2YWx1ZXMgYWxsIG9mIHRoZXNlIHdvdWxkIGJlIGNvZXJjZWQgdG8gY2hhcmFjdGVyIGFzIHdlbGwuCgotLS0KCjUuIFByZWNpc2VseSB3aGF0IGRvIGBpcy5hdG9taWMoKWAsIGBpcy5udW1lcmljKClgLCBhbmQgYGlzLnZlY3RvcigpYCB0ZXN0IGZvcj8KCkFuc3dlcnM6CgotIGBpcy5hdG9taWMoeClgOiB0ZXN0cyBpZiB4IGlzIGFuIGF0b21pYyB2ZWN0b3IgKGxvZ2ljYWwsIGludGVnZXIsIG51bWVyaWMsIGNvbXBsZXgsIGNoYXJhY3RlciwKICBhbmQgcmF3KSAtIGlzIGBGQUxTRWAgZm9yIGxpc3RzCi0gYGlzLm51bWVyaWMoeClgOiB0ZXN0cyBpZiB4IGlzIGFuIGF0b21pYyBudW1lcmljIHZlY3RvcgotIGBpcy52ZWN0b3IoeCwgbW9kZSA9ICJhbnkiKWA6IHRlc3RzIGlmIHggaXMgYW4gYXRvbWljIHZlY3RvciBPUiBhIGxpc3Qgb3IgZXhwcmVzc2lvbgoKQVIgU29sdXRpb25zOiBUaGUgZG9jdW1lbnRhdGlvbiBzdGF0ZXMgdGhhdDoKCi0gYGlzLmF0b21pYygpYCB0ZXN0cyBpZiBhbiBvYmplY3QgaXMgYW4gYXRvbWljIHZlY3RvciAoYXMgZGVmaW5lZCBpbiAqQWR2YW5jZWQgUiopIG9yIGlzIGBOVUxMYCAoISkuCi0gYGlzLm51bWVyaWMoKWAgdGVzdHMgaWYgYW4gb2JqZWN0IGhhcyB0eXBlIGludGVnZXIgb3IgZG91YmxlIGFuZCBpcyBub3Qgb2YgY2xhc3MgYGZhY3RvcmAsIGBEYXRlYCwgYFBPU0lYdGAgb3IgYGRpZmZ0aW1lYC4KLSBgaXMudmVjdG9yKClgIHRlc3RzIGlmIGFuIG9iamVjdCBpcyBhIHZlY3RvciAoYXMgZGVmaW5lZCBpbiAqQWR2YW5jZWQgUiopIG9yIGFuIGV4cHJlc3Npb24gYW5kIGhhcyBubyBhdHRyaWJ1dGVzLCBhcGFydCBmcm9tIG5hbWVzLgoKQXRvbWljIHZlY3RvcnMgYXJlIGRlZmluZWQgaW4gKkFkdmFuY2VkIFIqIGFzIG9iamVjdHMgb2YgdHlwZSBsb2dpY2FsLCBpbnRlZ2VyLCBkb3VibGUsIGNvbXBsZXgsIGNoYXJhY3RlciBvciByYXcuIFZlY3RvcnMgYXJlIGRlZmluZWQgYXMgYXRvbWljIHZlY3RvcnMgb3IgbGlzdHMuCgotLS0KCiMjIDMuMy40IEV4ZXJjaXNlcwoKMS4gIEhvdyBpcyBgc2V0TmFtZXMoKWAgaW1wbGVtZW50ZWQ/IEhvdyBpcyBgdW5uYW1lKClgIGltcGxlbWVudGVkPwogICAgUmVhZCB0aGUgc291cmNlIGNvZGUuCgpgYGB7cn0Kc2V0TmFtZXMKdW5uYW1lCmBgYAoKQW5zd2VyOiB1c2luZyBgbmFtZXMoKWAsIGFuZCBgZGltbmFtZXMoKWAgZm9yIGB1bm5hbWUoKWAuCgpBUiBTb2x1dGlvbnM6CgpCZWNhdXNlIHRoZSBkYXRhIGFyZ3VtZW50IGNvbWVzIGZpcnN0LCBgc2V0TmFtZXMoKWAgYWxzbyB3b3JrcyB3ZWxsIHdpdGggdGhlIG1hZ3JpdHRyLXBpcGUgb3BlcmF0b3IuIFdoZW4gbm8gZmlyc3QgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSByZXN1bHQgaXMgYSBuYW1lZCB2ZWN0b3IgKHRoaXMgaXMgcmF0aGVyIHVudHlwaWNhbCBhcyByZXF1aXJlZCBhcmd1bWVudHMgdXN1YWxseSBjb21lIGZpcnN0KToKCmB1bm5hbWUoKWAgcmVtb3ZlcyBleGlzdGluZyBuYW1lcyAob3IgZGltbmFtZXMpIGJ5IHNldHRpbmcgdGhlbSB0byBgTlVMTGAuCgotLS0KCjIuICBXaGF0IGRvZXMgYGRpbSgpYCByZXR1cm4gd2hlbiBhcHBsaWVkIHRvIGEgMS1kaW1lbnNpb25hbCB2ZWN0b3I/CiAgICBXaGVuIG1pZ2h0IHlvdSB1c2UgYE5ST1coKWAgb3IgYE5DT0woKWA/CgpgYGB7cn0KZGltKDE6MykKbnJvdygxOjEyKQpOUk9XKDE6MTIpCm5jb2woMToxMikKTkNPTCgxOjEyKQpgYGAKCkFuc3dlcnM6IGBOVUxMYC4gYE5ST1dgIGFuZCBgTkNPTGAgYXJlIHVzZWZ1bCB3aGVuIGNvbXBhcmluZyBgTlVMTGAgZGltZW5zaW9uYWwgdmVjdG9ycyB3aXRoIG1hdHJpY2VzIGFuZCBhcnJheXMuCgpBUiBTb2x1dGlvbnM6IEZyb20gYD9ucm93YDoKCj4gYGRpbSgpYCB3aWxsIHJldHVybiBgTlVMTGAgd2hlbiBhcHBsaWVkIHRvIGEgMWQgdmVjdG9yLgoKT25lIG1heSB3YW50IHRvIHVzZSBgTlJPVygpYCBvciBgTkNPTCgpYCB0byBoYW5kbGUgYXRvbWljIHZlY3RvcnMsIGxpc3RzIGFuZCBOVUxMIHZhbHVlcyBpbiB0aGUgc2FtZSB3YXkgYXMgb25lIGNvbHVtbiBtYXRyaWNlcyBvciBkYXRhIGZyYW1lcy4KCi0tLQoKMy4gIEhvdyB3b3VsZCB5b3UgZGVzY3JpYmUgdGhlIGZvbGxvd2luZyB0aHJlZSBvYmplY3RzPyBXaGF0IG1ha2VzIHRoZW0KICAgIGRpZmZlcmVudCBmcm9tIGAxOjVgPwoKYGBge3J9CngxIDwtIGFycmF5KDE6NSwgYygxLCAxLCA1KSkKeDIgPC0gYXJyYXkoMTo1LCBjKDEsIDUsIDEpKQp4MyA8LSBhcnJheSgxOjUsIGMoNSwgMSwgMSkpCgp4MQp4Mgp4MwpgYGAKCkFuc3dlcjogVGhleSBoYXZlIGEgMy1kaW1lbnNpb25hbCBzdHJ1Y3R1cmUsIGFycmFuZ2VkIGluIGRpZmZlcmVudCB3YXlzLCBhbG9uZyB0aGUgeiwgeCwgYW5kIHkgYXhpcy4KCkFSIFNvbHV0aW9uczogVGhlc2UgYXJlIGFsbCAib25lIGRpbWVuc2lvbmFsIi4gSWYgeW91IGltYWdpbmUgYSAzZCBjdWJlLCBgeDFgIGlzIGluIHRoZSB4LWRpbWVuc2lvbiwgYHgyYCBpcyBpbiB0aGUgeS1kaW1lbnNpb24sIGFuZCBgeDNgIGlzIGluIHRoZSB6LWRpbWVuc2lvbi4gSW4gY29udHJhc3QgdG8gYDE6NWAsIGB4MWAsIGB4MmAgYW5kIGB4M2AgaGF2ZSBhIGBkaW1gIGF0dHJpYnV0ZS4KCi0tLQoKNC4gIEFuIGVhcmx5IGRyYWZ0IHVzZWQgdGhpcyBjb2RlIHRvIGlsbHVzdHJhdGUgYHN0cnVjdHVyZSgpYDoKCmBgYHtyfQpzdHJ1Y3R1cmUoMTo1LCBjb21tZW50ID0gIm15IGF0dHJpYnV0ZSIpCmBgYAoKICAgIEJ1dCB3aGVuIHlvdSBwcmludCB0aGF0IG9iamVjdCB5b3UgZG9uJ3Qgc2VlIHRoZSBjb21tZW50IGF0dHJpYnV0ZS4KICAgIFdoeT8gSXMgdGhlIGF0dHJpYnV0ZSBtaXNzaW5nLCBvciBpcyB0aGVyZSBzb21ldGhpbmcgZWxzZSBzcGVjaWFsIGFib3V0CiAgICBpdD8gKEhpbnQ6IHRyeSB1c2luZyBoZWxwLikKCmBgYHtyfQpmYWN0b3IoImdyZWVuIiwgbGV2ZWxzID0gYygicmVkIiwgImFtYmVyIiwgImdyZWVuIikpCmRwdXQoZmFjdG9yKCJncmVlbiIsIGxldmVscyA9IGMoInJlZCIsICJhbWJlciIsICJncmVlbiIpKSkKYGBgCgpBbnN3ZXI6IHByaW50IGRvZXNuJ3QgZGlzcGxheSB0aGUgYXR0cmlidXRlcyBmb3IgYXJiaXRyYXJ5IHN0cnVjdHVyZXMsIG9ubHkgZGVmaW5lZCBjbGFzc2VzLCBsaWtlIGZhY3RvcnMgKGZvciBleGFtcGxlLCBhYm92ZSkuCgpBUiBTb2x1dGlvbnM6IFRoZSBkb2N1bWVudGF0aW9uIHN0YXRlcyAoc2VlIGA/Y29tbWVudGApOgoKPiBDb250cmFyeSB0byBvdGhlciBhdHRyaWJ1dGVzLCB0aGUgY29tbWVudCBpcyBub3QgcHJpbnRlZCAoYnkgcHJpbnQgb3IgcHJpbnQuZGVmYXVsdCkuCgpBbHNvLCBmcm9tIGA/YXR0cmlidXRlc2A6Cgo+IE5vdGUgdGhhdCBzb21lIGF0dHJpYnV0ZXMgKG5hbWVseSBjbGFzcywgY29tbWVudCwgZGltLCBkaW1uYW1lcywgbmFtZXMsIHJvdy5uYW1lcyBhbmQgdHNwKSBhcmUgdHJlYXRlZCBzcGVjaWFsbHkgYW5kIGhhdmUgcmVzdHJpY3Rpb25zIG9uIHRoZSB2YWx1ZXMgd2hpY2ggY2FuIGJlIHNldC4KCi0tLQoKIyMgMy40LjUgRXhlcmNpc2VzCgoxLiAgV2hhdCBzb3J0IG9mIG9iamVjdCBkb2VzIGB0YWJsZSgpYCByZXR1cm4/IFdoYXQgaXMgaXRzIHR5cGU/IFdoYXQgCiAgICBhdHRyaWJ1dGVzIGRvZXMgaXQgaGF2ZT8gSG93IGRvZXMgdGhlIGRpbWVuc2lvbmFsaXR5IGNoYW5nZSBhcyB5b3UKICAgIHRhYnVsYXRlIG1vcmUgdmFyaWFibGVzPwoKYGBge3J9CmEgPC0gbGV0dGVyc1sxOjNdCmFfdGFibGUgPC0gdGFibGUoYSwgc2FtcGxlKGEpKQphX3RhYmxlCgp0eXBlb2YoYV90YWJsZSkKYXR0cmlidXRlcyhhX3RhYmxlKQoKYiA8LSBsZXR0ZXJzWzE6NF0KYl90YWJsZSA8LSB0YWJsZShiLCBzYW1wbGUoYikpCmJfdGFibGUKCmF0dHJpYnV0ZXMoYl90YWJsZSkKYGBgCgpBbnN3ZXI6IGFuIG9iamVjdCBvZiBjbGFzcyAidGFibGUiLCBhbiBhcnJheSBvZiBpbnRlZ2VyIHZhbHVlcywgd2l0aCB0eXBlICJpbnRlZ2VyIi4gQXR0cmlidXRlcyBsaXN0ZWQgYWJvdmUsIHRoZSBkaW1lbnNpb25hbGl0eSBpcyBhbHdheXMgbiBieSBuLCB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgdmFyaWFibGVzIHRhYnVsYXRlZC4KCkFSIFNvbHV0aW9uczogYHRhYmxlKClgIHJldHVybnMgYSBjb250aW5nZW5jeSB0YWJsZSBvZiBpdHMgaW5wdXQgdmFyaWFibGVzLiBJdCBpcyBpbXBsZW1lbnRlZCBhcyBhbiBpbnRlZ2VyIHZlY3RvciB3aXRoIGNsYXNzIGB0YWJsZWAgYW5kIGRpbWVuc2lvbnMgKHdoaWNoIG1ha2VzIGl0IGFjdCBsaWtlIGFuIGFycmF5KS4gSXRzIGF0dHJpYnV0ZXMgYXJlIGBkaW1gIChkaW1lbnNpb25zKSBhbmQgYGRpbW5hbWVzYCAob25lIG5hbWUgZm9yIGVhY2ggaW5wdXQgY29sdW1uKS4gVGhlIGRpbWVuc2lvbnMgY29ycmVzcG9uZCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSB2YWx1ZXMgKGZhY3RvciBsZXZlbHMpIGluIGVhY2ggaW5wdXQgdmFyaWFibGUuCgotLS0KCjIuICBXaGF0IGhhcHBlbnMgdG8gYSBmYWN0b3Igd2hlbiB5b3UgbW9kaWZ5IGl0cyBsZXZlbHM/IAoKYGBge3J9CmYxIDwtIGZhY3RvcihsZXR0ZXJzKQpmMQpsZXZlbHMoZjEpIDwtIHJldihsZXZlbHMoZjEpKQpmMQpgYGAKCkFuc3dlcjogfn50aGUgZmFjdG9yIHdpbGwgcmVtYWluIHRoZSBzYW1lLCBidXQgdGhlIGF0dHJpYnV0ZXMgd2lsbCBjaGFuZ2Uufn4gdGhlIGZhY3RvciBhbmQgaXRzIGxldmVscyBhcmUgcmV2ZXJzZWQuCgpBUiBTb2x1dGlvbnM6IFRoZSB1bmRlcmx5aW5nIGludGVnZXIgdmFsdWVzIHN0YXkgdGhlIHNhbWUsIGJ1dCB0aGUgbGV2ZWxzIGFyZSBjaGFuZ2VkLCBtYWtpbmcgaXQgbG9vayBsaWtlIHRoZSBkYXRhIGhhcyBjaGFuZ2VkLgoKYGBge3J9CmYxIDwtIGZhY3RvcihsZXR0ZXJzKQpmMQphcy5pbnRlZ2VyKGYxKQoKbGV2ZWxzKGYxKSA8LSByZXYobGV2ZWxzKGYxKSkKZjEKYGBgCgotLS0KCjMuICBXaGF0IGRvZXMgdGhpcyBjb2RlIGRvPyBIb3cgZG8gYGYyYCBhbmQgYGYzYCBkaWZmZXIgZnJvbSBgZjFgPwoKYGBge3J9CmYyIDwtIHJldihmYWN0b3IobGV0dGVycykpCmYyCmYzIDwtIGZhY3RvcihsZXR0ZXJzLCBsZXZlbHMgPSByZXYobGV0dGVycykpCmYzCmBgYAoKQW5zd2VyOiBib3RoIGNyZWF0ZSBhIHJldmVyc2VkIGxpc3Qgb2YgbGV0dGVycy4gZjMgYWxzbyBoYXMgcmV2ZXJzZWQgbGV2ZWxzIGJ1dCBmMiBkb2VzIG5vdC4gKGNvcnJlY3QhKQoKQVIgU29sdXRpb25zOiBGb3IgYGYyYCBhbmQgYGYzYCBlaXRoZXIgdGhlIG9yZGVyIG9mIHRoZSBmYWN0b3IgZWxlbWVudHMgKm9yKiBpdHMgbGV2ZWxzIGFyZSBiZWluZyByZXZlcnNlZC4gRm9yIGBmMWAgYm90aCB0cmFuc2Zvcm1hdGlvbnMgYXJlIG9jY3VycmluZy4KCi0tLQoKIyMgMy41LjQgRXhlcmNpc2VzCgoxLiAgTGlzdCBhbGwgdGhlIHdheXMgdGhhdCBhIGxpc3QgZGlmZmVycyBmcm9tIGFuIGF0b21pYyB2ZWN0b3IuCgpBbnN3ZXJzOgoKLSBFYWNoIGVsZW1lbnQgY2FuIGJlIGEgZGlmZmVyZW50IHR5cGUKLSBFYWNoIGVsZW1lbnQgaXMgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0Ci0gTGlzdCBzaXplIGNhbiBiZSBzbWFsbGVyIHNpbmNlIGVsZW1lbnRzIGFyZSByZWZlcmVuY2VzCi0gTGlzdHMgY2FuIGNvbnRhaW4gb3RoZXIgbGlzdHMKCkFSIFNvbHV0aW9uczogVG8gc3VtbWFyaXNlOgoKLSBBdG9taWMgdmVjdG9ycyBhcmUgYWx3YXlzIGhvbW9nZW5lb3VzIChhbGwgZWxlbWVudHMgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlKS4gTGlzdHMgbWF5IGJlIGhldGVyb2dlbmVvdXMgKHRoZSBlbGVtZW50cyBjYW4gYmUgb2YgZGlmZmVyZW50IHR5cGVzKSBhcyBkZXNjcmliZWQgaW4gdGhlIFtpbnRyb2R1Y3Rpb24gb2YgdGhlIHZlY3RvcnMgY2hhcHRlcl0oaHR0cHM6Ly9hZHYtci5oYWRsZXkubnovdmVjdG9ycy1jaGFwLmh0bWwjaW50cm9kdWN0aW9uKS4KLSBBdG9taWMgdmVjdG9ycyBwb2ludCB0byBvbmUgYWRkcmVzcyBpbiBtZW1vcnksIHdoaWxlIGxpc3RzIGNvbnRhaW4gYSBzZXBhcmF0ZSByZWZlcmVuY2UgZm9yIGVhY2ggZWxlbWVudC4gKFRoaXMgd2FzIGRlc2NyaWJlZCBpbiB0aGUgbGlzdCBzZWN0aW9ucyBvZiB0aGUgW3ZlY3RvcnNdKGh0dHBzOi8vYWR2LXIuaGFkbGV5Lm56L3ZlY3RvcnMtY2hhcC5odG1sI2xpc3RzKSBhbmQgdGhlIFtuYW1lcyBhbmQgdmFsdWVzXShodHRwczovL2Fkdi1yLmhhZGxleS5uei9uYW1lcy12YWx1ZXMuaHRtbCNsaXN0LXJlZmVyZW5jZXMpIGNoYXB0ZXJzLikKLSBTdWJzZXR0aW5nIHdpdGggb3V0LW9mLWJvdW5kcyBhbmQgYE5BYCB2YWx1ZXMgbGVhZHMgdG8gZGlmZmVyZW50IG91dHB1dC4gRm9yIGV4YW1wbGUsIGBbYCByZXR1cm5zIGBOQWAgZm9yIGF0b21pY3MgYW5kIGBOVUxMYCBmb3IgbGlzdHMuIChUaGlzIGlzIGRlc2NyaWJlZCBpbiBtb3JlIGRldGFpbCB3aXRoaW4gdGhlIFtzdWJzZXR0aW5nIGNoYXB0ZXJdKGh0dHBzOi8vYWR2LXIuaGFkbGV5Lm56L3N1YnNldHRpbmcuaHRtbCkuKQoKLS0tCgoyLiAgV2h5IGRvIHlvdSBuZWVkIHRvIHVzZSBgdW5saXN0KClgIHRvIGNvbnZlcnQgYSBsaXN0IHRvIGFuIAogICAgYXRvbWljIHZlY3Rvcj8gV2h5IGRvZXNuJ3QgYGFzLnZlY3RvcigpYCB3b3JrPyAKCmBgYHtyfQppcy52ZWN0b3IobGlzdCgxOjQpKQpkcHV0KGFzLnZlY3RvcihsaXN0KDE6NCkpKQpgYGAKCkFuc3dlcjogYSBsaXN0IGlzIGNvbnNpZGVyZWQgYSB2ZWN0b3IgYnkgYGFzLnZlY3RvcigpYC4KCkFSIFNvbHV0aW9uczogQSBsaXN0IGlzIGFscmVhZHkgYSB2ZWN0b3IsIHRob3VnaCBub3QgYW4gYXRvbWljIG9uZSEKCi0tLQoKMy4gIENvbXBhcmUgYW5kIGNvbnRyYXN0IGBjKClgIGFuZCBgdW5saXN0KClgIHdoZW4gY29tYmluaW5nIGEgCiAgICBkYXRlIGFuZCBkYXRlLXRpbWUgaW50byBhIHNpbmdsZSB2ZWN0b3IuCgpgYGB7cn0KZCA8LSBsaXN0KGRhdGUgPSBhcy5EYXRlKCIyMDIyLTA2LTI1IiksIGRhdGV0aW1lID0gYXMuUE9TSVhjdCgiMjAyMi0wNi0yNSAwOTo1OTo0MCBDRFQiKSkKZHB1dChkKQoKZHB1dChjKGQpKSAjIG5vbGludDogdW5uZWVkZWRfY29uY2F0ZW5hdGlvbl9saW50ZXIuCmRwdXQodW5saXN0KGQpKQpgYGAKCkFuc3dlcjogYGMoKWAgcHJlc2VydmVzIHRoZSBsaXN0IHN0cnVjdHVyZS4gYHVubGlzdCgpYCBjb252ZXJ0cyBib3RoIHRvIGBkb3VibGVgLgoKQVIgU29sdXRpb25zOiBEYXRlIGFuZCBkYXRlLXRpbWUgb2JqZWN0cyBhcmUgYm90aCBidWlsdCB1cG9uIGRvdWJsZXMuIFdoaWxlIGRhdGVzIHN0b3JlIHRoZSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgcmVmZXJlbmNlIGRhdGUgMTk3MC0wMS0wMSAoYWxzbyBrbm93biBhcyDigJx0aGUgRXBvY2jigJ0pIGluIGRheXMsIGRhdGUtdGltZS1vYmplY3RzIChQT1NJWGN0KSBzdG9yZSB0aGUgdGltZSBkaWZmZXJlbmNlIHRvIHRoaXMgZGF0ZSBpbiBzZWNvbmRzLgoKYGBge3J9CmRhdGUgPC0gYXMuRGF0ZSgiMTk3MC0wMS0wMiIpCmR0dG1fY3QgPC0gYXMuUE9TSVhjdCgiMTk3MC0wMS0wMSAwMTowMCIsIHR6ID0gIlVUQyIpCiMgSW50ZXJuYWwgcmVwcmVzZW50YXRpb25zCnVuY2xhc3MoZGF0ZSkKdW5jbGFzcyhkdHRtX2N0KQpgYGAKCkFzIHRoZSBgYygpYCBnZW5lcmljIG9ubHkgZGlzcGF0Y2hlcyBvbiBpdHMgZmlyc3QgYXJndW1lbnQsIGNvbWJpbmluZyBkYXRlIGFuZCBkYXRlLXRpbWUgb2JqZWN0cyB2aWEgYGMoKWAgY291bGQgbGVhZCB0byBzdXJwcmlzaW5nIHJlc3VsdHMgaW4gb2xkZXIgUiB2ZXJzaW9ucyAocHJlIFIgNC4wLjApOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBPdXRwdXQgaW4gUiB2ZXJzaW9uIDMuNi4yCmMoZGF0ZSwgZHR0bV9jdCkgIyBlcXVhbCB0byBjLkRhdGUoZGF0ZSwgZHR0bV9jdCkKIz4gWzFdICIxOTcwLTAxLTAyIiAiMTk3OS0xMS0xMCIKYyhkdHRtX2N0LCBkYXRlKSAjIGVxdWFsIHRvIGMuUE9TSVhjdChkYXRlLCBkdHRtX2N0KQojPiBbMV0gIjE5NzAtMDEtMDEgMDI6MDA6MDAgQ0VUIiAiMTk3MC0wMS0wMSAwMTowMDowMSBDRVQiCmBgYAoKSW4gdGhlIGZpcnN0IHN0YXRlbWVudCBhYm92ZSBgYy5EYXRlKClgIGlzIGV4ZWN1dGVkLCB3aGljaCBpbmNvcnJlY3RseSB0cmVhdHMgdGhlIHVuZGVybHlpbmcgZG91YmxlIG9mIGBkdHRtX2N0YCAoMzYwMCkgYXMgZGF5cyBpbnN0ZWFkIG9mIHNlY29uZHMuIENvbnZlcnNlbHksIHdoZW4gYGMuUE9TSVhjdCgpYCBpcyBjYWxsZWQgb24gYSBkYXRlLCBvbmUgZGF5IGlzIGNvdW50ZWQgYXMgb25lIHNlY29uZCBvbmx5LgoKV2UgY2FuIGhpZ2hsaWdodCB0aGVzZSBtZWNoYW5pY3MgYnkgdGhlIGZvbGxvd2luZyBjb2RlOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBPdXRwdXQgaW4gUiB2ZXJzaW9uIDMuNi4yCnVuY2xhc3MoYyhkYXRlLCBkdHRtX2N0KSkgIyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbgojPiBbMV0gMSAzNjAwCmRhdGUgKyAzNTk5CiM+ICIxOTc5LTExLTEwIgpgYGAKCkFzIG9mIFIgNC4wLjAgdGhlc2UgaXNzdWVzIGhhdmUgYmVlbiByZXNvbHZlZCBhbmQgYm90aCBtZXRob2RzIG5vdyBjb252ZXJ0IHRoZWlyIGlucHV0IGZpcnN0IGludG8gYFBPU0lYY3RgIGFuZCBgRGF0ZWAsIHJlc3BlY3RpdmVseS4KCmBgYHtyfQpjKGR0dG1fY3QsIGRhdGUpCnVuY2xhc3MoYyhkdHRtX2N0LCBkYXRlKSkKYyhkYXRlLCBkdHRtX2N0KQp1bmNsYXNzKGMoZGF0ZSwgZHR0bV9jdCkpCmBgYAoKSG93ZXZlciwgYXMgYGMoKWAgc3RyaXBzIHRoZSB0aW1lIHpvbmUgKGFuZCBvdGhlciBhdHRyaWJ1dGVzKSBvZiBgUE9TSVhjdGAgb2JqZWN0cywgc29tZSBjYXV0aW9uIGlzIHN0aWxsIHJlY29tbWVuZGVkLgoKYGBge3J9CihkdHRtX2N0IDwtIGFzLlBPU0lYY3QoIjE5NzAtMDEtMDEgMDE6MDAiLCB0eiA9ICJIU1QiKSkKYXR0cmlidXRlcyhjKGR0dG1fY3QpKSAjIG5vbGludDogdW5uZWVkZWRfY29uY2F0ZW5hdGlvbl9saW50ZXIuCmBgYAoKQSBwYWNrYWdlIHRoYXQgZGVhbHMgd2l0aCB0aGVzZSBraW5kcyBvZiBwcm9ibGVtcyBpbiBtb3JlIGRlcHRoIGFuZCBwcm92aWRlcyBhIHN0cnVjdHVyYWwgc29sdXRpb24gZm9yIHRoZW0gaXMgdGhlIFtgdmN0cnNgIHBhY2thZ2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9yLWxpYi92Y3Rycykgd2hpY2ggaXMgYWxzbyB1c2VkIHRocm91Z2hvdXQgdGhlIHRpZHl2ZXJzZS4KCkxldCdzIGxvb2sgYXQgYHVubGlzdCgpYCwgd2hpY2ggb3BlcmF0ZXMgb24gbGlzdCBpbnB1dC4KCmBgYHtyfQojIEF0dHJpYnV0ZXMgYXJlIHN0cmlwcGVkCnVubGlzdChsaXN0KGRhdGUsIGR0dG1fY3QpKQpgYGAKCldlIHNlZSBhZ2FpbiB0aGF0IGRhdGVzIGFuZCBkYXRlLXRpbWVzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCBhcyBkb3VibGVzLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGlzIGFsbCB3ZSBhcmUgbGVmdCB3aXRoLCB3aGVuIHVubGlzdCBzdHJpcHMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxpc3QuCgpUbyBzdW1tYXJpc2U6IGBjKClgIGNvZXJjZXMgdHlwZXMgYW5kIHN0cmlwcyB0aW1lIHpvbmVzLiBFcnJvcnMgbWF5IGhhdmUgb2NjdXJyZWQgaW4gb2xkZXIgUiB2ZXJzaW9ucyBiZWNhdXNlIG9mIGluYXBwcm9wcmlhdGUgbWV0aG9kIGRpc3BhdGNoL2ltbWF0dXJlIG1ldGhvZHMuIGB1bmxpc3QoKWAgc3RyaXBzIGF0dHJpYnV0ZXMuCgotLS0KCiMjIDMuNi44IEV4ZXJjaXNlcwoKMS4gIENhbiB5b3UgaGF2ZSBhIGRhdGEgZnJhbWUgd2l0aCB6ZXJvIHJvd3M/IFdoYXQgYWJvdXQgemVybyBjb2x1bW5zPwoKYGBge3J9CiMgZnJvbSBkYXRhLmZyYW1lKCkgZXhhbXBsZXM6CmRmIDwtIGRhdGEuZnJhbWUoeCA9IDE6MywgeSA9IDQ6NiwgeiA9IDc6OSkKCmRmCmRmWywgRkFMU0VdCmRmW0ZBTFNFLCBdCmRmW0ZBTFNFLCBGQUxTRV0KYGBgCgpBbnN3ZXI6IHllcyEKCkFSIFNvbHV0aW9uczogWWVzLCB5b3UgY2FuIGNyZWF0ZSB0aGVzZSBkYXRhIGZyYW1lcyBlYXNpbHk7IGVpdGhlciBkdXJpbmcgY3JlYXRpb24gb3IgdmlhIHN1YnNldHRpbmcuIEV2ZW4gYm90aCBkaW1lbnNpb25zIGNhbiBiZSB6ZXJvLgoKLS0tCgoyLiAgV2hhdCBoYXBwZW5zIGlmIHlvdSBhdHRlbXB0IHRvIHNldCByb3duYW1lcyB0aGF0IGFyZSBub3QgdW5pcXVlPwoKYGBge3J9CnJvd25hbWVzKGRmKQp0cnkocm93bmFtZXMoZGYpIDwtIGMoImEiLCAiYSIsICJiIikpCmBgYAoKQW5zd2VyOiBlcnJvciwgZHVwbGljYXRlcyBub3QgYWxsb3dlZC4KCkFSIFNvbHV0aW9uczogTWF0cmljZXMgY2FuIGhhdmUgZHVwbGljYXRlZCByb3cgbmFtZXMsIHNvIHRoaXMgZG9lcyBub3QgY2F1c2UgcHJvYmxlbXMuCgpEYXRhIGZyYW1lcywgaG93ZXZlciwgcmVxdWlyZSB1bmlxdWUgcm93bmFtZXMgYW5kIHlvdSBnZXQgZGlmZmVyZW50IHJlc3VsdHMgZGVwZW5kaW5nIG9uIGhvdyB5b3UgYXR0ZW1wdCB0byBzZXQgdGhlbS4gSWYgeW91IHNldCB0aGVtIGRpcmVjdGx5IG9yIHZpYSBgcm93Lm5hbWVzKClgLCB5b3UgZ2V0IGFuIGVycm9yLiAgSWYgeW91IHVzZSBzdWJzZXR0aW5nLCBgW2AgYXV0b21hdGljYWxseSBkZWR1cGxpY2F0ZXMuCgotLS0KCjMuICBJZiBgZGZgIGlzIGEgZGF0YSBmcmFtZSwgd2hhdCBjYW4geW91IHNheSBhYm91dCBgdChkZilgLCBhbmQgYHQodChkZikpYD8gCiAgICBQZXJmb3JtIHNvbWUgZXhwZXJpbWVudHMsIG1ha2luZyBzdXJlIHRvIHRyeSBkaWZmZXJlbnQgY29sdW1uIHR5cGVzLgoKYGBge3J9CnQoZGYpCnQodChkZikpCgpkZjIgPC0gZGF0YS5mcmFtZSh4ID0gMTozLCB5ID0gYygiYSIsICJiIiwgImMiKSwgeiA9IDRMOjZMLCBzdHJpbmdzQXNGYWN0b3JzID0gRkFMU0UpCmRmMgp0KGRmMikKdCh0KGRmMikpCmBgYAoKQW5zd2VyOiBgdCgpYCBjb2VyY2VzIHRoZSB2ZWN0b3IgdHlwZXMsIHNvIGB0KHQoZGYpKWAgaXMgdGhlIHNhbWUgYXMgYGRmYCBvbmx5IHdoZW4gYWxsIGNvbHVtbnMgYXJlCnRoZSBzYW1lIHR5cGUuCgpBUiBTb2x1dGlvbnM6IEJvdGggb2YgYHQoZGYpYCBhbmQgYHQodChkZikpYCB3aWxsIHJldHVybiBtYXRyaWNlczoKCmBgYHtyfQpkZiA8LSBkYXRhLmZyYW1lKHggPSAxOjMsIHkgPSBsZXR0ZXJzWzE6M10pCmlzLm1hdHJpeChkZikKaXMubWF0cml4KHQoZGYpKQppcy5tYXRyaXgodCh0KGRmKSkpCmBgYAoKVGhlIGRpbWVuc2lvbnMgd2lsbCByZXNwZWN0IHRoZSB0eXBpY2FsIHRyYW5zcG9zaXRpb24gcnVsZXM6CgpgYGB7cn0KZGltKGRmKQpkaW0odChkZikpCmRpbSh0KHQoZGYpKSkKYGBgCgpCZWNhdXNlIHRoZSBvdXRwdXQgaXMgYSBtYXRyaXgsIGV2ZXJ5IGNvbHVtbiBpcyBjb2VyY2VkIHRvIHRoZSBzYW1lIHR5cGUuIChJdCBpcyBpbXBsZW1lbnRlZCB3aXRoaW4gYHQuZGF0YS5mcmFtZSgpYCB2aWEgYGFzLm1hdHJpeCgpYCB3aGljaCBpcyBkZXNjcmliZWQgYmVsb3cpLgoKYGBge3J9CmRmCnQoZGYpCmBgYAoKLS0tCgo0LiAgV2hhdCBkb2VzIGBhcy5tYXRyaXgoKWAgZG8gd2hlbiBhcHBsaWVkIHRvIGEgZGF0YSBmcmFtZSB3aXRoIAogICAgY29sdW1ucyBvZiBkaWZmZXJlbnQgdHlwZXM/IEhvdyBkb2VzIGl0IGRpZmZlciBmcm9tIGBkYXRhLm1hdHJpeCgpYD8KCmBgYHtyfQphcy5tYXRyaXgoZGYpCmFzLm1hdHJpeChkZjIpCmRhdGEubWF0cml4KGRmMikKYXMuZGF0YS5mcmFtZShkYXRhLm1hdHJpeChkZjIpKQphcy5kYXRhLmZyYW1lKGRhdGEubWF0cml4KGRhdGEuZnJhbWUoeCA9IDE6MywgeSA9IGMoMCwgMC41LCAxKSwgeiA9IDQ6NikpKQpgYGAKCkFuc3dlcjogYGFzLm1hdHJpeCgpYCBjb2VyY2VzIGFsbCBlbGVtZW50cyB0byB0aGUgc2FtZSB0eXBlLiBgZGF0YS5tYXRyaXgoKWAgY29lcmNlcyBlbGVtZW50cyB0byBlaXRoZXIgaW50ZWdlciAod2hlbiBwb3NzaWJsZSkgb3IgZG91YmxlICh3aGVuIG5vdCkuCgpBUiBTb2x1dGlvbnM6IFRoZSB0eXBlIG9mIHRoZSByZXN1bHQgb2YgYGFzLm1hdHJpeGAgZGVwZW5kcyBvbiB0aGUgdHlwZXMgb2YgdGhlIGlucHV0IGNvbHVtbnMgKHNlZSBgP2FzLm1hdHJpeGApOgoKPiBUaGUgbWV0aG9kIGZvciBkYXRhIGZyYW1lcyB3aWxsIHJldHVybiBhIGNoYXJhY3RlciBtYXRyaXggaWYgdGhlcmUgaXMgb25seSBhdG9taWMgY29sdW1ucyBhbmQgYW55IG5vbi0obnVtZXJpYy9sb2dpY2FsL2NvbXBsZXgpIGNvbHVtbiwgYXBwbHlpbmcgYXMudmVjdG9yIHRvIGZhY3RvcnMgYW5kIGZvcm1hdCB0byBvdGhlciBub24tY2hhcmFjdGVyIGNvbHVtbnMuIE90aGVyd2lzZSB0aGUgdXN1YWwgY29lcmNpb24gaGllcmFyY2h5IChsb2dpY2FsIDwgaW50ZWdlciA8IGRvdWJsZSA8IGNvbXBsZXgpIHdpbGwgYmUgdXNlZCwgZS5nLiBhbGwtbG9naWNhbCBkYXRhIGZyYW1lcyB3aWxsIGJlIGNvZXJjZWQgdG8gYSBsb2dpY2FsIG1hdHJpeCwgbWl4ZWQgbG9naWNhbC1pbnRlZ2VyIHdpbGwgZ2l2ZSBhbiBpbnRlZ2VyIG1hdHJpeCwgZXRjLgoKT24gdGhlIG90aGVyIGhhbmQsIGBkYXRhLm1hdHJpeGAgd2lsbCBhbHdheXMgcmV0dXJuIGEgbnVtZXJpYyBtYXRyaXggKHNlZSBgP2RhdGEubWF0cml4KClgKS4KCj4gUmV0dXJuIHRoZSBtYXRyaXggb2J0YWluZWQgYnkgY29udmVydGluZyBhbGwgdGhlIHZhcmlhYmxlcyBpbiBhIGRhdGEgZnJhbWUgdG8gbnVtZXJpYyBtb2RlIGFuZCB0aGVuIGJpbmRpbmcgdGhlbSB0b2dldGhlciBhcyB0aGUgY29sdW1ucyBvZiBhIG1hdHJpeC4gRmFjdG9ycyBhbmQgb3JkZXJlZCBmYWN0b3JzIGFyZSByZXBsYWNlZCBieSB0aGVpciBpbnRlcm5hbCBjb2Rlcy4gWy4uLl0gQ2hhcmFjdGVyIGNvbHVtbnMgYXJlIGZpcnN0IGNvbnZlcnRlZCB0byBmYWN0b3JzIGFuZCB0aGVuIHRvIGludGVnZXJzLgoKV2UgY2FuIGlsbHVzdHJhdGUgYW5kIGNvbXBhcmUgdGhlIG1lY2hhbmljcyBvZiB0aGVzZSBmdW5jdGlvbnMgdXNpbmcgYSBjb25jcmV0ZSBleGFtcGxlLiBgYXMubWF0cml4KClgIG1ha2VzIGl0IHBvc3NpYmxlIHRvIHJldHJpZXZlIG1vc3Qgb2YgdGhlIG9yaWdpbmFsIGluZm9ybWF0aW9uIGZyb20gdGhlIGRhdGEgZnJhbWUgYnV0IGxlYXZlcyB1cyB3aXRoIGNoYXJhY3RlcnMuIFRvIHJldHJpZXZlIGFsbCBpbmZvcm1hdGlvbiBmcm9tIGBkYXRhLm1hdHJpeCgpYCdzIG91dHB1dCwgd2Ugd291bGQgbmVlZCBhIGxvb2t1cCB0YWJsZSBmb3IgZWFjaCBjb2x1bW4uCgotLS0KCiMgNCBTdWJzZXR0aW5nCgpSJ3Mgc3Vic2V0dGluZyBvcGVyYXRvcnMgYXJlIGZhc3QgYW5kIHBvd2VyZnVsLiBNYXN0ZXJpbmcgdGhlbSBhbGxvd3MgeW91IHRvIHN1Y2NpbmN0bHkgcGVyZm9ybSBjb21wbGV4IG9wZXJhdGlvbnMgaW4gYSB3YXkgdGhhdCBmZXcgb3RoZXIgbGFuZ3VhZ2VzIGNhbiBtYXRjaC4gU3Vic2V0dGluZyBpbiBSIGlzIGVhc3kgdG8gbGVhcm4gYnV0IGhhcmQgdG8gbWFzdGVyIGJlY2F1c2UgeW91IG5lZWQgdG8gaW50ZXJuYWxpc2UgYSBudW1iZXIgb2YgaW50ZXJyZWxhdGVkIGNvbmNlcHRzOgoKKiBUaGVyZSBhcmUgc2l4IHdheXMgdG8gc3Vic2V0IGF0b21pYyB2ZWN0b3JzLgoKKiBUaGVyZSBhcmUgdGhyZWUgc3Vic2V0dGluZyBvcGVyYXRvcnMsIGBbW2AsIGBbYCwgYW5kIGAkYC4KCiogU3Vic2V0dGluZyBvcGVyYXRvcnMgaW50ZXJhY3QgZGlmZmVyZW50bHkgd2l0aCBkaWZmZXJlbnQgdmVjdG9yIAogIHR5cGVzIChlLmcuLCBhdG9taWMgdmVjdG9ycywgbGlzdHMsIGZhY3RvcnMsIG1hdHJpY2VzLCBhbmQgZGF0YSBmcmFtZXMpLgoKKiBTdWJzZXR0aW5nIGNhbiBiZSBjb21iaW5lZCB3aXRoIGFzc2lnbm1lbnQuCgpTdWJzZXR0aW5nIGlzIGEgbmF0dXJhbCBjb21wbGVtZW50IHRvIGBzdHIoKWAuIFdoaWxlIGBzdHIoKWAgc2hvd3MgeW91IGFsbCB0aGUgcGllY2VzIG9mIGFueSBvYmplY3QgKGl0cyBzdHJ1Y3R1cmUpLCBzdWJzZXR0aW5nIGFsbG93cyB5b3UgdG8gcHVsbCBvdXQgdGhlIHBpZWNlcyB0aGF0IHlvdSdyZSBpbnRlcmVzdGVkIGluLiBGb3IgbGFyZ2UsIGNvbXBsZXggb2JqZWN0cywgSSBoaWdobHkgcmVjb21tZW5kIHVzaW5nIHRoZSBpbnRlcmFjdGl2ZSBSU3R1ZGlvIFZpZXdlciwgd2hpY2ggeW91IGNhbiBhY3RpdmF0ZSB3aXRoIGBWaWV3KG15X29iamVjdClgLgoKYGBge3J9CnJtKGxpc3QgPSBscygpKQpgYGAKCiMjIDQuMi42IEV4ZXJjaXNlcwoKMS4gIEZpeCBlYWNoIG9mIHRoZSBmb2xsb3dpbmcgY29tbW9uIGRhdGEgZnJhbWUgc3Vic2V0dGluZyBlcnJvcnM6CgpgYGB7cn0KIyBub2xpbnQgc3RhcnQ6IGNvbW1lbnRlZF9jb2RlX2xpbnRlci4KIyBtdGNhcnNbbXRjYXJzJGN5bCA9IDQsIF0KbXRjYXJzW210Y2FycyRjeWwgPT0gNCwgXQojIHVzZSBgPT1gICAgICAgICAgICAgICAoaW5zdGVhZCBvZiBgPWApCgojIG10Y2Fyc1stMTo0LCBdCm10Y2Fyc1stKDE6NCksIF0KIyB1c2UgYC0oMTo0KWAgICAgICAgICAgKGluc3RlYWQgb2YgYC0xOjRgKQoKIyBtdGNhcnNbbXRjYXJzJGN5bCA8PSA1XQptdGNhcnNbbXRjYXJzJGN5bCA8PSA1LCBdCiMgYCxgIGlzIG1pc3NpbmcKCiMgbXRjYXJzW210Y2FycyRjeWwgPT0gNCB8IDYsIF0KbXRjYXJzW210Y2FycyRjeWwgPT0gNCB8IG10Y2FycyRjeWwgPT0gNiwgXQojIHVzZSBgbXRjYXJzJGN5bCA9PSA2YCAoaW5zdGVhZCBvZiBgNmApCiMgIG9yIGAlaW4lIGMoNCwgNilgICAgIChpbnN0ZWFkIG9mIGA9PSA0IHwgNmApCgojIG5vbGludCBlbmQKYGBgCgpBbnN3ZXI6IGZpeGVkIQoKQVIgc29sdXRpb25zOiBzZWUgdGhlIGNvbW1lbnRzIGJlbG93IHRoZSBmaXhlZCBjb2RlLgoKLS0tCgoyLiAgV2h5IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHlpZWxkIGZpdmUgbWlzc2luZyB2YWx1ZXM/IChIaW50OiB3aHkgaXMgCiAgICBpdCBkaWZmZXJlbnQgZnJvbSBgeFtOQV9yZWFsX11gPykKCmBgYHtyfQp4IDwtIDE6NQp4W05BXQoKeFtOQV9yZWFsX10KeFtUUlVFXQpgYGAKCkFuc3dlcjogTkEgaXMgYSBsb2dpY2FsIGNvbnN0YW50IG9mIGxlbmd0aCAxLgoKQVIgU29sdXRpb25zOiBJbiBjb250cmFzdCB0byBgTkFfcmVhbGAsIGBOQWAgaGFzIGxvZ2ljYWwgdHlwZSBhbmQgbG9naWNhbCB2ZWN0b3JzIGFyZSByZWN5Y2xlZCB0byB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIHZlY3RvciBiZWluZyBzdWJzZXQsIGkuZS4gYHhbTkFdYCBpcyByZWN5Y2xlZCB0byBgeFtjKE5BLCBOQSwgTkEsIE5BLCBOQSldYC4KCi0tLQoKMy4gIFdoYXQgZG9lcyBgdXBwZXIudHJpKClgIHJldHVybj8gSG93IGRvZXMgc3Vic2V0dGluZyBhIG1hdHJpeCB3aXRoIGl0IAogICAgd29yaz8gRG8gd2UgbmVlZCBhbnkgYWRkaXRpb25hbCBzdWJzZXR0aW5nIHJ1bGVzIHRvIGRlc2NyaWJlIGl0cyBiZWhhdmlvdXI/CgpgYGB7cn0KeCA8LSBvdXRlcigxOjUsIDE6NSwgRlVOID0gIioiKQp4CnhbdXBwZXIudHJpKHgpXQpgYGAKCkFuc3dlcjogYHVwcGVyLnRyaSgpYCByZXR1cm5zIGEgbWF0cml4IG9mIGxvZ2ljYWxzLCB3aGljaCBjYW4gYmUgdXNlZCB0byBzdWJzZXQgdGhlIHVwcGVyIHRyaWFuZ2xlLiBUaGlzIGlzIHN1YnNldHRpbmcgYnkgbWF0cml4LCB3aGljaCBpcyBuZXcuCgpBUiBTb2x1dGlvbnM6IGB1cHBlci50cmkoeClgIHJldHVybnMgYSBsb2dpY2FsIG1hdHJpeCwgd2hpY2ggY29udGFpbnMgYFRSVUVgIHZhbHVlcyBhYm92ZSB0aGUgZGlhZ29uYWwgYW5kIGBGQUxTRWAgdmFsdWVzIGV2ZXJ5d2hlcmUgZWxzZS4gSW4gYHVwcGVyLnRyaSgpYCB0aGUgcG9zaXRpb25zIGZvciBgVFJVRWAgYW5kIGBGQUxTRWAgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IGNvbXBhcmluZyBgeGAncyByb3cgYW5kIGNvbHVtbiBpbmRpY2VzIHZpYSBgLnJvdyhkaW0oeCkpIDwgLmNvbChkaW0oeCkpYC4KCldoZW4gc3Vic2V0dGluZyB3aXRoIGxvZ2ljYWwgbWF0cmljZXMsIGFsbCBlbGVtZW50cyB0aGF0IGNvcnJlc3BvbmQgdG8gYFRSVUVgIHdpbGwgYmUgc2VsZWN0ZWQuIE1hdHJpY2VzIGV4dGVuZCB2ZWN0b3JzIHdpdGggYSBkaW1lbnNpb24gYXR0cmlidXRlLCBzbyB0aGUgdmVjdG9yIGZvcm1zIG9mIHN1YnNldHRpbmcgY2FuIGJlIHVzZWQgKGluY2x1ZGluZyBsb2dpY2FsIHN1YnNldHRpbmcpLiBXZSBzaG91bGQgdGFrZSBjYXJlLCB0aGF0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzdWJzZXR0aW5nIG1hdHJpeCBtYXRjaCB0aGUgb2JqZWN0IG9mIGludGVyZXN0IOKAlCBvdGhlcndpc2UgdW5pbnRlbmRlZCBzZWxlY3Rpb25zIGR1ZSB0byB2ZWN0b3IgcmVjeWNsaW5nIG1heSBvY2N1ci4gUGxlYXNlIGFsc28gbm90ZSwgdGhhdCB0aGlzIGZvcm0gb2Ygc3Vic2V0dGluZyByZXR1cm5zIGEgdmVjdG9yIGluc3RlYWQgb2YgYSBtYXRyaXgsIGFzIHRoZSBzdWJzZXR0aW5nIGFsdGVycyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb2JqZWN0LgoKLS0tCgo0LiAgV2h5IGRvZXMgYG10Y2Fyc1sxOjIwXWAgcmV0dXJuIGFuIGVycm9yPyBIb3cgZG9lcyBpdCBkaWZmZXIgZnJvbSB0aGUgCiAgICBzaW1pbGFyIGBtdGNhcnNbMToyMCwgXWA/CgpgYGB7cn0KdHJ5KG10Y2Fyc1sxOjIwXSkKbXRjYXJzWzE6MjAsIF0KYGBgCgpBbnN3ZXI6IGBtdGNhcnNbMToyMF1gIHNlbGVjdHMgdGhlIGZpcnN0IDIwIGNvbHVtbnMsIGJ1dCB0aGVyZSBhcmUgb25seSAxMS4gYG10Y2Fyc1sxOjIwLCBdYCBzZWxlY3RzIHRoZSBmaXJzdCAyMCByb3dzIG9mIGByIG5yb3cobXRjYXJzKWAuCgpBUiBTb2x1dGlvbnM6IFdoZW4gc3Vic2V0dGluZyBhIGRhdGEgZnJhbWUgd2l0aCBhIHNpbmdsZSB2ZWN0b3IsIGl0IGJlaGF2ZXMgdGhlIHNhbWUgd2F5IGFzIHN1YnNldHRpbmcgYSBsaXN0IG9mIGNvbHVtbnMuIFNvLCBgbXRjYXJzWzE6MjBdYCB3b3VsZCByZXR1cm4gYSBkYXRhIGZyYW1lIGNvbnRhaW5pbmcgdGhlIGZpcnN0IDIwIGNvbHVtbnMgb2YgdGhlIGRhdGFzZXQuIEhvd2V2ZXIsIGFzIGBtdGNhcnNgIGhhcyBvbmx5IDExIGNvbHVtbnMsIHRoZSBpbmRleCB3aWxsIGJlIG91dCBvZiBib3VuZHMgYW5kIGFuIGVycm9yIGlzIHRocm93bi4gYG10Y2Fyc1sxOjIwLCBdYCBpcyBzdWJzZXR0ZWQgd2l0aCB0d28gdmVjdG9ycywgc28gMmQgc3Vic2V0dGluZyBraWNrcyBpbiwgYW5kIHRoZSBmaXJzdCBpbmRleCByZWZlcnMgdG8gcm93cy4KCi0tLQoKNS4gIEltcGxlbWVudCB5b3VyIG93biBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSBkaWFnb25hbCBlbnRyaWVzIGZyb20gYQogICAgbWF0cml4IChpdCBzaG91bGQgYmVoYXZlIGxpa2UgYGRpYWcoeClgIHdoZXJlIGB4YCBpcyBhIG1hdHJpeCkuCgpgYGB7cn0KbSA8LSBtYXRyaXgobmNvbCA9IDMsIGJ5cm93ID0gVFJVRSwgYygKICAxLCA0LCA3LAogIDIsIDUsIDgsCiAgMywgNiwgOQopKQptCmRpYWcobSkKCm15X2RpYWcgPC0gZnVuY3Rpb24oeCkgewogIGRpYWdfZWxlbWVudCA8LSBmdW5jdGlvbihuLCB4KSB7CiAgICB4W24sIG5dCiAgfQogIHZhcHBseShzZXFfbGVuKG5yb3cobSkpLCBkaWFnX2VsZW1lbnQsIDEsIHgpCn0KbXlfZGlhZyhtKQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogVGhlIGVsZW1lbnRzIGluIHRoZSBkaWFnb25hbCBvZiBhIG1hdHJpeCBoYXZlIHRoZSBzYW1lIHJvdy0gYW5kIGNvbHVtbiBpbmRpY2VzLiBUaGlzIGNoYXJhY3RlcmlzdGljIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIHN1aXRhYmxlIG51bWVyaWMgbWF0cml4IHVzZWQgZm9yIHN1YnNldHRpbmcuCgpgYGB7cn0KZGlhZzIgPC0gZnVuY3Rpb24oeCkgewogIG4gPC0gbWluKG5yb3coeCksIG5jb2woeCkpCiAgaWR4IDwtIGNiaW5kKHNlcV9sZW4obiksIHNlcV9sZW4obikpCiAgeFtpZHhdCn0KIyBMZXQncyBjaGVjayBpZiBpdCB3b3JrcwooeCA8LSBtYXRyaXgoMTozMCwgNSkpCgpkaWFnKHgpCmRpYWcyKHgpCmBgYAoKLS0tCgo1LiAgV2hhdCBkb2VzIGBkZltpcy5uYShkZildIDwtIDBgIGRvPyBIb3cgZG9lcyBpdCB3b3JrPwoKQW5zd2VyOiBzZXRzIHRoZSBgTkFgIHZhbHVlcyBpbiBgZGZgIHRvIGAwYCwgYnkgZmlyc3Qgc2VsZWN0aW5nIGBOQWAgdmFsdWVzIHRoZW4gYXNzaWduaW5nIGAwYC4KCmBgYHtyfQpkZiA8LSBkYXRhLmZyYW1lKHggPSBjKDEsIDIsIE5BKSwgeSA9IGMoNCwgTkEsIDYpLCB6ID0gYyhOQSwgOCwgOSkpCmRmCmRmW2lzLm5hKGRmKV0gPC0gMApkZgpgYGAKCkNvcnJlY3QhCgpBUiBTb2x1dGlvbnM6IFRoaXMgZXhwcmVzc2lvbiByZXBsYWNlcyB0aGUgYE5BYHMgaW4gYGRmYCB3aXRoIGAwYC4gSGVyZSBgaXMubmEoZGYpYCByZXR1cm5zIGEgbG9naWNhbCBtYXRyaXggdGhhdCBlbmNvZGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWlzc2luZyB2YWx1ZXMgaW4gYGRmYC4gU3Vic2V0dGluZyBhbmQgYXNzaWdubWVudCBhcmUgdGhlbiBjb21iaW5lZCB0byByZXBsYWNlIG9ubHkgdGhlIG1pc3NpbmcgdmFsdWVzLgoKLS0tCgojIyA0LjMuNSBFeGVyY2lzZXMKCjEuICBCcmFpbnN0b3JtIGFzIG1hbnkgd2F5cyBhcyBwb3NzaWJsZSB0byBleHRyYWN0IHRoZSB0aGlyZCB2YWx1ZSBmcm9tIHRoZQogICAgYGN5bGAgdmFyaWFibGUgaW4gdGhlIGBtdGNhcnNgIGRhdGFzZXQuCgpgYGB7cn0KbXRjYXJzJGN5bFszXQptdGNhcnMkY3lsW1szXV0KbXRjYXJzW1siY3lsIl1dW1szXV0KbXRjYXJzWzMsIDJdCm10Y2Fyc1tbMywgMl1dCm10Y2Fyc1tbIkRhdHN1biA3MTAiLCAiY3lsIl1dCm10Y2Fyc1stYygxOjIsIDQ6MzIpLCAtYygxLCAzOjExKV0KYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUgKHNvbWUgdmFyaWF0aW9ucyBvbWl0dGVkKS4gVGhlcmUgYXJlIG1hbnkgbW9yZS4KCkFSIFNvbHV0aW9uczogQmFzZSBSIGFscmVhZHkgcHJvdmlkZXMgYW4gYWJ1bmRhbmNlIG9mIHBvc3NpYmlsaXRpZXM6CgpgYGB7cn0KIyBTZWxlY3QgY29sdW1uIGZpcnN0Cm10Y2FycyRjeWxbWzNdXQptdGNhcnNbLCAiY3lsIl1bWzNdXQptdGNhcnNbWyJjeWwiXV1bWzNdXQp3aXRoKG10Y2FycywgY3lsW1szXV0pCgojIFNlbGVjdCByb3cgZmlyc3QKbXRjYXJzWzMsIF0kY3lsCm10Y2Fyc1szLCAiY3lsIl0KbXRjYXJzWzMsIF1bLCAiY3lsIl0KbXRjYXJzWzMsIF1bWyJjeWwiXV0KCiMgU2VsZWN0IHNpbXVsdGFuZW91c2x5Cm10Y2Fyc1szLCAyXQptdGNhcnNbW2MoMiwgMyldXQpgYGAKCi0tLQoKMi4gIEdpdmVuIGEgbGluZWFyIG1vZGVsLCBlLmcuLCBgbW9kIDwtIGxtKG1wZyB+IHd0LCBkYXRhID0gbXRjYXJzKWAsIGV4dHJhY3QKICAgIHRoZSByZXNpZHVhbCBkZWdyZWVzIG9mIGZyZWVkb20uIFRoZW4gZXh0cmFjdCB0aGUgUiBzcXVhcmVkIGZyb20gdGhlIG1vZGVsCiAgICBzdW1tYXJ5IChgc3VtbWFyeShtb2QpYCkKCmBgYHtyfQptb2QgPC0gbG0obXBnIH4gd3QsIGRhdGEgPSBtdGNhcnMpCm1vZCRkZi5yZXNpZHVhbAoKbW9kX3N1bSA8LSBzdW1tYXJ5KG1vZCkKbW9kX3N1bSRyLnNxdWFyZWQKCm1vZF9zdW0KYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IGBtb2RgIGlzIG9mIHR5cGUgbGlzdCwgd2hpY2ggb3BlbnMgdXAgc2V2ZXJhbCBwb3NzaWJpbGl0aWVzLiBXZSB1c2UgYCRgIG9yIGBbW2AgdG8gZXh0cmFjdCBhIHNpbmdsZSBlbGVtZW50OgoKYGBge3J9Cm1vZCA8LSBsbShtcGcgfiB3dCwgZGF0YSA9IG10Y2FycykKCm1vZCRkZi5yZXNpZHVhbAptb2RbWyJkZi5yZXNpZHVhbCJdXQpgYGAKClRoZSBzYW1lIGFsc28gYXBwbGllcyB0byBgc3VtbWFyeShtb2QpYCwgc28gd2UgY291bGQgdXNlLCBlLmcuOgoKYGBge3J9CnN1bW1hcnkobW9kKSRyLnNxdWFyZWQKYGBgCgooVGlwOiBUaGUgW2Bicm9vbWAgcGFja2FnZV0oaHR0cHM6Ly9naXRodWIuY29tL3RpZHltb2RlbHMvYnJvb20pIHByb3ZpZGVzIGEgdmVyeSB1c2VmdWwgYXBwcm9hY2ggdG8gd29yayB3aXRoIG1vZGVscyBpbiBhIHRpZHkgd2F5LikKCi0tLQoKIyMgNC41LjkgRXhlcmNpc2VzCgoxLiAgSG93IHdvdWxkIHlvdSByYW5kb21seSBwZXJtdXRlIHRoZSBjb2x1bW5zIG9mIGEgZGF0YSBmcmFtZT8gKFRoaXMgaXMgYW4KICAgIGltcG9ydGFudCB0ZWNobmlxdWUgaW4gcmFuZG9tIGZvcmVzdHMuKSBDYW4geW91IHNpbXVsdGFuZW91c2x5IHBlcm11dGUgCiAgICB0aGUgcm93cyBhbmQgY29sdW1ucyBpbiBvbmUgc3RlcD8KCmBgYHtyfQpkZiA8LSBkYXRhLmZyYW1lKHggPSAxOjUsIHkgPSA1OjEsIHogPSBsZXR0ZXJzWzE6NV0sIHJvdy5uYW1lcyA9IDE6NSkKCmRmWywgc2FtcGxlKG5jb2woZGYpKV0KCmRmW3NhbXBsZShucm93KGRmKSksIHNhbXBsZShuY29sKGRmKSldCmBgYAoKQW5zd2VyOiB1c2luZyBgc2FtcGxlKClgLiBZZXMhCgpBUiBTb2x1dGlvbnM6IFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IGNvbWJpbmluZyBgW2AgYW5kIGBzYW1wbGUoKWA6CgpgYGB7cixldmFsID0gRkFMU0V9CiMgUGVybXV0ZSBjb2x1bW5zCm10Y2Fyc1tzYW1wbGUobmNvbChtdGNhcnMpKV0KCiMgUGVybXV0ZSBjb2x1bW5zIGFuZCByb3dzIGluIG9uZSBzdGVwCm10Y2Fyc1tzYW1wbGUobnJvdyhtdGNhcnMpKSwgc2FtcGxlKG5jb2wobXRjYXJzKSldCmBgYAoKLS0tCgoyLiAgSG93IHdvdWxkIHlvdSBzZWxlY3QgYSByYW5kb20gc2FtcGxlIG9mIGBtYCByb3dzIGZyb20gYSBkYXRhIGZyYW1lPyAKICAgIFdoYXQgaWYgdGhlIHNhbXBsZSBoYWQgdG8gYmUgY29udGlndW91cyAoaS5lLiwgd2l0aCBhbiBpbml0aWFsIHJvdywgYSAKICAgIGZpbmFsIHJvdywgYW5kIGV2ZXJ5IHJvdyBpbiBiZXR3ZWVuKT8KCmBgYHtyfQpzYW1wbGVfcm93cyA8LSBmdW5jdGlvbihkZiwgbSwgY29udGlndW91cyA9IEZBTFNFKSB7CiAgaWYgKG0gPiBucm93KGRmKSkgewogICAgc3RvcCgic2FtcGxlIHNpemUgJyIsIG0sICInIGlzIGxhcmdlciB0aGFuIHRoZSBudW1iZXIgb2Ygcm93cywgJyIsIG5yb3coZGYpLCAiJyIpCiAgfQogIGlmIChjb250aWd1b3VzKSB7CiAgICBmaXJzdF9yb3cgPC0gc2FtcGxlKG5yb3coZGYpIC0gbSArIDEsIDEpCiAgICBsYXN0X3JvdyA8LSBmaXJzdF9yb3cgKyBtIC0gMQogICAgcmV0dXJuKGRmW2ZpcnN0X3JvdzpsYXN0X3JvdywgXSkKICB9CiAgZGZbc2FtcGxlKG5yb3coZGYpLCBtKSwgXQp9CgpzYW1wbGVfcm93cyhkZiwgMykKc2FtcGxlX3Jvd3MoZGYsIDMsIGNvbnRpZ3VvdXMgPSBUUlVFKQp0cnkoc2FtcGxlX3Jvd3MoZGYsIDYpKQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogU2VsZWN0aW5nIGBtYCByYW5kb20gcm93cyBmcm9tIGEgZGF0YSBmcmFtZSBjYW4gYmUgYWNoaWV2ZWQgdGhyb3VnaCBzdWJzZXR0aW5nLgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KbSA8LSAxMAptdGNhcnNbc2FtcGxlKG5yb3cobXRjYXJzKSwgbSksIF0KYGBgCgpIb2xkaW5nIHN1Y2Nlc3NpdmUgbGluZXMgdG9nZXRoZXIgYXMgYSBibG9ja2VkIHNhbXBsZSByZXF1aXJlcyBvbmx5IGEgY2VydGFpbiBhbW91bnQgb2YgY2F1dGlvbiBpbiBvcmRlciB0byBvYnRhaW4gdGhlIGNvcnJlY3Qgc3RhcnQgYW5kIGVuZCBpbmRleC4KCmBgYHtyLCBldmFsID0gRkFMU0V9CnN0YXJ0IDwtIHNhbXBsZShucm93KG10Y2FycykgLSBtICsgMSwgMSkKZW5kIDwtIHN0YXJ0ICsgbSAtIDEKbXRjYXJzW3N0YXJ0OmVuZCwgLCBkcm9wID0gRkFMU0VdCmBgYAoKLS0tCiAgICAKMy4gIEhvdyBjb3VsZCB5b3UgcHV0IHRoZSBjb2x1bW5zIGluIGEgZGF0YSBmcmFtZSBpbiBhbHBoYWJldGljYWwgb3JkZXI/CgpgYGB7cn0KbXRjYXJzW3NvcnQoY29sbmFtZXMobXRjYXJzKSldCmBgYAoKQW5zd2VyOiB1c2luZyBgc29ydChjb2xuYW1lcylgLgoKQVIgU29sdXRpb25zOiBXZSBjb21iaW5lIGBbYCB3aXRoIGBvcmRlcigpYCBvciBgc29ydCgpYDoKCmBgYHtyLCBldmFsID0gRkFMU0V9Cm10Y2Fyc1tvcmRlcihuYW1lcyhtdGNhcnMpKV0KbXRjYXJzW3NvcnQobmFtZXMobXRjYXJzKSldCmBgYAoKLS0tCgojIDUgQ29udHJvbCBmbG93CgpUaGVyZSBhcmUgdHdvIHByaW1hcnkgdG9vbHMgb2YgY29udHJvbCBmbG93OiBjaG9pY2VzIGFuZCBsb29wcy4gQ2hvaWNlcywgbGlrZSBgaWZgIHN0YXRlbWVudHMgYW5kIGBzd2l0Y2goKWAgY2FsbHMsIGFsbG93IHlvdSB0byBydW4gZGlmZmVyZW50IGNvZGUgZGVwZW5kaW5nIG9uIHRoZSBpbnB1dC4gTG9vcHMsIGxpa2UgYGZvcmAgYW5kIGB3aGlsZWAsIGFsbG93IHlvdSB0byByZXBlYXRlZGx5IHJ1biBjb2RlLCB0eXBpY2FsbHkgd2l0aCBjaGFuZ2luZyBvcHRpb25zLiBJJ2QgZXhwZWN0IHRoYXQgeW91J3JlIGFscmVhZHkgZmFtaWxpYXIgd2l0aCB0aGUgYmFzaWNzIG9mIHRoZXNlIGZ1bmN0aW9ucyBzbyBJJ2xsIGJyaWVmbHkgY292ZXIgc29tZSB0ZWNobmljYWwgZGV0YWlscyBhbmQgdGhlbiBpbnRyb2R1Y2Ugc29tZSB1c2VmdWwsIGJ1dCBsZXNzZXIga25vd24sIGZlYXR1cmVzLgoKVGhlIGNvbmRpdGlvbiBzeXN0ZW0gKG1lc3NhZ2VzLCB3YXJuaW5ncywgYW5kIGVycm9ycyksIHdoaWNoIHlvdSdsbCBsZWFybiBhYm91dCBpbiBDaGFwdGVyIDgsIGFsc28gcHJvdmlkZXMgbm9uLWxvY2FsIGNvbnRyb2wgZmxvdy4gCgpgYGB7cn0Kcm0obGlzdCA9IGxzKCkpCmBgYAoKIyMgNS4yLjQgRXhlcmNpc2VzCgoxLiAgV2hhdCB0eXBlIG9mIHZlY3RvciBkb2VzIGVhY2ggb2YgdGhlIGZvbGxvd2luZyBjYWxscyB0byBgaWZlbHNlKClgCiAgICByZXR1cm4/IFJlYWQgdGhlIGRvY3VtZW50YXRpb24gYW5kIHdyaXRlIGRvd24gdGhlIHJ1bGVzIGluIHlvdXIgb3duIHdvcmRzLgoKYGBge3J9CmlmZWxzZShUUlVFLCAxLCAibm8iKQp0eXBlb2YoaWZlbHNlKFRSVUUsIDEsICJubyIpKSAjIGRvdWJsZQppZmVsc2UoRkFMU0UsIDEsICJubyIpCnR5cGVvZihpZmVsc2UoRkFMU0UsIDEsICJubyIpKSAjIGNoYXJhY3RlcgppZmVsc2UoTkEsIDEsICJubyIpCnR5cGVvZihpZmVsc2UoTkEsIDEsICJubyIpKSAjIGxvZ2ljYWwKaWZlbHNlKE5VTEwsIDEsICJubyIpCmBgYAoKQW5zd2VyOgoKLSBpZiBgdGVzdGAgaXMgdHJ1ZSwgcmV0dXJuIGEgdmVjdG9yIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyBgdGVzdGAgKDEpIHBvcHVsYXRlZCB3aXRoICJ5ZXMiIC0gaGVyZSAxCiAgaXMgYSBkb3VibGUsIDFMIHdvdWxkIGJlIGludGVnZXIKLSBpZiBgdGVzdGAgaXMgZmFsc2UsIHJldHVybiBhIHZlY3RvciBvZiB0aGUgc2FtZSBsZW5ndGggYXMgYHRlc3RgICgxKSBwb3B1bGF0ZWQgd2l0aCAibm8iIC0gaGVyZQogICJubyIgaXMgYSBjaGFyYWN0ZXIKLSBpZiBgdGVzdGAgaXMgYE5BYCwgcmV0dXJuIGBOQWAsIGFuZCBpZiBgdGVzdGAgaXMgYE5VTExgLCByZXR1cm4gYGxvZ2ljYWwoMClgCgpBUiBTb2x1dGlvbnM6IFRoZSBhcmd1bWVudHMgb2YgYGlmZWxzZSgpYCBhcmUgbmFtZWQgYHRlc3RgLCBgeWVzYCBhbmQgYG5vYC4gSW4gZ2VuZXJhbCwgYGlmZWxzZSgpYCByZXR1cm5zIHRoZSBlbnRyeSBmb3IgYHllc2Agd2hlbiBgdGVzdGAgaXMgYFRSVUVgLCB0aGUgZW50cnkgZm9yIGBub2Agd2hlbiBgdGVzdGAgaXMgYEZBTFNFYCBhbmQgYE5BYCB3aGVuIGB0ZXN0YCBpcyBgTkFgLiBUaGVyZWZvcmUsIHRoZSBleHByZXNzaW9ucyBhYm92ZSByZXR1cm4gdmVjdG9ycyBvZiB0eXBlIGBkb3VibGVgIChgMWApLCBgY2hhcmFjdGVyYCAoYCJubyJgKSBhbmQgYGxvZ2ljYWxgIChgTkFgKS4KClRvIGJlIGEgbGl0dGxlIG1vcmUgcHJlY2lzZSwgd2Ugd2lsbCBjaXRlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudGF0aW9uIG9uIHRoZSByZXR1cm4gdmFsdWUgb2YgYGlmZWxzZSgpYDoKCj4gQSB2ZWN0b3Igb2YgdGhlIHNhbWUgbGVuZ3RoIGFuZCBhdHRyaWJ1dGVzIChpbmNsdWRpbmcgZGltZW5zaW9ucyBhbmQgImNsYXNzIikgYXMgdGVzdCBhbmQgZGF0YSB2YWx1ZXMgZnJvbSB0aGUgdmFsdWVzIG9mIHllcyBvciBuby4gVGhlIG1vZGUgb2YgdGhlIGFuc3dlciB3aWxsIGJlIGNvZXJjZWQgZnJvbSBsb2dpY2FsIHRvIGFjY29tbW9kYXRlIGZpcnN0IGFueSB2YWx1ZXMgdGFrZW4gZnJvbSB5ZXMgYW5kIHRoZW4gYW55IHZhbHVlcyB0YWtlbiBmcm9tIG5vLgoKVGhpcyBpcyBzdXJwcmlzaW5nIGJlY2F1c2UgaXQgdXNlcyB0aGUgdHlwZSBvZiBgdGVzdGAuIEluIHByYWN0aWNlIHRoaXMgbWVhbnMsIHRoYXQgYHRlc3RgIGlzIGZpcnN0IGNvbnZlcnRlZCB0byBsb2dpY2FsIGFuZCBpZiB0aGUgcmVzdWx0IGlzIG5laXRoZXIgYFRSVUVgIG5vciBgRkFMU0VgLCBzaW1wbHkgYGFzLmxvZ2ljYWwodGVzdClgIGlzIHJldHVybmVkLgoKLS0tCgoyLiAgV2h5IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHdvcms/CgpgYGB7cn0KeCA8LSAxOjEwCmlmIChsZW5ndGgoeCkpICJub3QgZW1wdHkiIGVsc2UgImVtcHR5IgoKeCA8LSBudW1lcmljKCkKaWYgKGxlbmd0aCh4KSkgIm5vdCBlbXB0eSIgZWxzZSAiZW1wdHkiCmBgYAoKQW5zd2VyOiBpbiB0aGUgZmlyc3QgZXhhbXBsZSwgYGxlbmd0aCh4KWAgaXMgbm9uemVybywgd2hpY2ggZXZhbHVhdGVzIHRvIGBUUlVFYC4gSW4gdGhlIHNlY29uZCBleGFtcGxlLCBgbnVtZXJpYygpYCByZXR1cm5zIGEgdmVjdG9yIG9mIGxlbmd0aCAwICh0aGUgZGVmYXVsdCksIGBsZW5ndGgoeClgIGlzIHplcm8sIHdoaWNoIGV2YWx1YXRlcyB0byBgRkFMU0VgLgoKQVIgU29sdXRpb25zOiBgaWYoKWAgZXhwZWN0cyBhIGxvZ2ljYWwgY29uZGl0aW9uLCBidXQgYWxzbyBhY2NlcHRzIGEgbnVtZXJpYyB2ZWN0b3Igd2hlcmUgYDBgIGlzIHRyZWF0ZWQgYXMgYEZBTFNFYCBhbmQgYWxsIG90aGVyIG51bWJlcnMgYXJlIHRyZWF0ZWQgYXMgYFRSVUVgLiBOdW1lcmljYWwgbWlzc2luZyB2YWx1ZXMgKGluY2x1ZGluZyBgTmFOYCkgbGVhZCB0byBhbiBlcnJvciBpbiB0aGUgc2FtZSB3YXkgdGhhdCBhIGxvZ2ljYWwgbWlzc2luZywgYE5BYCwgZG9lcy4KCi0tLQoKIyMgNS4zLjMgRXhlcmNpc2VzCgoxLiAgV2h5IGRvZXMgdGhpcyBjb2RlIHN1Y2NlZWQgd2l0aG91dCBlcnJvcnMgb3Igd2FybmluZ3M/IAoKYGBge3J9CnggPC0gbnVtZXJpYygpICMgeCBpcyBudW1lcmljKDApCm91dCA8LSB2ZWN0b3IoImxpc3QiLCBsZW5ndGgoeCkpICMgb3V0IGlzIGxpc3QoMCkKZm9yIChpIGluIDE6bGVuZ3RoKHgpKSB7ICMgbm9saW50OiBzZXFfbGludGVyLiBpIGlzIDEsIHRoZW4gMC4KICBvdXRbaV0gPC0geFtpXV4yICMgd2hlbiBpID0gMSB4WzFdIGlzIE5BLCBzZXRzIG91dFsxXSB0byBOQS4gd2hlbiBpID0gMCBub3RoaW5nIGhhcHBlbnMKfQpvdXQKYGBgCgpBbnN3ZXI6IGluIGFkZGl0aW9uIHRvIG5vdGVzIGFib3ZlLCBgb3V0WzBdYCBhbmQgYHhbMF1gIHJldHVybiBhIHplcm8tbGVuZ3RoIHZlY3Rvci4KCkFSIFNvbHV0aW9uczogVGhpcyBsb29wIGlzIGEgZGVsaWNhdGUgaXNzdWUsIGFuZCB3ZSBoYXZlIHRvIGNvbnNpZGVyIGEgZmV3IHBvaW50cyB0byBleHBsYWluIHdoeSBpdCBpcyBldmFsdWF0ZWQgd2l0aG91dCByYWlzaW5nIGFueSBlcnJvcnMgb3Igd2FybmluZ3MuCgpUaGUgYmVnaW5uaW5nIG9mIHRoaXMgY29kZSBzbWVsbCBpcyB0aGUgc3RhdGVtZW50IGAxOmxlbmd0aCh4KWAgd2hpY2ggY3JlYXRlcyB0aGUgaW5kZXggb2YgdGhlIGZvciBsb29wLiBBcyBgeGAgaGFzIGxlbmd0aCAwIGAxOmxlbmd0aCh4KWAgY291bnRzIGRvd24gZnJvbSAxIHRvIDAuIFRoaXMgaXNzdWUgaXMgdHlwaWNhbGx5IGF2b2lkZWQgdmlhIHVzYWdlIG9mIGBzZXFfYWxvbmcoeClgIG9yIHNpbWlsYXIgaGVscGVycyB3aGljaCB3b3VsZCBqdXN0IGdlbmVyYXRlIGBpbnRlZ2VyKDApYCBpbiB0aGlzIGNhc2UuCgpBcyB3ZSB1c2UgYFs8LWAgYW5kIGBbYCBmb3IgaW5kZXhpbmcgMC1sZW5ndGggdmVjdG9ycyBhdCB0aGVpciBmaXJzdCBhbmQgemVyb3RoIHBvc2l0aW9uLCB3ZSBuZWVkIHRvIGJlIGF3YXJlIG9mIHRoZWlyIHN1YnNldHRpbmcgYmVoYXZpb3VyIGZvciBvdXQtb2YtYm91bmRzIGFuZCB6ZXJvIGluZGljZXMuCgpEdXJpbmcgdGhlIGZpcnN0IGl0ZXJhdGlvbiBgeFsxXWAgd2lsbCBnZW5lcmF0ZSBhbiBgTkFgIChvdXQtb2YtYm91bmRzIGluZGV4aW5nIGZvciBhdG9taWNzKS4gVGhlIHJlc3VsdGluZyBgTkFgIChmcm9tIHNxdWFyaW5nKSB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBlbXB0eSBsZW5ndGgtMSBsaXN0IGBvdXRbMV1gIChvdXQtb2YtYm91bmRzIGluZGV4aW5nIGZvciBsaXN0cykuCgpJbiB0aGUgbmV4dCBpdGVyYXRpb24sIGB4WzBdYCB3aWxsIHJldHVybiBgbnVtZXJpYygwKWAgKHplcm8gaW5kZXhpbmcgZm9yIGF0b21pY3MpLiBBZ2Fpbiwgc3F1YXJpbmcgZG9lc24ndCBjaGFuZ2UgdGhlIHZhbHVlIGFuZCBgbnVtZXJpYygwKWAgaXMgYXNzaWduZWQgdG8gYG91dFswXWAgKHplcm8gaW5kZXhpbmcgZm9yIGxpc3RzKS4gQXNzaWduaW5nIGEgMC1sZW5ndGggdmVjdG9yIHRvIGEgMC1sZW5ndGggc3Vic2V0IHdvcmtzIGJ1dCBkb2Vzbid0IGNoYW5nZSB0aGUgb2JqZWN0LgoKT3ZlcmFsbCwgdGhlIGNvZGUgd29ya3MsIGJlY2F1c2UgZWFjaCBzdGVwIGluY2x1ZGVzIHZhbGlkIFIgb3BlcmF0aW9ucyAoZXZlbiB0aG91Z2ggdGhlIHJlc3VsdCBtYXkgbm90IGJlIHdoYXQgdGhlIHVzZXIgaW50ZW5kZWQpLgoKLS0tCgoyLiAgV2hlbiB0aGUgZm9sbG93aW5nIGNvZGUgaXMgZXZhbHVhdGVkLCB3aGF0IGNhbiB5b3Ugc2F5IGFib3V0IHRoZSAKICAgIHZlY3RvciBiZWluZyBpdGVyYXRlZD8KCmBgYHtyfQp4cyA8LSBjKDEsIDIsIDMpCmZvciAoeCBpbiB4cykgewogIHhzIDwtIGMoeHMsIHggKiAyKQp9CnhzCmBgYAoKQW5zd2VyOiBgeGAgaXRlcmF0ZXMgZnJvbSAxIHRvIDMsIGFuZCBpcyBub3QgYWZmZWN0ZWQgYnkgY2hhbmdlcyB0byBgeHNgIGR1cmluZyB0aGUgbG9vcCwgd2hpbGUgYHhzYCBpcyB1cGRhdGVkLgoKQVIgU29sdXRpb246IEluIHRoaXMgbG9vcCBgeGAgdGFrZXMgb24gdGhlIHZhbHVlcyBvZiB0aGUgaW5pdGlhbCBgeHNgIChgMWAsIGAyYCBhbmQgYDNgKSwgaW5kaWNhdGluZyB0aGF0IGl0IGlzIGV2YWx1YXRlZCBqdXN0IG9uY2UgaW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgbG9vcCwgbm90IGFmdGVyIGVhY2ggaXRlcmF0aW9uLiAoT3RoZXJ3aXNlLCB3ZSB3b3VsZCBydW4gaW50byBhbiBpbmZpbml0ZSBsb29wLikKCi0tLQoKMy4gIFdoYXQgZG9lcyB0aGUgZm9sbG93aW5nIGNvZGUgdGVsbCB5b3UgYWJvdXQgd2hlbiB0aGUgaW5kZXggaXMgdXBkYXRlZD8KCmBgYHtyfQpmb3IgKGkgaW4gMTozKSB7CiAgaSA8LSBpICogMgogIHByaW50KGkpCn0KYGBgCgpBbnN3ZXI6IHRoZSBpbmRleCBpcyB1cGRhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBsb29wLgoKQVIgU29sdXRpb25zOiBJbiBhIGZvciBsb29wIHRoZSBpbmRleCBpcyB1cGRhdGVkIGluIHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBpdGVyYXRpb24uIFRoZXJlZm9yZSwgcmVhc3NpZ25pbmcgdGhlIGluZGV4IHN5bWJvbCBkdXJpbmcgb25lIGl0ZXJhdGlvbiBkb2Vzbid0IGFmZmVjdCB0aGUgZm9sbG93aW5nIGl0ZXJhdGlvbnMuIChBZ2Fpbiwgd2Ugd291bGQgb3RoZXJ3aXNlIHJ1biBpbnRvIGFuIGluZmluaXRlIGxvb3AuKQoKLS0tCgojIDYgRnVuY3Rpb25zCgpJZiB5b3UncmUgcmVhZGluZyB0aGlzIGJvb2ssIHlvdSd2ZSBwcm9iYWJseSBhbHJlYWR5IGNyZWF0ZWQgbWFueSBSIGZ1bmN0aW9ucyBhbmQga25vdyBob3cgdG8gdXNlIHRoZW0gdG8gcmVkdWNlIGR1cGxpY2F0aW9uIGluIHlvdXIgY29kZS4gSW4gdGhpcyBjaGFwdGVyLCB5b3UnbGwgbGVhcm4gaG93IHRvIHR1cm4gdGhhdCBpbmZvcm1hbCwgd29ya2luZyBrbm93bGVkZ2UgaW50byBtb3JlIHJpZ29yb3VzLCB0aGVvcmV0aWNhbCB1bmRlcnN0YW5kaW5nLiBBbmQgd2hpbGUgeW91J2xsIHNlZSBzb21lIGludGVyZXN0aW5nIHRyaWNrcyBhbmQgdGVjaG5pcXVlcyBhbG9uZyB0aGUgd2F5LCBrZWVwIGluIG1pbmQgdGhhdCB3aGF0IHlvdSdsbCBsZWFybiBoZXJlIHdpbGwgYmUgaW1wb3J0YW50IGZvciB1bmRlcnN0YW5kaW5nIHRoZSBtb3JlIGFkdmFuY2VkIHRvcGljcyBkaXNjdXNzZWQgbGF0ZXIgaW4gdGhlIGJvb2suCgpgYGB7cn0Kcm0obGlzdCA9IGxzKCkpCmBgYAoKIyMgNiBRdWl6CgpBbnN3ZXIgdGhlIGZvbGxvd2luZyBxdWVzdGlvbnMgdG8gc2VlIGlmIHlvdSBjYW4gc2FmZWx5IHNraXAgdGhpcyBjaGFwdGVyLgoKMS4gIFdoYXQgYXJlIHRoZSB0aHJlZSBjb21wb25lbnRzIG9mIGEgZnVuY3Rpb24/IGE6IGFyZ3VtZW50cywgY29kZSwgcmV0dXJuIHZhbHVlIFtib2R5LCBhcmd1bWVudHMsCiAgICBlbnZpcm9ubWVudF0KCjIuICBXaGF0IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHJldHVybj8gYTogMTEgW2NvcnJlY3QhXQoKYGBge3J9CnggPC0gMTAKZjEgPC0gZnVuY3Rpb24oeCkgewogIGZ1bmN0aW9uKCkgewogICAgeCArIDEwCiAgfQp9CmYxKDEpKCkKYGBgCgozLiAgSG93IHdvdWxkIHlvdSB1c3VhbGx5IHdyaXRlIHRoaXMgY29kZT8gYTogYDEgKyAyICogM2AgW2NvcnJlY3QhIC4uLiBgMSArICgyICogMylgXQoKYGBge3IsIGV2YWwgPSBGQUxTRX0KYCtgKDEsIGAqYCgyLCAzKSkKYGBgCgo0LiAgSG93IGNvdWxkIHlvdSBtYWtlIHRoaXMgY2FsbCBlYXNpZXIgdG8gcmVhZD8gYG1lYW4oYygxOjEwLCBOQSksIG5hLnJtID0gVFJVRSlgIFtjb3JyZWN0IV0KCmBgYHtyLCBldmFsID0gRkFMU0V9Cm1lYW4oLCBUUlVFLCB4ID0gYygxOjEwLCBOQSkpICMgbm9saW50OiBtaXNzaW5nX2FyZ3VtZW50X2xpbnRlci4KYGBgCgo1LiAgRG9lcyB0aGUgZm9sbG93aW5nIGNvZGUgdGhyb3cgYW4gZXJyb3Igd2hlbiBleGVjdXRlZD8gV2h5IG9yIHdoeSBub3Q/IGE6IG5vLCBkdWUgdG8gbGF6eQogICAgZXZhbHVhdGlvbiwgdGhlIGBzdG9wKClgIGlzIG5ldmVyIHJ1biBbY29ycmVjdCEgLi4uIHNlY29uZCBhcmd1bWVudCBpcyBuZXZlciB1c2VkXQoKYGBge3J9CmYyIDwtIGZ1bmN0aW9uKGEsIGIpIHsKICBhICogMTAKfQpmMigxMCwgc3RvcCgiVGhpcyBpcyBhbiBlcnJvciEiKSkKYGBgCgo2LiAgV2hhdCBpcyBhbiBpbmZpeCBmdW5jdGlvbj8gSG93IGRvIHlvdSB3cml0ZSBpdD8gV2hhdCdzIGEgcmVwbGFjZW1lbnQgCiAgICBmdW5jdGlvbj8gSG93IGRvIHlvdSB3cml0ZSBpdD8gYTogYGZ1bmN0aW9uKHgpIHhgLiA/Pz8gW3NlZSA2LjguMyBhbmQgNi44LjRdCgo3LiAgSG93IGRvIHlvdSBlbnN1cmUgdGhhdCBjbGVhbnVwIGFjdGlvbiBvY2N1cnMgcmVnYXJkbGVzcyBvZiBob3cgYSBmdW5jdGlvbiAKICAgIGV4aXRzPyBhOiA/Pz8gW2Bvbi5leGl0KClgXQoKIyMgNi4yLjUgRXhlcmNpc2VzCgoxLiBHaXZlbiBhIG5hbWUsIGxpa2UgYCJtZWFuImAsIGBtYXRjaC5mdW4oKWAgbGV0cyB5b3UgZmluZCBhIGZ1bmN0aW9uLiAKICAgR2l2ZW4gYSBmdW5jdGlvbiwgY2FuIHlvdSBmaW5kIGl0cyBuYW1lPyBXaHkgZG9lc24ndCB0aGF0IG1ha2Ugc2Vuc2UgaW4gUj8KCkFuc3dlcjogYSBmdW5jdGlvbiBpcyBhbiBvYmplY3QgYW5kIGNvdWxkIGhhdmUgbXVsdGlwbGUgbmFtZXMgcG9pbnRpbmcgdG8gaXQuCgpBUiBTb2x1dGlvbnM6IEluIFIgdGhlcmUgaXMgbm8gb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gZnVuY3Rpb25zIGFuZCBuYW1lcy4gQSBuYW1lIGFsd2F5cyBwb2ludHMgdG8gYSBzaW5nbGUgb2JqZWN0LCBidXQgYW4gb2JqZWN0IG1heSBoYXZlIHplcm8sIG9uZSBvciBtYW55IG5hbWVzLgoKLS0tCgoyLiAgSXQncyBwb3NzaWJsZSAoYWx0aG91Z2ggdHlwaWNhbGx5IG5vdCB1c2VmdWwpIHRvIGNhbGwgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLgogICAgV2hpY2ggb2YgdGhlIHR3byBhcHByb2FjaGVzIGJlbG93IGlzIGNvcnJlY3Q/IFdoeT8KCmBgYHtyLCByZXN1bHQgPSAiaGlkZSJ9CmZ1bmN0aW9uKHgpIDMoKQooZnVuY3Rpb24oeCkgMykoKQpgYGAKCkFuc3dlcjogVGhlIHNlY29uZCBpcyBjb3JyZWN0LCBhcyB0aGUgZmlyc3QgaXMgdGhlIGZvcm0gb2YgZGVmaW5pbmcgYSBmdW5jdGlvbi4KCkFSIFNvbHV0aW9uczogVGhlIHNlY29uZCBhcHByb2FjaCBpcyBjb3JyZWN0LgoKVGhlIGFub255bW91cyBmdW5jdGlvbiBgZnVuY3Rpb24oeCkgM2AgaXMgc3Vycm91bmRlZCBieSBhIHBhaXIgb2YgcGFyZW50aGVzZXMgYmVmb3JlIGl0IGlzIGNhbGxlZCBieSBgKClgLiBUaGVzZSBleHRyYSBwYXJlbnRoZXNlcyBzZXBhcmF0ZSB0aGUgZnVuY3Rpb24gY2FsbCBmcm9tIHRoZSBhbm9ueW1vdXMgZnVuY3Rpb24ncyBib2R5LiBXaXRob3V0IHRoZW0gYSBmdW5jdGlvbiB3aXRoIHRoZSBpbnZhbGlkIGJvZHkgYDMoKWAgaXMgcmV0dXJuZWQsIHdoaWNoIHRocm93cyBhbiBlcnJvciB3aGVuIHdlIGNhbGwgaXQuCgotLS0KCjMuIEEgZ29vZCBydWxlIG9mIHRodW1iIGlzIHRoYXQgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIHNob3VsZCBmaXQgb24gb25lIGxpbmUgCiAgIGFuZCBzaG91bGRuJ3QgbmVlZCB0byB1c2UgYHt9YC4gUmV2aWV3IHlvdXIgY29kZS4gV2hlcmUgY291bGQgeW91IGhhdmUgCiAgIHVzZWQgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSBuYW1lZCBmdW5jdGlvbj8gV2hlcmUgc2hvdWxkIHlvdSAKICAgaGF2ZSB1c2VkIGEgbmFtZWQgZnVuY3Rpb24gaW5zdGVhZCBvZiBhbiBhbm9ueW1vdXMgZnVuY3Rpb24/CgpBbnN3ZXI6IGluIGByZGV2OjpidWlsZF9hbmFseXNpc19zaXRlKClgLCBgYW5hbHlzaXNfbWVudV9pdGVtKClgIGlzIHByb3Blcmx5IHdyaXR0ZW4gYXMgYSBuYW1lZCBmdW5jdGlvbiwgd2hlcmUgYGdldF9jb21wb25lbnQoKWAgY291bGQgYmUgd3JpdHRlbiBhcyBhbiBhbm9ueW1vdXMgZnVuY3Rpb24sIHdpdGggYGRpcl9jaGVja19jb3B5KClgIGFuZCBgZGlyX2NoZWNrX2RlbGV0ZSgpYCBwb3RlbnRpYWxseSBlaXRoZXIuCgpBUiBTb2x1dGlvbnM6IFRoZSB1c2Ugb2YgYW5vbnltb3VzIGZ1bmN0aW9ucyBhbGxvd3MgY29uY2lzZSBhbmQgZWxlZ2FudCBjb2RlIGluIGNlcnRhaW4gc2l0dWF0aW9ucy4gSG93ZXZlciwgdGhleSBtaXNzIGEgZGVzY3JpcHRpdmUgbmFtZSBhbmQgd2hlbiByZS1yZWFkaW5nIHRoZSBjb2RlLCBpdCBjYW4gdGFrZSBhIHdoaWxlIHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGV5IGRvLiBUaGF0J3Mgd2h5IGl0J3MgaGVscGZ1bCB0byBnaXZlIGxvbmcgYW5kIGNvbXBsZXggZnVuY3Rpb25zIGEgZGVzY3JpcHRpdmUgbmFtZS4gSXQgbWF5IGJlIHdvcnRod2hpbGUgdG8gdGFrZSBhIGxvb2sgYXQgeW91ciBvd24gcHJvamVjdHMgb3Igb3RoZXIgcGVvcGxlJ3MgY29kZSB0byByZWZsZWN0IG9uIHRoaXMgcGFydCBvZiB5b3VyIGNvZGluZyBzdHlsZS4KCi0tLQoKNC4gIFdoYXQgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byB0ZWxsIGlmIGFuIG9iamVjdCBpcyBhIGZ1bmN0aW9uPyBXaGF0IGZ1bmN0aW9uCiAgICBhbGxvd3MgeW91IHRvIHRlbGwgaWYgYSBmdW5jdGlvbiBpcyBhIHByaW1pdGl2ZSBmdW5jdGlvbj8KCkFuc3dlcjogYGlzLmZ1bmN0aW9uKClgIGFuZCBgaXMucHJpbWl0aXZlKClgLgoKQVIgU29sdXRpb25zOiBVc2UgYGlzLmZ1bmN0aW9uKClgIHRvIHRlc3QgaWYgYW4gb2JqZWN0IGlzIGEgZnVuY3Rpb24uIENvbnNpZGVyIHVzaW5nIGBpcy5wcmltaXRpdmUoKWAgdG8gdGVzdCBzcGVjaWZpY2FsbHkgZm9yIHByaW1pdGl2ZSBmdW5jdGlvbnMuCgotLS0KCjUuICBUaGlzIGNvZGUgbWFrZXMgYSBsaXN0IG9mIGFsbCBmdW5jdGlvbnMgaW4gdGhlIGJhc2UgcGFja2FnZS4gCgpgYGB7cn0Kb2JqcyA8LSBtZ2V0KGxzKCJwYWNrYWdlOmJhc2UiLCBhbGwgPSBUUlVFKSwgaW5oZXJpdHMgPSBUUlVFKQpmdW5zIDwtIEZpbHRlcihpcy5mdW5jdGlvbiwgb2JqcykKYGBgCgpVc2UgaXQgdG8gYW5zd2VyIHRoZSBmb2xsb3dpbmcgcXVlc3Rpb25zOgoKYS4gV2hpY2ggYmFzZSBmdW5jdGlvbiBoYXMgdGhlIG1vc3QgYXJndW1lbnRzPwphLiBIb3cgbWFueSBiYXNlIGZ1bmN0aW9ucyBoYXZlIG5vIGFyZ3VtZW50cz8gV2hhdCdzIHNwZWNpYWwgYWJvdXQgdGhvc2UKICAgZnVuY3Rpb25zPwphLiBIb3cgY291bGQgeW91IGFkYXB0IHRoZSBjb2RlIHRvIGZpbmQgYWxsIHByaW1pdGl2ZSBmdW5jdGlvbnM/CgpgYGB7cn0KZnVuX2FyZ3MgPC0gZGF0YS5mcmFtZSgKICBuYW1lID0gbmFtZXMoZnVucyksCiAgYXJncyA9IHVubmFtZSh2YXBwbHkoZnVucywgZnVuY3Rpb24oeCkgbGVuZ3RoKGZvcm1hbHMoeCkpLCAxTCkpCikKaGVhZChmdW5fYXJnc1tvcmRlcihmdW5fYXJncyRhcmdzLCBkZWNyZWFzaW5nID0gVFJVRSksIF0sIDEwKQpmdW5fYXJnc1tmdW5fYXJncyRhcmdzID09IDAsIF0KIyBjaGVjayBpZiBhbGwgZnVuY3Rpb25zIHdpdGggMCBhcmd1bWVudHMgYXJlIHByaW1pdGl2ZQpmdW5fYXJnczIgPC0gZGF0YS5mcmFtZSgKICBuYW1lID0gbmFtZXMoZnVucyksCiAgYXJncyA9IHVubmFtZSh2YXBwbHkoZnVucywgZnVuY3Rpb24oeCkgbGVuZ3RoKGZvcm1hbHMoeCkpLCAxTCkpLAogIHByaW0gPSB1bm5hbWUodmFwcGx5KGZ1bnMsIGlzLnByaW1pdGl2ZSwgVFJVRSkpCikKZnVuX2FyZ3MyW2Z1bl9hcmdzMiRhcmdzID09IDAsIF0KYGBgCgpBbnN3ZXJzOgoKYS4gYHNjYW4oKWAgaGFzIHRoZSBtb3N0IGFyZ3VtZW50cywgMjIKYS4gbW9zdCAoYnV0IG5vdCBhbGwpIGFyZSBwcmltaXRpdmUgZnVuY3Rpb25zICgyMDQgb2YgMjU0KQphLiB0aGUgYGxzKClgIGluIHRoZSBvcmlnaW5hbCBjb2RlIGNvdWxkIGJlIGV4cGFuZGVkIHRvIHNlYXJjaCBhbGwgcGFja2FnZXMKCkFSIFNvbHV0aW9uczogTGV0J3MgbG9vayBhdCBlYWNoIHN1Yi1xdWVzdGlvbiBzZXBhcmF0ZWx5OgoKYS4gVG8gZmluZCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgbW9zdCBhcmd1bWVudHMsIHdlIGZpcnN0IGNvbXB1dGUgdGhlIGxlbmd0aCBvZiBgZm9ybWFscygpYC4KCmBgYHtyLCBtZXNzYWdlID0gRkFMU0V9CmxpYnJhcnkocHVycnIpCgpuX2FyZ3MgPC0gZnVucyAlPiUKICBtYXAoZm9ybWFscykgJT4lCiAgbWFwX2ludChsZW5ndGgpCmBgYAoKVGhlbiB3ZSBzb3J0IGBuX2FyZ3NgIGluIGRlY3JlYXNpbmcgb3JkZXIgYW5kIGxvb2sgYXQgaXRzIGZpcnN0IGVudHJpZXMuCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQpuX2FyZ3MgJT4lCiAgc29ydChkZWNyZWFzaW5nID0gVFJVRSkgJT4lCiAgaGVhZCgpCiM+IHNjYW4gZm9ybWF0LmRlZmF1bHQgc291cmNlCiM+IDIyIDE2IDE2CiM+IGZvcm1hdEMgbGlicmFyeSBtZXJnZS5kYXRhLmZyYW1lCiM+IDE1IDEzIDEzCmBgYAoKYi4gV2UgY2FuIGZ1cnRoZXIgdXNlIGBuX2FyZ3NgIHRvIGZpbmQgdGhlIG51bWJlciBvZiBmdW5jdGlvbnMgd2l0aCBubyBhcmd1bWVudHM6CgpgYGB7cn0Kc3VtKG5fYXJncyA9PSAwKQpgYGAKCkhvd2V2ZXIsIHRoaXMgb3ZlciBjb3VudHMgYmVjYXVzZSBgZm9ybWFscygpYCByZXR1cm5zIGBOVUxMYCBmb3IgcHJpbWl0aXZlIGZ1bmN0aW9ucywgYW5kIGBsZW5ndGgoTlVMTClgIGlzIDAuIFRvIGZpeCB0aGlzLCB3ZSBjYW4gZmlyc3QgcmVtb3ZlIHRoZSBwcmltaXRpdmUgZnVuY3Rpb25zOgoKYGBge3J9Cm5fYXJnczIgPC0gZnVucyAlPiUKICBkaXNjYXJkKGlzLnByaW1pdGl2ZSkgJT4lCiAgbWFwKGZvcm1hbHMpICU+JQogIG1hcF9pbnQobGVuZ3RoKQoKc3VtKG5fYXJnczIgPT0gMCkKYGBgCgpJbmRlZWQsIG1vc3Qgb2YgdGhlIGZ1bmN0aW9ucyB3aXRoIG5vIGFyZ3VtZW50cyBhcmUgYWN0dWFsbHkgcHJpbWl0aXZlIGZ1bmN0aW9ucy4KCmMuIFRvIGZpbmQgYWxsIHByaW1pdGl2ZSBmdW5jdGlvbnMsIHdlIGNhbiBjaGFuZ2UgdGhlIHByZWRpY2F0ZSBpbiBgRmlsdGVyKClgIGZyb20gYGlzLmZ1bmN0aW9uKClgIHRvIGBpcy5wcmltaXRpdmUoKWA6CgpgYGB7cn0KZnVucyA8LSBGaWx0ZXIoaXMucHJpbWl0aXZlLCBvYmpzKQpsZW5ndGgoZnVucykKYGBgCgotLS0KCjYuIFdoYXQgYXJlIHRoZSB0aHJlZSBpbXBvcnRhbnQgY29tcG9uZW50cyBvZiBhIGZ1bmN0aW9uPwoKQW5zd2VyOiB0aGUgYGZvcm1hbHMoKWAsIGBib2R5KClgIGFuZCBgZW52aXJvbm1lbnQoKWAuCgpBUiBTb2x1dGlvbnM6IFRoZXNlIGNvbXBvbmVudHMgYXJlIHRoZSBmdW5jdGlvbidzIGBib2R5KClgLCBgZm9ybWFscygpYCBhbmQgYGVudmlyb25tZW50KClgLiBIb3dldmVyLCBhcyBtZW50aW9uZWQgaW4gKkFkdmFuY2VkIFIqOgoKPiBUaGVyZSBpcyBvbmUgZXhjZXB0aW9uIHRvIHRoZSBydWxlIHRoYXQgZnVuY3Rpb25zIGhhdmUgdGhyZWUgY29tcG9uZW50cy4gUHJpbWl0aXZlIGZ1bmN0aW9ucywgbGlrZSBgc3VtKClgLCBjYWxsIEMgY29kZSBkaXJlY3RseSB3aXRoIGAuUHJpbWl0aXZlKClgIGFuZCBjb250YWluIG5vIFIgY29kZS4gVGhlcmVmb3JlLCB0aGVpciBgZm9ybWFscygpYCwgYGJvZHkoKWAsIGFuZCBgZW52aXJvbm1lbnQoKWAgYXJlIGFsbCBgTlVMTGAuCgotLS0KCjcuIFdoZW4gZG9lcyBwcmludGluZyBhIGZ1bmN0aW9uIG5vdCBzaG93IHRoZSBlbnZpcm9ubWVudCBpdCB3YXMgY3JlYXRlZCBpbj8KCkFuc3dlcjogd2hlbiBpdCBpcyBjcmVhdGVkIGluIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQuCgpBUiBTb2x1dGlvbnM6IFByaW1pdGl2ZSBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9ucyBjcmVhdGVkIGluIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQgZG8gbm90IHByaW50IHRoZWlyIGVudmlyb25tZW50LgoKLS0tCgojIyA2LjQuNSBFeGVyY2lzZXMKCjEuIFdoYXQgZG9lcyB0aGUgZm9sbG93aW5nIGNvZGUgcmV0dXJuPyBXaHk/IERlc2NyaWJlIGhvdyBlYWNoIG9mIHRoZSB0aHJlZQogICBgY2AncyBpcyBpbnRlcnByZXRlZC4KCmBgYHtyfQpjIDwtIDEwCmMoYyA9IGMpCmBgYAoKQW5zd2VyOiBhIG5hbWVkIHZlY3RvciwgYGMgMTBgLiBUaGUgZmlyc3QgYW5kIGZpbmFsIGMgaXMgYSB2YXJpYWJsZS4gVGhlIHNlY29uZCBjIGlzIGEgZnVuY3Rpb24gbmFtZS4gdGhlIHRoaXJkIGMgaXMgYSBuYW1lLgoKQVIgU29sdXRpb25zOiBUaGlzIGNvZGUgcmV0dXJucyBhIG5hbWVkIG51bWVyaWMgdmVjdG9yIG9mIGxlbmd0aCBvbmUg4oCUIHdpdGggb25lIGVsZW1lbnQgb2YgdGhlIHZhbHVlIGAxMGAgYW5kIHRoZSBuYW1lIGAiYyJgLiBUaGUgZmlyc3QgYGNgIHJlcHJlc2VudHMgdGhlIGBjKClgIGZ1bmN0aW9uLCB0aGUgc2Vjb25kIGBjYCBpcyBpbnRlcnByZXRlZCBhcyBhIChxdW90ZWQpIG5hbWUgYW5kIHRoZSB0aGlyZCBgY2AgYXMgYSB2YWx1ZS4KCi0tLQoKMi4gV2hhdCBhcmUgdGhlIGZvdXIgcHJpbmNpcGxlcyB0aGF0IGdvdmVybiBob3cgUiBsb29rcyBmb3IgdmFsdWVzPwoKQW5zd2VyOiBuYW1lIG1hc2tpbmcsIGZ1bmN0aW9ucyB2ZXJzdXMgdmFyaWFibGVzLCBhIGZyZXNoIHN0YXJ0LCBkeW5hbWljIGxvb2t1cC4KCkFSIFNvbHV0aW9uczogUidzIFtsZXhpY2FsIHNjb3BpbmddKGh0dHBzOi8vYWR2LXIuaGFkbGV5Lm56L2Z1bmN0aW9ucy5odG1sI2xleGljYWwtc2NvcGluZykgcnVsZXMgYXJlIGJhc2VkIG9uIHRoZXNlIGZvdXIgcHJpbmNpcGxlczoKLSBbTmFtZSBtYXNraW5nXShodHRwczovL2Fkdi1yLmhhZGxleS5uei9mdW5jdGlvbnMuaHRtbCNuYW1lLW1hc2tpbmcpCi0gW0Z1bmN0aW9ucyB2cy4gdmFyaWFibGVzXShodHRwczovL2Fkdi1yLmhhZGxleS5uei9mdW5jdGlvbnMuaHRtbCNmdW5jdGlvbnMtdmVyc3VzLXZhcmlhYmxlcykKLSBbQSBmcmVzaCBzdGFydF0oaHR0cHM6Ly9hZHYtci5oYWRsZXkubnovZnVuY3Rpb25zLmh0bWwjZnJlc2gtc3RhcnQpCi0gW0R5bmFtaWMgbG9va3VwXShodHRwczovL2Fkdi1yLmhhZGxleS5uei9mdW5jdGlvbnMuaHRtbCNkeW5hbWljLWxvb2t1cCkKCi0tLQoKMy4gV2hhdCBkb2VzIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gcmV0dXJuPyBNYWtlIGEgcHJlZGljdGlvbiBiZWZvcmUgCiAgIHJ1bm5pbmcgdGhlIGNvZGUgeW91cnNlbGYuCgpgYGB7cn0KZiA8LSBmdW5jdGlvbih4KSB7CiAgZiA8LSBmdW5jdGlvbih4KSB7ICMgcmV0dXJuIHZhbHVlIG9mIHRoaXMgaXMgMTAxCiAgICBmIDwtIGZ1bmN0aW9uKCkgewogICAgICB4XjIKICAgIH0KICAgIGYoKSArIDEKICB9CiAgZih4KSAqIDIKfQpmKDEwKQpgYGAKCkFuc3dlcjogMjAyLiBDb3JyZWN0IQoKQVIgU29sdXRpb25zOiBXaXRoaW4gdGhpcyBuZXN0ZWQgZnVuY3Rpb24gdHdvIG1vcmUgZnVuY3Rpb25zIGFsc28gbmFtZWQgYGZgIGFyZSBkZWZpbmVkIGFuZCBjYWxsZWQuIEJlY2F1c2UgdGhlIGZ1bmN0aW9ucyBhcmUgZWFjaCBleGVjdXRlZCBpbiB0aGVpciBvd24gZW52aXJvbm1lbnQgUiB3aWxsIGxvb2sgdXAgYW5kIHVzZSB0aGUgZnVuY3Rpb25zIGRlZmluZWQgbGFzdCBpbiB0aGVzZSBlbnZpcm9ubWVudHMuIFRoZSBpbm5lcm1vc3QgYGYoKWAgaXMgY2FsbGVkIGxhc3QsIHRob3VnaCBpdCBpcyB0aGUgZmlyc3QgZnVuY3Rpb24gdG8gcmV0dXJuIGEgdmFsdWUuIFRoZXJlZm9yZSwgdGhlIG9yZGVyIG9mIHRoZSBjYWxjdWxhdGlvbiBwYXNzZXMgImZyb20gdGhlIGluc2lkZSB0byB0aGUgb3V0c2lkZSIgYW5kIHRoZSBmdW5jdGlvbiByZXR1cm5zIGAoKDEwIF4gMikgKyAxKSAqIDJgLCBpLmUuIDIwMi4KCi0tLQoKIyMgNi41LjQgRXhlcmNpc2VzCgoxLiAgV2hhdCBpbXBvcnRhbnQgcHJvcGVydHkgb2YgYCYmYCBtYWtlcyBgeF9vaygpYCB3b3JrPwoKYGBge3J9Cnhfb2sgPC0gZnVuY3Rpb24oeCkgewogICFpcy5udWxsKHgpICYmIGxlbmd0aCh4KSA9PSAxICYmIHggPiAwCn0KCnhfb2soTlVMTCkKeF9vaygxKQp4X29rKDE6MykKYGBgCgpBbnN3ZXI6IEZyb20gdGhlIGAmJmAgZG9jcywgIlRoZSBsb25nZXIgZm9ybXMgZXZhbHVhdGVzIGxlZnQgdG8gcmlnaHQsIHByb2NlZWRpbmcgb25seSB1bnRpbCB0aGUgcmVzdWx0IGlzIGRldGVybWluZWQuIgoKV2hhdCBpcyBkaWZmZXJlbnQgd2l0aCB0aGlzIGNvZGU/IFdoeSBpcyB0aGlzIGJlaGF2aW91ciB1bmRlc2lyYWJsZSBoZXJlPwoKYGBge3J9Cnhfb2sgPC0gZnVuY3Rpb24oeCkgewogICFpcy5udWxsKHgpICYgbGVuZ3RoKHgpID09IDEgJiB4ID4gMAp9Cgp4X29rKE5VTEwpCnhfb2soMSkKeF9vaygxOjMpCmBgYAoKQW5zd2VyOiAiVGhlIHNob3J0ZXIgZm9ybXMgcGVyZm9ybXMgZWxlbWVudHdpc2UgY29tcGFyaXNvbnMgaW4gbXVjaCB0aGUgc2FtZSB3YXkgYXMgYXJpdGhtZXRpYyBvcGVyYXRvcnMuIiBUaGlzIGlzIHVuZGVzaXJhYmxlIGJlY2F1c2UgdGhlIGludGVudCBvZiB0aGUgZnVuY3Rpb24gaXMgdG8gcmV0dXJuIGBUUlVFYCBvciBgRkFMU0VgLgoKQVIgU29sdXRpb25zOiBJbiBzdW1tYXJ5OiBgJiZgIHNob3J0LWNpcmN1aXRzIHdoaWNoIG1lYW5zIHRoYXQgaWYgdGhlIGxlZnQtaGFuZCBzaWRlIGlzIGBGQUxTRWAgaXQgZG9lc24ndCBldmFsdWF0ZSB0aGUgcmlnaHQtaGFuZCBzaWRlIChiZWNhdXNlIGl0IGRvZXNuJ3QgbWF0dGVyKS4gU2ltaWxhcmx5LCBpZiB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgYHx8YCBpcyBgVFJVRWAgaXQgZG9lc24ndCBldmFsdWF0ZSB0aGUgcmlnaHQtaGFuZCBzaWRlLgoKV2UgZXhwZWN0IGB4X29rKClgIHRvIHZhbGlkYXRlIGl0cyBpbnB1dCB2aWEgY2VydGFpbiBjcml0ZXJpYTogaXQgbXVzdCBub3QgYmUgYE5VTExgLCBoYXZlIGxlbmd0aCBgMWAgYW5kIGJlIGdyZWF0ZXIgdGhhbiBgMGAuIE1lYW5pbmdmdWwgb3V0Y29tZXMgZm9yIHRoaXMgYXNzZXJ0aW9uIHdpbGwgYmUgYFRSVUVgLCBgRkFMU0VgIG9yIGBOQWAuIFRoZSBkZXNpcmVkIGJlaGF2aW91ciBpcyByZWFjaGVkIGJ5IGNvbWJpbmluZyB0aGUgYXNzZXJ0aW9ucyB0aHJvdWdoIGAmJmAgaW5zdGVhZCBvZiBgJmAuCgpgJiZgIGRvZXMgbm90IHBlcmZvcm0gZWxlbWVudHdpc2UgY29tcGFyaXNvbnM7IGluc3RlYWQgaXQgdXNlcyB0aGUgZmlyc3QgZWxlbWVudCBvZiBlYWNoIHZhbHVlIG9ubHkuIEl0IGFsc28gdXNlcyBsYXp5IGV2YWx1YXRpb24sIGluIHRoZSBzZW5zZSB0aGF0IGV2YWx1YXRpb24gInByb2NlZWRzIG9ubHkgdW50aWwgdGhlIHJlc3VsdCBpcyBkZXRlcm1pbmVkIiAoZnJvbSBgP0xvZ2ljYCkuIFRoaXMgbWVhbnMgdGhhdCB0aGUgUkhTIG9mIGAmJmAgd29uJ3QgYmUgZXZhbHVhdGVkIGlmIHRoZSBMSFMgYWxyZWFkeSBkZXRlcm1pbmVzIHRoZSBvdXRjb21lIG9mIHRoZSBjb21wYXJpc29uIChlLmcuIGV2YWx1YXRlIHRvIGBGQUxTRWApLiBUaGlzIGJlaGF2aW91ciBpcyBhbHNvIGtub3duIGFzICJzaG9ydC1jaXJjdWl0aW5nIi4gRm9yIHNvbWUgc2l0dWF0aW9ucyAoYHggPSAxYCkgYm90aCBvcGVyYXRvcnMgd2lsbCBsZWFkIHRvIHRoZSBzYW1lIHJlc3VsdC4gQnV0IHRoaXMgaXMgbm90IGFsd2F5cyB0aGUgY2FzZS4gRm9yIGB4ID0gTlVMTGAsIHRoZSBgJiZgLW9wZXJhdG9yIHdpbGwgc3RvcCBhZnRlciB0aGUgYCFpcy5udWxsYCBzdGF0ZW1lbnQgYW5kIHJldHVybiB0aGUgcmVzdWx0LiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgd29uJ3QgZXZlbiBiZSBldmFsdWF0ZWQhIChJZiB0aGUgb3RoZXIgY29uZGl0aW9ucyBhcmUgYWxzbyBldmFsdWF0ZWQgKGJ5IHRoZSB1c2Ugb2YgYCZgKSwgdGhlIG91dGNvbWUgd291bGQgY2hhbmdlLiBgTlVMTCA+IDBgIHJldHVybnMgYGxvZ2ljYWwoMClgLCB3aGljaCBpcyBub3QgaGVscGZ1bCBpbiB0aGlzIGNhc2UuKQoKV2UgY2FuIGFsc28gc2VlIHRoZSBkaWZmZXJlbmNlIGluIGJlaGF2aW91ciwgd2hlbiB3ZSBzZXQgYHggPSAxOjNgLiBUaGUgYCYmYC1vcGVyYXRvciByZXR1cm5zIHRoZSByZXN1bHQgZnJvbSBgbGVuZ3RoKHgpID09IDFgLCB3aGljaCBpcyBgRkFMU0VgLiBVc2luZyBgJmAgYXMgdGhlIGxvZ2ljYWwgb3BlcmF0b3IgbGVhZHMgdG8gdGhlICh2ZWN0b3Jpc2VkKSBgeCA+IDBgIGNvbmRpdGlvbiBiZWluZyBldmFsdWF0ZWQgYW5kIGFsc28gcmV0dXJuZWQuCgotLS0KCjIuICBXaGF0IGRvZXMgdGhpcyBmdW5jdGlvbiByZXR1cm4/IFdoeT8gV2hpY2ggcHJpbmNpcGxlIGRvZXMgaXQgaWxsdXN0cmF0ZT8KCmBgYHtyfQpmMiA8LSBmdW5jdGlvbih4ID0geikgewogIHogPC0gMTAwCiAgeAp9CmYyKCkKYGBgCgpBbnN3ZXI6IDEwMCwgbGF6eSBldmFsdWF0aW9uLiBgeCA9IHpgIGlzbid0IGV2YWx1YXRlZCB1bnRpbCBgeGAuCgpBUiBTb2x1dGlvbnM6IFRoZSBmdW5jdGlvbiByZXR1cm5zIDEwMC4gVGhlIGRlZmF1bHQgYXJndW1lbnQgKGB4ID0gemApIGdldHMgbGF6aWx5IGV2YWx1YXRlZCB3aXRoaW4gdGhlIGZ1bmN0aW9uIGVudmlyb25tZW50IHdoZW4gYHhgIGdldHMgYWNjZXNzZWQuIEF0IHRoaXMgdGltZSBgemAgaGFzIGFscmVhZHkgYmVlbiBib3VuZCB0byB0aGUgdmFsdWUgYDEwMGAuIFRoZSBpbGx1c3RyYXRlZCBwcmluY2lwbGUgaGVyZSBpcyAqbGF6eSBldmFsdWF0aW9uKi4KCi0tLQoKMy4gIFdoYXQgZG9lcyB0aGlzIGZ1bmN0aW9uIHJldHVybj8gV2h5PyBXaGljaCBwcmluY2lwbGUgZG9lcyBpdCBpbGx1c3RyYXRlPwoKYGBge3J9CnkgPC0gMTAKIyBzdHlsZXI6IG9mZgpmMSA8LSBmdW5jdGlvbih4ID0ge3kgPC0gMTsgMn0sIHkgPSAwKSB7ICMgbm9saW50IGJyYWNlX2xpbnRlciwgc2VtaWNvbG9uX2xpbnRlci4KICAjIHN0eWxlcjogb24KICBjKHgsIHkpCn0KZjEoKQp5CmBgYAoKQW5zd2VyOiBgYygyLCAxKWAuIGRlZmF1bHQgYXJndW1lbnRzLgoKQVIgU29sdXRpb25zOiBUaGUgZnVuY3Rpb24gcmV0dXJucyBgYygyLCAxKWAgd2hpY2ggaXMgZHVlIHRvICpuYW1lIG1hc2tpbmcqLiBXaGVuIGB4YCBpcyBhY2Nlc3NlZCB3aXRoaW4gYGMoKWAsIHRoZSBwcm9taXNlIGB4ID0ge3kgPC0gMTsgMn1gIGlzIGV2YWx1YXRlZCBpbnNpZGUgYGYxKClgJ3MgZW52aXJvbm1lbnQuIGB5YCBnZXRzIGJvdW5kIHRvIHRoZSB2YWx1ZSBgMWAgYW5kIHRoZSByZXR1cm4gdmFsdWUgb2YgYHsoKWAgKGAyYCkgZ2V0cyBhc3NpZ25lZCB0byBgeGAuIFdoZW4gYHlgIGdldHMgYWNjZXNzZWQgbmV4dCB3aXRoaW4gYGMoKWAsIGl0IGhhcyBhbHJlYWR5IHRoZSB2YWx1ZSBgMWAgYW5kIFIgZG9lc24ndCBuZWVkIHRvIGxvb2sgaXQgdXAgYW55IGZ1cnRoZXIuIFRoZXJlZm9yZSwgdGhlIHByb21pc2UgYHkgPSAwYCB3b24ndCBiZSBldmFsdWF0ZWQuIEFsc28sIGFzIGB5YCBpcyBhc3NpZ25lZCB3aXRoaW4gYGYxKClgJ3MgZW52aXJvbm1lbnQsIHRoZSB2YWx1ZSBvZiB0aGUgZ2xvYmFsIHZhcmlhYmxlIGB5YCBpcyBsZWZ0IHVudG91Y2hlZC4KCi0tLQoKNC4gIEluIGBoaXN0KClgLCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgeGxpbWAgaXMgYHJhbmdlKGJyZWFrcylgLCB0aGUgZGVmYXVsdCAKICAgIHZhbHVlIGZvciBgYnJlYWtzYCBpcyBgIlN0dXJnZXMiYCwgYW5kCgpgYGB7cn0KcmFuZ2UoIlN0dXJnZXMiKQpgYGAKCkV4cGxhaW4gaG93IGBoaXN0KClgIHdvcmtzIHRvIGdldCBhIGNvcnJlY3QgYHhsaW1gIHZhbHVlLgoKQW5zd2VyOiBmcm9tIHRoZSBkb2NzLCAiTm90ZSB0aGF0IGB4bGltYCBpcyAqbm90KiB1c2VkIHRvIGRlZmluZSB0aGUgaGlzdG9ncmFtIChicmVha3MpLCBidXQgb25seSBmb3IgcGxvdHRpbmcgKHdoZW4gYHBsb3QgPSBUUlVFYCkuIiBTbywgdGhlIGJyZWFrcG9pbnRzIGFyZSBjYWxjdWxhdGVkIHdoZW4gdGhlIG9iamVjdCBpcyBjcmVhdGVkLCBhbmQgYHhsaW1gIGlzIGNhbGN1bGF0ZWQgd2hlbiB0aGUgaGlzdG9ncmFtIGlzIHBsb3R0ZWQsIGluIHRoZSBzZWNvbmQgc3RlcC4KCkFSIFNvbHV0aW9uczogVGhlIGB4bGltYCBhcmd1bWVudCBvZiBgaGlzdCgpYCBkZWZpbmVzIHRoZSByYW5nZSBvZiB0aGUgaGlzdG9ncmFtJ3MgeC1heGlzLiBJbiBvcmRlciB0byBwcm92aWRlIGEgdmFsaWQgYXhpcyBgeGxpbWAgbXVzdCBjb250YWluIGEgbnVtZXJpYyB2ZWN0b3Igb2YgZXhhY3RseSB0d28gdW5pcXVlIHZhbHVlcy4gQ29uc2VxdWVudGx5LCBmb3IgdGhlIGRlZmF1bHQgYHhsaW0gPSByYW5nZShicmVha3MpYCksIGBicmVha3NgIG11c3QgZXZhbHVhdGUgdG8gYSB2ZWN0b3Igd2l0aCBhdCBsZWFzdCB0d28gdW5pcXVlIHZhbHVlcy4KCkR1cmluZyBleGVjdXRpb24gYGhpc3QoKWAgb3ZlcndyaXRlcyB0aGUgYGJyZWFrc2AgYXJndW1lbnQuIFRoZSBgYnJlYWtzYCBhcmd1bWVudCBpcyBxdWl0ZSBmbGV4aWJsZSBhbmQgYWxsb3dzIHRoZSB1c2VycyB0byBwcm92aWRlIHRoZSBicmVha3BvaW50cyBkaXJlY3RseSBvciBjb21wdXRlIHRoZW0gaW4gc2V2ZXJhbCB3YXlzLiBUaGVyZWZvcmUsIHRoZSBzcGVjaWZpYyBiZWhhdmlvdXIgZGVwZW5kcyBoaWdobHkgb24gdGhlIGlucHV0LiBCdXQgYGhpc3RgIGVuc3VyZXMgdGhhdCBgYnJlYWtzYCBldmFsdWF0ZXMgdG8gYSBudW1lcmljIHZlY3RvciBjb250YWluaW5nIGF0IGxlYXN0IHR3byB1bmlxdWUgZWxlbWVudHMgYmVmb3JlIGB4bGltYCBpcyBjb21wdXRlZC4KCi0tLQogICAgCjUuICBFeHBsYWluIHdoeSB0aGlzIGZ1bmN0aW9uIHdvcmtzLiBXaHkgaXMgaXQgY29uZnVzaW5nPwoKYGBge3J9CnNob3dfdGltZSA8LSBmdW5jdGlvbih4ID0gc3RvcCgiRXJyb3IhIikpIHsKICBzdG9wIDwtIGZ1bmN0aW9uKC4uLikgU3lzLnRpbWUoKQogIHByaW50KHgpCn0Kc2hvd190aW1lKCkKYGBgCgpBbnN3ZXI6IGBzdG9wYCBpcyByZWRlZmluZWQgYmVmb3JlIGB4YCBpcyBldmFsdWF0ZWQuIFRoaXMgaXMgYSBjb25mdXNpbmcgdXNlIG9mIGxhenkgZXZhbHVhdGlvbi4KCkFSIFNvbHV0aW9uczogQmVmb3JlIGBzaG93X3RpbWUoKWAgYWNjZXNzZXMgYHhgIChkZWZhdWx0IGBzdG9wKCJFcnJvciIpYCksIHRoZSBgc3RvcCgpYCBmdW5jdGlvbiBpcyBtYXNrZWQgYnkgYGZ1bmN0aW9uKC4uLikgU3lzLnRpbWUoKWAuIEFzIGRlZmF1bHQgYXJndW1lbnRzIGFyZSBldmFsdWF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGVudmlyb25tZW50LCBgcHJpbnQoeClgIHdpbGwgYmUgZXZhbHVhdGVkIGFzIGBwcmludChTeXMudGltZSgpKWAuCgpUaGlzIGZ1bmN0aW9uIGlzIGNvbmZ1c2luZyBiZWNhdXNlIGl0cyBiZWhhdmlvdXIgY2hhbmdlcyB3aGVuIGB4YCdzIHZhbHVlIGlzIHN1cHBsaWVkIGRpcmVjdGx5LiBOb3cgdGhlIHZhbHVlIGZyb20gdGhlIGNhbGxpbmcgZW52aXJvbm1lbnQgd2lsbCBiZSB1c2VkIGFuZCB0aGUgb3ZlcndyaXRpbmcgb2YgYHN0b3AoKWAgd29uJ3QgYWZmZWN0IGB4YCBhbnltb3JlLgoKLS0tCgo2LiAgSG93IG1hbnkgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB3aGVuIGNhbGxpbmcgYGxpYnJhcnkoKWA/CgpBbnN3ZXI6IHplcm8uIGBsaWJyYXJ5KClgIHVzZXMgYG1pc3NpbmcoKWAgdG8gcmV0dXJuIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBwYWNrYWdlcyBpZiB0aGVyZSBhcmUgbm8gYXJndW1lbnRzLgoKQVIgU29sdXRpb25zOiBgbGlicmFyeSgpYCBkb2Vzbid0IHJlcXVpcmUgYW55IGFyZ3VtZW50cy4gV2hlbiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMgYGxpYnJhcnkoKWAgaW52aXNpYmx5IHJldHVybnMgYSBsaXN0IG9mIGNsYXNzIGBsaWJyYXJ5SVFSYCwgd2hpY2ggY29udGFpbnMgYSByZXN1bHRzIG1hdHJpeCB3aXRoIG9uZSByb3cgYW5kIHRocmVlIGNvbHVtbnMgcGVyIGluc3RhbGxlZCBwYWNrYWdlLiBUaGVzZSBjb2x1bW5zIGNvbnRhaW4gZW50cmllcyBmb3IgdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgKCJQYWNrYWdlIiksIHRoZSBwYXRoIHRvIHRoZSBwYWNrYWdlICgiTGliUGF0aCIpIGFuZCB0aGUgdGl0bGUgb2YgdGhlIHBhY2thZ2UgKCJUaXRsZSIpLiBgbGlicmFyeSgpYCBhbHNvIGhhcyBpdHMgb3duIHByaW50IG1ldGhvZCAoYHByaW50LmxpYnJhcnlJUVIoKWApLCB3aGljaCBkaXNwbGF5cyB0aGlzIGluZm9ybWF0aW9uIGNvbnZlbmllbnRseSBpbiBpdHMgb3duIHdpbmRvdy4KClRoaXMgYmVoYXZpb3VyIGlzIGFsc28gZG9jdW1lbnRlZCB1bmRlciB0aGUgZGV0YWlscyBzZWN0aW9uIG9mIGBsaWJyYXJ5KClgJ3MgaGVscCBwYWdlIChgP2xpYnJhcnlgKToKCj4gSWYgbGlicmFyeSBpcyBjYWxsZWQgd2l0aCBubyBwYWNrYWdlIG9yIGhlbHAgYXJndW1lbnQsIGl0IGxpc3RzIGFsbCBhdmFpbGFibGUgcGFja2FnZXMgaW4gdGhlIGxpYnJhcmllcyBzcGVjaWZpZWQgYnkgbGliLmxvYywgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgaW5mb3JtYXRpb24gaW4gYW4gb2JqZWN0IG9mIGNsYXNzIOKAnGxpYnJhcnlJUVLigJ0uIChUaGUgc3RydWN0dXJlIG9mIHRoaXMgY2xhc3MgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuKSBVc2UgLnBhY2thZ2VzKGFsbCA9IFRSVUUpIHRvIG9idGFpbiBqdXN0IHRoZSBuYW1lcyBvZiBhbGwgYXZhaWxhYmxlIHBhY2thZ2VzLCBhbmQgaW5zdGFsbGVkLnBhY2thZ2VzKCkgZm9yIGV2ZW4gbW9yZSBpbmZvcm1hdGlvbi4KCkJlY2F1c2UgdGhlIGBwYWNrYWdlYCBhbmQgYGhlbHBgIGFyZ3VtZW50IGZyb20gYGxpYnJhcnkoKWAgZG8gbm90IHNob3cgYSBkZWZhdWx0IHZhbHVlLCBpdCdzIGVhc3kgdG8gb3Zlcmxvb2sgdGhlIHBvc3NpYmlsaXR5IHRvIGNhbGwgYGxpYnJhcnkoKWAgd2l0aG91dCB0aGVzZSBhcmd1bWVudHMuIChJbnN0ZWFkIG9mIHByb3ZpZGluZyBgTlVMTGBzIGFzIGRlZmF1bHQgdmFsdWVzIGBsaWJyYXJ5KClgIHVzZXMgYG1pc3NpbmcoKWAgdG8gY2hlY2sgaWYgdGhlc2UgYXJndW1lbnRzIHdlcmUgcHJvdmlkZWQuKQoKLS0tCgojIyA2LjYuMSBFeGVyY2lzZXMKCjEuICBFeHBsYWluIHRoZSBmb2xsb3dpbmcgcmVzdWx0czoKCmBgYHtyfQpzdW0oMSwgMiwgMykKbWVhbigxLCAyLCAzKQoKc3VtKDEsIDIsIDMsIG5hLm9taXQgPSBUUlVFKQptZWFuKDEsIDIsIDMsIG5hLm9taXQgPSBUUlVFKQpgYGAKCkFuc3dlcjoKCi0gImBzdW0oKWAgcmV0dXJucyB0aGUgc3VtIG9mIGFsbCB0aGUgdmFsdWVzIHByZXNlbnQgaW4gaXRzIGFyZ3VtZW50cy4iIFRoZSBmaXJzdCBleGFtcGxlIGlzCiAgc3RyYWlnaHRmb3J3YXJkLiBJbiB0aGUgc2Vjb25kIHN1bSBleGFtcGxlLCBgbmEub21pdGAgaXNuJ3QgYSB2YWxpZCBhcmd1bWVudCAoYG5hLnJtYCBpcyksIHNvIHRoZQogIGBUUlVFYCB2YWx1ZSBpcyBwYXNzZWQgdG8gYC4uLmAsIGNvZXJjZWQgdG8gMSwgYW5kIGluY2x1ZGVkIGluIHRoZSBzdW0uCi0gYG1lYW4oKWAgdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLCBhbmQgcGFzc2VzIG9uIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gYC4uLmAuIEluIGJvdGggY2FzZXMsIHRoZQogIGFyZ3VtZW50cyBhZnRlciB0aGUgYDFgIGFyZSBzaWxlbnRseSBkcm9wcGVkLiBUaGUgY29ycmVjdCBmb3JtIHdvdWxkIGJlIGBtZWFuKGMoMSwgMiwgMykpYC4KCkFSIFNvbHV0aW9uczogTGV0J3MgaW5zcGVjdCB0aGUgYXJndW1lbnRzIGFuZCB0aGVpciBvcmRlciBmb3IgYm90aCBmdW5jdGlvbnMuIEZvciBgc3VtKClgIHRoZXNlIGFyZSBgLi4uYCBhbmQgYG5hLnJtYDoKCmBgYHtyfQpzdHIoc3VtKQpgYGAKRm9yIHRoZSBgLi4uYCBhcmd1bWVudCBgc3VtKClgIGV4cGVjdHMgbnVtZXJpYywgY29tcGxleCwgb3IgbG9naWNhbCB2ZWN0b3IgaW5wdXQgKHNlZSBgP3N1bWApLiBVbmZvcnR1bmF0ZWx5LCB3aGVuIGAuLi5gIGlzIHVzZWQsIG1pc3NwZWxsZWQgYXJndW1lbnRzICghKSBsaWtlIGBuYS5vbWl0YCB3b24ndCByYWlzZSBhbiBlcnJvciAoaW4gY2FzZSBvZiBubyBmdXJ0aGVyIGlucHV0IGNoZWNrcykuIFNvIGluc3RlYWQsIGBuYS5vbWl0YCBpcyB0cmVhdGVkIGFzIGEgbG9naWNhbCBhbmQgYmVjb21lcyBwYXJ0IG9mIHRoZSBgLi4uYCBhcmd1bWVudC4gSXQgd2lsbCBiZSBjb2VyY2VkIHRvIGAxYCBhbmQgYmUgcGFydCBvZiB0aGUgc3VtLiBBbGwgb3RoZXIgYXJndW1lbnRzIGFyZSBsZWZ0IHVuY2hhbmdlZC4gVGhlcmVmb3JlIGBzdW0oMSwgMiwgMylgIHJldHVybnMgYDZgIGFuZCBgc3VtKDEsIDIsIDMsIG5hLm9taXQgPSBUUlVFKWAgcmV0dXJucyBgN2AuCgpJbiBjb250cmFzdCwgdGhlIGdlbmVyaWMgZnVuY3Rpb24gYG1lYW4oKWAgZXhwZWN0cyBgeGAsIGB0cmltYCwgYG5hLnJtYCBhbmQgYC4uLmAgZm9yIGl0cyBkZWZhdWx0IG1ldGhvZC4KCmBgYHtyfQpzdHIobWVhbi5kZWZhdWx0KQpgYGAKCkFzIGBuYS5vbWl0YCBpcyBub3Qgb25lIG9mIGBtZWFuKClgJ3MgbmFtZWQgYXJndW1lbnRzIChgeGA7IGFuZCBubyBjYW5kaWRhdGUgZm9yIHBhcnRpYWwgbWF0Y2hpbmcpLCBgbmEub21pdGAgYWdhaW4gYmVjb21lcyBwYXJ0IG9mIHRoZSBgLi4uYCBhcmd1bWVudC4gSG93ZXZlciwgaW4gY29udHJhc3QgdG8gYHN1bSgpYCB0aGUgZWxlbWVudHMgb2YgYC4uLmAgYXJlIG5vdCAicGFydCIgb2YgdGhlIG1lYW4uIFRoZSBvdGhlciBzdXBwbGllZCBhcmd1bWVudHMgYXJlIG1hdGNoZWQgYnkgdGhlaXIgb3JkZXIsIGkuZS4gYHggPSAxYCwgYHRyaW0gPSAyYCBhbmQgYG5hLnJtID0gM2AuIEFzIGB4YCBpcyBvZiBsZW5ndGggMSBhbmQgbm90IGBOQWAsIHRoZSBzZXR0aW5ncyBvZiBgdHJpbWAgYW5kIGBuYS5ybWAgZG8gbm90IGFmZmVjdCB0aGUgY2FsY3VsYXRpb24gb2YgdGhlIG1lYW4uIEJvdGggY2FsbHMgKGBtZWFuKDEsIDIsIDMpYCBhbmQgYG1lYW4oMSwgMiwgMywgbmEub21pdCA9IFRSVUUpYCkgcmV0dXJuIGAxYC4KCi0tLQoKMi4gIEV4cGxhaW4gaG93IHRvIGZpbmQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBuYW1lZCBhcmd1bWVudHMgaW4gdGhlIAogICAgZm9sbG93aW5nIGZ1bmN0aW9uIGNhbGw6Cgo8IS0tIFRPRE86IGJ1Z2ZpeDogdGhlIGZpZ3VyZSBiZWxvdyByZW5kZXJzIGluY29ycmVjdGx5LAogICAgIHBvc3NpYmx5IGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vcnN0dWRpby9yc3R1ZGlvL2lzc3Vlcy80NTIxCiAgICAgc2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9oYWRsZXkvYWR2LXIvYmxvYi9tYXN0ZXIvY29tbW9uLlIKICAgICBhbmQ6IGh0dHBzOi8veWlodWkub3JnL2tuaXRyL29wdGlvbnMvI3Bsb3RzCiAgICAgd29ya2Fyb3VuZDogdXNlIHtyLCBmaWcuYXNwID0gMX0uCiAgICAge3IsIGZpZy5hc3AgPSAxLCBmaWcud2lkdGggPSAzfSBsb29rcyBjb3JyZWN0IGluIFJTdHVkaW8sIGJ1dCBkb2Vzbid0IHJlbmRlciBwcm9wZXJseSBmb3IKICAgICBidWlsZF9hbmFseXNpc19zaXRlKCkuIHtyLCBmaWcuYXNwID0gMX0gd29ya3Mgd2l0aCBidWlsZF9hbmFseXNpc19zaXRlKCkgYnV0IGlzIG5vdCBzaXplZAogICAgIHByb3Blcmx5IGluIFJTdHVkaW8uIHtyLCBmaWcuYXNwID0gMX0gaXMgdGhlIGJlc3Qgb3B0aW9uIGZvciBub3cuCiAgLS0+CgpgYGB7ciwgc21hbGxfbWFyID0gVFJVRSwgZmlnLmFzcCA9IDF9CnBsb3QoMToxMCwgY29sID0gInJlZCIsIHBjaCA9IDIwLCB4bGFiID0gIngiLCBjb2wubGFiID0gImJsdWUiKQpgYGAKCkFuc3dlcjogaW4gb3RoZXIgZnVuY3Rpb25zLCBzcGVjaWZpY2FsbHkgYHBhcigpYCBhbmQgYHBsb3QuZGVmYXVsdCgpYC4KCkFSIFNvbHV0aW9uczogRmlyc3Qgd2UgdHlwZSBgP3Bsb3RgIGluIHRoZSBjb25zb2xlIGFuZCBjaGVjayB0aGUgIlVzYWdlIiBzZWN0aW9uIHdoaWNoIGNvbnRhaW5zOgoKYGBgcgpwbG90KHgsIHksIC4uLikKYGBgCgpUaGUgYXJndW1lbnRzIHdlIHdhbnQgdG8gbGVhcm4gbW9yZSBhYm91dCAoYGNvbGAsIGBwY2hgLCBgeGxhYmAsIGBjb2wubGFiYCkgYXJlIHBhcnQgb2YgdGhlIGAuLi5gIGFyZ3VtZW50LiBUaGVyZSB3ZSBjYW4gZmluZCBpbmZvcm1hdGlvbiBmb3IgdGhlIGB4bGFiYCBhcmd1bWVudCBhbmQgYSByZWNvbW1lbmRhdGlvbiB0byB2aXNpdCBgP3BhcmAgZm9yIHRoZSBvdGhlciBhcmd1bWVudHMuIFVuZGVyIGA/cGFyYCB3ZSB0eXBlICJjb2wiIGludG8gdGhlIHNlYXJjaCBiYXIsIHdoaWNoIGxlYWRzIHVzIHRvIHRoZSBzZWN0aW9uICJDb2xvciBTcGVjaWZpY2F0aW9uIi4gV2UgYWxzbyBzZWFyY2ggZm9yIHRoZSBgcGNoYCBhcmd1bWVudCwgd2hpY2ggbGVhZHMgdG8gdGhlIHJlY29tbWVuZGF0aW9uIHRvIGNoZWNrIGA/cG9pbnRzYC4gRmluYWxseSwgYGNvbC5sYWJgIGlzIGFsc28gZGlyZWN0bHkgZG9jdW1lbnRlZCB3aXRoaW4gYD9wYXJgLgoKLS0tCgozLiAgV2h5IGRvZXMgYHBsb3QoMToxMCwgY29sID0gInJlZCIpYCBvbmx5IGNvbG91ciB0aGUgcG9pbnRzLCBub3QgdGhlIGF4ZXMgCiAgICBvciBsYWJlbHM/IFJlYWQgdGhlIHNvdXJjZSBjb2RlIG9mIGBwbG90LmRlZmF1bHQoKWAgdG8gZmluZCBvdXQuCgpgYGByCmxvY2FsQXhpcyA8LSBmdW5jdGlvbiguLi4sIGNvbCwgYmcsIHBjaCwgY2V4LCBsdHksIGx3ZCkgQXhpcyguLi4pCmxvY2FsQm94IDwtIGZ1bmN0aW9uKC4uLiwgY29sLCBiZywgcGNoLCBjZXgsIGx0eSwgbHdkKSBib3goLi4uKQpsb2NhbFdpbmRvdyA8LSBmdW5jdGlvbiguLi4sIGNvbCwgYmcsIHBjaCwgY2V4LCBsdHksIGx3ZCkgcGxvdC53aW5kb3coLi4uKQpsb2NhbFRpdGxlIDwtIGZ1bmN0aW9uKC4uLiwgY29sLCBiZywgcGNoLCBjZXgsIGx0eSwgbHdkKSB0aXRsZSguLi4pCmBgYAoKQW5zd2VyOiBgcGxvdC5kZWZhdWx0KClgIGRpc2NhcmRzIGBjb2xgIGFuZCBzZXZlcmFsIG90aGVyIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgYEF4aXMoKWAsIGBib3goKWAsIGBwbG90LndpbmRvdygpYCwgYW5kIGB0aXRsZSgpYC4KCkFSIFNvbHV0aW9uczogVG8gbGVhcm4gYWJvdXQgdGhlIGludGVybmFscyBvZiBgcGxvdC5kZWZhdWx0KClgIHdlIGFkZCBgYnJvd3NlcigpYCB0byB0aGUgZmlyc3QgbGluZSBvZiB0aGUgY29kZSBhbmQgaW50ZXJhY3RpdmVseSBydW4gYHBsb3QoMToxMCwgY29sID0gInJlZCIpYC4gVGhpcyB3YXkgd2UgY2FuIHNlZSBob3cgdGhlIHBsb3QgaXMgYnVpbHQgYW5kIGxlYXJuIHdoZXJlIHRoZSBheGVzIGFyZSBhZGRlZC4KVGhpcyBsZWFkcyB1cyB0byB0aGUgZnVuY3Rpb24gY2FsbAoKYGBge3IsIGV2YWwgPSBGQUxTRX0KbG9jYWxUaXRsZShtYWluID0gbWFpbiwgc3ViID0gc3ViLCB4bGFiID0geGxhYiwgeWxhYiA9IHlsYWIsIC4uLikKYGBgCgpUaGUgYGxvY2FsVGl0bGUoKWAgZnVuY3Rpb24gd2FzIGRlZmluZWQgaW4gdGhlIGZpcnN0IGxpbmVzIG9mIGBwbG90LmRlZmF1bHQoKWAgYXM6CgpgYGB7ciwgZXZhbCA9IEZBTFNFfQpsb2NhbFRpdGxlIDwtIGZ1bmN0aW9uKC4uLiwgY29sLCBiZywgcGNoLCBjZXgsIGx0eSwgbHdkKSB0aXRsZSguLi4pICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCmBgYAoKVGhlIGNhbGwgdG8gYGxvY2FsVGl0bGUoKWAgcGFzc2VzIHRoZSBgY29sYCBwYXJhbWV0ZXIgYXMgcGFydCBvZiB0aGUgYC4uLmAgYXJndW1lbnQgdG8gYHRpdGxlKClgLiBgP3RpdGxlYCB0ZWxscyB1cyB0aGF0IHRoZSBgdGl0bGUoKWAgZnVuY3Rpb24gc3BlY2lmaWVzIGZvdXIgcGFydHMgb2YgdGhlIHBsb3Q6IE1haW4gKHRpdGxlIG9mIHRoZSBwbG90KSwgc3ViIChzdWItdGl0bGUgb2YgdGhlIHBsb3QpIGFuZCBib3RoIGF4aXMgbGFiZWxzLiBUaGVyZWZvcmUsIGl0IHdvdWxkIGludHJvZHVjZSBhbWJpZ3VpdHkgaW5zaWRlIGB0aXRsZSgpYCB0byB1c2UgYGNvbGAgZGlyZWN0bHkuIEluc3RlYWQsIG9uZSBoYXMgdGhlIG9wdGlvbiB0byBzdXBwbHkgYGNvbGAgdmlhIHRoZSBgLi4uYCBhcmd1bWVudCwgdmlhIGBjb2wubGFiYCBvciBhcyBwYXJ0IG9mIGB4bGFiYCBpbiB0aGUgZm9ybSBgeGxhYiA9IGxpc3QoYygiaW5kZXgiKSwgY29sID0gInJlZCIpYCAoc2ltaWxhciBmb3IgYHlsYWJgKS4KCi0tLQoKIyMgNi43LjUgRXhlcmNpc2VzCgoxLiAgV2hhdCBkb2VzIGBsb2FkKClgIHJldHVybj8gV2h5IGRvbid0IHlvdSBub3JtYWxseSBzZWUgdGhlc2UgdmFsdWVzPwoKQW5zd2VyOiBmcm9tIHRoZSBkb2NzLCBgbG9hZCgpYCByZXR1cm5zICJBIGNoYXJhY3RlciB2ZWN0b3Igb2YgdGhlIG5hbWVzIG9mIG9iamVjdHMgY3JlYXRlZCwgaW52aXNpYmx5LiIKCkFSIFNvbHV0aW9uczogYGxvYWQoKWAgbG9hZHMgb2JqZWN0cyBzYXZlZCB0byBkaXNrIGluIGAuUmRhdGFgIGZpbGVzIGJ5IGBzYXZlKClgLiBXaGVuIHJ1biBzdWNjZXNzZnVsbHksIGBsb2FkKClgIGludmlzaWJseSByZXR1cm5zIGEgY2hhcmFjdGVyIHZlY3RvciBjb250YWluaW5nIHRoZSBuYW1lcyBvZiB0aGUgbmV3bHkgbG9hZGVkIG9iamVjdHMuIFRvIHByaW50IHRoZXNlIG5hbWVzIHRvIHRoZSBjb25zb2xlLCBvbmUgY2FuIHNldCB0aGUgYXJndW1lbnQgYHZlcmJvc2VgIHRvIGBUUlVFYCBvciBzdXJyb3VuZCB0aGUgY2FsbCBpbiBwYXJlbnRoZXNlcyB0byB0cmlnZ2VyIFIncyBhdXRvLXByaW50aW5nIG1lY2hhbmlzbS4KCi0tLQoKMi4gIFdoYXQgZG9lcyBgd3JpdGUudGFibGUoKWAgcmV0dXJuPyBXaGF0IHdvdWxkIGJlIG1vcmUgdXNlZnVsPwoKQW5zd2VyOiBpdCByZXR1cm5zIGBpbnZpc2libGUoTlVMTClgLiBSZXR1cm5pbmcgdGhlIHdyaXR0ZW4gdGFibGUgb3IgdGhlIGFyZ3VtZW50IGB4YCB3b3VsZCBiZSBtb3JlIHVzZWZ1bC4KCkFSIFNvbHV0aW9uczogYHdyaXRlLnRhYmxlKClgIHdyaXRlcyBhbiBvYmplY3QsIHVzdWFsbHkgYSBkYXRhIGZyYW1lIG9yIGEgbWF0cml4LCB0byBkaXNrLiBUaGUgZnVuY3Rpb24gaW52aXNpYmx5IHJldHVybnMgYE5VTExgLiBJdCB3b3VsZCBiZSBtb3JlIHVzZWZ1bCBpZiBgd3JpdGUudGFibGUoKWAgd291bGQgKGludmlzaWJseSkgcmV0dXJuIHRoZSBpbnB1dCBkYXRhLCBgeGAuIFRoaXMgd291bGQgYWxsb3cgdG8gc2F2ZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBhbmQgZGlyZWN0bHkgdGFrZSBvbiBmdXJ0aGVyIHByb2Nlc3Npbmcgc3RlcHMgd2l0aG91dCBicmVha2luZyB0aGUgZmxvdyBvZiB0aGUgY29kZSAoaS5lLiBicmVha2luZyBpdCBpbnRvIGRpZmZlcmVudCBsaW5lcykuIE9uZSBwYWNrYWdlIHdoaWNoIHVzZXMgdGhpcyBwYXR0ZXJuIGlzIHRoZSBge3JlYWRyfWAgcGFja2FnZSwgd2hpY2ggaXMgcGFydCBvZiB0aGUgW3RpZHl2ZXJzZS1lY29zeXN0ZW1dKGh0dHBzOi8vd3d3LnRpZHl2ZXJzZS5vcmcvKS4KCi0tLQoKMy4gIEhvdyBkb2VzIHRoZSBgY2hkaXJgIHBhcmFtZXRlciBvZiBgc291cmNlKClgIGNvbXBhcmUgdG8gYHdpdGhfZGlyKClgPyBXaHkgCiAgICBtaWdodCB5b3UgcHJlZmVyIG9uZSB0byB0aGUgb3RoZXI/CgpBbnN3ZXI6IGJvdGggdGVtcG9yYXJpbHkgY2hhbmdlIHRoZSB3b3JraW5nIGRpcmVjdG9yeS4gYGNoZGlyYCBpcyBwcmVmZXJhYmxlIHNpbmNlIHRoaXMgaXMgZXhwZWN0ZWQgYmVoYXZpb3IgZm9yIHRoZSBmdW5jdGlvbiwgdW5sZXNzIHlvdSBuZWVkIHRvIHNldCBhIHdvcmtpbmcgZGlyZWN0b3J5IG90aGVyIHRoYW4gdGhlIGRpcmVjdG9yeSBjb250YWluaW5nIGBmaWxlYC4KCkFSIFNvbHV0aW9uczogYHdpdGhfZGlyKClgIHRha2VzIGEgcGF0aCBmb3IgYSB3b3JraW5nIGRpcmVjdG9yeSAoYGRpcmApIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gVGhpcyBpcyB0aGUgZGlyZWN0b3J5IHdoZXJlIHRoZSBwcm92aWRlZCBjb2RlIChgY29kZWApIHNob3VsZCBiZSBleGVjdXRlZC4gVGhlcmVmb3JlLCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSBpcyBjaGFuZ2VkIGluIGB3aXRoX2RpcigpYCB2aWEgYHNldHdkKClgLiBUaGVuLCBgb24uZXhpdCgpYCBlbnN1cmVzIHRoYXQgdGhlIG1vZGlmaWNhdGlvbiBvZiB0aGUgd29ya2luZyBkaXJlY3RvcnkgaXMgcmVzZXQgdG8gdGhlIGluaXRpYWwgdmFsdWUgd2hlbiB0aGUgZnVuY3Rpb24gZXhpdHMuIEJ5IHBhc3NpbmcgdGhlIHBhdGggZXhwbGljaXRseSwgdGhlIHVzZXIgaGFzIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBkaXJlY3RvcnkgdG8gZXhlY3V0ZSB0aGUgY29kZSBpbi4KCkluIGBzb3VyY2UoKWAgdGhlIGNvZGUgaXMgcGFzc2VkIHZpYSB0aGUgYGZpbGVgIGFyZ3VtZW50IChhIHBhdGggdG8gYSBmaWxlKS4gVGhlIGBjaGRpcmAgYXJndW1lbnQgc3BlY2lmaWVzIGlmIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBzaG91bGQgYmUgY2hhbmdlZCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIGZpbGUuIFRoZSBkZWZhdWx0IGZvciBgY2hkaXJgIGlzIGBGQUxTRWAsIHNvIHlvdSBkb24ndCBoYXZlIHRvIHByb3ZpZGUgYSB2YWx1ZS4gSG93ZXZlciwgYXMgeW91IGNhbiBvbmx5IHByb3ZpZGUgYFRSVUVgIG9yIGBGQUxTRWAsIHlvdSBhcmUgYWxzbyBsZXNzIGZsZXhpYmxlIGluIGNob29zaW5nIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBmb3IgdGhlIGNvZGUgZXhlY3V0aW9uLgoKLS0tCgo0LiAgV3JpdGUgYSBmdW5jdGlvbiB0aGF0IG9wZW5zIGEgZ3JhcGhpY3MgZGV2aWNlLCBydW5zIHRoZSBzdXBwbGllZCBjb2RlLCBhbmQgCiAgICBjbG9zZXMgdGhlIGdyYXBoaWNzIGRldmljZSAoYWx3YXlzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSAKICAgIHBsb3R0aW5nIGNvZGUgd29ya3MpLgoKYGBge3J9CndpdGhfcG5nIDwtIGZ1bmN0aW9uKGNvZGUsIC4uLikgewogIHBuZyguLi4pCiAgb24uZXhpdChkZXYub2ZmKCksIGFkZCA9IFRSVUUsIGFmdGVyID0gVFJVRSkKICBmb3JjZShjb2RlKQp9Cgp3aXRoX3BuZygKICBwbG90KDE6MTApLAogIGZpbGVuYW1lID0gInJlbmRlcmVkL3dpdGhwbmctZXhhbXBsZS5wbmciLAogICMgdXNlIDMgdGltZXMgZGVmYXVsdCByZXNvbHV0aW9uIHdoaWNoIGlzIGNsb3NlIHRvIHJldGluYSBkaXNwbGF5IHBwaSAoMjE4LTI1NCBkZXBlbmRpbmcgb24gbW9kZWwpCiAgIyBodHRwczovL3N1cHBvcnQuYXBwbGUuY29tL2VuLXVzL0hUMjAyNDcxCiAgd2lkdGggPSA0ODAgKiAzLCBoZWlnaHQgPSA0ODAgKiAzLCByZXMgPSA3MiAqIDMKKQpgYGAKCiFbd2l0aF9wbmcgb3V0cHV0XShyZW5kZXJlZC93aXRocG5nLWV4YW1wbGUucG5nKQoKQW5zd2VyOiBjb2RlIGV4YW1wbGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IFRvIGNvbnRyb2wgdGhlIGdyYXBoaWNzIGRldmljZSB3ZSB1c2UgYHBkZigpYCBhbmQgYGRldi5vZmYoKWAuIFRvIGVuc3VyZSBhIGNsZWFuIHRlcm1pbmF0aW9uIGBvbi5leGl0KClgIGlzIHVzZWQuCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQpwbG90X3BkZiA8LSBmdW5jdGlvbihjb2RlKSB7CiAgcGRmKCJ0ZXN0LnBkZiIpCiAgb24uZXhpdChkZXYub2ZmKCksIGFkZCA9IFRSVUUpCiAgY29kZQp9CmBgYAoKLS0tCgo1LiAgV2UgY2FuIHVzZSBgb24uZXhpdCgpYCB0byBpbXBsZW1lbnQgYSBzaW1wbGUgdmVyc2lvbiBvZiBgY2FwdHVyZS5vdXRwdXQoKWAuCgpgYGB7ciwgZXZhbCA9IGdldFJ2ZXJzaW9uKCkgPj0gIjMuNSJ9CiMgbm9saW50IHN0YXJ0OiBvYmplY3RfbmFtZV9saW50ZXIsIHVuZGVzaXJhYmxlX2Z1bmN0aW9uX2xpbnRlci4KY2FwdHVyZS5vdXRwdXQyIDwtIGZ1bmN0aW9uKGNvZGUpIHsKICB0ZW1wIDwtIHRlbXBmaWxlKCkKICBvbi5leGl0KGZpbGUucmVtb3ZlKHRlbXApLCBhZGQgPSBUUlVFLCBhZnRlciA9IFRSVUUpCiAgc2luayh0ZW1wKQogIG9uLmV4aXQoc2luaygpLCBhZGQgPSBUUlVFLCBhZnRlciA9IFRSVUUpCiAgZm9yY2UoY29kZSkKICByZWFkTGluZXModGVtcCkKfQojIG5vbGludCBlbmQKY2FwdHVyZS5vdXRwdXQyKGNhdCgiYSIsICJiIiwgImMiLCBzZXAgPSAiXG4iKSkKYGBgCgpDb21wYXJlIGBjYXB0dXJlLm91dHB1dCgpYCB0byBgY2FwdHVyZS5vdXRwdXQyKClgLiBIb3cgZG8gdGhlIGZ1bmN0aW9ucyAgZGlmZmVyPyBXaGF0IGZlYXR1cmVzIGhhdmUgSSByZW1vdmVkIHRvIG1ha2UgdGhlIGtleSBpZGVhcyBlYXNpZXIgdG8gc2VlPyBIb3cgaGF2ZSBJIHJld3JpdHRlbiB0aGUga2V5IGlkZWFzIHNvIHRoZXkncmUgZWFzaWVyIHRvIHVuZGVyc3RhbmQ/CgpBbnN3ZXI6IGBjYXB0dXJlLm91dHB1dDIoKWAgaGFzIGZld2VyIGZlYXR1cmVzIGFuZCB1c2VzIHR3byBzZXBhcmF0ZSBjYWxscyB0byBgb24uZXhpdCgpYC4gSXQgc2ltcGx5IHJldHVybnMgdGhlIG91dHB1dCAoYnkgbGluZSkgZnJvbSB0aGUgZXhlY3V0ZWQgY29kZSwgYW5kIGhpZ2hsaWdodHMgdGhlIGtleSBpZGVhLCB1c2luZyBgc2luaygpYCB0byBjYXB0dXJlIG91dHB1dCB0byBhIHRlbXBvcmFyeSBmaWxlLgoKQVIgU29sdXRpb25zOiBVc2luZyBgYm9keShjYXB0dXJlLm91dHB1dClgIHdlIGluc3BlY3QgdGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBvcmlnaW5hbCBgY2FwdHVyZS5vdXRwdXQoKWAgZnVuY3Rpb246IFRoZSBpbXBsZW1lbnRhdGlvbiBmb3IgYGNhcHR1cmUub3V0cHV0KClgIGlzIHF1aXRlIGEgYml0IGxvbmdlciAoMzkgbGluZXMgdnMuIDcgbGluZXMpLgoKSW4gYGNhcHR1cmVfb3V0cHV0MigpYCB0aGUgY29kZSBpcyBzaW1wbHkgZm9yY2VkLCBhbmQgdGhlIG91dHB1dCBpcyBjYXVnaHQgdmlhIGBzaW5rKClgIGluIGEgdGVtcG9yYXJ5IGZpbGUuIEFuIGFkZGl0aW9uYWwgZmVhdHVyZSBvZiBgY2FwdHVyZV9vdXRwdXQoKWAgaXMgdGhhdCBvbmUgY2FuIGFsc28gY2FwdHVyZSBtZXNzYWdlcyBieSBzZXR0aW5nIGB0eXBlID0gIm1lc3NhZ2UiYC4gQXMgdGhpcyBpcyBpbnRlcm5hbGx5IGZvcndhcmRlZCB0byBgc2luaygpYCwgdGhpcyBiZWhhdmlvdXIgKGFuZCBhbHNvIGBzaW5rKClgJ3MgYHNwbGl0YCBhcmd1bWVudCkgY291bGQgYmUgZWFzaWx5IGludHJvZHVjZWQgd2l0aGluIGBjYXB0dXJlX291dHB1dDIoKWAgYXMgd2VsbC4KClRoZSBtYWluIGRpZmZlcmVuY2UgaXMgdGhhdCBgY2FwdHVyZS5vdXRwdXQoKWAgY2FsbHMgcHJpbnQuCgotLS0KCiMjIDYuOC42IEV4ZXJjaXNlcwoKMS4gUmV3cml0ZSB0aGUgZm9sbG93aW5nIGNvZGUgc25pcHBldHMgaW50byBwcmVmaXggZm9ybToKCmBgYHtyfQoxICsgMiArIDMKYCtgKGArYCgxLCAyKSwgMykKCjEgKyAoMiArIDMpCmArYCgxLCBgK2AoMiwgMykpCgpmeG4gPC0gZnVuY3Rpb24oeCwgbikgaWYgKGxlbmd0aCh4KSA8PSA1KSB4W1s1XV0gZWxzZSB4W1tuXV0KZnhuKDE6NSwgMikKZnhuKDE6MTAsIDIpCgpmeG4yIDwtIGZ1bmN0aW9uKHgsIG4pIGBpZmAoYDw9YChsZW5ndGgoeCksIDUpLCBgW1tgKHgsIDUpLCBgW1tgKHgsIG4pKQpmeG4yKDE6NSwgMikKZnhuMigxOjEwLCAyKQpgYGAKCkFuc3dlcjogaW5saW5lIGFib3ZlLgoKQVIgU29sdXRpb25zOiBMZXQncyByZXdyaXRlIHRoZSBleHByZXNzaW9ucyB0byBtYXRjaCB0aGUgZXhhY3Qgc3ludGF4IGZyb20gdGhlIGNvZGUgYWJvdmUuIEJlY2F1c2UgcHJlZml4IGZ1bmN0aW9ucyBhbHJlYWR5IGRlZmluZSB0aGUgZXhlY3V0aW9uIG9yZGVyLCB3ZSBtYXkgb21pdCB0aGUgcGFyZW50aGVzZXMgaW4gdGhlIHNlY29uZCBleHByZXNzaW9uLgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KYCtgKGArYCgxLCAyKSwgMykKYCtgKDEsIGAoYChgK2AoMiwgMykpKQpgK2AoMSwgYCtgKDIsIDMpKQpgaWZgKGA8PWAobGVuZ3RoKHgpLCA1KSwgYFtbYCh4LCA1KSwgYFtbYCh4LCBuKSkKYGBgCgotLS0KCjIuICBDbGFyaWZ5IHRoZSBmb2xsb3dpbmcgbGlzdCBvZiBvZGQgZnVuY3Rpb24gY2FsbHM6CgpgYGB7ciwgZXZhbCA9IEZBTFNFfQp4IDwtIHNhbXBsZShyZXBsYWNlID0gVFJVRSwgMjAsIHggPSBjKDE6MTAsIE5BKSkKeSA8LSBydW5pZihtaW4gPSAwLCBtYXggPSAxLCAyMCkKY29yKG0gPSAiayIsIHkgPSB5LCB1ID0gInAiLCB4ID0geCkKYGBgCgpBbnN3ZXJzOiBpbXByb3ZlZCBjb2RlIGJlbG93LgoKYGBge3J9CnggPC0gc2FtcGxlKGMoMToxMCwgTkEpLCAyMCwgcmVwbGFjZSA9IFRSVUUpCnkgPC0gcnVuaWYoMjApCmNvcih4LCB5LCB1c2UgPSAicGFpcndpc2UuY29tcGxldGUub2JzIiwgbWV0aG9kID0gImtlbmRhbGwiKQpgYGAKCkFSIFNvbHV0aW9uczogTm9uZSBvZiB0aGVzZSBmdW5jdGlvbnMgcHJvdmlkZXMgYSBgLi4uYCBhcmd1bWVudC4gVGhlcmVmb3JlLCB0aGUgZnVuY3Rpb24gYXJndW1lbnRzIGFyZSBmaXJzdCBtYXRjaGVkIGV4YWN0bHksIHRoZW4gdmlhIHBhcnRpYWwgbWF0Y2hpbmcgYW5kIGZpbmFsbHkgYnkgcG9zaXRpb24uIFRoaXMgbGVhZHMgdXMgdG8gdGhlIGZvbGxvd2luZyBleHBsaWNpdCBmdW5jdGlvbiBjYWxsczoKCmBgYHtyLCBldmFsID0gRkFMU0V9CnggPC0gc2FtcGxlKGMoMToxMCwgTkEpLCBzaXplID0gMjAsIHJlcGxhY2UgPSBUUlVFKQp5IDwtIHJ1bmlmKDIwLCBtaW4gPSAwLCBtYXggPSAxKQpjb3IoeCwgeSwgdXNlID0gInBhaXJ3aXNlLmNvbXBsZXRlLm9icyIsIG1ldGhvZCA9ICJrZW5kYWxsIikKYGBgCgotLS0KCjMuIEV4cGxhaW4gd2h5IHRoZSBmb2xsb3dpbmcgY29kZSBmYWlsczoKCmBgYHtyfQpgbW9kaWZ5PC1gIDwtIGZ1bmN0aW9uKHgsIHBvc2l0aW9uLCB2YWx1ZSkgewogIHhbcG9zaXRpb25dIDwtIHZhbHVlCiAgeAp9Cgp0cnkobW9kaWZ5KGdldCgieCIpLCAxKSA8LSAxMCkKIz4gRXJyb3I6IHRhcmdldCBvZiBhc3NpZ25tZW50IGV4cGFuZHMgdG8gbm9uLWxhbmd1YWdlIG9iamVjdApgYGAKCkFuc3dlcjogYXMgZXhwbGFpbmVkIG9uIFtzdGFjayBvdmVyZmxvd10oaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjc2NjIxNjIvZXJyb3ItaW4tbXktY29kZS10YXJnZXQtb2YtYXNzaWdubWVudC1leHBhbmRzLXRvLW5vbi1sYW5ndWFnZS1vYmplY3QpLCB0aGUgZXJyb3IgaXMgY2F1c2VkIHdoZW4gYXNzaWduaW5nIHRvIGFuIG9iamVjdCBkaXJlY3RseSwgaW5zdGVhZCBvZiBhIG5hbWUgdGhhdCByZWZlcnMgdG8gdGhlIG9iamVjdCAobGlrZSBgeGApLgoKQVIgU29sdXRpb25zOiBGaXJzdCwgbGV0J3MgZGVmaW5lIGB4YCBhbmQgcmVjYWxsIHRoZSBkZWZpbml0aW9uIG9mIGBtb2RpZnkoKWAgZnJvbSAqQWR2YW5jZWQgUio6CgpgYGB7cn0KeCA8LSAxOjMKCmBtb2RpZnk8LWAgPC0gZnVuY3Rpb24oeCwgcG9zaXRpb24sIHZhbHVlKSB7CiAgeFtwb3NpdGlvbl0gPC0gdmFsdWUKICB4Cn0KYGBgCgpSIGludGVybmFsbHkgdHJhbnNmb3JtcyB0aGUgY29kZSwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBjb2RlIHJlcHJvZHVjZXMgdGhlIGVycm9yIGFib3ZlOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KZ2V0KCJ4IikgPC0gYG1vZGlmeTwtYChnZXQoIngiKSwgMSwgMTApCiM+IEVycm9yIGluIGdldCgieCIpIDwtIGBtb2RpZnk8LWAoZ2V0KCJ4IiksIDEsIDEwKSA6CiM+ICAgdGFyZ2V0IG9mIGFzc2lnbm1lbnQgZXhwYW5kcyB0byBub24tbGFuZ3VhZ2Ugb2JqZWN0CmBgYAoKVGhlIGVycm9yIG9jY3VycyBkdXJpbmcgdGhlIGFzc2lnbm1lbnQgYmVjYXVzZSBubyBjb3JyZXNwb25kaW5nIHJlcGxhY2VtZW50IGZ1bmN0aW9uLCBpLmUuIGBnZXQ8LWAsIGV4aXN0cyBmb3IgYGdldCgpYC4gVG8gY29uZmlybSB0aGlzLCB3ZSByZXByb2R1Y2UgdGhlIGVycm9yIHZpYSB0aGUgZm9sbG93aW5nIHNpbXBsaWZpZWQgZXhhbXBsZS4KCmBgYHtyLCBldmFsID0gRkFMU0V9CmdldCgieCIpIDwtIDIKIz4gRXJyb3IgaW4gZ2V0KCJ4IikgPC0gMiA6CiM+ICAgdGFyZ2V0IG9mIGFzc2lnbm1lbnQgZXhwYW5kcyB0byBub24tbGFuZ3VhZ2Ugb2JqZWN0CmBgYAoKLS0tCgo0LiBDcmVhdGUgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB0aGF0IG1vZGlmaWVzIGEgcmFuZG9tIGxvY2F0aW9uIGluIGEgdmVjdG9yLgoKYGBge3J9CmBtb2RyYW5kPC1gIDwtIGZ1bmN0aW9uKHgsIHZhbHVlKSB7CiAgeFtzYW1wbGUobGVuZ3RoKHgpLCAxKV0gPC0gdmFsdWUKICB4Cn0KCnYgPC0gMToyMAptb2RyYW5kKHYpIDwtIE5BCnYKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IExldCdzIGRlZmluZSBgcmFuZG9tPC1gIGxpa2UgdGhpczoKCmBgYHtyLCBldmFsID0gRkFMU0V9CmByYW5kb208LWAgPC0gZnVuY3Rpb24oeCwgdmFsdWUpIHsKICBpZHggPC0gc2FtcGxlKGxlbmd0aCh4KSwgMSkKICB4W2lkeF0gPC0gdmFsdWUKICB4Cn0KYGBgCgotLS0KCjUuIFdyaXRlIHlvdXIgb3duIHZlcnNpb24gb2YgYCtgIHRoYXQgcGFzdGVzIGl0cyBpbnB1dHMgdG9nZXRoZXIgaWYgdGhleSBhcmUgCiAgIGNoYXJhY3RlciB2ZWN0b3JzIGJ1dCBiZWhhdmVzIGFzIHVzdWFsIG90aGVyd2lzZS4gSW4gb3RoZXIgd29yZHMsIG1ha2UgdGhpcyAKICAgY29kZSB3b3JrOgoKYGBge3J9CmArYCA8LSBmdW5jdGlvbih4LCB5KSB7CiAgaWYgKGlzLmNoYXJhY3Rlcih4KSAmJiBpcy5jaGFyYWN0ZXIoeSkpIHsKICAgIHJldHVybihwYXN0ZTAoeCwgeSkpCiAgfQogIGJhc2U6OmArYCh4LCB5KQp9CgoxICsgMgojPiBbMV0gMwoKImEiICsgImIiCiM+IFsxXSAiYWIiCgpybShgK2ApCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLgoKQVIgU29sdXRpb25zOiBUbyBhY2hpZXZlIHRoaXMgYmVoYXZpb3VyLCB3ZSBuZWVkIHRvIG92ZXJyaWRlIHRoZSBgK2Agb3BlcmF0b3IuIFdlIG5lZWQgdG8gdGFrZSBjYXJlIHRvIG5vdCB1c2UgdGhlIGArYCBvcGVyYXRvciBpdHNlbGYgaW5zaWRlIG9mIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uLCBhcyB0aGlzIHdvdWxkIGxlYWQgdG8gYW4gdW5kZXNpcmVkIGluZmluaXRlIHJlY3Vyc2lvbi4gV2UgYWxzbyBhZGQgYGIgPSAwTGAgYXMgYSBkZWZhdWx0IHZhbHVlIHRvIGtlZXAgdGhlIGJlaGF2aW91ciBvZiBgK2AgYXMgYSB1bmFyeSBvcGVyYXRvciwgaS5lLiB0byBrZWVwIGArIDFgIHdvcmtpbmcgYW5kIG5vdCB0aHJvd2luZyBhbiBlcnJvci4KCmBgYHtyfQpgK2AgPC0gZnVuY3Rpb24oYSwgYiA9IDBMKSB7CiAgaWYgKGlzLmNoYXJhY3RlcihhKSAmJiBpcy5jaGFyYWN0ZXIoYikpIHsKICAgIHBhc3RlMChhLCBiKQogIH0gZWxzZSB7CiAgICBiYXNlOjpgK2AoYSwgYikKICB9Cn0KIyBUZXN0CisxCjEgKyAyCiJhIiArICJiIgojIFJldHVybiBiYWNrIHRvIHRoZSBvcmlnaW5hbCBgK2Agb3BlcmF0b3IKcm0oYCtgKQpgYGAKCi0tLQoKNi4gQ3JlYXRlIGEgbGlzdCBvZiBhbGwgdGhlIHJlcGxhY2VtZW50IGZ1bmN0aW9ucyBmb3VuZCBpbiB0aGUgYmFzZSBwYWNrYWdlLiAKICAgV2hpY2ggb25lcyBhcmUgcHJpbWl0aXZlIGZ1bmN0aW9ucz8gKEhpbnQ6IHVzZSBgYXByb3BvcygpYC4pCgpgYGB7cn0KIyBhbGwgcmVwbGFjZW1lbnQgZnVuY3Rpb25zIGluIGJhc2UKZnVuX2FyZ3MyW2VuZHNXaXRoKGZ1bl9hcmdzMiRuYW1lLCAiPC0iKSwgXSRuYW1lCgojIGFsbCByZXBsYWNlbWVudCBwcmltaXRpdmUgZnVuY3Rpb25zIGluIGJhc2UKZnVuX2FyZ3MyW2VuZHNXaXRoKGZ1bl9hcmdzMiRuYW1lLCAiPC0iKSAmIGZ1bl9hcmdzMiRwcmltLCBdJG5hbWUKYGBgCgpBbnN3ZXI6IHdoaWxlIHlvdSBjb3VsZCB1c2UgYGFwcm9wb3MoIjwtIilgLCBJIGxldmVyYWdlZCB0aGUgZXhpc3RpbmcgY29kZSBmcm9tIDYuMi41ICM1LgoKQVIgU29sdXRpb25zOiBUaGUgaGludCBzdWdnZXN0cyB0byBsb29rIGZvciBmdW5jdGlvbnMgd2l0aCBhIHNwZWNpZmljIG5hbWluZyBwYXR0ZXJuOiBSZXBsYWNlbWVudCBmdW5jdGlvbnMgY29udmVudGlvbmFsbHkgZW5kIG9uICI8LSIuIFdlIGNhbiBzZWFyY2ggZm9yIHRoZXNlIG9iamVjdHMgYnkgc3VwcGx5aW5nIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYCI8LSQiYCB0byBgYXByb3BvcygpYC4gYGFwcm9wb3MoKWAgYWxzbyBhbGxvd3MgdG8gcmV0dXJuIHRoZSBwb3NpdGlvbiBvbiB0aGUgc2VhcmNoIHBhdGggKGBzZWFyY2goKWApIGZvciBlYWNoIG9mIGl0cyBtYXRjaGVzIHZpYSBzZXR0aW5nIGB3aGVyZSA9IFRSVUVgLiBGaW5hbGx5LCB3ZSBjYW4gc2V0IGBtb2RlID0gZnVuY3Rpb25gIHRvIG5hcnJvdyBkb3duIG91ciBzZWFyY2ggdG8gcmVsZXZhbnQgb2JqZWN0cyBvbmx5LiBUaGlzIGdpdmVzIHVzIHRoZSBmb2xsb3dpbmcgc3RhdGVtZW50IHRvIGJlZ2luIHdpdGg6CgpgYGB7cn0KcmVwbHMgPC0gYXByb3BvcygiPC0iLCB3aGVyZSA9IFRSVUUsIG1vZGUgPSAiZnVuY3Rpb24iKQpoZWFkKHJlcGxzLCAzMCkKYGBgCgpUbyByZXN0cmljdCBgcmVwbGAgdG8gbmFtZXMgb2YgcmVwbGFjZW1lbnQgZnVuY3Rpb25zIGZyb20gdGhlIGB7YmFzZX1gIHBhY2thZ2UsIHdlIHNlbGVjdCBvbmx5IG1hdGNoZXMgY29udGFpbmluZyB0aGUgcmVsZXZhbnQgcG9zaXRpb24gb24gdGhlIHNlYXJjaCBwYXRoLgoKYGBge3J9CnJlcGxzX2Jhc2UgPC0gcmVwbHNbbmFtZXMocmVwbHMpID09IGxlbmd0aChzZWFyY2goKSldCnJlcGxzX2Jhc2UKYGBgCgpUbyBmaW5kIG91dCB3aGljaCBvZiB0aGVzZSBmdW5jdGlvbnMgYXJlIHByaW1pdGl2ZXMsIHdlIGZpcnN0IHNlYXJjaCBmb3IgdGhlc2UgZnVuY3Rpb25zIHZpYSBgbWdldCgpYCBhbmQgdGhlbiBzdWJzZXQgdGhlIHJlc3VsdCB1c2luZyBgRmlsdGVyKClgIGFuZCBgaXMucHJpbWl0aXZlKClgLgoKYGBge3J9CnJlcGxzX2Jhc2VfcHJpbSA8LSBtZ2V0KHJlcGxzX2Jhc2UsIGVudmlyID0gYmFzZWVudigpKSAlPiUKICBGaWx0ZXIoaXMucHJpbWl0aXZlLCAuKSAlPiUKICBuYW1lcygpCnJlcGxzX2Jhc2VfcHJpbQpgYGAKCk92ZXJhbGwgdGhlIGBiYXNlYCBwYWNrYWdlIGNvbnRhaW5zIDYzIHJlcGxhY2VtZW50IGZ1bmN0aW9ucyBvZiB3aGljaCAxNyBhcmUgcHJpbWl0aXZlIGZ1bmN0aW9ucy4KCi0tLQoKNy4gV2hhdCBhcmUgdmFsaWQgbmFtZXMgZm9yIHVzZXItY3JlYXRlZCBpbmZpeCBmdW5jdGlvbnM/CgpBbnN3ZXI6IHRoZXkgbXVzdCBiZWdpbiBhbmQgZW5kIHdpdGggYCVgLCBhbmQgY2FuIGNvbnRhaW4gYW55IHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgZXhjZXB0IGAlYC4KCi0tLQoKOC4gQ3JlYXRlIGFuIGluZml4IGB4b3IoKWAgb3BlcmF0b3IuCgpgYGB7cn0KYCV4b3IlYCA8LSBmdW5jdGlvbih4LCB5KSB4b3IoeCwgeSkKCnhvcigwLCAwKQp4b3IoMSwgMCkKeG9yKDEsIDEpCgowICV4b3IlIDAKMSAleG9yJSAwCjEgJXhvciUgMQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogV2UgY291bGQgY3JlYXRlIGFuIGluZml4IGAleG9yJWAgbGlrZSB0aGlzOgoKYGBge3J9CmAleG9yJWAgPC0gZnVuY3Rpb24oYSwgYikgewogIHhvcihhLCBiKQp9ClRSVUUgJXhvciUgVFJVRQpGQUxTRSAleG9yJSBUUlVFCmBgYAoKLS0tCgo5LiBDcmVhdGUgaW5maXggdmVyc2lvbnMgb2YgdGhlIHNldCBmdW5jdGlvbnMgYGludGVyc2VjdCgpYCwgYHVuaW9uKClgLCBhbmQKICAgYHNldGRpZmYoKWAuIFlvdSBtaWdodCBjYWxsIHRoZW0gYCVuJWAsIGAldSVgLCBhbmQgYCUvJWAgdG8gbWF0Y2ggCiAgIGNvbnZlbnRpb25zIGZyb20gbWF0aGVtYXRpY3MuCgpgYGB7cn0KYCVuJWAgPC0gZnVuY3Rpb24oeCwgeSkgaW50ZXJzZWN0KHgsIHkpCmAldSVgIDwtIGZ1bmN0aW9uKHgsIHkpIHVuaW9uKHgsIHkpCmAlcyVgIDwtIGZ1bmN0aW9uKHgsIHkpIHNldGRpZmYoeCwgeSkKCiMgdGFrZW4gZnJvbSBkb2NzIGV4YW1wbGVzCih4IDwtIGMoc29ydChzYW1wbGUoMToyMCwgOSkpLCBOQSkpCih5IDwtIGMoc29ydChzYW1wbGUoMzoyMywgNykpLCBOQSkpCnggJXUlIHkKeCAlbiUgeQp4ICVzJSB5CnkgJXMlIHgKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IFRoZXNlIGluZml4IG9wZXJhdG9ycyBjb3VsZCBiZSBkZWZpbmVkIGluIHRoZSBmb2xsb3dpbmcgd2F5LiAoYCUvJWAgaXMgY2hvc2VuIGluc3RlYWQgb2YgYCVcJWAsIGJlY2F1c2UgYFxgIHNlcnZlcyBhcyBhbiBlc2NhcGUgY2hhcmFjdGVyLikKCmBgYHtyfQpgJW4lYCA8LSBmdW5jdGlvbihhLCBiKSB7CiAgaW50ZXJzZWN0KGEsIGIpCn0KCmAldSVgIDwtIGZ1bmN0aW9uKGEsIGIpIHsKICB1bmlvbihhLCBiKQp9CgpgJS8lYCA8LSBmdW5jdGlvbihhLCBiKSB7CiAgc2V0ZGlmZihhLCBiKQp9Cgp4IDwtIGMoImEiLCAiYiIsICJkIikKeSA8LSBjKCJhIiwgImMiLCAiZCIpCgp4ICV1JSB5CnggJW4lIHkKeCAlLyUgeQpgYGAKCi0tLQoKIyA3IEVudmlyb25tZW50cwoKVGhlIGVudmlyb25tZW50IGlzIHRoZSBkYXRhIHN0cnVjdHVyZSB0aGF0IHBvd2VycyBzY29waW5nLiBUaGlzIGNoYXB0ZXIgZGl2ZXMgZGVlcCBpbnRvIGVudmlyb25tZW50cywgZGVzY3JpYmluZyB0aGVpciBzdHJ1Y3R1cmUgaW4gZGVwdGgsIGFuZCB1c2luZyB0aGVtIHRvIGltcHJvdmUgeW91ciB1bmRlcnN0YW5kaW5nIG9mIHRoZSBmb3VyIHNjb3BpbmcgcnVsZXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gNi40LiBVbmRlcnN0YW5kaW5nIGVudmlyb25tZW50cyBpcyBub3QgbmVjZXNzYXJ5IGZvciBkYXktdG8tZGF5IHVzZSBvZiBSLiBCdXQgdGhleSBhcmUgaW1wb3J0YW50IHRvIHVuZGVyc3RhbmQgYmVjYXVzZSB0aGV5IHBvd2VyIG1hbnkgaW1wb3J0YW50IFIgZmVhdHVyZXMgbGlrZSBsZXhpY2FsIHNjb3BpbmcsIG5hbWVzcGFjZXMsIGFuZCBSNiBjbGFzc2VzLCBhbmQgaW50ZXJhY3Qgd2l0aCBldmFsdWF0aW9uIHRvIGdpdmUgeW91IHBvd2VyZnVsIHRvb2xzIGZvciBtYWtpbmcgZG9tYWluIHNwZWNpZmljIGxhbmd1YWdlcywgbGlrZSBkcGx5ciBhbmQgZ2dwbG90Mi4KCmBgYHtyfQpybShsaXN0ID0gbHMoKSkKYGBgCgojIyA3LjIuNyBFeGVyY2lzZXMKCjEuICBMaXN0IHRocmVlIHdheXMgaW4gd2hpY2ggYW4gZW52aXJvbm1lbnQgZGlmZmVycyBmcm9tIGEgbGlzdC4KCkFuc3dlcjoKCi0gRXZlcnkgbmFtZSBpbiBhbiBlbnZpcm9ubWVudCBtdXN0IGJlIHVuaXF1ZQotIEVudmlyb25tZW50IG5hbWVzIGFyZSBub3Qgb3JkZXJlZAotIEVudmlyb25tZW50cyBoYXZlIHBhcmVudHMgKGV4Y2VwdCB0aGUgZW1wdHkgZW52aXJvbm1lbnQpCi0gRW52aXJvbm1lbnRzIGFyZSBub3QgY29waWVkIHdoZW4gbW9kaWZpZWQKCkFSIFNvbHV0aW9uczogVGhlIG1vc3QgaW1wb3J0YW50IGRpZmZlcmVuY2VzIGJldHdlZW4gZW52aXJvbm1lbnRzIGFuZCBsaXN0cyBhcmU6CgotIGVudmlyb25tZW50cyBoYXZlIHJlZmVyZW5jZSBzZW1hbnRpY3MgKGkuZS4gdGhleSBkb24ndCBjb3B5LW9uLW1vZGlmeSkKLSBlbnZpcm9ubWVudHMgaGF2ZSBwYXJlbnRzCi0gdGhlIGNvbnRlbnRzIG9mIGFuIGVudmlyb25tZW50IG11c3QgaGF2ZSB1bmlxdWUgbmFtZXMKLSB0aGUgY29udGVudHMgb2YgYW4gZW52aXJvbm1lbnQgYXJlIG5vdCBvcmRlcmVkCi0gKGVudmlyb25tZW50cyBjYW4gb25seSBiZSBjb21wYXJlZCB2aWEgYGlkZW50aWNhbCgpYDsgbm90IHdpdGggYD09YCkKLSAoZW52aXJvbm1lbnRzIGNhbiBjb250YWluIHRoZW1zZWx2ZXMpCgotLS0KCjIuICBDcmVhdGUgYW4gZW52aXJvbm1lbnQgYXMgaWxsdXN0cmF0ZWQgYnkgdGhpcyBwaWN0dXJlLgoKIVtdKGFzc2V0cy9yZWN1cnNpdmUtMS5wbmcpCgpgYGB7cn0KZTEgPC0gZW52KCkKZTEkbG9vcCA8LSBlMQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogTGV0J3MgY3JlYXRlIGFuIGVudmlyb25tZW50IHRoYXQgY29udGFpbnMgaXRzZWxmLgoKYGBge3J9CmUxIDwtIGVudigpCmUxJGxvb3AgPC0gZTEKCiMgUHJpbnQgdGhlIGVudmlyb25tZW50CmVudl9wcmludChlMSkKCiMgVmVyaWZ5IHRoYXQgaXQgY29udGFpbnMgaXRzZWxmCmxvYnN0cjo6cmVmKGUxKQpgYGAKCi0tLQoKMy4gIENyZWF0ZSBhIHBhaXIgb2YgZW52aXJvbm1lbnRzIGFzIGlsbHVzdHJhdGVkIGJ5IHRoaXMgcGljdHVyZS4KCiFbXShhc3NldHMvcmVjdXJzaXZlLTIucG5nKQoKYGBge3J9CmUyIDwtIGVudigpCmUzIDwtIGVudigpCgplMiRsb29wIDwtIGUzCmUzJGRlZG9vcCA8LSBlMgpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogVGhlc2UgdHdvIGVudmlyb25tZW50cyBjb250YWluIGVhY2ggb3RoZXI6CgpgYGB7cn0KZTEgPC0gZW52KCkKZTIgPC0gZW52KCkKCmUxJGxvb3AgPC0gZTIKZTIkZGVkb29wIDwtIGUxCgpsb2JzdHI6OnJlZihlMSkKbG9ic3RyOjpyZWYoZTIpCmBgYAoKLS0tCgo0LiAgRXhwbGFpbiB3aHkgYGVbWzFdXWAgYW5kIGBlW2MoImEiLCAiYiIpXWAgZG9uJ3QgbWFrZSBzZW5zZSB3aGVuIGBlYCBpcwogICAgYW4gZW52aXJvbm1lbnQuCgpBbnN3ZXI6IGVudmlyb25tZW50IG5hbWVzIGFyZSBub3Qgb3JkZXJlZCwgYW5kIGFyZW4ndCBjb3BpZWQgd2hlbiBtb2RpZmllZCwgc28gdGhleSBhcmVuJ3Qgc3Vic2V0dGFibGUuCgpBUiBTb2x1dGlvbnM6IFRoZSBmaXJzdCBvcHRpb24gZG9lc24ndCBtYWtlIHNlbnNlLCBiZWNhdXNlIGVsZW1lbnRzIG9mIGFuIGVudmlyb25tZW50IGFyZSBub3Qgb3JkZXJlZC4gVGhlIHNlY29uZCBvcHRpb24gd291bGQgcmV0dXJuIHR3byBvYmplY3RzIGF0IHRoZSBzYW1lIHRpbWUuIFdoYXQgZGF0YSBzdHJ1Y3R1cmUgd291bGQgdGhleSBiZSBjb250YWluZWQgaW5zaWRlPwoKLS0tCgo1LiAgQ3JlYXRlIGEgdmVyc2lvbiBvZiBgZW52X3Bva2UoKWAgdGhhdCB3aWxsIG9ubHkgYmluZCBuZXcgbmFtZXMsIG5ldmVyIAogICAgcmUtYmluZCBvbGQgbmFtZXMuIFNvbWUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzIG9ubHkgZG8gdGhpcywgYW5kIGFyZSBrbm93biAKICAgIGFzIFtzaW5nbGUgYXNzaWdubWVudCBsYW5ndWFnZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Fzc2lnbm1lbnRfKGNvbXB1dGVyX3NjaWVuY2UpI1NpbmdsZV9hc3NpZ25tZW50KS4KCmBgYHtyfQplbnZfcG9rZV9uZXcgPC0gZnVuY3Rpb24oZW52LCBubSwgdmFsdWUpIHsKICBpZiAoIWlzLmVudmlyb25tZW50KGVudikpIHN0b3AoImVudiBpcyBub3QgYW4gZW52aW9ybm1lbnQiKQogIGlmIChubSAlaW4lIG5hbWVzKGVudikpIHN0b3AoIm5tICciLCBubSwgIicgYWxyZWFkeSBib3VuZCIpCiAgZW52W1tubV1dIDwtIHZhbHVlCn0KCmVfdGVzdCA8LSBlbnYoYSA9IE5VTEwsIGIgPSAyLCBjID0gInRocmVlIikKCmVudl9wb2tlX25ldyhlX3Rlc3QsICJkIiwgInN1Y2Nlc3MiKQp0cnkoZW52X3Bva2VfbmV3KGVfdGVzdCwgImEiLCAiZmFpbCIpKQplbnZfcHJpbnQoZV90ZXN0KQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogQXMgZGVzY3JpYmVkIGluICpBZHZhbmNlZCBSKiBgcmxhbmc6OmVudl9wb2tlKClgIHRha2VzIGEgbmFtZSAoYXMgc3RyaW5nKSBhbmQgYSB2YWx1ZSB0byBhc3NpZ24gKG9yIHJlYXNzaWduKSBhIGJpbmRpbmcgaW4gYW4gZW52aXJvbm1lbnQuCgpgYGB7cn0KZTMgPC0gbmV3LmVudigpCgplbnZfcG9rZShlMywgImEiLCAxMDApCmUzJGEKZW52X3Bva2UoZTMsICJhIiwgMjAwKQplMyRhCmBgYAoKU28sIHdlIHdhbnQgYGVudl9wb2tlMigpYCB0byB0ZXN0LCBpZiB0aGUgc3VwcGxpZWQgbmFtZSBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGdpdmVuIGVudmlyb25tZW50LiBUaGlzIGNhbiBiZSBjaGVja2VkIHZpYSBgZW52X2hhcygpYC4gSWYgdGhpcyBpcyB0aGUgY2FzZSwgYW4gKGluZm9ybWF0aXZlKSBlcnJvciBpcyB0aHJvd24uCgpgYGB7ciwgZXJyb3IgPSBUUlVFfQplbnZfcG9rZTIgPC0gZnVuY3Rpb24oZW52LCBuYW1lLCB2YWx1ZSkgewogIGlmIChlbnZfaGFzKGVudiwgbmFtZSkpIHsKICAgIGFib3J0KHBhc3RlMCgiXCIiLCBuYW1lLCAiXCIgaXMgYWxyZWFkeSBhc3NpZ25lZCB0byBhIHZhbHVlLiIpKQogIH0KCiAgZW52X3Bva2UoZW52LCBuYW1lLCB2YWx1ZSkKICBpbnZpc2libGUoZW52KQp9CgojIFRlc3QKZW52X3Bva2UyKGUzLCAiYiIsIDEwMCkKZTMkYgp0cnkoZW52X3Bva2UyKGUzLCAiYiIsIDIwMCkpCmBgYAoKLS0tCgo2LiAgV2hhdCBkb2VzIHRoaXMgZnVuY3Rpb24gZG8/IEhvdyBkb2VzIGl0IGRpZmZlciBmcm9tIGA8PC1gIGFuZCB3aHkKICAgIG1pZ2h0IHlvdSBwcmVmZXIgaXQ/CgpgYGB7ciwgZXJyb3IgPSBUUlVFfQpybShhKQpyZWJpbmQgPC0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIGVudiA9IGNhbGxlcl9lbnYoKSkgewogIGlmIChpZGVudGljYWwoZW52LCBlbXB0eV9lbnYoKSkpIHsKICAgIHN0b3AoIkNhbid0IGZpbmQgYCIsIG5hbWUsICJgIiwgY2FsbC4gPSBGQUxTRSkKICB9IGVsc2UgaWYgKGVudl9oYXMoZW52LCBuYW1lKSkgewogICAgZW52X3Bva2UoZW52LCBuYW1lLCB2YWx1ZSkKICB9IGVsc2UgewogICAgcmViaW5kKG5hbWUsIHZhbHVlLCBlbnZfcGFyZW50KGVudikpCiAgfQp9CnRyeShyZWJpbmQoImEiLCAxMCkpCihhIDwtIDUpCnJlYmluZCgiYSIsIDEwKQphCmBgYAoKQW5zd2VyOiBgPDwtYCB3aWxsIGFzc2lnbiBhIHZhbHVlIHRvIHRoZSBuYW1lIGluIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQgaWYgdGhlIG5hbWUgaXMgbm90IGZvdW5kLCBgcmViaW5kKClgIGRvZXMgbm90LgoKQVIgU29sdXRpb25zOiBUaGUgcHJpbWFyeSBkaWZmZXJlbmNlIGJldHdlZW4gYHJlYmluZCgpYCBhbmQgYDw8LWAgaXMgdGhhdCBgcmViaW5kKClgIHdpbGwgb25seSBjYXJyeSBvdXQgYW4gYXNzaWdubWVudCB3aGVuIGl0IGZpbmRzIGFuIGV4aXN0aW5nIGJpbmRpbmc7IHVubGlrZSBgPDwtYCBpdCB3aWxsIG5ldmVyIGNyZWF0ZSBhIG5ldyBvbmUgaW4gdGhlIGdsb2JhbCBlbnZpcm9ubWVudC4gVGhpcyBiZWhhdmlvdXIgb2YgYDw8LWAgaXMgdXN1YWxseSB1bmRlc2lyYWJsZSBiZWNhdXNlIGdsb2JhbCB2YXJpYWJsZXMgaW50cm9kdWNlIG5vbi1vYnZpb3VzIGRlcGVuZGVuY2llcyBiZXR3ZWVuIGZ1bmN0aW9ucy4KCi0tLQoKIyMgNy4zLjEgRXhlcmNpc2VzCgoxLiAgTW9kaWZ5IGB3aGVyZSgpYCB0byByZXR1cm4gX2FsbF8gZW52aXJvbm1lbnRzIHRoYXQgY29udGFpbiBhIGJpbmRpbmcgZm9yCiAgICBgbmFtZWAuIENhcmVmdWxseSB0aGluayB0aHJvdWdoIHdoYXQgdHlwZSBvZiBvYmplY3QgdGhlIGZ1bmN0aW9uIHdpbGwKICAgIG5lZWQgdG8gcmV0dXJuLgoKYGBge3J9CndoZXJlIDwtIGZ1bmN0aW9uKG5hbWUsIGVudiA9IGNhbGxlcl9lbnYoKSkgewogIGlmIChpZGVudGljYWwoZW52LCBlbXB0eV9lbnYoKSkpIHsKICAgICMgQmFzZSBjYXNlCiAgICBzdG9wKCJDYW4ndCBmaW5kICIsIG5hbWUsIGNhbGwuID0gRkFMU0UpCiAgfSBlbHNlIGlmIChlbnZfaGFzKGVudiwgbmFtZSkpIHsKICAgICMgU3VjY2VzcyBjYXNlCiAgICBlbnYKICB9IGVsc2UgewogICAgIyBSZWN1cnNpdmUgY2FzZQogICAgd2hlcmUobmFtZSwgZW52X3BhcmVudChlbnYpKQogIH0KfQoKeCA8LSA1CnRyeSh3aGVyZSgieXl5IikpCndoZXJlKCJ4IikKd2hlcmUoIm1lYW4iKQoKYWxsX3doZXJlIDwtIGZ1bmN0aW9uKG5hbWUsIGVudiA9IGNhbGxlcl9lbnYoKSwgZm91bmQgPSBsaXN0KCkpIHsKICBpZiAoaWRlbnRpY2FsKGVudiwgZW1wdHlfZW52KCkpKSB7CiAgICAjIEJhc2UgY2FzZQogICAgZm91bmQKICB9IGVsc2UgaWYgKGVudl9oYXMoZW52LCBuYW1lKSkgewogICAgIyBTdWNjZXNzIGNhc2UKICAgIGFsbF93aGVyZShuYW1lLCBlbnZfcGFyZW50KGVudiksIGFwcGVuZChlbnYsIGZvdW5kLCBhZnRlciA9IDApKQogIH0gZWxzZSB7CiAgICAjIFJlY3Vyc2l2ZSBjYXNlCiAgICBhbGxfd2hlcmUobmFtZSwgZW52X3BhcmVudChlbnYpLCBmb3VuZCkKICB9Cn0KCmFsbF93aGVyZSgieCIpCmxvY2FsKHsKICB4IDwtIDEwCiAgYWxsX3doZXJlKCJ4IikKfSkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IGB3aGVyZSgpYCBzZWFyY2hlcyAocmVjdXJzaXZlbHkpIGZvciBhIGdpdmVuIG5hbWUgd2l0aGluIGEgZ2l2ZW4gZW52aXJvbm1lbnQgYW5kIGl0cyBhbmNlc3RvcnMuIElmIGB3aGVyZSgpYCBmaW5kcyB0aGUgbmFtZSBpbiBvbmUgb2YgdGhlc2UgZW52aXJvbm1lbnRzLCBpdCByZXR1cm5zIHRoZSBlbnZpcm9ubWVudCdzIG5hbWUuIE90aGVyd2lzZSwgaXQgdGhyb3dzIGFuIGVycm9yLgoKT3VyIG1vZGlmaWVkIHZlcnNpb24gb2YgYHdoZXJlKClgIHdpbGwgYWx3YXlzIHJlY3Vyc2UgdW50aWwgaXQgcmVhY2hlcyB0aGUgZW1wdHkgZW52aXJvbm1lbnQuIE5vIG1hdHRlciBpZiBpdCBoYXMgYWxyZWFkeSBmb3VuZCB0aGUgbmFtZSBvciBub3QuIEFsb25nIHRoZSB3YXksIGl0IHdpbGwgY2hlY2sgZWFjaCBlbnZpcm9ubWVudCBmb3IgdGhlIGdpdmVuIGBuYW1lYC4gRmluYWxseSwgaXQgd2lsbCByZXR1cm4gYSBsaXN0IG9mIGVudmlyb25tZW50cyB3aGVyZSB0aGUgYmluZGluZyB3YXMgZm91bmQ7IGlmIG5vIGJpbmRpbmcgd2FzIGZvdW5kLCB0aGUgbGlzdCB3aWxsIGJlIGVtcHR5LgoKUGxlYXNlIGFsc28gbm90ZSBob3cgdGhlIGxpc3QgaXMgaW5pdGlhbGlzZWQgdmlhIHRoZSBkZWZhdWx0IGFyZ3VtZW50LCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIGEgYml0IGNvbmZ1c2luZywgd2hpY2ggaXMgd2h5IGl0J3MgY29tbW9uIHRvIHdyYXAgYSByZWN1cnNpdmUgZnVuY3Rpb24gaW5zaWRlIGFub3RoZXIsIG1vcmUgdXNlciBmcmllbmRseSwgZnVuY3Rpb24uCgpgYGB7cn0Kd2hlcmUyIDwtIGZ1bmN0aW9uKG5hbWUsIGVudiA9IGNhbGxlcl9lbnYoKSwgcmVzdWx0cyA9IGxpc3QoKSkgewogIGlmIChpZGVudGljYWwoZW52LCBlbXB0eV9lbnYoKSkpIHsKICAgICMgQmFzZSBjYXNlCiAgICByZXN1bHRzCiAgfSBlbHNlIHsKICAgICMgUmVjdXJzaXZlIGNhc2UKICAgIGlmIChlbnZfaGFzKGVudiwgbmFtZSkpIHsKICAgICAgcmVzdWx0cyA8LSBjKHJlc3VsdHMsIGVudikKICAgIH0KICAgIHdoZXJlMihuYW1lLCBlbnZfcGFyZW50KGVudiksIHJlc3VsdHMpCiAgfQp9CiMgVGVzdAplMWEgPC0gZW52KGVtcHR5X2VudigpLCBhID0gMSwgYiA9IDIpCmUxYiA8LSBlbnYoZTFhLCBiID0gMTAsIGMgPSAxMSkKZTFjIDwtIGVudihlMWIsIGEgPSAxMiwgZCA9IDEzKQp3aGVyZTIoImEiLCBlMWMpCmBgYAoKLS0tCgoyLiAgV3JpdGUgYSBmdW5jdGlvbiBjYWxsZWQgYGZnZXQoKWAgdGhhdCBmaW5kcyBvbmx5IGZ1bmN0aW9uIG9iamVjdHMuIEl0IAogICAgc2hvdWxkIGhhdmUgdHdvIGFyZ3VtZW50cywgYG5hbWVgIGFuZCBgZW52YCwgYW5kIHNob3VsZCBvYmV5IHRoZSByZWd1bGFyIAogICAgc2NvcGluZyBydWxlcyBmb3IgZnVuY3Rpb25zOiBpZiB0aGVyZSdzIGFuIG9iamVjdCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSAKICAgIHRoYXQncyBub3QgYSBmdW5jdGlvbiwgbG9vayBpbiB0aGUgcGFyZW50LiBGb3IgYW4gYWRkZWQgY2hhbGxlbmdlLCBhbHNvIAogICAgYWRkIGFuIGBpbmhlcml0c2AgYXJndW1lbnQgd2hpY2ggY29udHJvbHMgd2hldGhlciB0aGUgZnVuY3Rpb24gcmVjdXJzZXMgdXAgCiAgICB0aGUgcGFyZW50cyBvciBvbmx5IGxvb2tzIGluIG9uZSBlbnZpcm9ubWVudC4KCmBgYHtyfQpmZ2V0IDwtIGZ1bmN0aW9uKG5hbWUsIGVudiA9IGNhbGxlcl9lbnYoKSwgaW5oZXJpdHMgPSBUUlVFKSB7CiAgaWYgKGlkZW50aWNhbChlbnYsIGVtcHR5X2VudigpKSkgewogICAgIyBCYXNlIGNhc2UKICAgIHN0b3AoIkNhbid0IGZpbmQgIiwgbmFtZSwgY2FsbC4gPSBGQUxTRSkKICB9IGVsc2UgaWYgKGVudl9oYXMoZW52LCBuYW1lKSAmJiBpcy5mdW5jdGlvbihlbnZbW25hbWVdXSkpIHsKICAgICMgU3VjY2VzcyBjYXNlCiAgICBlbnYKICB9IGVsc2UgaWYgKGluaGVyaXRzKSB7CiAgICAjIFJlY3Vyc2l2ZSBjYXNlCiAgICBmZ2V0KG5hbWUsIGVudl9wYXJlbnQoZW52KSkKICB9IGVsc2UgewogICAgc3RvcCgiQ2FuJ3QgZmluZCAiLCBuYW1lLCBjYWxsLiA9IEZBTFNFKQogIH0KfQoKdHJ5KGZnZXQoIngiKSkKZmdldCgicHJpbnQiKQp0cnkoZmdldCgicHJpbnQiLCBpbmhlcml0cyA9IEZBTFNFKSkKZmdldCgiYWxsX3doZXJlIiwgaW5oZXJpdHMgPSBGQUxTRSkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IFdlIGZvbGxvdyBhIHNpbWlsYXIgYXBwcm9hY2ggdG8gdGhlIHByZXZpb3VzIGV4ZXJjaXNlLiBUaGlzIHRpbWUgd2UgYWRkaXRpb25hbGx5IGNoZWNrIGlmIHRoZSBmb3VuZCBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgaW1wbGVtZW50IGFuIGFyZ3VtZW50IHRvIHR1cm4gb2ZmIHRoZSByZWN1cnNpb24sIGlmIGRlc2lyZWQuCgpgYGB7cn0KZmdldCA8LSBmdW5jdGlvbihuYW1lLCBlbnYgPSBjYWxsZXJfZW52KCksIGluaGVyaXRzID0gVFJVRSkgewogICMgQmFzZSBjYXNlCiAgaWYgKGVudl9oYXMoZW52LCBuYW1lKSkgewogICAgb2JqIDwtIGVudl9nZXQoZW52LCBuYW1lKQogICAgaWYgKGlzLmZ1bmN0aW9uKG9iaikpIHsKICAgICAgcmV0dXJuKG9iaikKICAgIH0KICB9CiAgaWYgKGlkZW50aWNhbChlbnYsIGVtcHR5ZW52KCkpIHx8ICFpbmhlcml0cykgewogICAgc3RvcCgiQ291bGQgbm90IGZpbmQgYSBmdW5jdGlvbiBjYWxsZWQgXCIiLCBuYW1lLCAiXCIuIiwKICAgICAgY2FsbC4gPSBGQUxTRQogICAgKQogIH0KCiAgIyBSZWN1cnNpdmUgQ2FzZQogIGZnZXQobmFtZSwgZW52X3BhcmVudChlbnYpKQp9CgojIFRlc3QKbWVhbiA8LSAxMApmZ2V0KCJtZWFuIiwgaW5oZXJpdHMgPSBUUlVFKQpgYGAKCi0tLQoKIyMgNy40LjUgRXhlcmNpc2VzCgoxLiAgSG93IGlzIGBzZWFyY2hfZW52cygpYCBkaWZmZXJlbnQgZnJvbSBgZW52X3BhcmVudHMoZ2xvYmFsX2VudigpKWA/CgpBbnN3ZXI6IGBzZWFyY2hfZW52cygpYCBpbmNsdWRlcyB0aGUgZ2xvYmFsIGVudmlyb25tZW50LiBgZW52X3BhcmVudHMoZ2xvYmFsX2VudigpKWAgZG9lc24ndCBpbmNsdWRlIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQgYW5kIGFsc28gcmV0dXJucyB0aGUgZW1wdHkgZW52aXJvbm1lbnQgKHRoZSB0b3AgcGFyZW50KS4KCkFSIFNvbHV0aW9uczogYHNlYXJjaF9lbnZzKClgIHJldHVybnMgYWxsIHRoZSBlbnZpcm9ubWVudHMgb24gdGhlIHNlYXJjaCBwYXRoLCB3aGljaCBpcyAiYSBjaGFpbiBvZiBlbnZpcm9ubWVudHMgY29udGFpbmluZyBleHBvcnRlZCBmdW5jdGlvbnMgb2YgYXR0YWNoZWQgcGFja2FnZXMiIChmcm9tIGA/c2VhcmNoX2VudnNgKS4gRXZlcnkgdGltZSB5b3UgYXR0YWNoIGEgbmV3IHBhY2thZ2UsIHRoaXMgc2VhcmNoIHBhdGggd2lsbCBncm93LiBUaGUgc2VhcmNoIHBhdGggZW5kcyB3aXRoIHRoZSBiYXNlLWVudmlyb25tZW50LiBUaGUgZ2xvYmFsIGVudmlyb25tZW50IGlzIGluY2x1ZGVkLCBiZWNhdXNlIGZ1bmN0aW9ucyBwcmVzZW50IGluIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQgd2lsbCBhbHdheXMgYmUgcGFydCBvZiB0aGUgc2VhcmNoIHBhdGguCgpgZW52X3BhcmVudHMoZ2xvYmFsX2VudigpKWAgd2lsbCBsaXN0IGFsbCB0aGUgYW5jZXN0b3JzIG9mIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQsIHRoZXJlZm9yZSB0aGUgZ2xvYmFsIGVudmlyb25tZW50IGl0c2VsZiBpcyBub3QgaW5jbHVkZWQuIFRoaXMgYWxzbyBpbmNsdWRlcyB0aGUgInVsdGltYXRlIGFuY2VzdG9yIiwgdGhlIGVtcHR5IGVudmlyb25tZW50LiBUaGlzIGVudmlyb25tZW50IGlzIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHNlYXJjaCBwYXRoIGJlY2F1c2UgaXQgY29udGFpbnMgbm8gb2JqZWN0cy4KCi0tLQoKMi4gIERyYXcgYSBkaWFncmFtIHRoYXQgc2hvd3MgdGhlIGVuY2xvc2luZyBlbnZpcm9ubWVudHMgb2YgdGhpcyBmdW5jdGlvbjoKCmBgYHtyLCBldmFsID0gRkFMU0V9CmYxIDwtIGZ1bmN0aW9uKHgxKSB7CiAgZjIgPC0gZnVuY3Rpb24oeDIpIHsKICAgIGYzIDwtIGZ1bmN0aW9uKHgzKSB7CiAgICAgIHgxICsgeDIgKyB4MwogICAgfQogICAgZjMoMykKICB9CiAgZjIoMikKfQpmMSgxKQpgYGAKCkFuc3dlcjogTm8uCgotLS0KCjMuICBXcml0ZSBhbiBlbmhhbmNlZCB2ZXJzaW9uIG9mIGBzdHIoKWAgdGhhdCBwcm92aWRlcyBtb3JlIGluZm9ybWF0aW9uIAogICAgYWJvdXQgZnVuY3Rpb25zLiBTaG93IHdoZXJlIHRoZSBmdW5jdGlvbiB3YXMgZm91bmQgYW5kIHdoYXQgZW52aXJvbm1lbnQgCiAgICBpdCB3YXMgZGVmaW5lZCBpbi4KCmBgYHtyfQplX3N0ciA8LSBmdW5jdGlvbihvYmplY3QsIC4uLikgewogIHN0cihvYmplY3QsIC4uLikKICBpZiAoaXMuZnVuY3Rpb24ob2JqZWN0KSkgewogICAgbWVzc2FnZSgiZm5fZW52KCk6IikKICAgIHByaW50KGZuX2VudihvYmplY3QpKQogICAgbWVzc2FnZSgiZW52aXJvbm1lbnQoKToiKQogICAgcHJpbnQoZW52aXJvbm1lbnQob2JqZWN0KSkKICB9Cn0KCmVfc3RyKHByaW50KQplX3N0cihmZ2V0KQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogVG8gc29sdmUgdGhpcyBwcm9ibGVtLCB3ZSBuZWVkIHRvIHdyaXRlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGFuZCBsb29rcyBmb3IgdGhhdCBmdW5jdGlvbiByZXR1cm5pbmcgYm90aCB0aGUgZnVuY3Rpb24gYW5kIHRoZSBlbnZpcm9ubWVudCB0aGF0IGl0IHdhcyBmb3VuZCBpbi4KCmBgYHtyfQpmZ2V0MiA8LSBmdW5jdGlvbihuYW1lLCBlbnYgPSBjYWxsZXJfZW52KCkpIHsKICAjIEJhc2UgY2FzZQogIGlmIChlbnZfaGFzKGVudiwgbmFtZSkpIHsKICAgIG9iaiA8LSBlbnZfZ2V0KGVudiwgbmFtZSkKICAgIGlmIChpcy5mdW5jdGlvbihvYmopKSB7CiAgICAgIHJldHVybihsaXN0KGZ1biA9IG9iaiwgZW52ID0gZW52KSkKICAgIH0KICB9CiAgaWYgKGlkZW50aWNhbChlbnYsIGVtcHR5ZW52KCkpKSB7CiAgICBzdG9wKCJDb3VsZCBub3QgZmluZCBhIGZ1bmN0aW9uIGNhbGxlZCBcIiIsIG5hbWUsICJcIiIsCiAgICAgIGNhbGwuID0gRkFMU0UKICAgICkKICB9CiAgIyBSZWN1cnNpdmUgQ2FzZQogIGZnZXQyKG5hbWUsIGVudl9wYXJlbnQoZW52KSkKfQoKZnN0ciA8LSBmdW5jdGlvbihmdW5fbmFtZSwgZW52ID0gY2FsbGVyX2VudigpKSB7CiAgaWYgKCFpcy5jaGFyYWN0ZXIoZnVuX25hbWUpICYmIGxlbmd0aChmdW5fbmFtZSkgPT0gMSkgewogICAgc3RvcCgiYGZ1bl9uYW1lYCBtdXN0IGJlIGEgc3RyaW5nLiIsIGNhbGwuID0gRkFMU0UpCiAgfQogIGZ1bl9lbnYgPC0gZmdldDIoZnVuX25hbWUsIGVudikKICBsaXN0KAogICAgd2hlcmUgPSBmdW5fZW52JGVudiwKICAgIGVuY2xvc2luZyA9IGZuX2VudihmdW5fZW52JGZ1bikKICApCn0KCiMgVGVzdApmc3RyKCJtZWFuIikKYGBgCgpPbmNlIHlvdSBoYXZlIGxlYXJuZWQgYWJvdXQgdGlkeSBldmFsdWF0aW9uLCB5b3UgY291bGQgcmV3cml0ZSBgZnN0cigpYCB0byB1c2UgYGVucXVvKClgIHNvIHRoYXQgeW91J2QgY2FsbCBpdCBtb3JlIGxpa2UgYHN0cigpYCwgaS5lLiBgZnN0cihzdW0pYC4KCi0tLQoKIyMgNy41LjUgRXhlcmNpc2VzCgoxLiAgV3JpdGUgYSBmdW5jdGlvbiB0aGF0IGxpc3RzIGFsbCB0aGUgdmFyaWFibGVzIGRlZmluZWQgaW4gdGhlIGVudmlyb25tZW50CiAgICBpbiB3aGljaCBpdCB3YXMgY2FsbGVkLiBJdCBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgYGxzKClgLgoKYGBge3J9Cm15X2xzIDwtIGZ1bmN0aW9uKCkgewogIHZhcnMgPC0gc29ydChuYW1lcyhwYXJlbnQuZnJhbWUoKSkpCiAgdmFyc1shc3RhcnRzV2l0aCh2YXJzLCAiLiIpXQp9CgpscygpCm15X2xzKCkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IFdlIGNhbiBpbXBsZW1lbnQgdGhpcyBkeW5hbWljIHNjb3BpbmcgYmVoYXZpb3VyIGJ5IGV4cGxpY2l0bHkgcmVmZXJlbmNpbmcgdGhlIGNhbGxlciBlbnZpcm9ubWVudC4gUGxlYXNlIG5vdGUgdGhhdCB0aGlzIGFwcHJvYWNoIHJldHVybnMgYWxzbyB2YXJpYWJsZXMgc3RhcnRpbmcgd2l0aCBhIGRvdCwgYW4gb3B0aW9uIHRoYXQgYGxzKClgIHVzdWFsbHkgcmVxdWlyZXMuCgpgYGB7cn0KbHMyIDwtIGZ1bmN0aW9uKGVudiA9IGNhbGxlcl9lbnYoKSkgewogIHNvcnQoZW52X25hbWVzKGVudikpCn0KCiMgVGVzdCBpbiBnbG9iYWwgZW52aXJvbm1lbnQKbHMoYWxsLm5hbWVzID0gVFJVRSkKbHMyKCkKCiMgVGVzdCBpbiAic2FuZGJveCIgZW52aXJvbm1lbnQKZTEgPC0gZW52KGEgPSAxLCBiID0gMikKbHMoZTEpCmxzMihlMSkKYGBgCgotLS0KCiMgOCBDb25kaXRpb25zCgpUaGUgX19jb25kaXRpb25fXyBzeXN0ZW0gcHJvdmlkZXMgYSBwYWlyZWQgc2V0IG9mIHRvb2xzIHRoYXQgYWxsb3cgdGhlIGF1dGhvciBvZiBhIGZ1bmN0aW9uIHRvIGluZGljYXRlIHRoYXQgc29tZXRoaW5nIHVudXN1YWwgaXMgaGFwcGVuaW5nLCBhbmQgdGhlIHVzZXIgb2YgdGhhdCBmdW5jdGlvbiB0byBkZWFsIHdpdGggaXQuIFRoZSBmdW5jdGlvbiBhdXRob3IgX19zaWduYWxzX18gY29uZGl0aW9ucyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBzdG9wKClgIChmb3IgZXJyb3JzKSwgYHdhcm5pbmcoKWAgKGZvciB3YXJuaW5ncyksIGFuZCBgbWVzc2FnZSgpYCAoZm9yIG1lc3NhZ2VzKSwgdGhlbiB0aGUgZnVuY3Rpb24gdXNlciBjYW4gaGFuZGxlIHRoZW0gd2l0aCBmdW5jdGlvbnMgbGlrZSBgdHJ5Q2F0Y2goKWAgYW5kIGB3aXRoQ2FsbGluZ0hhbmRsZXJzKClgLiBVbmRlcnN0YW5kaW5nIHRoZSBjb25kaXRpb24gc3lzdGVtIGlzIGltcG9ydGFudCBiZWNhdXNlIHlvdSdsbCBvZnRlbiBuZWVkIHRvIHBsYXkgYm90aCByb2xlczogc2lnbmFsbGluZyBjb25kaXRpb25zIGZyb20gdGhlIGZ1bmN0aW9ucyB5b3UgY3JlYXRlLCBhbmQgaGFuZGxlIGNvbmRpdGlvbnMgc2lnbmFsbGVkIGJ5IHRoZSBmdW5jdGlvbnMgeW91IGNhbGwuCgpSIG9mZmVycyBhIHZlcnkgcG93ZXJmdWwgY29uZGl0aW9uIHN5c3RlbSBiYXNlZCBvbiBpZGVhcyBmcm9tIENvbW1vbiBMaXNwLiBMaWtlIFIncyBhcHByb2FjaCB0byBvYmplY3Qtb3JpZW50ZWQgcHJvZ3JhbW1pbmcsIGl0IGlzIHJhdGhlciBkaWZmZXJlbnQgdG8gY3VycmVudGx5IHBvcHVsYXIgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzIHNvIGl0IGlzIGVhc3kgdG8gbWlzdW5kZXJzdGFuZCwgYW5kIHRoZXJlIGhhcyBiZWVuIHJlbGF0aXZlbHkgbGl0dGxlIHdyaXR0ZW4gYWJvdXQgaG93IHRvIHVzZSBpdCBlZmZlY3RpdmVseS4gSGlzdG9yaWNhbGx5LCB0aGlzIGhhcyBtZWFudCB0aGF0IGZldyBwZW9wbGUgKG15c2VsZiBpbmNsdWRlZCkgaGF2ZSB0YWtlbiBmdWxsIGFkdmFudGFnZSBvZiBpdHMgcG93ZXIuIFRoZSBnb2FsIG9mIHRoaXMgY2hhcHRlciBpcyB0byByZW1lZHkgdGhhdCBzaXR1YXRpb24uIEhlcmUgeW91IHdpbGwgbGVhcm4gYWJvdXQgdGhlIGJpZyBpZGVhcyBvZiBSJ3MgY29uZGl0aW9uIHN5c3RlbSwgYXMgd2VsbCBhcyBsZWFybmluZyBhIGJ1bmNoIG9mIHByYWN0aWNhbCB0b29scyB0aGF0IHdpbGwgbWFrZSB5b3VyIGNvZGUgc3Ryb25nZXIuCgpJIGZvdW5kIHR3byByZXNvdXJjZXMgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHdyaXRpbmcgdGhpcyBjaGFwdGVyLiBZb3UgbWF5IGFsc28gd2FudCB0byByZWFkIHRoZW0gaWYgeW91IHdhbnQgdG8gbGVhcm4gbW9yZSBhYm91dCB0aGUgaW5zcGlyYXRpb25zIGFuZCBtb3RpdmF0aW9ucyBmb3IgdGhlIHN5c3RlbToKCiogW19BIHByb3RvdHlwZSBvZiBhIGNvbmRpdGlvbiBzeXN0ZW0gZm9yIFJfXShodHRwczovL2hvbWVwYWdlLnN0YXQudWlvd2EuZWR1L35sdWtlL1IvZXhjZXB0aW9ucy9zaW1wY29uZC5odG1sKSBieSBSb2JlcnQgR2VudGxlbWFuIAogIGFuZCBMdWtlIFRpZXJuZXkuIFRoaXMgZGVzY3JpYmVzIGFuIGVhcmx5IHZlcnNpb24gb2YgUidzIGNvbmRpdGlvbiBzeXN0ZW0uIAogIFdoaWxlIHRoZSBpbXBsZW1lbnRhdGlvbiBoYXMgY2hhbmdlZCBzb21ld2hhdCBzaW5jZSB0aGlzIGRvY3VtZW50IHdhcyAKICB3cml0dGVuLCBpdCBwcm92aWRlcyBhIGdvb2Qgb3ZlcnZpZXcgb2YgaG93IHRoZSBwaWVjZXMgZml0IHRvZ2V0aGVyLCBhbmQgCiAgc29tZSBtb3RpdmF0aW9uIGZvciBpdHMgZGVzaWduLgoKKiBbX0JleW9uZCBleGNlcHRpb24gaGFuZGxpbmc6IGNvbmRpdGlvbnMgYW5kIHJlc3RhcnRzX10oaHR0cHM6Ly9naWdhbW9ua2V5cy5jb20vYm9vay9iZXlvbmQtZXhjZXB0aW9uLWhhbmRsaW5nLWNvbmRpdGlvbnMtYW5kLXJlc3RhcnRzLmh0bWwpCiAgYnkgUGV0ZXIgU2VpYmVsLiBUaGlzIGRlc2NyaWJlcyBleGNlcHRpb24gaGFuZGxpbmcgaW4gTGlzcCwgd2hpY2ggaGFwcGVucyAKICB0byBiZSB2ZXJ5IHNpbWlsYXIgdG8gUidzIGFwcHJvYWNoLiBJdCBwcm92aWRlcyB1c2VmdWwgbW90aXZhdGlvbiBhbmQgCiAgbW9yZSBzb3BoaXN0aWNhdGVkIGV4YW1wbGVzLiBJIGhhdmUgcHJvdmlkZWQgYW4gUiB0cmFuc2xhdGlvbiBvZiB0aGUgCiAgY2hhcHRlciBhdCA8aHR0cDovL2Fkdi1yLmhhZC5jby5uei9iZXlvbmQtZXhjZXB0aW9uLWhhbmRsaW5nLmh0bWw+LgoKSSBhbHNvIGZvdW5kIGl0IGhlbHBmdWwgdG8gd29yayB0aHJvdWdoIHRoZSB1bmRlcmx5aW5nIEMgY29kZSB0aGF0IGltcGxlbWVudHMgdGhlc2UgaWRlYXMuIElmIHlvdSdyZSBpbnRlcmVzdGVkIGluIHVuZGVyc3RhbmRpbmcgaG93IGl0IGFsbCB3b3JrcywgeW91IG1pZ2h0IGZpbmQgW215IG5vdGVzXShodHRwczovL2dpc3QuZ2l0aHViLmNvbS9oYWRsZXkvNDI3OGQwYTZkM2ExMGU0MjUzM2Q1OTkwNWZiZWQwYWMpIHRvIGJlIHVzZWZ1bC4KCmBgYHtyfQpybShsaXN0ID0gbHMoKSkKYGBgCgojIyA4LjIuNCBFeGVyY2lzZXMKCjEuICBXcml0ZSBhIHdyYXBwZXIgYXJvdW5kIGBmaWxlLnJlbW92ZSgpYCB0aGF0IHRocm93cyBhbiBlcnJvciBpZiB0aGUgZmlsZQogICAgdG8gYmUgZGVsZXRlZCBkb2VzIG5vdCBleGlzdC4KCmBgYHtyfQpzYWZlX2ZpbGVfcmVtb3ZlIDwtIGZ1bmN0aW9uKC4uLikgewogIGlmICghZmlsZS5leGlzdHMoLi4uKSkgc3RvcCgiZmlsZSAnIiwgLi4uLCAiJyBkb2VzIG5vdCBleGlzdCIpCiAgZmlsZS5yZW1vdmUoLi4uKQp9Cgp0bXAgPC0gdGVtcGZpbGUoKQoKZmlsZS5jcmVhdGUodG1wKQpzYWZlX2ZpbGVfcmVtb3ZlKHRtcCkKZmlsZS5yZW1vdmUodG1wKQp0cnkoc2FmZV9maWxlX3JlbW92ZSh0bXApKQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogV2UgcHJlZmVyIHRoZSBmb2xsb3dpbmcgc29sdXRpb24gZm9yIGl0cyBjbGFyaXR5IGFuZCBzaW1wbGljaXR5OgoKYGBge3IsIGVycm9yID0gVFJVRX0KZmlsZV9yZW1vdmVfc3RyaWN0IDwtIGZ1bmN0aW9uKHBhdGgpIHsKICBpZiAoIWZpbGUuZXhpc3RzKHBhdGgpKSB7CiAgICBzdG9wKCJDYW4ndCBkZWxldGUgdGhlIGZpbGUgXCIiLCBwYXRoLAogICAgICAiXCIgYmVjYXVzZSBpdCBkb2Vzbid0IGV4aXN0LiIsCiAgICAgIGNhbGwuID0gRkFMU0UKICAgICkKICB9CiAgZmlsZS5yZW1vdmUocGF0aCkKfQoKIyBUZXN0CnNhdmVSRFMobXRjYXJzLCAibXRjYXJzLnJkcyIpCmZpbGVfcmVtb3ZlX3N0cmljdCgibXRjYXJzLnJkcyIpCnRyeShmaWxlX3JlbW92ZV9zdHJpY3QoIm10Y2Fycy5yZHMiKSkKYGBgCgotLS0KCjIuICBXaGF0IGRvZXMgdGhlIGBhcHBlbmRMRmAgYXJndW1lbnQgdG8gYG1lc3NhZ2UoKWAgZG8/IEhvdyBpcyBpdCByZWxhdGVkIHRvCiAgICBgY2F0KClgPwoKQW5zd2VyOiBgYXBwZW5kTEZgIGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGEgbmV3bGluZSBpcyBhZGRlZCB0byB0aGUgbWVzc2FnZTsgYnkgZGVmYXVsdCwgYGNhdCgpYCBkb2VzIG5vdCBhZGQgYSBuZXdsaW5lLgoKQVIgU29sdXRpb25zOiBUaGUgYGFwcGVuZExGYCBhcmd1bWVudCBhdXRvbWF0aWNhbGx5IGFwcGVuZHMgYSBuZXcgbGluZSB0byB0aGUgbWVzc2FnZS4KCkNvbXBhcmFibGUgYmVoYXZpb3VyIHJlZ2FyZGluZyBsaW5lIGJyZWFrcyBmb3IgYGNhdCgpYCBjYW4gYmUgYWNoaWV2ZWQgdmlhIHNldHRpbmcgaXRzIGBzZXBgIGFyZ3VtZW50IHRvIGAiXG4iYC4KCi0tLQoKIyMgOC40LjUgRXhlcmNpc2VzCgoxLiAgV2hhdCBleHRyYSBpbmZvcm1hdGlvbiBkb2VzIHRoZSBjb25kaXRpb24gZ2VuZXJhdGVkIGJ5IGBhYm9ydCgpYCBjb250YWluCiAgICBjb21wYXJlZCB0byB0aGUgY29uZGl0aW9uIGdlbmVyYXRlZCBieSBgc3RvcCgpYCBpLmUuIHdoYXQncyB0aGUgZGlmZmVyZW5jZQogICAgYmV0d2VlbiB0aGVzZSB0d28gb2JqZWN0cz8gUmVhZCB0aGUgaGVscCBmb3IgYD9hYm9ydGAgdG8gbGVhcm4gbW9yZS4KCmBgYHtyfQpjYXRjaF9jbmQoc3RvcCgiQW4gZXJyb3IiKSkKY2F0Y2hfY25kKGFib3J0KCJBbiBlcnJvciIpKQpgYGAKCkFuc3dlcjogYGFib3J0KClgIGluY2x1ZGVzIHRoZSBlcnJvciBtZXNzYWdlIGFuZCBiYWNrdHJhY2UgaW4gdGhlIGNvbmRpdGlvbiBvYmplY3QuIGBhYm9ydCgpYCB1c2VzIHRoZSBjdXN0b20gY2xhc3MgYHJsYW5nX2Vycm9yYC4KCkFSIFNvbHV0aW9uczogSW4gY29udHJhc3QgdG8gYHN0b3AoKWAsIHdoaWNoIGNvbnRhaW5zIHRoZSBjYWxsLCBgYWJvcnQoKWAgc3RvcmVzIHRoZSB3aG9sZSBiYWNrdHJhY2UgZ2VuZXJhdGVkIGJ5IGBybGFuZzo6dHJhY2VfYmFjaygpYC4gVGhpcyBpcyBhIGxvdCBvZiBleHRyYSBkYXRhIQoKLS0tCgoyLiAgUHJlZGljdCB0aGUgcmVzdWx0cyBvZiBldmFsdWF0aW5nIHRoZSBmb2xsb3dpbmcgY29kZQoKYGBge3J9CnNob3dfY29uZGl0aW9uIDwtIGZ1bmN0aW9uKGNvZGUpIHsKICB0cnlDYXRjaCgKICAgIGVycm9yID0gZnVuY3Rpb24oY25kKSAiZXJyb3IiLAogICAgd2FybmluZyA9IGZ1bmN0aW9uKGNuZCkgIndhcm5pbmciLAogICAgbWVzc2FnZSA9IGZ1bmN0aW9uKGNuZCkgIm1lc3NhZ2UiLAogICAgewogICAgICBjb2RlCiAgICAgIE5VTEwKICAgIH0KICApCn0KCnNob3dfY29uZGl0aW9uKHN0b3AoIiEiKSkgIz4gImVycm9yIgpzaG93X2NvbmRpdGlvbigxMCkgIz4gMTAgW05VTExdCnNob3dfY29uZGl0aW9uKHdhcm5pbmcoIj8hIikpICM+ICJ3YXJuaW5nIgpzaG93X2NvbmRpdGlvbih7CiAgMTAKICBtZXNzYWdlKCI/IikKICB3YXJuaW5nKCI/ISIpCn0pCiM+IDEwCiM+ICJtZXNzYWdlIgojPiAid2FybmluZyIKYGBgCgpBbnN3ZXI6IHByZWRpY3Rpb25zIGluIGNvbW1lbnRzLiBUaGUgcHJlZGljdGlvbiBmb3IgYHNob3dfY29uZGl0aW9uKDEwKWAgd2FzIGluY29ycmVjdDsgdGhlIGNvcnJlY3QgYW5zd2VyIGlzIGBOVUxMYCBhcyB0aGF0J3Mgd2hhdCdzIHJldHVybmVkIHdoZW4gdGhlcmUgaXMgbm8gY29uZGl0aW9uLiBUaGUgZmluYWwgcHJlZGljdGlvbiB3YXMgYWxzbyBpbmNvcnJlY3Q7IHRoZSBgdHJ5Q2F0Y2goKWAgY2FsbCBzdG9wcyBmdXJ0aGVyIGV4ZWN1dGlvbiB3aGVuIHRoZSBgbWVzc2FnZSgpYCBpcyBjYXVnaHQuCgpBUiBTb2x1dGlvbnM6IFRoZSBmaXJzdCB0aHJlZSBleGFtcGxlcyBhcmUgc3RyYWlnaHRmb3J3YXJkOgoKYGBge3J9CnNob3dfY29uZGl0aW9uKHN0b3AoIiEiKSkgIyBzdG9wIHJhaXNlcyBhbiBlcnJvcgpzaG93X2NvbmRpdGlvbigxMCkgIyBubyBjb25kaXRpb24gaXMgc2lnbmFsbGVkCnNob3dfY29uZGl0aW9uKHdhcm5pbmcoIj8hIikpICMgd2FybmluZyByYWlzZXMgYSB3YXJuaW5nCmBgYAoKVGhlIGxhc3QgZXhhbXBsZSBpcyB0aGUgbW9zdCBpbnRlcmVzdGluZyBhbmQgbWFrZXMgdXMgYXdhcmUgb2YgdGhlIGV4aXRpbmcgcXVhbGl0aWVzIG9mIGB0cnlDYXRjaCgpYDsgaXQgd2lsbCB0ZXJtaW5hdGUgdGhlIGV2YWx1YXRpb24gb2YgdGhlIGNvZGUgYXMgc29vbiBhcyBpdCBpcyBjYWxsZWQuCgpgYGB7cn0Kc2hvd19jb25kaXRpb24oewogIDEwCiAgbWVzc2FnZSgiPyIpCiAgd2FybmluZygiPyEiKQp9KQpgYGAKCi0tLQoKMy4gIEV4cGxhaW4gdGhlIHJlc3VsdHMgb2YgcnVubmluZyB0aGlzIGNvZGU6CgpgYGB7cn0Kd2l0aENhbGxpbmdIYW5kbGVycygKICBtZXNzYWdlID0gZnVuY3Rpb24oY25kKSBtZXNzYWdlKCJiIiksICMgaGFuZGxlciAxCiAgd2l0aENhbGxpbmdIYW5kbGVycygKICAgIG1lc3NhZ2UgPSBmdW5jdGlvbihjbmQpIG1lc3NhZ2UoImEiKSwgIyBoYW5kbGVyIDIKICAgIG1lc3NhZ2UoImMiKQogICkKKQpgYGAKCkFuc3dlcjoKCjEuIGBtZXNzYWdlKCJjIilgIGlzIGNhdWdodCwgaGFuZGxlciAyIGlzIGNhbGxlZAoxLiBpbiBoYW5kbGVyIDIsIGBtZXNzYWdlKCJhIilgIGlzIGNhdWdodCBhbmQgaGFuZGxlciAxIGlzIGNhbGxlZAoxLiBoYW5kbGVyIDEgd3JpdGVzIG1lc3NhZ2UgYGJgCjEuIGNvZGUgcmVzdW1lcyBhbmQgaGFuZGxlciAyIHdyaXRlcyBtZXNzYWdlIGBhYAoxLiBgbWVzc2FnZSgiYyIpYCBwcm9wYWdhdGVzIHRvIHRoZSBwYXJlbnQsIGlzIGNhdWdodCwgYW5kIGhhbmRsZXIgMSBpcyBjYWxsZWQKMS4gaGFuZGxlciAxIHdyaXRlcyBtZXNzYWdlIGBiYAoxLiBjb2RlIHJlc3VtZXMgYW5kIHRoZSBjb2RlIHdyaXRlcyBtZXNzYWdlIGBjYAoKCkFSIFNvbHV0aW9uczogSXQncyBhIGxpdHRsZSB0cmlja3kgdG8gdW50YW5nbGUgdGhlIGZsb3cgaGVyZToKRmlyc3QsIGBtZXNzYWdlKCJjIilgIGlzIHJ1biwgYW5kIGl0J3MgY2F1Z2h0IGJ5ICgxKS4gSXQgdGhlbiBjYWxscyBgbWVzc2FnZSgiYSIpYCwgd2hpY2ggaXMgY2F1Z2h0IGJ5ICgyKSwgd2hpY2ggY2FsbHMgYG1lc3NhZ2UoImIiKWAuIGBtZXNzYWdlKCJiIilgIGlzbid0IGNhdWdodCBieSBhbnl0aGluZywgc28gd2Ugc2VlIGEgYGJgIG9uIHRoZSBjb25zb2xlLCBmb2xsb3dlZCBieSBgYWAuIEJ1dCB3aHkgZG8gd2UgZ2V0IGFub3RoZXIgYGJgIGJlZm9yZSB3ZSBzZWUgYGNgPyBUaGF0J3MgYmVjYXVzZSB3ZSBoYXZlbid0IGhhbmRsZWQgdGhlIG1lc3NhZ2UsIHNvIGl0IGJ1YmJsZXMgdXAgdG8gdGhlIG91dGVyIGNhbGxpbmcgaGFuZGxlci4KCi0tLQoKNC4gIFJlYWQgdGhlIHNvdXJjZSBjb2RlIGZvciBgY2F0Y2hfY25kKClgIGFuZCBleHBsYWluIGhvdyBpdCB3b3Jrcy4KCmBgYHtyfQpjYXRjaF9jbmQKCmNhdGNoX2NuZChzdG9wKCJlcnJvciIpKQoKIyByZXBsaWNhdGUgdGhlIGNvcmUgZnVuY3Rpb25hbGl0eQp0cnlDYXRjaChjb25kaXRpb24gPSBmdW5jdGlvbih4KSB4LCBmb3JjZShzdG9wKCJlcnJvciIpKSkKYGBgCgpBbnN3ZXI6IGBjYXRjaF9jbmQoKWAgdXNlcyBgdHJ5Q2F0Y2goKWAgdG8gY2F0Y2ggYW55IGNvbmRpdGlvbiBhbmQgcmV0dXJuIGl0c2VsZiB1c2luZyBgaWRlbnRpdHkoKWAuCgpBUiBTb2x1dGlvbnM6IEF0IHRoZSB0aW1lICpBZHZhbmNlZCBSKiB3YXMgd3JpdHRlbiwgdGhlIHNvdXJjZSBmb3IgYGNhdGNoX2NuZCgpYCB3YXMgYSBsaXR0bGUgc2ltcGxlcjoKCmBgYHtyfQpjYXRjaF9jbmQgPC0gZnVuY3Rpb24oZXhwcikgewogIHRyeUNhdGNoKAogICAgY29uZGl0aW9uID0gZnVuY3Rpb24oY25kKSBjbmQsCiAgICB7CiAgICAgIGZvcmNlKGV4cHIpCiAgICAgIHJldHVybihOVUxMKQogICAgfQogICkKfQpgYGAKCmBjYXRjaF9jbmQoKWAgaXMgYSBzaW1wbGUgd3JhcHBlciBhcm91bmQgYHRyeUNhdGNoKClgLiBJZiBhIGNvbmRpdGlvbiBpcyBzaWduYWxsZWQsIGl0J3MgY2F1Z2h0IGFuZCByZXR1cm5lZC4gSWYgbm8gY29uZGl0aW9uIGlzIHNpZ25hbGxlZCwgZXhlY3V0aW9uIHByb2NlZWRzIHNlcXVlbnRpYWxseSBhbmQgdGhlIGZ1bmN0aW9uIHJldHVybnMgYE5VTExgLgoKVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBgY2F0Y2hfY25kKClgIGlzIGEgbGl0dGxlIG1vcmUgY29tcGxleCBiZWNhdXNlIGl0IGFsbG93cyB5b3UgdG8gc3BlY2lmeSB3aGljaCBjbGFzc2VzIG9mIGNvbmRpdGlvbiB5b3Ugd2FudCB0byBjYXB0dXJlLiBUaGlzIHJlcXVpcmVzIHNvbWUgbWFudWFsIGNvZGUgZ2VuZXJhdGlvbiBiZWNhdXNlIHRoZSBpbnRlcmZhY2Ugb2YgYHRyeUNhdGNoKClgIHByb3ZpZGVzIGNvbmRpdGlvbiBjbGFzc2VzIGFzIGFyZ3VtZW50IG5hbWVzLgoKLS0tCgo1LiAgSG93IGNvdWxkIHlvdSByZXdyaXRlIGBzaG93X2NvbmRpdGlvbigpYCB0byB1c2UgYSBzaW5nbGUgaGFuZGxlcj8KCmBgYHtyfQpzaG93X2NvbmRpdGlvbjIgPC0gZnVuY3Rpb24oY29kZSkgewogIHRyeUNhdGNoKAogICAgY29uZGl0aW9uID0gZnVuY3Rpb24oY25kKSB7CiAgICAgIGlmIChpc19lcnJvcihjbmQpKSB7CiAgICAgICAgcmV0dXJuKCJlcnJvciIpCiAgICAgIH0KICAgICAgaWYgKGlzX3dhcm5pbmcoY25kKSkgewogICAgICAgIHJldHVybigid2FybmluZyIpCiAgICAgIH0KICAgICAgaWYgKGlzX21lc3NhZ2UoY25kKSkgewogICAgICAgIHJldHVybigibWVzc2FnZSIpCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgIGNvZGUKICAgICAgTlVMTAogICAgfQogICkKfQoKc2hvd19jb25kaXRpb24yKHN0b3AoIiEiKSkKc2hvd19jb25kaXRpb24yKDEwKQpzaG93X2NvbmRpdGlvbjIod2FybmluZygiPyEiKSkKc2hvd19jb25kaXRpb24yKHsKICAxMAogIG1lc3NhZ2UoIj8iKQogIHdhcm5pbmcoIj8hIikKfSkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IGBzaG93X2NvbmRpdGlvbigpYCB3YXMgZGVmaW5lZCBpbiBvbmUgb2YgdGhlIHByZXZpb3VzIHF1ZXN0aW9ucy4gTGV0J3MgdXNlIHRoZSBgY29uZGl0aW9uYCBhcmd1bWVudCBvZiBgdHJ5Q2F0Y2goKWAgYXMgc2hvd24gaW4gYHJsYW5nOjpjYXRjaF9jb25kKClgIGFib3ZlIGZvciBvdXIgcmUtaW1wbGVtZW50YXRpb246CgpgYGB7cn0Kc2hvd19jb25kaXRpb24yIDwtIGZ1bmN0aW9uKGNvZGUpIHsKICB0cnlDYXRjaCgKICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKGNuZCkgewogICAgICBpZiAoaW5oZXJpdHMoY25kLCAiZXJyb3IiKSkgewogICAgICAgIHJldHVybigiZXJyb3IiKQogICAgICB9CiAgICAgIGlmIChpbmhlcml0cyhjbmQsICJ3YXJuaW5nIikpIHsKICAgICAgICByZXR1cm4oIndhcm5pbmciKQogICAgICB9CiAgICAgIGlmIChpbmhlcml0cyhjbmQsICJtZXNzYWdlIikpIHsKICAgICAgICByZXR1cm4oIm1lc3NhZ2UiKQogICAgICB9CiAgICB9LAogICAgewogICAgICBjb2RlCiAgICAgIE5VTEwKICAgIH0KICApCn0KCiMgVGVzdApzaG93X2NvbmRpdGlvbjIoc3RvcCgiISIpKQpzaG93X2NvbmRpdGlvbjIoMTApCnNob3dfY29uZGl0aW9uMih3YXJuaW5nKCI/ISIpKQpzaG93X2NvbmRpdGlvbjIoewogIDEwCiAgbWVzc2FnZSgiPyIpCiAgd2FybmluZygiPyEiKQp9KQpgYGAKCmB0cnlDYXRjaCgpYCBleGVjdXRlcyB0aGUgY29kZSBhbmQgY2FwdHVyZXMgYW55IGNvbmRpdGlvbiByYWlzZWQuIFRoZSBmdW5jdGlvbiBwcm92aWRlZCBhcyB0aGUgYGNvbmRpdGlvbmAgaGFuZGxlcyB0aGlzIGNvbmRpdGlvbi4gSW4gdGhpcyBjYXNlIGl0IGRpc3BhdGNoZXMgb24gdGhlIGNsYXNzIG9mIHRoZSBjb25kaXRpb24uCgotLS0KCiMjIDguNS40IEV4ZXJjaXNlcwoKMS4gIEluc2lkZSBhIHBhY2thZ2UsIGl0J3Mgb2NjYXNpb25hbGx5IHVzZWZ1bCB0byBjaGVjayB0aGF0IGEgcGFja2FnZSBpcyAKICAgIGluc3RhbGxlZCBiZWZvcmUgdXNpbmcgaXQuIFdyaXRlIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBwYWNrYWdlIGlzIAogICAgaW5zdGFsbGVkICh3aXRoIGByZXF1aXJlTmFtZXNwYWNlKCJwa2ciLCBxdWlldGx5ID0gRkFMU0UpKWAgYW5kIGlmIG5vdCwKICAgIHRocm93cyBhIGN1c3RvbSBjb25kaXRpb24gdGhhdCBpbmNsdWRlcyB0aGUgcGFja2FnZSBuYW1lIGluIHRoZSBtZXRhZGF0YS4KCmBgYHtyfQpteV9jaGVja19pbnN0YWxsZWQgPC0gZnVuY3Rpb24ocGtnKSB7CiAgaWYgKCFyZXF1aXJlTmFtZXNwYWNlKHBrZywgcXVpZXRseSA9IFRSVUUpKSB7CiAgICBhYm9ydCgKICAgICAgImVycm9yX25vdF9mb3VuZCIsCiAgICAgIG1lc3NhZ2UgPSBwYXN0ZTAoInBhY2thZ2UgJyIsIHBrZywgIicgbm90IGZvdW5kIiksCiAgICAgIHBrZyA9IHBrZwogICAgKQogIH0KfQoKbXlfY2hlY2tfaW5zdGFsbGVkKCJybGFuZyIpCiMgTk9URTogdGhpcyBjb2RlIGNhdXNlcyByZW52OjpkZXBlbmRlbmNpZXMoKSB0byBtaXN0YWtlbmx5IHJlcG9ydCBwYWNrYWdlICdwa2cnIGFzIGEgZGVwZW5kZW5jeQojIG5vbGludCBzdGFydDogY29tbWVudGVkX2NvZGVfbGludGVyLgojIHJlcXVpcmVOYW1lc3BhY2UoInBrZyIsIHF1aWV0bHkgPSBGQUxTRSkKIyBlcnIgPC0gY2F0Y2hfY25kKG15X2NoZWNrX2luc3RhbGxlZCgicGtnIikpCiMgZXJyCiMgZXJyJHBrZwojIG5vbGludCBlbmQKdHJ5KG15X2NoZWNrX2luc3RhbGxlZCgicGtnIikpCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLiBUaGUgcXVlc3Rpb24gc3BlY2lmaWVzIHRvIHVzZSBgcXVpZXRseSA9IEZBTFNFYCwgYnV0IHRoaXMgYXBwcm9hY2ggbWFrZXMgbW9yZSBzZW5zZSAodG8gbWUpLiBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gY2F0Y2ggdGhlICdGYWlsZWQgd2l0aCBlcnJvcjonIG1lc3NhZ2Ugd2hpY2ggc2VlbXMgbGVzcyByZWxpYWJsZS4KCmBgYHtyfQpteV9jaGVja19pbnN0YWxsZWQyIDwtIGZ1bmN0aW9uKHBrZykgewogIHRyeUNhdGNoKAogICAgY29uZGl0aW9uID0gZnVuY3Rpb24oY25kKSB7CiAgICAgIGFib3J0KAogICAgICAgICJlcnJvcl9ub3RfZm91bmQiLAogICAgICAgIG1lc3NhZ2UgPSBwYXN0ZTAoInBhY2thZ2UgJyIsIHBrZywgIicgbm90IGZvdW5kIiksCiAgICAgICAgcGtnID0gcGtnCiAgICAgICkKICAgIH0sCiAgICByZXF1aXJlTmFtZXNwYWNlKHBrZywgcXVpZXRseSA9IEZBTFNFKQogICkKfQoKbXlfY2hlY2tfaW5zdGFsbGVkMigicmxhbmciKQp0cnkobXlfY2hlY2tfaW5zdGFsbGVkMigicGtnIikpCmBgYAoKVGhlIGFsdGVybmF0aXZlIHZlcnNpb24sIGBteV9jaGVja19pbnN0YWxsZWQyKClgIHdvcmtzIGJ1dCBpdHMgQmFja3RyYWNlIGlzIGhhcmRlciB0byByZWFkLgoKQVIgU29sdXRpb25zOiBXZSB1c2UgYHJsYW5nOjphYm9ydCgpYCB0byBzdXBwbHkgZXJyb3IgbWV0YWRhdGE6CgpgYGB7ciwgZXJyb3IgPSBUUlVFfQpjaGVja19pbnN0YWxsZWQgPC0gZnVuY3Rpb24ocGFja2FnZSkgewogIGlmICghcmVxdWlyZU5hbWVzcGFjZShwYWNrYWdlLCBxdWlldGx5ID0gRkFMU0UpKSB7CiAgICBhYm9ydCgKICAgICAgImVycm9yX3BrZ19ub3RfZm91bmQiLAogICAgICBtZXNzYWdlID0gcGFzdGUwKCJwYWNrYWdlICciLCBwYWNrYWdlLCAiJyBub3QgaW5zdGFsbGVkLiIpLAogICAgICBwYWNrYWdlID0gcGFja2FnZQogICAgKQogIH0KICBUUlVFCn0KY2hlY2tfaW5zdGFsbGVkKCJybGFuZyIpCnRyeShjaGVja19pbnN0YWxsZWQoImdncGxvdDMiKSkKYGBgCgotLS0KCjIuICBJbnNpZGUgYSBwYWNrYWdlIHlvdSBvZnRlbiBuZWVkIHRvIHN0b3Agd2l0aCBhbiBlcnJvciB3aGVuIHNvbWV0aGluZwogICAgaXMgbm90IHJpZ2h0LiBPdGhlciBwYWNrYWdlcyB0aGF0IGRlcGVuZCBvbiB5b3VyIHBhY2thZ2UgbWlnaHQgYmUKICAgIHRlbXB0ZWQgdG8gY2hlY2sgdGhlc2UgZXJyb3JzIGluIHRoZWlyIHVuaXQgdGVzdHMuIEhvdyBjb3VsZCB5b3UgaGVscAogICAgdGhlc2UgcGFja2FnZXMgdG8gYXZvaWQgcmVseWluZyBvbiB0aGUgZXJyb3IgbWVzc2FnZSB3aGljaCBpcyBwYXJ0IG9mCiAgICB0aGUgdXNlciBpbnRlcmZhY2UgcmF0aGVyIHRoYW4gdGhlIEFQSSBhbmQgbWlnaHQgY2hhbmdlIHdpdGhvdXQgbm90aWNlPwoKQW5zd2VyOiByZXR1cm4gY3VzdG9tIGVycm9yIG9iamVjdHMgdGhhdCBhcmVuJ3QgZGVwZW5kZW50IG9uIHRoZSBlcnJvciB0ZXh0IChsaWtlIGluIDguNS4zKQoKQVIgU29sdXRpb25zOiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciBpdCBtaWdodCBiZSBwcmVmZXJhYmxlIHRvIHRocm93IGEgY3VzdG9taXNlZCBjb25kaXRpb24gYW5kIHBsYWNlIGEgc3RhbmRhcmRpc2VkIGVycm9yIG1lc3NhZ2UgaW5zaWRlIHRoZSBtZXRhZGF0YS4gVGhlbiB0aGUgZG93bnN0cmVhbSBwYWNrYWdlIGNvdWxkIGNoZWNrIGZvciB0aGUgY2xhc3Mgb2YgdGhlIGNvbmRpdGlvbiwgcmF0aGVyIHRoYW4gaW5zcGVjdGluZyB0aGUgbWVzc2FnZS4KCi0tLQoKIyMgOC42LjYgRXhlcmNpc2VzCgoxLiAgQ3JlYXRlIGBzdXBwcmVzc0NvbmRpdGlvbnMoKWAgdGhhdCB3b3JrcyBsaWtlIGBzdXBwcmVzc01lc3NhZ2VzKClgIGFuZCAKICAgIGBzdXBwcmVzc1dhcm5pbmdzKClgIGJ1dCBzdXBwcmVzc2VzIGV2ZXJ5dGhpbmcuIFRoaW5rIGNhcmVmdWxseSBhYm91dCBob3cgeW91CiAgICBzaG91bGQgaGFuZGxlIGVycm9ycy4KCmBgYHtyfQpzdXBwcmVzc0NvbmRpdGlvbnMgPC0gZnVuY3Rpb24oZXhwcikgeyAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIHRyeUNhdGNoKAogICAgZXJyb3IgPSBmdW5jdGlvbihjbmQpIGludmlzaWJsZShjbmQpLAogICAgd2l0aENhbGxpbmdIYW5kbGVycygKICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24oY25kKSB7CiAgICAgICAgY25kX211ZmZsZShjbmQpCiAgICAgIH0sCiAgICAgIGV4cHIKICAgICkKICApCn0KCnN1cCA8LSBzdXBwcmVzc0NvbmRpdGlvbnMoewogIG1lc3NhZ2UoInByb2Nlc3NpbmcuLi4iKQogIHdhcm5pbmcoInNvbWV0aGluZyB3ZW50IHdyb25nIikKICBwcmludCgic3RpbGwgcnVubmluZyIpCiAgc3RvcCgiZXJyb3IiKQogIHByaW50KCJ0aGlzIHNob3VsZG4ndCBydW4iKQp9KQoKc3RyKHN1cCkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuIEVycm9ycyBhcmUgbm90IHByaW50ZWQsIGJ1dCBhcmUgcmV0dXJuZWQsIGludmlzaWJseS4KCkFSIFNvbHV0aW9uczogSW4gZ2VuZXJhbCwgd2Ugd291bGQgbGlrZSB0byBjYXRjaCBlcnJvcnMsIHNpbmNlIHRoZXkgY29udGFpbiBpbXBvcnRhbnQgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZy4gVG8gc3VwcHJlc3MgdGhlIGVycm9yIG1lc3NhZ2UgYW5kIGhpZGUgdGhlIHJldHVybmVkIGVycm9yIG9iamVjdCBmcm9tIHRoZSBjb25zb2xlLCB3ZSBoYW5kbGUgZXJyb3JzIHdpdGhpbiBhIGB0cnlDYXRjaCgpYCBhbmQgcmV0dXJuIHRoZSBlcnJvciBvYmplY3QgaW52aXNpYmx5OgoKYGBge3J9CnN1cHByZXNzRXJyb3JzIDwtIGZ1bmN0aW9uKGV4cHIpIHsgIyBub2xpbnQ6IG9iamVjdF9uYW1lX2xpbnRlci4KICB0cnlDYXRjaCgKICAgIGVycm9yID0gZnVuY3Rpb24oY25kKSBpbnZpc2libGUoY25kKSwKICAgIGludGVycnVwdCA9IGZ1bmN0aW9uKGNuZCkgewogICAgICBzdG9wKCJUZXJtaW5hdGVkIGJ5IHRoZSB1c2VyLiIsCiAgICAgICAgY2FsbC4gPSBGQUxTRQogICAgICApCiAgICB9LAogICAgZXhwcgogICkKfQpgYGAKCkFmdGVyIHdlIGRlZmluZWQgdGhlIGVycm9yIGhhbmRsaW5nLCB3ZSBjYW4ganVzdCBjb21iaW5lIGl0IHdpdGggdGhlIG90aGVyIGhhbmRsZXJzIHRvIGNyZWF0ZSBgc3VwcHJlc3NDb25kaXRpb25zKClgOgoKYGBge3J9CnN1cHByZXNzQ29uZGl0aW9ucyA8LSBmdW5jdGlvbihleHByKSB7ICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgc3VwcHJlc3NFcnJvcnMoc3VwcHJlc3NXYXJuaW5ncyhzdXBwcmVzc01lc3NhZ2VzKGV4cHIpKSkKfQpgYGAKClRvIHRlc3QgdGhlIG5ldyBmdW5jdGlvbiwgd2UgYXBwbHkgaXQgdG8gYSBzZXQgb2YgY29uZGl0aW9ucyBhbmQgaW5zcGVjdCB0aGUgcmV0dXJuZWQgZXJyb3Igb2JqZWN0LgoKYGBge3J9CiMgVGhlIG1lc3NhZ2VzL3dhcm5pbmdzL2NvbmRpdGlvbnMgYXJlIHN1cHByZXNzZWQgc3VjY2Vzc2Z1bGx5CmVycm9yX29iaiA8LSBzdXBwcmVzc0NvbmRpdGlvbnMoewogIG1lc3NhZ2UoIm1lc3NhZ2UiKQogIHdhcm5pbmcoIndhcm5pbmciKQogIGFib3J0KCJlcnJvciIpCn0pCmVycm9yX29iagpgYGAKCi0tLQoKMi4gIENvbXBhcmUgdGhlIGZvbGxvd2luZyB0d28gaW1wbGVtZW50YXRpb25zIG9mIGBtZXNzYWdlMmVycm9yKClgLiBXaGF0IGlzIHRoZQogICAgbWFpbiBhZHZhbnRhZ2Ugb2YgYHdpdGhDYWxsaW5nSGFuZGxlcnMoKWAgaW4gdGhpcyBzY2VuYXJpbz8gKEhpbnQ6IGxvb2sKICAgIGNhcmVmdWxseSBhdCB0aGUgdHJhY2ViYWNrLikKCmBgYHtyfQptZXNzYWdlMmVycm9yIDwtIGZ1bmN0aW9uKGNvZGUpIHsKICB3aXRoQ2FsbGluZ0hhbmRsZXJzKGNvZGUsIG1lc3NhZ2UgPSBmdW5jdGlvbihlKSBzdG9wKGUpKQp9CgptZXNzYWdlMmVycm9yMiA8LSBmdW5jdGlvbihjb2RlKSB7CiAgdHJ5Q2F0Y2goY29kZSwgbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHN0b3AoZSkpCn0KYGBgCgpBbnN3ZXI6IGBtZXNzYWdlMmVycm9yKClgIHNob3dzIHRoZSBpbnZvY2F0aW9uIG9mIGBtZXNzYWdlKClgIGluIHRoZSB0cmFjZWJhY2ssIGJ1dApgbWVzc2FnZTJlcnJvcjIoKWAgZG9lcyBub3QuCgpBUiBTb2x1dGlvbnM6IEJvdGggZnVuY3Rpb25zIGRpZmZlciBpbiB0aGUgd2F5IGNvbmRpdGlvbnMgYXJlIGhhbmRsZWQuIGB3aXRoQ2FsbGluZ0hhbmRsZXJzKClgIGNyZWF0ZXMgYSAqY2FsbGluZyBoYW5kbGVyKiwgd2hpY2ggaXMgZXhlY3V0ZWQgZnJvbSB3aXRoaW4gdGhlIHNpZ25hbGxpbmcgZnVuY3Rpb24uIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgdG8gcmVjb3JkIGEgZGV0YWlsZWQgY2FsbCBzdGFjaywgd2hpY2ggaGVscHMgdXMgaWRlbnRpZnkgdGhlIHNpZ25hbGxpbmcgY29uZGl0aW9uLgoKYHRyeUNhdGNoKClgIGRlZmluZXMgYW4gKmV4aXRpbmcgaGFuZGxlciosIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHNpZ25hbGxpbmcgZnVuY3Rpb24gaXMgdGVybWluYXRlZCBhcyBzb29uIGFzIGEgY29uZGl0aW9uIGlzIHJhaXNlZC4gSXQgYWxzbyByZXR1cm5zIGNvbnRyb2wgdG8gdGhlIGNvbnRleHQgd2hlcmUgYHRyeUNhdGNoKClgIHdhcyBjYWxsZWQuCgpJbiB0aGlzIGV4YW1wbGUgdGhlIHVzZSBvZiBgd2l0aENhbGxpbmdIYW5kbGVycygpYCByZXR1cm5zIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGUgdXNlIG9mIGB0cnlDYXRjaCgpYC4gVGhpcyBhbGxvd3MgdXMgdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBjYWxsIHRoYXQgcmFpc2VkIHRoZSBjb25kaXRpb24uCgpgYGB7ciwgZXJyb3IgPSBUUlVFLCBldmFsID0gRkFMU0V9Cm1lc3NhZ2UyZXJyb3IxIDwtIGZ1bmN0aW9uKGNvZGUpIHsKICB3aXRoQ2FsbGluZ0hhbmRsZXJzKGNvZGUsIG1lc3NhZ2UgPSBmdW5jdGlvbihlKSBzdG9wKCJlcnJvciIpKQp9CgptZXNzYWdlMmVycm9yMSh7CiAgMQogIG1lc3NhZ2UoImhpZGRlbiBlcnJvciIpCiAgTlVMTAp9KQojPiBFcnJvciBpbiAoZnVuY3Rpb24gKGUpIDogZXJyb3IKdHJhY2ViYWNrKCkKIz4gOTogc3RvcCgiZXJyb3IiKSBhdCAjMgojPiA4OiAoZnVuY3Rpb24gKGUpCiM+ICAgIHN0b3AoImVycm9yIikpKGxpc3QobWVzc2FnZSA9ICJoaWRkZW4gZXJyb3JcbiIsCiM+ICAgICAgY2FsbCA9IG1lc3NhZ2UoImhpZGRlbiBlcnJvciIpKSkKIz4gNzogc2lnbmFsQ29uZGl0aW9uKGNvbmQpCiM+IDY6IGRvV2l0aE9uZVJlc3RhcnQocmV0dXJuKGV4cHIpLCByZXN0YXJ0KQojPiA1OiB3aXRoT25lUmVzdGFydChleHByLCByZXN0YXJ0c1tbMUxdXSkKIz4gNDogd2l0aFJlc3RhcnRzKHsKIz4gICAgICAgIHNpZ25hbENvbmRpdGlvbihjb25kKQojPiAgICAgICAgZGVmYXVsdEhhbmRsZXIoY29uZCkKIz4gICAgfSwgbXVmZmxlTWVzc2FnZSA9IGZ1bmN0aW9uKCkgTlVMTCkKIz4gMzogbWVzc2FnZSgiaGlkZGVuIGVycm9yIikgYXQgIzEKIz4gMjogd2l0aENhbGxpbmdIYW5kbGVycyhjb2RlLAojPiAgICAgIG1lc3NhZ2UgPSBmdW5jdGlvbihlKSBzdG9wKCJlcnJvciIpKSBhdCAjMgojPiAxOiBtZXNzYWdlMmVycm9yMSh7CiM+ICAgICAgICAxCiM+ICAgICAgICBtZXNzYWdlKCJoaWRkZW4gZXJyb3IiKQojPiAgICAgICAgTlVMTAojPiAgICB9KQpgYGAKCmBgYHtyLCBlcnJvciA9IFRSVUUsIGV2YWwgPSBGQUxTRX0KbWVzc2FnZTJlcnJvcjIgPC0gZnVuY3Rpb24oY29kZSkgewogIHRyeUNhdGNoKGNvZGUsIG1lc3NhZ2UgPSBmdW5jdGlvbihlKSAoc3RvcCgiZXJyb3IiKSkpCn0KCm1lc3NhZ2UyZXJyb3IyKHsKICAxCiAgc3RvcCgiaGlkZGVuIGVycm9yIikKICBOVUxMCn0pCiM+IEVycm9yIGluIHZhbHVlW1szTF1dKGNvbmQpIDogZXJyb3IKdHJhY2ViYWNrKCkKIz4gNjogc3RvcCgiZXJyb3IiKSBhdCAjMgojPiA1OiB2YWx1ZVtbM0xdXShjb25kKQojPiA0OiB0cnlDYXRjaE9uZShleHByLCBuYW1lcywgcGFyZW50ZW52LCBoYW5kbGVyc1tbMUxdXSkKIz4gMzogdHJ5Q2F0Y2hMaXN0KGV4cHIsIGNsYXNzZXMsIHBhcmVudGVudiwgaGFuZGxlcnMpCiM+IDI6IHRyeUNhdGNoKGNvZGUsIG1lc3NhZ2UgPSBmdW5jdGlvbihlKSAoc3RvcCgiZXJyb3IiKSkpIGF0ICMyCiM+IDE6IG1lc3NhZ2UyZXJyb3IyKHsKIz4gICAgICAgIDEKIz4gICAgICAgIG1lc3NhZ2UoImhpZGRlbiBlcnJvciIpCiM+ICAgICAgICBOVUxMCiM+ICAgIH0pCmBgYAoKLS0tCgozLiAgSG93IHdvdWxkIHlvdSBtb2RpZnkgdGhlIGBjYXRjaF9jbmRzKClgIGRlZmluaXRpb24gaWYgeW91IHdhbnRlZCB0byByZWNyZWF0ZQogICAgdGhlIG9yaWdpbmFsIGludGVybWluZ2xpbmcgb2Ygd2FybmluZ3MgYW5kIG1lc3NhZ2VzPwoKQW5zd2VyOiBhcyBub3RlZCBpbgpbQWR2YW5jZWQgUiBTb2x1dGlvbnNdKGh0dHBzOi8vYWR2YW5jZWQtci1zb2x1dGlvbnMucmJpbmQuaW8vY29uZGl0aW9ucy5odG1sI2FwcGxpY2F0aW9ucy0xKSwKIkl0IGxvb2tzIGxpa2UgSGFkbGV5IHdyb3RlIGEgcGFydCBvZiB0aGUgY2hhcHRlciBhZnRlciB0aGUgZXhlcmNpc2VzLCBhcyB0aGUgYGNhdGNoX2NuZHMoKWAKZnVuY3Rpb24gZGVmaW5lZCBpbiB0aGUgY2hhcHRlciBhbHJlYWR5IHNvbHZlcyB0aGlzIHByb2JsZW0gYnkgc3RvcmluZyBhbGwgbWVzc2FnZXMgYW5kIHdhcm5pbmdzIGluCnRoZWlyIG9yaWdpbmFsIG9yZGVyIHdpdGhpbiBhIGxpc3QuIgoKLS0tCgo0LiAgV2h5IGlzIGNhdGNoaW5nIGludGVycnVwdHMgZGFuZ2Vyb3VzPyBSdW4gdGhpcyBjb2RlIHRvIGZpbmQgb3V0LgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KYm90dGxlc19vZl9iZWVyIDwtIGZ1bmN0aW9uKGkgPSA5OSkgewogIG1lc3NhZ2UoCiAgICAiVGhlcmUgYXJlICIsIGksICIgYm90dGxlcyBvZiBiZWVyIG9uIHRoZSB3YWxsLCAiLAogICAgaSwgIiBib3R0bGVzIG9mIGJlZXIuIgogICkKICB3aGlsZSAoaSA+IDApIHsKICAgIHRyeUNhdGNoKAogICAgICBTeXMuc2xlZXAoMSksCiAgICAgIGludGVycnVwdCA9IGZ1bmN0aW9uKGVycikgewogICAgICAgIGkgPDwtIGkgLSAxICMgbm9saW50OiB1bmRlc2lyYWJsZV9vcGVyYXRvcl9saW50ZXIuCiAgICAgICAgaWYgKGkgPiAwKSB7CiAgICAgICAgICBtZXNzYWdlKAogICAgICAgICAgICAiVGFrZSBvbmUgZG93biwgcGFzcyBpdCBhcm91bmQsICIsIGksCiAgICAgICAgICAgICIgYm90dGxlIiwgaWYgKGkgPiAxKSAicyIsICIgb2YgYmVlciBvbiB0aGUgd2FsbC4iCiAgICAgICAgICApCiAgICAgICAgfQogICAgICB9CiAgICApCiAgfQogIG1lc3NhZ2UoCiAgICAiTm8gbW9yZSBib3R0bGVzIG9mIGJlZXIgb24gdGhlIHdhbGwsICIsCiAgICAibm8gbW9yZSBib3R0bGVzIG9mIGJlZXIuIgogICkKfQpgYGAKCkFuc3dlcjogdGhpcyBwcmV2ZW50cyB1c2VyIGludGVycnVwdHMgKGNvbnRyb2wtYykgZnJvbSBoYWx0aW5nIHRoZSBjb2RlLCB3aGljaCBpbiB0aGlzIGNhc2UgY2FuIGJlCnByZXR0eSBhbm5veWluZyBpZiBydW4gd2l0aCB0aGUgZGVmYXVsdHMsIHJlcXVpcmluZyA5OSBpbnRlcnJ1cHRzIChvciBqdXN0ICJSZXN0YXJ0IFIiKS4KCkFSIFNvbHV0aW9uczogV2hlbiBydW5uaW5nIHRoZSBgYm90dGxlc19vZl9iZWVyKClgIGZ1bmN0aW9uIGluIHlvdXIgY29uc29sZSwgdGhlIG91dHB1dCBzaG91bGQgbG9vayBzb21laG93IGxpa2UgdGhlIGZvbGxvd2luZzoKCmBgYHtyLCBldmFsID0gRkFMU0V9CmJvdHRsZXNfb2ZfYmVlcigpCiM+IFRoZXJlIGFyZSA5OSBib3R0bGVzIG9mIGJlZXIgb24gdGhlIHdhbGwsIDk5IGJvdHRsZXMgb2YgYmVlci4KIz4gVGFrZSBvbmUgZG93biwgcGFzcyBpdCBhcm91bmQsIDk4IGJvdHRsZXMgb2YgYmVlciBvbiB0aGUgd2FsbC4KIz4gVGFrZSBvbmUgZG93biwgcGFzcyBpdCBhcm91bmQsIDk3IGJvdHRsZXMgb2YgYmVlciBvbiB0aGUgd2FsbC4KIz4gVGFrZSBvbmUgZG93biwgcGFzcyBpdCBhcm91bmQsIDk2IGJvdHRsZXMgb2YgYmVlciBvbiB0aGUgd2FsbC4KIz4gVGFrZSBvbmUgZG93biwgcGFzcyBpdCBhcm91bmQsIDk1IGJvdHRsZXMgb2YgYmVlciBvbiB0aGUgd2FsbC4KIz4KYGBgCgpBdCB0aGlzIHBvaW50IHlvdSdsbCBwcm9iYWJseSByZWNvZ25pc2UgaG93IGhhcmQgaXQgaXMgdG8gZ2V0IHRoZSBudW1iZXIgb2YgYm90dGxlcyBkb3duIGZyb20gYDk5YCB0byBgMGAuIFRoZXJlJ3Mgbm8gd2F5IHRvIGJyZWFrIG91dCBvZiB0aGUgZnVuY3Rpb24gYmVjYXVzZSB3ZSdyZSBjYXB0dXJpbmcgdGhlIGludGVycnVwdCB0aGF0IHlvdSdkIHVzdWFsbHkgdXNlIQoKLS0tCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("advanced-r-1.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
