<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2022-06-12" />

<title>Advanced R Workbook (Foundations)</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link href="site_libs/bootstrap-5.1.3/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-5.1.3/bootstrap.bundle.min.js"></script>
<script src="site_libs/bs3compat-0.4.0/transition.js"></script>
<script src="site_libs/bs3compat-0.4.0/tabs.js"></script>
<script src="site_libs/bs3compat-0.4.0/bs3compat.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">rtraining notebooks</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="reference/index.html">Reference</a>
</li>
<li>
  <a href="news/index.html">Changelog</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="FaultTree.html">FaultTree.widget Test</a>
    </li>
    <li>
      <a href="advanced-r-1.html">Advanced R Workbook (Foundations)</a>
    </li>
    <li>
      <a href="r-setup-log.html">R Setup Log</a>
    </li>
    <li>
      <a href="r-training-log.html">R Training Log</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/jabenninghoff/rtraining/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Advanced R Workbook (Foundations)</h1>
<h4 class="date">2022-06-12</h4>

</div>


<p>Workbook for completing quizzes and exercises from the “Foundations”
chapters of <a href="https://adv-r.hadley.nz/index.html">Advanced R</a>,
second edition, with comparisons to solutions from <a
href="https://advanced-r-solutions.rbind.io">Advanced R
Solutions</a>.</p>
<pre class="r"><code>library(lobstr)
library(bench)
library(rlang)

# from https://github.com/hadley/adv-r/blob/master/common.R
knitr::opts_chunk$set(
  comment = &quot;#&gt;&quot;,
  fig.align = &quot;center&quot;
)

knitr::knit_hooks$set(
  small_mar = function(before, options, envir) {
    if (before) {
      par(mar = c(4.1, 4.1, 0.5, 0.5)) # nolint: undesirable_function_linter.
    }
  }
)</code></pre>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This workbook includes answers and solutions to the quizzes and
exercises from <a href="https://adv-r.hadley.nz/index.html">Advanced
R</a>, organized by chapter. It includes excerpts from the book, copied
here.</p>
<p><strong>WARNING, SPOILERS!</strong> If you haven’t read Advanced R
and intend to complete the quizzes and exercises, don’t read this
notebook. It contains my (potentially wrong) answers to both.</p>
</div>
<div id="names-and-values" class="section level1">
<h1>2 Names and values</h1>
<p>In R, it is important to understand the distinction between an object
and its name. Doing so will help you:</p>
<ul>
<li>More accurately predict the performance and memory usage of your
code.</li>
<li>Write faster code by avoiding accidental copies, a major source of
slow code.</li>
<li>Better understand R’s functional programming tools.</li>
</ul>
<p>The goal of this chapter is to help you understand the distinction
between names and values, and when R will copy an object.</p>
<div id="quiz" class="section level2">
<h2>2 Quiz</h2>
<ol style="list-style-type: decimal">
<li>Given the following data frame, how do I create a new column called
“3” that contains the sum of <code>1</code> and <code>2</code>? You may
only use <code>$</code>, not <code>[[</code>. What makes <code>1</code>,
<code>2</code>, and <code>3</code> challenging as variable names?</li>
</ol>
<pre class="r"><code>df &lt;- data.frame(runif(3), runif(3))
names(df) &lt;- c(1, 2)</code></pre>
<p>Answer: use the following code.</p>
<pre class="r"><code>df2 &lt;- data.frame(df, df$`1` + df$`2`)
names(df2) &lt;- c(1, 2, 3)</code></pre>
<p>Using numbers as names is problematic due to them being interpreted
as numeric constants by default.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>In the following code, how much memory does <code>y</code>
occupy?</li>
</ol>
<pre class="r"><code>x &lt;- runif(1e6)
y &lt;- list(x, x, x)</code></pre>
<p>Answer: 3 times the size of x, 24 MB. Note: this is incorrect, as
shown by <code>obj_size</code> and <code>obj_addr</code>:</p>
<pre class="r"><code>obj_size(x)</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code>obj_size(y)</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code>obj_addr(y[[1]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7faac91f8000&quot;</code></pre>
<pre class="r"><code>obj_addr(y[[2]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7faac91f8000&quot;</code></pre>
<pre class="r"><code>obj_addr(y[[3]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7faac91f8000&quot;</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>On which line does <code>a</code> get copied in the following
example?</li>
</ol>
<pre class="r"><code>a &lt;- c(1, 5, 3, 2)
obj_addr(a)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa84772558&quot;</code></pre>
<pre class="r"><code>b &lt;- a
obj_addr(b)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa84772558&quot;</code></pre>
<pre class="r"><code>b[[1]] &lt;- 10
obj_addr(b)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa82e04818&quot;</code></pre>
<p>Answer: the third line (copy-on-write). [copy-on-modify]</p>
</div>
<div id="exercises" class="section level2">
<h2>2.2.2 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Explain the relationship between <code>a</code>, <code>b</code>,
<code>c</code> and <code>d</code> in the following code:</li>
</ol>
<pre class="r"><code>a &lt;- 1:10
b &lt;- a
c &lt;- b
d &lt;- 1:10</code></pre>
<p>Answer: a, b, and c all point to the same object (1:10). d points to
an identical object at a different address.</p>
<p>AR Solutions: <code>a</code>, <code>b</code>, and <code>c</code>
point to the same object (with the same address in memory). This object
has the value <code>1:10</code>. <code>d</code> points to a different
object with the same value.</p>
<pre class="r"><code>obj_addr(a)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa87350660&quot;</code></pre>
<pre class="r"><code>obj_addr(b)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa87350660&quot;</code></pre>
<pre class="r"><code>obj_addr(c)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa87350660&quot;</code></pre>
<pre class="r"><code>obj_addr(d)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa8691a208&quot;</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>The following code accesses the mean function in multiple ways. Do
they all point to the same underlying function object? Verify this with
<code>lobstr::obj_addr()</code>.</li>
</ol>
<pre class="r"><code>mean
base::mean
get(&quot;mean&quot;)
evalq(mean)
match.fun(&quot;mean&quot;)</code></pre>
<p>Check the <code>obj_addr</code>:</p>
<pre class="r"><code>obj_addr(mean)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faab3390b20&quot;</code></pre>
<pre class="r"><code>obj_addr(base::mean)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faab3390b20&quot;</code></pre>
<pre class="r"><code>obj_addr(get(&quot;mean&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;0x7faab3390b20&quot;</code></pre>
<pre class="r"><code>obj_addr(evalq(mean))</code></pre>
<pre><code>#&gt; [1] &quot;0x7faab3390b20&quot;</code></pre>
<pre class="r"><code>obj_addr(match.fun(&quot;mean&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;0x7faab3390b20&quot;</code></pre>
<p>Answer: they do.</p>
<p>AR Solutions: Yes, they point to the same object. We confirm this by
inspecting the address of the underlying function object.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>By default, base R data import functions, like
<code>read.csv()</code>, will automatically convert non-syntactic names
to syntactic ones. Why might this be problematic? What option allows you
to suppress this behaviour?</li>
</ol>
<p>Answer: this could introduce problematic names, like <code>1</code>.
Setting <code>check.names = FALSE</code> suppresses this behavior.</p>
<p>AR Solutions: Column names are often data, and the underlying
<code>make.names()</code> transformation is non-invertible, so the
default behaviour corrupts data. To avoid this, set
<code>check.names = FALSE</code>.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What rules does <code>make.names()</code> use to convert
non-syntactic names into syntactic ones?</li>
</ol>
<p>Answer: from <code>?make.names</code>:</p>
<blockquote>
<p>The character “X” is prepended if necessary. All invalid characters
are translated to “.”. A missing value is translated to “NA”. Names
which match R keywords have a dot appended to them. Duplicated values
are altered by make.unique.</p>
</blockquote>
<p>AR Solutions: A valid name must start with a letter or a dot (not
followed by a number) and may further contain numbers and underscores
(<code>"_"</code>s are allowed since R version 1.9.0).</p>
<p>Three main mechanisms ensure syntactically valid names (see
<code>?make.names</code>):</p>
<ol style="list-style-type: decimal">
<li>Names that do not start with a letter or a dot will be prepended
with an <code>"X"</code>. The same holds for names that begin with a dot
followed by a number.</li>
<li>Additionally, non-valid characters are replaced by a dot.</li>
<li>Reserved R keywords (see <code>?reserved</code>) are suffixed by a
dot.</li>
</ol>
<p>Interestingly, some of these transformations are influenced by the
current locale. From <code>?make.names</code>:</p>
<blockquote>
<p>The definition of a letter depends on the current locale, but only
ASCII digits are considered to be digits.</p>
</blockquote>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>I slightly simplified the rules that govern syntactic names. Why is
<code>.123e1</code> not a syntactic name? Read <code>?make.names</code>
for the full details.</li>
</ol>
<p>Answer: from <code>?make.names</code>:</p>
<blockquote>
<p>A syntactically valid name consists of letters, numbers and the dot
or underline characters and starts with a letter or the dot not followed
by a number. Names such as “.2way” are not valid, and neither are the
reserved words.</p>
</blockquote>
<p>AR Solutions: <code>.123e1</code> is not a syntactic name, because it
starts with one dot which is followed by a number. This makes it a
double, <code>1.23</code>.</p>
<hr />
</div>
<div id="exercises-1" class="section level2">
<h2>2.3.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Why is <code>tracemem(1:10)</code> not useful?</li>
</ol>
<p>Answer: this is tracing an ‘immutable’ object which will always have
the same address.</p>
<p>AR Solutions: When <code>1:10</code> is called an object with an
address in memory is created, but it is not bound to a name. Therefore,
the object cannot be called or manipulated from R. As no copies will be
made, it is not useful to track the object for copying.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Explain why <code>tracemem()</code> shows two copies when you run
this code. Hint: carefully look at the difference between this code and
the code shown earlier in the section.</li>
</ol>
<pre class="r"><code>rm(list = ls())
x &lt;- c(1L, 2L, 3L)
tracemem(x)</code></pre>
<pre><code>#&gt; [1] &quot;&lt;0x7faa82c15e08&gt;&quot;</code></pre>
<pre class="r"><code>x[[3]] &lt;- 4</code></pre>
<pre><code>#&gt; tracemem[0x7faa82c15e08 -&gt; 0x7faa82c10a88]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; withCallingHandlers suppressMessages render_one FUN lapply sapply &lt;Anonymous&gt; &lt;Anonymous&gt; build_analysis_site stage_release 
#&gt; tracemem[0x7faa82c10a88 -&gt; 0x7faaa3aac3f8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; withCallingHandlers suppressMessages render_one FUN lapply sapply &lt;Anonymous&gt; &lt;Anonymous&gt; build_analysis_site stage_release</code></pre>
<pre class="r"><code>untracemem(x)</code></pre>
<p>Answer: unclear. The behavior in R 4.2.0 seems to have changed, since
this code shows two copies:</p>
<pre class="r"><code>rm(list = ls())
x &lt;- c(1, 2, 3)
tracemem(x)</code></pre>
<pre><code>#&gt; [1] &quot;&lt;0x7faaa489e878&gt;&quot;</code></pre>
<pre class="r"><code>y &lt;- x
y[[3]] &lt;- 4L</code></pre>
<pre><code>#&gt; tracemem[0x7faaa489e878 -&gt; 0x7faaa37ae6a8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; withCallingHandlers suppressMessages render_one FUN lapply sapply &lt;Anonymous&gt; &lt;Anonymous&gt; build_analysis_site stage_release</code></pre>
<pre class="r"><code>y[[3]] &lt;- 5L
untracemem(x)</code></pre>
<p>AR Solutions: Initially the vector <code>x</code> has integer type.
The replacement call assigns a double to the third element of
<code>x</code>, which triggers copy-on-modify.</p>
<pre class="r"><code>x &lt;- c(1L, 2L, 3L)
tracemem(x)
#&gt; &lt;0x66a4a70&gt;

x[[3]] &lt;- 4
#&gt; tracemem[0x55eec7b3af38 -&gt; 0x55eec774cc18]:</code></pre>
<p>We can avoid the copy by sub-assigning an integer instead of a
double:</p>
<pre class="r"><code>x &lt;- c(1L, 2L, 3L)
tracemem(x)
#&gt; &lt;0x55eec6940ae0&gt;

x[[3]] &lt;- 4L</code></pre>
<p>Please be aware that running this code in RStudio will result in
additional copies because of the reference from the environment
pane.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Sketch out the relationship between the following objects:</li>
</ol>
<pre class="r"><code>a &lt;- 1:10
b &lt;- list(a, a)
c &lt;- list(b, a, 1:10)

print(&quot;first object&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;first object&quot;</code></pre>
<pre class="r"><code>obj_addr(a)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa87370580&quot;</code></pre>
<pre class="r"><code>obj_addr(b[[1]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa87370580&quot;</code></pre>
<pre class="r"><code>obj_addr(b[[2]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa87370580&quot;</code></pre>
<pre class="r"><code>obj_addr(c[[2]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa87370580&quot;</code></pre>
<pre class="r"><code>print(&quot;second object&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;second object&quot;</code></pre>
<pre class="r"><code>obj_addr(b)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa85eb8308&quot;</code></pre>
<pre class="r"><code>obj_addr(c[[1]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa85eb8308&quot;</code></pre>
<pre class="r"><code>print(&quot;third object&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;third object&quot;</code></pre>
<pre class="r"><code>obj_addr(c)</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa81d8c3f8&quot;</code></pre>
<pre class="r"><code>print(&quot;fourth object (?)&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;fourth object (?)&quot;</code></pre>
<pre class="r"><code>obj_addr(c[[3]])</code></pre>
<pre><code>#&gt; [1] &quot;0x7faa81d2e800&quot;</code></pre>
<p>Answer: four different objects with multiple names.</p>
<p>AR Solutions: <code>a</code> contains a reference to an address with
the value <code>1:10</code>. <code>b</code> contains a list of two
references to the same address as <code>a</code>. <code>c</code>
contains a list of <code>b</code> (containing two references to
<code>a</code>), <code>a</code> (containing the same reference again)
and a reference pointing to a different address containing the same
value (<code>1:10</code>).</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What happens when you run this code? Draw a picture.</li>
</ol>
<pre class="r"><code>x &lt;- list(1:10)

x[[2]] &lt;- x

ref(x)</code></pre>
<pre><code>#&gt; █ [1:0x7faa91f0d408] &lt;list&gt; 
#&gt; ├─[2:0x7faa905ee0b0] &lt;int&gt; 
#&gt; └─█ [3:0x7faa819ec900] &lt;list&gt; 
#&gt;   └─[2:0x7faa905ee0b0]</code></pre>
<p>Initially x is a list of one element, an int vector 1:10. Then a
second list element is added, which points to the original int
vector.</p>
<p>AR Solutions: The initial reference tree of <code>x</code> shows that
the name <code>x</code> binds to a list object. This object contains a
reference to the integer vector <code>1:10</code>. When <code>x</code>
is assigned to an element of itself, copy-on-modify takes place and the
list is copied to a new address in memory. The list object previously
bound to <code>x</code> is now referenced in the newly created list
object. It is no longer bound to a name. The integer vector is
referenced twice.</p>
<hr />
</div>
<div id="exercises-2" class="section level2">
<h2>2.4.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>In the following example, why are <code>object.size(y)</code> and
<code>obj_size(y)</code> so radically different? Consult the
documentation of <code>object.size()</code>.</li>
</ol>
<pre class="r"><code>y &lt;- rep(list(runif(1e4)), 100)

object.size(y)</code></pre>
<pre><code>#&gt; 8005648 bytes</code></pre>
<pre class="r"><code>obj_size(y)</code></pre>
<pre><code>#&gt; 80.90 kB</code></pre>
<p>Answer: <code>object.size()</code> “does not detect if elements of a
list are shared”, which is the case here. That is, it does not detect
the list has been replicated 100 times, and overestimates by a factor of
100 compared to <code>object_size()</code>.</p>
<p>AR Solutions: <code>object.size()</code> doesn’t account for shared
elements within lists. Therefore, the results differ by a factor of ~
100.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Take the following list. Why is its size somewhat misleading?</li>
</ol>
<pre class="r"><code>funs &lt;- list(mean, sd, var)
obj_size(funs)</code></pre>
<pre><code>#&gt; 17.55 kB</code></pre>
<p>Answer: it doesn’t seem misleading to me, but the list includes the
function objects, not the return values. Also, it calculates the size
discarding the overlap between the functions. Per the code below, there
is some:</p>
<pre class="r"><code>obj_size(mean) + obj_size(sd) + obj_size(var)</code></pre>
<pre><code>#&gt; 18.08 kB</code></pre>
<p>AR Solutions: All three functions are built-in to R as part of the
<code>{base}</code> and <code>{stats}</code> packages and hence always
available. So, what does it mean to measure the size of something that’s
already included in R?</p>
<p>(There’s typically a more general question about what you want to
know when you ask for the size of something — do you want to know how
much data you’d need to send to communicate the object to someone else
(e.g. serialise it), or do you want to know how much memory you’d free
if you deleted it?)</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Predict the output of the following code:</li>
</ol>
<pre class="r"><code>a &lt;- runif(1e6)
obj_size(a) # 8,000,048 B ~ 8MB</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code># correct: from example above, runif(1e6) ~= 8MB

b &lt;- list(a, a)
obj_size(b) # slightly larger than obj_size(a)</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code># correct: two lists containing numeric vectors
obj_size(a, b) # slightly larger than obj_size(b)</code></pre>
<pre><code>#&gt; 8.00 MB</code></pre>
<pre class="r"><code># wrong: a is entirely contained within b

b[[1]][[1]] &lt;- 10
obj_size(b) # copy of b, same size</code></pre>
<pre><code>#&gt; 16.00 MB</code></pre>
<pre class="r"><code># wrong: double, since R copies an entire column, this adds the size of runif(1e6)
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)</code></pre>
<pre><code>#&gt; 16.00 MB</code></pre>
<pre class="r"><code># wrong: a is still entirely contained with b

b[[2]][[1]] &lt;- 10
obj_size(b) # copy of b, same size</code></pre>
<pre><code>#&gt; 16.00 MB</code></pre>
<pre class="r"><code># wrong: same size since it&#39;s still 2 numeric vectors of 1e6 length
obj_size(a, b) # still mostly overlaps, slightly larger than previous obj_size(a, b)</code></pre>
<pre><code>#&gt; 24.00 MB</code></pre>
<pre class="r"><code># wrong: there is no longer any overlap, so the size of obj_size(a, b) = obj_size(a) = obj_size(b)</code></pre>
<p>Answer: answers inline.</p>
<p>AR Solutions:</p>
<p><code>a &lt;- runif(1e6)</code>:</p>
<ul>
<li>In R (on most platforms) a length-0 vector has 48 bytes of
overhead.</li>
<li>A single double takes up an additional 8 bytes of memory.</li>
<li>So, a 1 million double should take up 8,000,048 bytes.</li>
</ul>
<p>For <code>b &lt;- list(a, a)</code> both list elements contain
references to the same memory address. Therefore, no additional memory
is required for the second list element. The list itself requires 64
bytes, 48 bytes for an empty list and 8 bytes for each element
(<code>obj_size(vector("list", 2))</code>). This lets us predict
8,000,048 B + 64 B = 8,000,112 B.</p>
<p><code>b[[1]][[1]] &lt;- 10</code>: When we modify the first element
of <code>b[[1]]</code> copy-on-modify occurs. Both elements will still
have the same size (8,000,040 B), but the first one gets a new address
in memory. As <code>b</code>’s elements don’t share references anymore,
its object size adds up to the sum of the elements and the length-2
list: 8,000,048 B + 8,000,048 B + 64 B = 16,000,160 B (16 MB). The
second element of <code>b</code> still references the same address as
<code>a</code>, so the combined size of <code>a</code> and
<code>b</code> is the same as <code>b</code>.</p>
<p><code>b[[2]][[1]] &lt;- 10</code>: When we modify the second element
of <code>b</code>, this element will also point to a new memory address.
This does not affect the size of the list. However, as <code>b</code>
doesn’t share references with <code>a</code> anymore, the memory usage
of the combined objects increases.</p>
<hr />
</div>
<div id="exercises-3" class="section level2">
<h2>2.5.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Explain why the following code doesn’t create a circular list.</li>
</ol>
<pre class="r"><code>x &lt;- list()
x[[1]] &lt;- x</code></pre>
<p>Answer: the name x is assigned to the empty list, and then the first
element of x is mapped to the object that x points to, the empty
list.</p>
<p>AR Solutions: In this situation copy-on-modify prevents the creation
of a circular list. Let us step through the details:</p>
<pre class="r"><code>x &lt;- list() # creates initial object
obj_addr(x)
#&gt; [1] &quot;0x55862f23ab80&quot;
tracemem(x)
#&gt; [1] &quot;&lt;0x55862f23ab80&gt;&quot;
x[[1]] &lt;- x # Copy-on-modify triggers new copy
#&gt; tracemem[0x55862f23ab80 -&gt; 0x55862e8ce028]:
obj_addr(x) # copied object has new memory address
#&gt; [1] &quot;0x55862e8ce028&quot;
obj_addr(x[[1]]) # list element contains old memory address
#&gt; [1] &quot;0x55862f23ab80&quot;</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Wrap the two methods for subtracting medians into two functions,
then use the ‘bench’ package <span class="citation">[@bench]</span> to
carefully compare their speeds. How does performance change as the
number of columns increase?</li>
</ol>
<pre class="r"><code>x_medians &lt;- function(ncol) {
  x &lt;- data.frame(matrix(runif(5 * 1e4), ncol = ncol))
  medians &lt;- vapply(x, median, numeric(1))
  return(list(x = x, medians = medians))
}

df_medians &lt;- function(x, medians) {
  # subtract medians using data.frame method
  for (i in seq_along(medians)) {
    x[[i]] &lt;- x[[i]] - medians[[i]]
  }
  x
}

ls_medians &lt;- function(x, medians) {
  y &lt;- as.list(x)

  for (i in seq_along(medians)) {
    y[[i]] &lt;- y[[i]] - medians[[i]]
  }
  y
}

# confirm they both work
xm &lt;- x_medians(5)
head(df_medians(xm$x, xm$medians), 10)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["X1"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["X2"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["X3"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["X4"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["X5"],"name":[5],"type":["dbl"],"align":["right"]}],"data":[{"1":"-0.3712137","2":"-0.19166837","3":"-0.1852909","4":"-0.42570809","5":"-0.01430796","_rn_":"1"},{"1":"0.4203710","2":"0.31758559","3":"0.4387238","4":"0.12306304","5":"-0.22452494","_rn_":"2"},{"1":"0.0560481","2":"0.12589057","3":"0.3360677","4":"0.22771187","5":"-0.40573594","_rn_":"3"},{"1":"-0.1454032","2":"0.29313549","3":"0.4959894","4":"-0.06383546","5":"-0.21966373","_rn_":"4"},{"1":"-0.3484668","2":"0.42588452","3":"-0.4583303","4":"-0.38133057","5":"-0.24372682","_rn_":"5"},{"1":"-0.4854098","2":"0.08625993","3":"0.4172645","4":"-0.29004761","5":"0.33923599","_rn_":"6"},{"1":"0.4406745","2":"-0.35867341","3":"0.1047977","4":"0.36649655","5":"0.24019367","_rn_":"7"},{"1":"0.3616487","2":"-0.19142239","3":"-0.3267061","4":"0.29172215","5":"0.06062248","_rn_":"8"},{"1":"-0.1786752","2":"0.08042562","3":"-0.2621003","4":"-0.46319169","5":"0.05435104","_rn_":"9"},{"1":"0.2632146","2":"0.48301911","3":"0.3080055","4":"-0.17653571","5":"0.15797053","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>head(as.data.frame(ls_medians(xm$x, xm$medians)), 10)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["X1"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["X2"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["X3"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["X4"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["X5"],"name":[5],"type":["dbl"],"align":["right"]}],"data":[{"1":"-0.3712137","2":"-0.19166837","3":"-0.1852909","4":"-0.42570809","5":"-0.01430796","_rn_":"1"},{"1":"0.4203710","2":"0.31758559","3":"0.4387238","4":"0.12306304","5":"-0.22452494","_rn_":"2"},{"1":"0.0560481","2":"0.12589057","3":"0.3360677","4":"0.22771187","5":"-0.40573594","_rn_":"3"},{"1":"-0.1454032","2":"0.29313549","3":"0.4959894","4":"-0.06383546","5":"-0.21966373","_rn_":"4"},{"1":"-0.3484668","2":"0.42588452","3":"-0.4583303","4":"-0.38133057","5":"-0.24372682","_rn_":"5"},{"1":"-0.4854098","2":"0.08625993","3":"0.4172645","4":"-0.29004761","5":"0.33923599","_rn_":"6"},{"1":"0.4406745","2":"-0.35867341","3":"0.1047977","4":"0.36649655","5":"0.24019367","_rn_":"7"},{"1":"0.3616487","2":"-0.19142239","3":"-0.3267061","4":"0.29172215","5":"0.06062248","_rn_":"8"},{"1":"-0.1786752","2":"0.08042562","3":"-0.2621003","4":"-0.46319169","5":"0.05435104","_rn_":"9"},{"1":"0.2632146","2":"0.48301911","3":"0.3080055","4":"-0.17653571","5":"0.15797053","_rn_":"10"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># benchmark
mark(df_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 df_medians(xm$x, xm$medians)     93µs    223µs     4358.     391KB     2.96</code></pre>
<pre class="r"><code>mark(ls_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 ls_medians(xm$x, xm$medians)   41.7µs    158µs     6255.     391KB     2.08</code></pre>
<pre class="r"><code>mark(as.data.frame(ls_medians(xm$x, xm$medians))) # as.data.frame introduces significant overhead</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                       min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                                  &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 as.data.frame(ls_medians(xm$x, xm$medians))    239µs    330µs     2888.     391KB     5.51</code></pre>
<p>Answer: with 5 columns, the list method is about twice as fast.</p>
<pre class="r"><code>xm &lt;- x_medians(10)
mark(df_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 df_medians(xm$x, xm$medians)    155µs    210µs     3940.     391KB     6.73</code></pre>
<pre class="r"><code>mark(ls_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 ls_medians(xm$x, xm$medians)   46.9µs    158µs     6834.     391KB        0</code></pre>
<pre class="r"><code>xm &lt;- x_medians(20)
mark(df_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 df_medians(xm$x, xm$medians)    273µs    414µs     2397.     400KB     10.1</code></pre>
<pre class="r"><code>mark(ls_medians(xm$x, xm$medians))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 ls_medians(xm$x, xm$medians)   66.3µs    198µs     4876.     392KB     2.47</code></pre>
<p>With 10 columns, the list method is 3 times as fast. With 20, the
list method is 5 times as fast. So, the list method is near constant
time regardless of columns, whereas the data.frame method scales
linearly with the number of columns.</p>
<p>AR Solutions:</p>
<p>When working directly with the data frame, the execution time grows
quadratically with the number of columns in the input data. This is
because (e.g.) the first column must be copied n times, the second
column n-1 times, and so on. When working with a list, the execution
time increases only linearly.</p>
<p>Obviously in the long run, linear growth creates shorter run-times,
but there is some cost to this strategy — we have to convert between
data structures with as.list() and list2DF(). Even though this is fast
and probably doesn’t hurt much, the improved approach doesn’t really pay
off in this scenario until we get to a data frame that is about 300
columns wide (with the exact value depending on the characteristics of
the system running the code).</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What happens if you attempt to use <code>tracemem()</code> on an
environment?</li>
</ol>
<pre class="r"><code>e &lt;- rlang::env()
try(tracemem(e))</code></pre>
<pre><code>#&gt; Error in tracemem(e) : 
#&gt;   &#39;tracemem&#39; is not useful for promise and environment objects</code></pre>
<p>Answer: it throws an error!</p>
<p>AR Solutions: <code>tracemem()</code> cannot be used to mark and
trace environments.</p>
<p>The error occurs because “it is not useful to trace NULL,
environments, promises, weak references, or external pointer objects, as
these are not duplicated” (see <code>?tracemem</code>). Environments are
always modified in place.</p>
<hr />
</div>
</div>
<div id="vectors" class="section level1">
<h1>3 Vectors</h1>
<p>This chapter discusses the most important family of data types in
base R: vectors. While you’ve probably already used many (if not all) of
the different types of vectors, you may not have thought deeply about
how they’re interrelated. In this chapter, I won’t cover individual
vectors types in too much detail, but I will show you how all the types
fit together as a whole. If you need more details, you can find them in
R’s documentation.</p>
<p>Vectors come in two flavours: atomic vectors and lists. They differ
in terms of their elements’ types: for atomic vectors, all elements must
have the same type; for lists, elements can have different types. While
not a vector, <code>NULL</code> is closely related to vectors and often
serves the role of a generic zero length vector. This diagram, which
we’ll be expanding on throughout this chapter, illustrates the basic
relationships:</p>
<p>Every vector can also have <strong>attributes</strong>, which you can
think of as a named list of arbitrary metadata. Two attributes are
particularly important. The <strong>dimension</strong> attribute turns
vectors into matrices and arrays and the <strong>class</strong>
attribute powers the S3 object system. While you’ll learn how to use S3
in Chapter 13, here you’ll learn about some of the most important S3
vectors: factors, date and times, data frames, and tibbles. And while 2D
structures like matrices and data frames are not necessarily what come
to mind when you think of vectors, you’ll also learn why R considers
them to be vectors.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-4" class="section level2">
<h2>3.2.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How do you create raw and complex scalars? (See <code>?raw</code>
and <code>?complex</code>.)</li>
</ol>
<p>Answer: using either <code>raw()</code>, <code>complex()</code>, or
<code>as.raw()</code>, <code>as.complex()</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Test your knowledge of the vector coercion rules by predicting the
output of the following uses of <code>c()</code>:</li>
</ol>
<pre class="r"><code>c(1, FALSE) # 1.0, 0.0 - double</code></pre>
<pre><code>#&gt; [1] 1 0</code></pre>
<pre class="r"><code>c(&quot;a&quot;, 1) # &quot;a&quot;, &quot;1&quot; - character</code></pre>
<pre><code>#&gt; [1] &quot;a&quot; &quot;1&quot;</code></pre>
<pre class="r"><code>c(TRUE, 1L) # 1L, 1L - integer</code></pre>
<pre><code>#&gt; [1] 1 1</code></pre>
<pre class="r"><code>typeof(c(1, FALSE))</code></pre>
<pre><code>#&gt; [1] &quot;double&quot;</code></pre>
<pre class="r"><code>typeof(c(&quot;a&quot;, 1))</code></pre>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
<pre class="r"><code>typeof(c(TRUE, 1L))</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<p>Answer: guesses inline. [correct!]</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Why is <code>1 == "1"</code> true? Why is <code>-1 &lt; FALSE</code>
true? Why is <code>"one" &lt; 2</code> false?</li>
</ol>
<p>Answers:</p>
<ul>
<li><code>1 == "1"</code>: the 1 is coerced to “1”</li>
<li><code>-1 &lt; FALSE</code>: FALSE is coerced to 0</li>
<li>`“one” &lt; 2: the 2 is coerced to “2”</li>
</ul>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Why is the default missing value, <code>NA</code>, a logical vector?
What’s special about logical vectors? (Hint: think about
<code>c(FALSE, NA_character_)</code>.)</li>
</ol>
<p>Answer: NA must be logical so that it can exist in a logical
vector.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Precisely what do <code>is.atomic()</code>,
<code>is.numeric()</code>, and <code>is.vector()</code> test for?</li>
</ol>
<p>Answers:</p>
<ul>
<li><code>is.atomic(x)</code>: tests if x is an atomic vector (logical,
integer, numeric, complex, character, and raw) - is <code>FALSE</code>
for lists</li>
<li><code>is.numeric(x)</code>: tests if x is an atomic numeric
vector</li>
<li><code>is.vector(x, mode = "any")</code>: tests if x is an atomic
vector OR a list or expression</li>
</ul>
<hr />
</div>
<div id="exercises-5" class="section level2">
<h2>3.3.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How is <code>setNames()</code> implemented? How is
<code>unname()</code> implemented? Read the source code.</li>
</ol>
<pre class="r"><code>setNames</code></pre>
<pre><code>#&gt; function (object = nm, nm) 
#&gt; {
#&gt;     names(object) &lt;- nm
#&gt;     object
#&gt; }
#&gt; &lt;bytecode: 0x7faab3c55180&gt;
#&gt; &lt;environment: namespace:stats&gt;</code></pre>
<pre class="r"><code>unname</code></pre>
<pre><code>#&gt; function (obj, force = FALSE) 
#&gt; {
#&gt;     if (!is.null(names(obj))) 
#&gt;         names(obj) &lt;- NULL
#&gt;     if (!is.null(dimnames(obj)) &amp;&amp; (force || !is.data.frame(obj))) 
#&gt;         dimnames(obj) &lt;- NULL
#&gt;     obj
#&gt; }
#&gt; &lt;bytecode: 0x7faaf18d75c8&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<p>Answer: using <code>names()</code>, and <code>dimnames()</code> for
<code>unname()</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What does <code>dim()</code> return when applied to a 1-dimensional
vector? When might you use <code>NROW()</code> or
<code>NCOL()</code>?</li>
</ol>
<pre class="r"><code>dim(1:3)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>nrow(1:12)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>NROW(1:12)</code></pre>
<pre><code>#&gt; [1] 12</code></pre>
<pre class="r"><code>ncol(1:12)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>NCOL(1:12)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<p>Answers: <code>NULL</code>. <code>NROW</code> and <code>NCOL</code>
are useful when comparing <code>NULL</code> dimensional vectors with
matrices and arrays.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>How would you describe the following three objects? What makes them
different from <code>1:5</code>?</li>
</ol>
<pre class="r"><code>x1 &lt;- array(1:5, c(1, 1, 5))
x2 &lt;- array(1:5, c(1, 5, 1))
x3 &lt;- array(1:5, c(5, 1, 1))

x1</code></pre>
<pre><code>#&gt; , , 1
#&gt; 
#&gt;      [,1]
#&gt; [1,]    1
#&gt; 
#&gt; , , 2
#&gt; 
#&gt;      [,1]
#&gt; [1,]    2
#&gt; 
#&gt; , , 3
#&gt; 
#&gt;      [,1]
#&gt; [1,]    3
#&gt; 
#&gt; , , 4
#&gt; 
#&gt;      [,1]
#&gt; [1,]    4
#&gt; 
#&gt; , , 5
#&gt; 
#&gt;      [,1]
#&gt; [1,]    5</code></pre>
<pre class="r"><code>x2</code></pre>
<pre><code>#&gt; , , 1
#&gt; 
#&gt;      [,1] [,2] [,3] [,4] [,5]
#&gt; [1,]    1    2    3    4    5</code></pre>
<pre class="r"><code>x3</code></pre>
<pre><code>#&gt; , , 1
#&gt; 
#&gt;      [,1]
#&gt; [1,]    1
#&gt; [2,]    2
#&gt; [3,]    3
#&gt; [4,]    4
#&gt; [5,]    5</code></pre>
<p>They have a 3-dimensional structure, arranged in different ways,
along the z, x, and y axis.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>An early draft used this code to illustrate
<code>structure()</code>:</li>
</ol>
<pre class="r"><code>structure(1:5, comment = &quot;my attribute&quot;)</code></pre>
<pre><code>#&gt; [1] 1 2 3 4 5</code></pre>
<pre><code>But when you print that object you don&#39;t see the comment attribute.
Why? Is the attribute missing, or is there something else special about
it? (Hint: try using help.)</code></pre>
<pre class="r"><code>factor(&quot;green&quot;, levels = c(&quot;red&quot;, &quot;amber&quot;, &quot;green&quot;))</code></pre>
<pre><code>#&gt; [1] green
#&gt; Levels: red amber green</code></pre>
<pre class="r"><code>dput(factor(&quot;green&quot;, levels = c(&quot;red&quot;, &quot;amber&quot;, &quot;green&quot;)))</code></pre>
<pre><code>#&gt; structure(3L, levels = c(&quot;red&quot;, &quot;amber&quot;, &quot;green&quot;), class = &quot;factor&quot;)</code></pre>
<p>Answer: print doesn’t display the attributes for arbitrary
structures, only defined classes, like factors (for example, above).</p>
<hr />
</div>
<div id="exercises-6" class="section level2">
<h2>3.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What sort of object does <code>table()</code> return? What is its
type? What attributes does it have? How does the dimensionality change
as you tabulate more variables?</li>
</ol>
<pre class="r"><code>a &lt;- letters[1:3]
a_table &lt;- table(a, sample(a))
a_table</code></pre>
<pre><code>#&gt;    
#&gt; a   a b c
#&gt;   a 1 0 0
#&gt;   b 0 0 1
#&gt;   c 0 1 0</code></pre>
<pre class="r"><code>typeof(a_table)</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>attributes(a_table)</code></pre>
<pre><code>#&gt; $dim
#&gt; [1] 3 3
#&gt; 
#&gt; $dimnames
#&gt; $dimnames$a
#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
#&gt; 
#&gt; $dimnames[[2]]
#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
#&gt; 
#&gt; 
#&gt; $class
#&gt; [1] &quot;table&quot;</code></pre>
<pre class="r"><code>b &lt;- letters[1:4]
b_table &lt;- table(b, sample(b))
b_table</code></pre>
<pre><code>#&gt;    
#&gt; b   a b c d
#&gt;   a 0 0 1 0
#&gt;   b 0 1 0 0
#&gt;   c 0 0 0 1
#&gt;   d 1 0 0 0</code></pre>
<pre class="r"><code>attributes(b_table)</code></pre>
<pre><code>#&gt; $dim
#&gt; [1] 4 4
#&gt; 
#&gt; $dimnames
#&gt; $dimnames$b
#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;
#&gt; 
#&gt; $dimnames[[2]]
#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;
#&gt; 
#&gt; 
#&gt; $class
#&gt; [1] &quot;table&quot;</code></pre>
<p>Answer: an object of class “table”, an array of integer values, with
type “integer”. Attributes listed above, the dimensionality is always n
by n, where n is the number of variables tabulated.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What happens to a factor when you modify its levels?</li>
</ol>
<pre class="r"><code>f1 &lt;- factor(letters)
f1</code></pre>
<pre><code>#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z</code></pre>
<pre class="r"><code>levels(f1) &lt;- rev(levels(f1))
f1</code></pre>
<pre><code>#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a
#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a</code></pre>
<p>Answer: <del>the factor will remain the same, but the attributes will
change.</del> the factor and its levels are reversed.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does this code do? How do <code>f2</code> and <code>f3</code>
differ from <code>f1</code>?</li>
</ol>
<pre class="r"><code>f2 &lt;- rev(factor(letters))
f2</code></pre>
<pre><code>#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a
#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z</code></pre>
<pre class="r"><code>f3 &lt;- factor(letters, levels = rev(letters))
f3</code></pre>
<pre><code>#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a</code></pre>
<p>Answer: both create a reversed list of letters. f3 also has reversed
levels but f2 does not. (correct!)</p>
<hr />
</div>
<div id="exercises-7" class="section level2">
<h2>3.5.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>List all the ways that a list differs from an atomic vector.</li>
</ol>
<p>Answers:</p>
<ul>
<li>Each element can be a different type</li>
<li>Each element is a reference to an object</li>
<li>List size can be smaller since elements are references</li>
<li>Lists can contain other lists</li>
</ul>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Why do you need to use <code>unlist()</code> to convert a list to an
atomic vector? Why doesn’t <code>as.vector()</code> work?</li>
</ol>
<pre class="r"><code>is.vector(list(1:4))</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>dput(as.vector(list(1:4)))</code></pre>
<pre><code>#&gt; list(1:4)</code></pre>
<p>Answer: a list is considered a vector by
<code>as.vector()</code>.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Compare and contrast <code>c()</code> and <code>unlist()</code> when
combining a date and date-time into a single vector.</li>
</ol>
<pre class="r"><code>d &lt;- list(date = as.Date(&quot;2022-06-25&quot;), datetime = as.POSIXct(&quot;2022-06-25 09:59:40 CDT&quot;))
dput(d)</code></pre>
<pre><code>#&gt; list(date = structure(19168, class = &quot;Date&quot;), datetime = structure(1656169180, class = c(&quot;POSIXct&quot;, 
#&gt; &quot;POSIXt&quot;), tzone = &quot;&quot;))</code></pre>
<pre class="r"><code>dput(c(d)) # nolint: unneeded_concatenation_linter.</code></pre>
<pre><code>#&gt; list(date = structure(19168, class = &quot;Date&quot;), datetime = structure(1656169180, class = c(&quot;POSIXct&quot;, 
#&gt; &quot;POSIXt&quot;), tzone = &quot;&quot;))</code></pre>
<pre class="r"><code>dput(unlist(d))</code></pre>
<pre><code>#&gt; c(date = 19168, datetime = 1656169180)</code></pre>
<p>Answer: <code>c()</code> preserves the list structure.
<code>unlist()</code> converts both to <code>double</code>.</p>
<hr />
</div>
<div id="exercises-8" class="section level2">
<h2>3.6.8 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Can you have a data frame with zero rows? What about zero
columns?</li>
</ol>
<pre class="r"><code># from data.frame() examples:
df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9)

df</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"7"},{"1":"2","2":"5","3":"8"},{"1":"3","2":"6","3":"9"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[, FALSE]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[],"data":[],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[FALSE, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["int"],"align":["right"]}],"data":[],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[FALSE, FALSE]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[],"data":[],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: yes!</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What happens if you attempt to set rownames that are not
unique?</li>
</ol>
<pre class="r"><code>rownames(df)</code></pre>
<pre><code>#&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</code></pre>
<pre class="r"><code>try(rownames(df) &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;))</code></pre>
<pre><code>#&gt; Warning: non-unique value when setting &#39;row.names&#39;: &#39;a&#39;</code></pre>
<pre><code>#&gt; Error in `.rowNamesDF&lt;-`(x, value = value) : 
#&gt;   duplicate &#39;row.names&#39; are not allowed</code></pre>
<p>Answer: error, duplicates not allowed.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>If <code>df</code> is a data frame, what can you say about
<code>t(df)</code>, and <code>t(t(df))</code>? Perform some experiments,
making sure to try different column types.</li>
</ol>
<pre class="r"><code>t(df)</code></pre>
<pre><code>#&gt;   [,1] [,2] [,3]
#&gt; x    1    2    3
#&gt; y    4    5    6
#&gt; z    7    8    9</code></pre>
<pre class="r"><code>t(t(df))</code></pre>
<pre><code>#&gt;      x y z
#&gt; [1,] 1 4 7
#&gt; [2,] 2 5 8
#&gt; [3,] 3 6 9</code></pre>
<pre class="r"><code>df2 &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), z = 4L:6L, stringsAsFactors = FALSE)
df2</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["chr"],"align":["left"]},{"label":["z"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"a","3":"4"},{"1":"2","2":"b","3":"5"},{"1":"3","2":"c","3":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>t(df2)</code></pre>
<pre><code>#&gt;   [,1] [,2] [,3]
#&gt; x &quot;1&quot;  &quot;2&quot;  &quot;3&quot; 
#&gt; y &quot;a&quot;  &quot;b&quot;  &quot;c&quot; 
#&gt; z &quot;4&quot;  &quot;5&quot;  &quot;6&quot;</code></pre>
<pre class="r"><code>t(t(df2))</code></pre>
<pre><code>#&gt;      x   y   z  
#&gt; [1,] &quot;1&quot; &quot;a&quot; &quot;4&quot;
#&gt; [2,] &quot;2&quot; &quot;b&quot; &quot;5&quot;
#&gt; [3,] &quot;3&quot; &quot;c&quot; &quot;6&quot;</code></pre>
<p>Answer: <code>t()</code> coerces the vector types, so
<code>t(t(df))</code> is the same as <code>df</code> only when all
columns are the same type.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What does <code>as.matrix()</code> do when applied to a data frame
with columns of different types? How does it differ from
<code>data.matrix()</code>?</li>
</ol>
<pre class="r"><code>as.matrix(df)</code></pre>
<pre><code>#&gt;      x y z
#&gt; [1,] 1 4 7
#&gt; [2,] 2 5 8
#&gt; [3,] 3 6 9</code></pre>
<pre class="r"><code>as.matrix(df2)</code></pre>
<pre><code>#&gt;      x   y   z  
#&gt; [1,] &quot;1&quot; &quot;a&quot; &quot;4&quot;
#&gt; [2,] &quot;2&quot; &quot;b&quot; &quot;5&quot;
#&gt; [3,] &quot;3&quot; &quot;c&quot; &quot;6&quot;</code></pre>
<pre class="r"><code>data.matrix(df2)</code></pre>
<pre><code>#&gt;      x y z
#&gt; [1,] 1 1 4
#&gt; [2,] 2 2 5
#&gt; [3,] 3 3 6</code></pre>
<pre class="r"><code>as.data.frame(data.matrix(df2))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"4"},{"1":"2","2":"2","3":"5"},{"1":"3","2":"3","3":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>as.data.frame(data.matrix(data.frame(x = 1:3, y = c(0, 0.5, 1), z = 4:6)))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["z"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"0.0","3":"4"},{"1":"2","2":"0.5","3":"5"},{"1":"3","2":"1.0","3":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: <code>as.matrix()</code> coerces all elements to the same
type. <code>data.matrix()</code> coerces elements to either integer
(when possible) or double (when not).</p>
<hr />
</div>
</div>
<div id="subsetting" class="section level1">
<h1>4 Subsetting</h1>
<p>R’s subsetting operators are fast and powerful. Mastering them allows
you to succinctly perform complex operations in a way that few other
languages can match. Subsetting in R is easy to learn but hard to master
because you need to internalise a number of interrelated concepts:</p>
<ul>
<li><p>There are six ways to subset atomic vectors.</p></li>
<li><p>There are three subsetting operators, <code>[[</code>,
<code>[</code>, and <code>$</code>.</p></li>
<li><p>Subsetting operators interact differently with different vector
types (e.g., atomic vectors, lists, factors, matrices, and data
frames).</p></li>
<li><p>Subsetting can be combined with assignment.</p></li>
</ul>
<p>Subsetting is a natural complement to <code>str()</code>. While
<code>str()</code> shows you all the pieces of any object (its
structure), subsetting allows you to pull out the pieces that you’re
interested in. For large, complex objects, I highly recommend using the
interactive RStudio Viewer, which you can activate with
<code>View(my_object)</code>.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-9" class="section level2">
<h2>4.2.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Fix each of the following common data frame subsetting errors:</li>
</ol>
<pre class="r"><code># nolint start: commented_code_linter.
# mtcars[mtcars$cyl = 4, ]
mtcars[mtcars$cyl == 4, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># mtcars[-1:4, ]
mtcars[-(1:4), ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"18.7","2":"8","3":"360.0","4":"175","5":"3.15","6":"3.440","7":"17.02","8":"0","9":"0","10":"3","11":"2","_rn_":"Hornet Sportabout"},{"1":"18.1","2":"6","3":"225.0","4":"105","5":"2.76","6":"3.460","7":"20.22","8":"1","9":"0","10":"3","11":"1","_rn_":"Valiant"},{"1":"14.3","2":"8","3":"360.0","4":"245","5":"3.21","6":"3.570","7":"15.84","8":"0","9":"0","10":"3","11":"4","_rn_":"Duster 360"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"19.2","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.30","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280"},{"1":"17.8","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.90","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"16.4","2":"8","3":"275.8","4":"180","5":"3.07","6":"4.070","7":"17.40","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SE"},{"1":"17.3","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.730","7":"17.60","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SL"},{"1":"15.2","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.780","7":"18.00","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SLC"},{"1":"10.4","2":"8","3":"472.0","4":"205","5":"2.93","6":"5.250","7":"17.98","8":"0","9":"0","10":"3","11":"4","_rn_":"Cadillac Fleetwood"},{"1":"10.4","2":"8","3":"460.0","4":"215","5":"3.00","6":"5.424","7":"17.82","8":"0","9":"0","10":"3","11":"4","_rn_":"Lincoln Continental"},{"1":"14.7","2":"8","3":"440.0","4":"230","5":"3.23","6":"5.345","7":"17.42","8":"0","9":"0","10":"3","11":"4","_rn_":"Chrysler Imperial"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"15.5","2":"8","3":"318.0","4":"150","5":"2.76","6":"3.520","7":"16.87","8":"0","9":"0","10":"3","11":"2","_rn_":"Dodge Challenger"},{"1":"15.2","2":"8","3":"304.0","4":"150","5":"3.15","6":"3.435","7":"17.30","8":"0","9":"0","10":"3","11":"2","_rn_":"AMC Javelin"},{"1":"13.3","2":"8","3":"350.0","4":"245","5":"3.73","6":"3.840","7":"15.41","8":"0","9":"0","10":"3","11":"4","_rn_":"Camaro Z28"},{"1":"19.2","2":"8","3":"400.0","4":"175","5":"3.08","6":"3.845","7":"17.05","8":"0","9":"0","10":"3","11":"2","_rn_":"Pontiac Firebird"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"15.8","2":"8","3":"351.0","4":"264","5":"4.22","6":"3.170","7":"14.50","8":"0","9":"1","10":"5","11":"4","_rn_":"Ford Pantera L"},{"1":"19.7","2":"6","3":"145.0","4":"175","5":"3.62","6":"2.770","7":"15.50","8":"0","9":"1","10":"5","11":"6","_rn_":"Ferrari Dino"},{"1":"15.0","2":"8","3":"301.0","4":"335","5":"3.54","6":"3.570","7":"14.60","8":"0","9":"1","10":"5","11":"8","_rn_":"Maserati Bora"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># mtcars[mtcars$cyl &lt;= 5]
mtcars[mtcars$cyl &lt;= 5, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># mtcars[mtcars$cyl == 4 | 6, ]
mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.620","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4"},{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.875","7":"17.02","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4 Wag"},{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"21.4","2":"6","3":"258.0","4":"110","5":"3.08","6":"3.215","7":"19.44","8":"1","9":"0","10":"3","11":"1","_rn_":"Hornet 4 Drive"},{"1":"18.1","2":"6","3":"225.0","4":"105","5":"2.76","6":"3.460","7":"20.22","8":"1","9":"0","10":"3","11":"1","_rn_":"Valiant"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"19.2","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.30","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280"},{"1":"17.8","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.90","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"19.7","2":"6","3":"145.0","4":"175","5":"3.62","6":"2.770","7":"15.50","8":"0","9":"1","10":"5","11":"6","_rn_":"Ferrari Dino"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># nolint end</code></pre>
<p>Answer: fixed!</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Why does the following code yield five missing values? (Hint: why is
it different from <code>x[NA_real_]</code>?)</li>
</ol>
<pre class="r"><code>x &lt;- 1:5
x[NA]</code></pre>
<pre><code>#&gt; [1] NA NA NA NA NA</code></pre>
<pre class="r"><code>x[NA_real_]</code></pre>
<pre><code>#&gt; [1] NA</code></pre>
<pre class="r"><code>x[TRUE]</code></pre>
<pre><code>#&gt; [1] 1 2 3 4 5</code></pre>
<p>Answer: NA is a logical constant of length 1.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does <code>upper.tri()</code> return? How does subsetting a
matrix with it work? Do we need any additional subsetting rules to
describe its behaviour?</li>
</ol>
<pre class="r"><code>x &lt;- outer(1:5, 1:5, FUN = &quot;*&quot;)
x</code></pre>
<pre><code>#&gt;      [,1] [,2] [,3] [,4] [,5]
#&gt; [1,]    1    2    3    4    5
#&gt; [2,]    2    4    6    8   10
#&gt; [3,]    3    6    9   12   15
#&gt; [4,]    4    8   12   16   20
#&gt; [5,]    5   10   15   20   25</code></pre>
<pre class="r"><code>x[upper.tri(x)]</code></pre>
<pre><code>#&gt;  [1]  2  3  6  4  8 12  5 10 15 20</code></pre>
<p>Answer: <code>upper.tri()</code> returns a matrix of logicals, which
can be used to subset the upper triangle. This is subsetting by matrix,
which is new.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Why does <code>mtcars[1:20]</code> return an error? How does it
differ from the similar <code>mtcars[1:20, ]</code>?</li>
</ol>
<pre class="r"><code>try(mtcars[1:20])</code></pre>
<pre><code>#&gt; Error in `[.data.frame`(mtcars, 1:20) : undefined columns selected</code></pre>
<pre class="r"><code>mtcars[1:20, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.620","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4"},{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.875","7":"17.02","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4 Wag"},{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"21.4","2":"6","3":"258.0","4":"110","5":"3.08","6":"3.215","7":"19.44","8":"1","9":"0","10":"3","11":"1","_rn_":"Hornet 4 Drive"},{"1":"18.7","2":"8","3":"360.0","4":"175","5":"3.15","6":"3.440","7":"17.02","8":"0","9":"0","10":"3","11":"2","_rn_":"Hornet Sportabout"},{"1":"18.1","2":"6","3":"225.0","4":"105","5":"2.76","6":"3.460","7":"20.22","8":"1","9":"0","10":"3","11":"1","_rn_":"Valiant"},{"1":"14.3","2":"8","3":"360.0","4":"245","5":"3.21","6":"3.570","7":"15.84","8":"0","9":"0","10":"3","11":"4","_rn_":"Duster 360"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"19.2","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.30","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280"},{"1":"17.8","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.90","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"16.4","2":"8","3":"275.8","4":"180","5":"3.07","6":"4.070","7":"17.40","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SE"},{"1":"17.3","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.730","7":"17.60","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SL"},{"1":"15.2","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.780","7":"18.00","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SLC"},{"1":"10.4","2":"8","3":"472.0","4":"205","5":"2.93","6":"5.250","7":"17.98","8":"0","9":"0","10":"3","11":"4","_rn_":"Cadillac Fleetwood"},{"1":"10.4","2":"8","3":"460.0","4":"215","5":"3.00","6":"5.424","7":"17.82","8":"0","9":"0","10":"3","11":"4","_rn_":"Lincoln Continental"},{"1":"14.7","2":"8","3":"440.0","4":"230","5":"3.23","6":"5.345","7":"17.42","8":"0","9":"0","10":"3","11":"4","_rn_":"Chrysler Imperial"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: <code>mtcars[1:20]</code> selects the first 20 columns, but
there are only 11. <code>mtcars[1:20, ]</code> selects the first 20 rows
of 32.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Implement your own function that extracts the diagonal entries from
a matrix (it should behave like <code>diag(x)</code> where
<code>x</code> is a matrix).</li>
</ol>
<pre class="r"><code>m &lt;- matrix(ncol = 3, byrow = TRUE, c(
  1, 4, 7,
  2, 5, 8,
  3, 6, 9
))
m</code></pre>
<pre><code>#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    4    7
#&gt; [2,]    2    5    8
#&gt; [3,]    3    6    9</code></pre>
<pre class="r"><code>diag(m)</code></pre>
<pre><code>#&gt; [1] 1 5 9</code></pre>
<pre class="r"><code>my_diag &lt;- function(x) {
  diag_element &lt;- function(n, x) {
    x[n, n]
  }
  vapply(seq_len(nrow(m)), diag_element, 1, x)
}
my_diag(m)</code></pre>
<pre><code>#&gt; [1] 1 5 9</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>What does <code>df[is.na(df)] &lt;- 0</code> do? How does it
work?</li>
</ol>
<p>Answer: sets the <code>NA</code> values in <code>df</code> to
<code>0</code>, by first selecting <code>NA</code> values then assigning
<code>0</code>.</p>
<pre class="r"><code>df &lt;- data.frame(x = c(1, 2, NA), y = c(4, NA, 6), z = c(NA, 8, 9))
df</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["z"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"NA"},{"1":"2","2":"NA","3":"8"},{"1":"NA","2":"6","3":"9"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[is.na(df)] &lt;- 0
df</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["x"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["y"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["z"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"0"},{"1":"2","2":"0","3":"8"},{"1":"0","2":"6","3":"9"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Correct!</p>
<hr />
</div>
<div id="exercises-10" class="section level2">
<h2>4.3.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Brainstorm as many ways as possible to extract the third value from
the <code>cyl</code> variable in the <code>mtcars</code> dataset.</li>
</ol>
<pre class="r"><code>mtcars$cyl[3]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars$cyl[[3]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[[&quot;cyl&quot;]][[3]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[3, 2]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[[3, 2]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[[&quot;Datsun 710&quot;, &quot;cyl&quot;]]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<pre class="r"><code>mtcars[-c(1:2, 4:32), -c(1, 3:11)]</code></pre>
<pre><code>#&gt; [1] 4</code></pre>
<p>Answer: code above (some variations omitted). There are many
more.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Given a linear model, e.g.,
<code>mod &lt;- lm(mpg ~ wt, data = mtcars)</code>, extract the residual
degrees of freedom. Then extract the R squared from the model summary
(<code>summary(mod)</code>)</li>
</ol>
<pre class="r"><code>mod &lt;- lm(mpg ~ wt, data = mtcars)
mod$df.residual</code></pre>
<pre><code>#&gt; [1] 30</code></pre>
<pre class="r"><code>mod_sum &lt;- summary(mod)
mod_sum$r.squared</code></pre>
<pre><code>#&gt; [1] 0.7528328</code></pre>
<pre class="r"><code>mod_sum</code></pre>
<pre><code>#&gt; 
#&gt; Call:
#&gt; lm(formula = mpg ~ wt, data = mtcars)
#&gt; 
#&gt; Residuals:
#&gt;     Min      1Q  Median      3Q     Max 
#&gt; -4.5432 -2.3647 -0.1252  1.4096  6.8727 
#&gt; 
#&gt; Coefficients:
#&gt;             Estimate Std. Error t value Pr(&gt;|t|)    
#&gt; (Intercept)  37.2851     1.8776  19.858  &lt; 2e-16 ***
#&gt; wt           -5.3445     0.5591  -9.559 1.29e-10 ***
#&gt; ---
#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
#&gt; 
#&gt; Residual standard error: 3.046 on 30 degrees of freedom
#&gt; Multiple R-squared:  0.7528, Adjusted R-squared:  0.7446 
#&gt; F-statistic: 91.38 on 1 and 30 DF,  p-value: 1.294e-10</code></pre>
<p>Answer: code above.</p>
<hr />
</div>
<div id="exercises-11" class="section level2">
<h2>4.5.9 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How would you randomly permute the columns of a data frame? (This is
an important technique in random forests.) Can you simultaneously
permute the rows and columns in one step?</li>
</ol>
<pre class="r"><code>df &lt;- data.frame(x = 1:5, y = 5:1, z = letters[1:5], row.names = 1:5)

df[, sample(ncol(df))]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["y"],"name":[1],"type":["int"],"align":["right"]},{"label":["z"],"name":[2],"type":["chr"],"align":["left"]},{"label":["x"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"5","2":"a","3":"1","_rn_":"1"},{"1":"4","2":"b","3":"2","_rn_":"2"},{"1":"3","2":"c","3":"3","_rn_":"3"},{"1":"2","2":"d","3":"4","_rn_":"4"},{"1":"1","2":"e","3":"5","_rn_":"5"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>df[sample(nrow(df)), sample(ncol(df))]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["y"],"name":[1],"type":["int"],"align":["right"]},{"label":["x"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"2","2":"4","3":"d","_rn_":"4"},{"1":"1","2":"5","3":"e","_rn_":"5"},{"1":"5","2":"1","3":"a","_rn_":"1"},{"1":"4","2":"2","3":"b","_rn_":"2"},{"1":"3","2":"3","3":"c","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: using <code>sample()</code>. Yes!</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>How would you select a random sample of <code>m</code> rows from a
data frame? What if the sample had to be contiguous (i.e., with an
initial row, a final row, and every row in between)?</li>
</ol>
<pre class="r"><code>sample_rows &lt;- function(df, m, contiguous = FALSE) {
  if (m &gt; nrow(df)) {
    stop(&quot;sample size &#39;&quot;, m, &quot;&#39; is larger than the number of rows, &#39;&quot;, nrow(df), &quot;&#39;&quot;)
  }
  if (contiguous) {
    first_row &lt;- sample(nrow(df) - m + 1, 1)
    last_row &lt;- first_row + m - 1
    return(df[first_row:last_row, ])
  }
  df[sample(nrow(df), m), ]
}

sample_rows(df, 3)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"2","2":"4","3":"b","_rn_":"2"},{"1":"1","2":"5","3":"a","_rn_":"1"},{"1":"3","2":"3","3":"c","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>sample_rows(df, 3, contiguous = TRUE)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["x"],"name":[1],"type":["int"],"align":["right"]},{"label":["y"],"name":[2],"type":["int"],"align":["right"]},{"label":["z"],"name":[3],"type":["chr"],"align":["left"]}],"data":[{"1":"3","2":"3","3":"c","_rn_":"3"},{"1":"4","2":"2","3":"d","_rn_":"4"},{"1":"5","2":"1","3":"e","_rn_":"5"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>try(sample_rows(df, 6))</code></pre>
<pre><code>#&gt; Error in sample_rows(df, 6) : 
#&gt;   sample size &#39;6&#39; is larger than the number of rows, &#39;5&#39;</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>How could you put the columns in a data frame in alphabetical
order?</li>
</ol>
<pre class="r"><code>mtcars[sort(colnames(mtcars))]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["am"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["mpg"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"6","4":"160.0","5":"3.90","6":"4","7":"110","8":"21.0","9":"16.46","10":"0","11":"2.620","_rn_":"Mazda RX4"},{"1":"1","2":"4","3":"6","4":"160.0","5":"3.90","6":"4","7":"110","8":"21.0","9":"17.02","10":"0","11":"2.875","_rn_":"Mazda RX4 Wag"},{"1":"1","2":"1","3":"4","4":"108.0","5":"3.85","6":"4","7":"93","8":"22.8","9":"18.61","10":"1","11":"2.320","_rn_":"Datsun 710"},{"1":"0","2":"1","3":"6","4":"258.0","5":"3.08","6":"3","7":"110","8":"21.4","9":"19.44","10":"1","11":"3.215","_rn_":"Hornet 4 Drive"},{"1":"0","2":"2","3":"8","4":"360.0","5":"3.15","6":"3","7":"175","8":"18.7","9":"17.02","10":"0","11":"3.440","_rn_":"Hornet Sportabout"},{"1":"0","2":"1","3":"6","4":"225.0","5":"2.76","6":"3","7":"105","8":"18.1","9":"20.22","10":"1","11":"3.460","_rn_":"Valiant"},{"1":"0","2":"4","3":"8","4":"360.0","5":"3.21","6":"3","7":"245","8":"14.3","9":"15.84","10":"0","11":"3.570","_rn_":"Duster 360"},{"1":"0","2":"2","3":"4","4":"146.7","5":"3.69","6":"4","7":"62","8":"24.4","9":"20.00","10":"1","11":"3.190","_rn_":"Merc 240D"},{"1":"0","2":"2","3":"4","4":"140.8","5":"3.92","6":"4","7":"95","8":"22.8","9":"22.90","10":"1","11":"3.150","_rn_":"Merc 230"},{"1":"0","2":"4","3":"6","4":"167.6","5":"3.92","6":"4","7":"123","8":"19.2","9":"18.30","10":"1","11":"3.440","_rn_":"Merc 280"},{"1":"0","2":"4","3":"6","4":"167.6","5":"3.92","6":"4","7":"123","8":"17.8","9":"18.90","10":"1","11":"3.440","_rn_":"Merc 280C"},{"1":"0","2":"3","3":"8","4":"275.8","5":"3.07","6":"3","7":"180","8":"16.4","9":"17.40","10":"0","11":"4.070","_rn_":"Merc 450SE"},{"1":"0","2":"3","3":"8","4":"275.8","5":"3.07","6":"3","7":"180","8":"17.3","9":"17.60","10":"0","11":"3.730","_rn_":"Merc 450SL"},{"1":"0","2":"3","3":"8","4":"275.8","5":"3.07","6":"3","7":"180","8":"15.2","9":"18.00","10":"0","11":"3.780","_rn_":"Merc 450SLC"},{"1":"0","2":"4","3":"8","4":"472.0","5":"2.93","6":"3","7":"205","8":"10.4","9":"17.98","10":"0","11":"5.250","_rn_":"Cadillac Fleetwood"},{"1":"0","2":"4","3":"8","4":"460.0","5":"3.00","6":"3","7":"215","8":"10.4","9":"17.82","10":"0","11":"5.424","_rn_":"Lincoln Continental"},{"1":"0","2":"4","3":"8","4":"440.0","5":"3.23","6":"3","7":"230","8":"14.7","9":"17.42","10":"0","11":"5.345","_rn_":"Chrysler Imperial"},{"1":"1","2":"1","3":"4","4":"78.7","5":"4.08","6":"4","7":"66","8":"32.4","9":"19.47","10":"1","11":"2.200","_rn_":"Fiat 128"},{"1":"1","2":"2","3":"4","4":"75.7","5":"4.93","6":"4","7":"52","8":"30.4","9":"18.52","10":"1","11":"1.615","_rn_":"Honda Civic"},{"1":"1","2":"1","3":"4","4":"71.1","5":"4.22","6":"4","7":"65","8":"33.9","9":"19.90","10":"1","11":"1.835","_rn_":"Toyota Corolla"},{"1":"0","2":"1","3":"4","4":"120.1","5":"3.70","6":"3","7":"97","8":"21.5","9":"20.01","10":"1","11":"2.465","_rn_":"Toyota Corona"},{"1":"0","2":"2","3":"8","4":"318.0","5":"2.76","6":"3","7":"150","8":"15.5","9":"16.87","10":"0","11":"3.520","_rn_":"Dodge Challenger"},{"1":"0","2":"2","3":"8","4":"304.0","5":"3.15","6":"3","7":"150","8":"15.2","9":"17.30","10":"0","11":"3.435","_rn_":"AMC Javelin"},{"1":"0","2":"4","3":"8","4":"350.0","5":"3.73","6":"3","7":"245","8":"13.3","9":"15.41","10":"0","11":"3.840","_rn_":"Camaro Z28"},{"1":"0","2":"2","3":"8","4":"400.0","5":"3.08","6":"3","7":"175","8":"19.2","9":"17.05","10":"0","11":"3.845","_rn_":"Pontiac Firebird"},{"1":"1","2":"1","3":"4","4":"79.0","5":"4.08","6":"4","7":"66","8":"27.3","9":"18.90","10":"1","11":"1.935","_rn_":"Fiat X1-9"},{"1":"1","2":"2","3":"4","4":"120.3","5":"4.43","6":"5","7":"91","8":"26.0","9":"16.70","10":"0","11":"2.140","_rn_":"Porsche 914-2"},{"1":"1","2":"2","3":"4","4":"95.1","5":"3.77","6":"5","7":"113","8":"30.4","9":"16.90","10":"1","11":"1.513","_rn_":"Lotus Europa"},{"1":"1","2":"4","3":"8","4":"351.0","5":"4.22","6":"5","7":"264","8":"15.8","9":"14.50","10":"0","11":"3.170","_rn_":"Ford Pantera L"},{"1":"1","2":"6","3":"6","4":"145.0","5":"3.62","6":"5","7":"175","8":"19.7","9":"15.50","10":"0","11":"2.770","_rn_":"Ferrari Dino"},{"1":"1","2":"8","3":"8","4":"301.0","5":"3.54","6":"5","7":"335","8":"15.0","9":"14.60","10":"0","11":"3.570","_rn_":"Maserati Bora"},{"1":"1","2":"2","3":"4","4":"121.0","5":"4.11","6":"4","7":"109","8":"21.4","9":"18.60","10":"1","11":"2.780","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: using <code>sort(colnames)</code>.</p>
<hr />
</div>
</div>
<div id="control-flow" class="section level1">
<h1>5 Control flow</h1>
<p>There are two primary tools of control flow: choices and loops.
Choices, like <code>if</code> statements and <code>switch()</code>
calls, allow you to run different code depending on the input. Loops,
like <code>for</code> and <code>while</code>, allow you to repeatedly
run code, typically with changing options. I’d expect that you’re
already familiar with the basics of these functions so I’ll briefly
cover some technical details and then introduce some useful, but lesser
known, features.</p>
<p>The condition system (messages, warnings, and errors), which you’ll
learn about in Chapter 8, also provides non-local control flow.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-12" class="section level2">
<h2>5.2.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What type of vector does each of the following calls to
<code>ifelse()</code> return? Read the documentation and write down the
rules in your own words.</li>
</ol>
<pre class="r"><code>ifelse(TRUE, 1, &quot;no&quot;)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>typeof(ifelse(TRUE, 1, &quot;no&quot;)) # double</code></pre>
<pre><code>#&gt; [1] &quot;double&quot;</code></pre>
<pre class="r"><code>ifelse(FALSE, 1, &quot;no&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;no&quot;</code></pre>
<pre class="r"><code>typeof(ifelse(FALSE, 1, &quot;no&quot;)) # character</code></pre>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
<pre class="r"><code>ifelse(NA, 1, &quot;no&quot;)</code></pre>
<pre><code>#&gt; [1] NA</code></pre>
<pre class="r"><code>typeof(ifelse(NA, 1, &quot;no&quot;)) # logical</code></pre>
<pre><code>#&gt; [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>ifelse(NULL, 1, &quot;no&quot;)</code></pre>
<pre><code>#&gt; logical(0)</code></pre>
<p>Answer:</p>
<ul>
<li>if <code>test</code> is true, return a vector of the same length as
<code>test</code> (1) populated with “yes” - here 1 is a double, 1L
would be integer</li>
<li>if <code>test</code> is false, return a vector of the same length as
<code>test</code> (1) populated with “no” - here “no” is a
character</li>
<li>if <code>test</code> is <code>NA</code>, return <code>NA</code>, and
if <code>test</code> is <code>NULL</code>, return
<code>logical(0)</code></li>
</ul>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Why does the following code work?</li>
</ol>
<pre class="r"><code>x &lt;- 1:10
if (length(x)) &quot;not empty&quot; else &quot;empty&quot;</code></pre>
<pre><code>#&gt; [1] &quot;not empty&quot;</code></pre>
<pre class="r"><code>x &lt;- numeric()
if (length(x)) &quot;not empty&quot; else &quot;empty&quot;</code></pre>
<pre><code>#&gt; [1] &quot;empty&quot;</code></pre>
<p>Answer: in the first example, <code>length(x)</code> is nonzero,
which evaluates to <code>TRUE</code>. In the second example,
<code>numeric()</code> returns a vector of length 0 (the default),
<code>length(x)</code> is zero, which evaluates to
<code>FALSE</code>.</p>
<hr />
</div>
<div id="exercises-13" class="section level2">
<h2>5.3.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Why does this code succeed without errors or warnings?</li>
</ol>
<pre class="r"><code>x &lt;- numeric() # x is numeric(0)
out &lt;- vector(&quot;list&quot;, length(x)) # out is list(0)
for (i in 1:length(x)) { # nolint: seq_linter. i is 1, then 0.
  out[i] &lt;- x[i]^2 # when i = 1 x[1] is NA, sets out[1] to NA. when i = 0 nothing happens
}
out</code></pre>
<pre><code>#&gt; [[1]]
#&gt; [1] NA</code></pre>
<p>Answer: in addition to notes above, <code>out[0]</code> and
<code>x[0]</code> return a zero-length vector.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>When the following code is evaluated, what can you say about the
vector being iterated?</li>
</ol>
<pre class="r"><code>xs &lt;- c(1, 2, 3)
for (x in xs) {
  xs &lt;- c(xs, x * 2)
}
xs</code></pre>
<pre><code>#&gt; [1] 1 2 3 2 4 6</code></pre>
<p>Answer: <code>x</code> iterates from 1 to 3, and is not affected by
changes to <code>xs</code> during the loop, while <code>xs</code> is
updated.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does the following code tell you about when the index is
updated?</li>
</ol>
<pre class="r"><code>for (i in 1:3) {
  i &lt;- i * 2
  print(i)
}</code></pre>
<pre><code>#&gt; [1] 2
#&gt; [1] 4
#&gt; [1] 6</code></pre>
<p>Answer: the index is updated at the beginning of each loop.</p>
<hr />
</div>
</div>
<div id="functions" class="section level1">
<h1>6 Functions</h1>
<p>If you’re reading this book, you’ve probably already created many R
functions and know how to use them to reduce duplication in your code.
In this chapter, you’ll learn how to turn that informal, working
knowledge into more rigorous, theoretical understanding. And while
you’ll see some interesting tricks and techniques along the way, keep in
mind that what you’ll learn here will be important for understanding the
more advanced topics discussed later in the book.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="quiz-1" class="section level2">
<h2>6 Quiz</h2>
<p>Answer the following questions to see if you can safely skip this
chapter. You can find the answers in Section @ref(function-answers).</p>
<ol style="list-style-type: decimal">
<li><p>What are the three components of a function? a: arguments, code,
return value [body, arguments, environment]</p></li>
<li><p>What does the following code return? a: 11 [correct!]</p></li>
</ol>
<pre class="r"><code>x &lt;- 10
f1 &lt;- function(x) {
  function() {
    x + 10
  }
}
f1(1)()</code></pre>
<pre><code>#&gt; [1] 11</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>How would you usually write this code? a: <code>1 + 2 * 3</code>
[correct! … <code>1 + (2 * 3)</code>]</li>
</ol>
<pre class="r"><code>`+`(1, `*`(2, 3))</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>How could you make this call easier to read?
<code>mean(c(1:10, NA), na.rm = TRUE)</code> [correct!]</li>
</ol>
<pre class="r"><code>mean(, TRUE, x = c(1:10, NA)) # nolint: missing_argument_linter.</code></pre>
<ol start="5" style="list-style-type: decimal">
<li>Does the following code throw an error when executed? Why or why
not? a: no, due to lazy evaluation, the <code>stop()</code> is never run
[correct! … second argument is never used]</li>
</ol>
<pre class="r"><code>f2 &lt;- function(a, b) {
  a * 10
}
f2(10, stop(&quot;This is an error!&quot;))</code></pre>
<pre><code>#&gt; [1] 100</code></pre>
<ol start="6" style="list-style-type: decimal">
<li><p>What is an infix function? How do you write it? What’s a
replacement function? How do you write it? a:
<code>function(x) x</code>. ??? [see 6.8.3 and 6.8.4]</p></li>
<li><p>How do you ensure that cleanup action occurs regardless of how a
function exits? a: ??? [<code>on.exit()</code>]</p></li>
</ol>
</div>
<div id="exercises-14" class="section level2">
<h2>6.2.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Given a name, like <code>"mean"</code>, <code>match.fun()</code>
lets you find a function. Given a function, can you find its name? Why
doesn’t that make sense in R?</li>
</ol>
<p>Answer: a function is an object and could have multiple names
pointing to it.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>It’s possible (although typically not useful) to call an anonymous
function. Which of the two approaches below is correct? Why?</li>
</ol>
<pre class="r"><code>function(x) 3()</code></pre>
<pre><code>#&gt; function(x) 3()
#&gt; &lt;environment: 0x7faa9191fba0&gt;</code></pre>
<pre class="r"><code>(function(x) 3)()</code></pre>
<pre><code>#&gt; [1] 3</code></pre>
<p>Answer: The second is correct, as the first is the form of defining a
function.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>A good rule of thumb is that an anonymous function should fit on one
line and shouldn’t need to use <code>{}</code>. Review your code. Where
could you have used an anonymous function instead of a named function?
Where should you have used a named function instead of an anonymous
function?</li>
</ol>
<p>Answer: in <code>rdev::build_analysis_site()</code>,
<code>analysis_menu_item()</code> is properly written as a named
function, where <code>get_component()</code> could be written as an
anonymous function, with <code>dir_check_copy()</code> and
<code>dir_check_delete()</code> potentially either.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What function allows you to tell if an object is a function? What
function allows you to tell if a function is a primitive function?</li>
</ol>
<p>Answer: <code>is.function()</code> and
<code>is.primitive()</code>.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>This code makes a list of all functions in the base package.</li>
</ol>
<pre class="r"><code>objs &lt;- mget(ls(&quot;package:base&quot;, all = TRUE), inherits = TRUE)</code></pre>
<pre><code>#&gt; Warning in ls(&quot;package:base&quot;, all = TRUE): partial argument match of &#39;all&#39; to &#39;all.names&#39;</code></pre>
<pre class="r"><code>funs &lt;- Filter(is.function, objs)</code></pre>
<p>Use it to answer the following questions:</p>
<ol style="list-style-type: lower-alpha">
<li>Which base function has the most arguments?</li>
<li>How many base functions have no arguments? What’s special about
those functions?</li>
<li>How could you adapt the code to find all primitive functions?</li>
</ol>
<pre class="r"><code>fun_args &lt;- data.frame(
  name = names(funs),
  args = unname(vapply(funs, function(x) length(formals(x)), 1L))
)
head(fun_args[order(fun_args$args, decreasing = TRUE), ], 10)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["args"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"scan","2":"22","_rn_":"1056"},{"1":"format.default","2":"16","_rn_":"564"},{"1":"source","2":"16","_rn_":"1109"},{"1":"formatC","2":"15","_rn_":"577"},{"1":"library","2":"13","_rn_":"755"},{"1":"merge.data.frame","2":"13","_rn_":"812"},{"1":"prettyNum","2":"13","_rn_":"907"},{"1":"system2","2":"11","_rn_":"1219"},{"1":"print.default","2":"10","_rn_":"915"},{"1":"save","2":"10","_rn_":"1051"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>fun_args[fun_args$args == 0, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["args"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"-","2":"0","_rn_":"1"},{"1":":","2":"0","_rn_":"4"},{"1":"::","2":"0","_rn_":"5"},{"1":":::","2":"0","_rn_":"6"},{"1":"!","2":"0","_rn_":"7"},{"1":"!=","2":"0","_rn_":"10"},{"1":"...elt","2":"0","_rn_":"13"},{"1":"...length","2":"0","_rn_":"14"},{"1":"...names","2":"0","_rn_":"15"},{"1":".C","2":"0","_rn_":"20"},{"1":".cache_class","2":"0","_rn_":"21"},{"1":".Call","2":"0","_rn_":"22"},{"1":".Call.graphics","2":"0","_rn_":"23"},{"1":".class2","2":"0","_rn_":"24"},{"1":".External","2":"0","_rn_":"41"},{"1":".External.graphics","2":"0","_rn_":"42"},{"1":".External2","2":"0","_rn_":"43"},{"1":".First.sys","2":"0","_rn_":"44"},{"1":".Fortran","2":"0","_rn_":"46"},{"1":".Internal","2":"0","_rn_":"54"},{"1":".isMethodsDispatchOn","2":"0","_rn_":"55"},{"1":".NotYetImplemented","2":"0","_rn_":"66"},{"1":".OptRequireMethods","2":"0","_rn_":"68"},{"1":".Primitive","2":"0","_rn_":"74"},{"1":".primTrace","2":"0","_rn_":"75"},{"1":".primUntrace","2":"0","_rn_":"76"},{"1":".standard_regexps","2":"0","_rn_":"87"},{"1":".subset","2":"0","_rn_":"88"},{"1":".subset2","2":"0","_rn_":"89"},{"1":".tryResumeInterrupt","2":"0","_rn_":"92"},{"1":"(","2":"0","_rn_":"94"},{"1":"[","2":"0","_rn_":"95"},{"1":"[[","2":"0","_rn_":"113"},{"1":"[[<-","2":"0","_rn_":"120"},{"1":"[<-","2":"0","_rn_":"125"},{"1":"{","2":"0","_rn_":"133"},{"1":"@","2":"0","_rn_":"134"},{"1":"@<-","2":"0","_rn_":"135"},{"1":"*","2":"0","_rn_":"136"},{"1":"/","2":"0","_rn_":"138"},{"1":"&","2":"0","_rn_":"140"},{"1":"&&","2":"0","_rn_":"143"},{"1":"%*%","2":"0","_rn_":"144"},{"1":"%/%","2":"0","_rn_":"145"},{"1":"%%","2":"0","_rn_":"146"},{"1":"^","2":"0","_rn_":"150"},{"1":"+","2":"0","_rn_":"151"},{"1":"<","2":"0","_rn_":"154"},{"1":"<-","2":"0","_rn_":"155"},{"1":"<<-","2":"0","_rn_":"156"},{"1":"<=","2":"0","_rn_":"157"},{"1":"=","2":"0","_rn_":"158"},{"1":"==","2":"0","_rn_":"159"},{"1":">","2":"0","_rn_":"160"},{"1":">=","2":"0","_rn_":"161"},{"1":"|","2":"0","_rn_":"162"},{"1":"||","2":"0","_rn_":"165"},{"1":"~","2":"0","_rn_":"166"},{"1":"$","2":"0","_rn_":"167"},{"1":"$<-","2":"0","_rn_":"170"},{"1":"abs","2":"0","_rn_":"173"},{"1":"acos","2":"0","_rn_":"174"},{"1":"acosh","2":"0","_rn_":"175"},{"1":"all","2":"0","_rn_":"182"},{"1":"any","2":"0","_rn_":"199"},{"1":"anyNA","2":"0","_rn_":"205"},{"1":"Arg","2":"0","_rn_":"214"},{"1":"as.call","2":"0","_rn_":"220"},{"1":"as.character","2":"0","_rn_":"221"},{"1":"as.complex","2":"0","_rn_":"232"},{"1":"as.double","2":"0","_rn_":"266"},{"1":"as.environment","2":"0","_rn_":"269"},{"1":"as.integer","2":"0","_rn_":"276"},{"1":"as.logical","2":"0","_rn_":"288"},{"1":"as.numeric","2":"0","_rn_":"298"},{"1":"as.raw","2":"0","_rn_":"317"},{"1":"asin","2":"0","_rn_":"327"},{"1":"asinh","2":"0","_rn_":"328"},{"1":"atan","2":"0","_rn_":"334"},{"1":"atanh","2":"0","_rn_":"336"},{"1":"attr","2":"0","_rn_":"339"},{"1":"attr<-","2":"0","_rn_":"341"},{"1":"attributes","2":"0","_rn_":"342"},{"1":"attributes<-","2":"0","_rn_":"343"},{"1":"baseenv","2":"0","_rn_":"347"},{"1":"break","2":"0","_rn_":"366"},{"1":"browser","2":"0","_rn_":"367"},{"1":"c","2":"0","_rn_":"376"},{"1":"call","2":"0","_rn_":"385"},{"1":"ceiling","2":"0","_rn_":"392"},{"1":"class","2":"0","_rn_":"404"},{"1":"class<-","2":"0","_rn_":"405"},{"1":"closeAllConnections","2":"0","_rn_":"411"},{"1":"Conj","2":"0","_rn_":"428"},{"1":"contributors","2":"0","_rn_":"429"},{"1":"cos","2":"0","_rn_":"430"},{"1":"cosh","2":"0","_rn_":"431"},{"1":"cospi","2":"0","_rn_":"432"},{"1":"Cstack_info","2":"0","_rn_":"434"},{"1":"cummax","2":"0","_rn_":"435"},{"1":"cummin","2":"0","_rn_":"436"},{"1":"cumprod","2":"0","_rn_":"437"},{"1":"cumsum","2":"0","_rn_":"438"},{"1":"date","2":"0","_rn_":"447"},{"1":"default.stringsAsFactors","2":"0","_rn_":"451"},{"1":"digamma","2":"0","_rn_":"468"},{"1":"dim","2":"0","_rn_":"469"},{"1":"dim<-","2":"0","_rn_":"471"},{"1":"dimnames","2":"0","_rn_":"472"},{"1":"dimnames<-","2":"0","_rn_":"474"},{"1":"emptyenv","2":"0","_rn_":"503"},{"1":"enc2native","2":"0","_rn_":"504"},{"1":"enc2utf8","2":"0","_rn_":"505"},{"1":"environment<-","2":"0","_rn_":"513"},{"1":"exp","2":"0","_rn_":"521"},{"1":"expm1","2":"0","_rn_":"523"},{"1":"expression","2":"0","_rn_":"524"},{"1":"extSoftVersion","2":"0","_rn_":"525"},{"1":"floor","2":"0","_rn_":"552"},{"1":"for","2":"0","_rn_":"555"},{"1":"forceAndCall","2":"0","_rn_":"557"},{"1":"function","2":"0","_rn_":"580"},{"1":"gamma","2":"0","_rn_":"581"},{"1":"gc.time","2":"0","_rn_":"583"},{"1":"getAllConnections","2":"0","_rn_":"589"},{"1":"geterrmessage","2":"0","_rn_":"597"},{"1":"getLoadedDLLs","2":"0","_rn_":"600"},{"1":"getRversion","2":"0","_rn_":"610"},{"1":"getTaskCallbackNames","2":"0","_rn_":"612"},{"1":"getwd","2":"0","_rn_":"615"},{"1":"globalenv","2":"0","_rn_":"618"},{"1":"iconvlist","2":"0","_rn_":"630"},{"1":"if","2":"0","_rn_":"635"},{"1":"Im","2":"0","_rn_":"637"},{"1":"interactive","2":"0","_rn_":"643"},{"1":"invisible","2":"0","_rn_":"648"},{"1":"is.array","2":"0","_rn_":"651"},{"1":"is.atomic","2":"0","_rn_":"652"},{"1":"is.call","2":"0","_rn_":"653"},{"1":"is.character","2":"0","_rn_":"654"},{"1":"is.complex","2":"0","_rn_":"655"},{"1":"is.double","2":"0","_rn_":"657"},{"1":"is.environment","2":"0","_rn_":"659"},{"1":"is.expression","2":"0","_rn_":"660"},{"1":"is.finite","2":"0","_rn_":"662"},{"1":"is.function","2":"0","_rn_":"663"},{"1":"is.infinite","2":"0","_rn_":"664"},{"1":"is.integer","2":"0","_rn_":"665"},{"1":"is.language","2":"0","_rn_":"666"},{"1":"is.list","2":"0","_rn_":"667"},{"1":"is.logical","2":"0","_rn_":"669"},{"1":"is.matrix","2":"0","_rn_":"670"},{"1":"is.na","2":"0","_rn_":"671"},{"1":"is.name","2":"0","_rn_":"679"},{"1":"is.nan","2":"0","_rn_":"680"},{"1":"is.null","2":"0","_rn_":"681"},{"1":"is.numeric","2":"0","_rn_":"682"},{"1":"is.object","2":"0","_rn_":"687"},{"1":"is.pairlist","2":"0","_rn_":"690"},{"1":"is.R","2":"0","_rn_":"693"},{"1":"is.raw","2":"0","_rn_":"694"},{"1":"is.recursive","2":"0","_rn_":"695"},{"1":"is.single","2":"0","_rn_":"696"},{"1":"is.symbol","2":"0","_rn_":"697"},{"1":"isS4","2":"0","_rn_":"713"},{"1":"l10n_info","2":"0","_rn_":"727"},{"1":"La_library","2":"0","_rn_":"728"},{"1":"La_version","2":"0","_rn_":"729"},{"1":"lazyLoadDBfetch","2":"0","_rn_":"736"},{"1":"length","2":"0","_rn_":"739"},{"1":"length<-","2":"0","_rn_":"741"},{"1":"levels<-","2":"0","_rn_":"750"},{"1":"lgamma","2":"0","_rn_":"753"},{"1":"libcurlVersion","2":"0","_rn_":"754"},{"1":"licence","2":"0","_rn_":"758"},{"1":"license","2":"0","_rn_":"759"},{"1":"list","2":"0","_rn_":"760"},{"1":"loadedNamespaces","2":"0","_rn_":"766"},{"1":"loadingNamespaceInfo","2":"0","_rn_":"767"},{"1":"log","2":"0","_rn_":"772"},{"1":"log10","2":"0","_rn_":"773"},{"1":"log1p","2":"0","_rn_":"774"},{"1":"log2","2":"0","_rn_":"775"},{"1":"max","2":"0","_rn_":"798"},{"1":"memory.profile","2":"0","_rn_":"810"},{"1":"min","2":"0","_rn_":"816"},{"1":"missing","2":"0","_rn_":"817"},{"1":"Mod","2":"0","_rn_":"818"},{"1":"names","2":"0","_rn_":"827"},{"1":"names<-","2":"0","_rn_":"829"},{"1":"nargs","2":"0","_rn_":"836"},{"1":"next","2":"0","_rn_":"842"},{"1":"nullfile","2":"0","_rn_":"851"},{"1":"nzchar","2":"0","_rn_":"856"},{"1":"oldClass","2":"0","_rn_":"858"},{"1":"oldClass<-","2":"0","_rn_":"859"},{"1":"on.exit","2":"0","_rn_":"861"},{"1":"pcre_config","2":"0","_rn_":"894"},{"1":"pos.to.env","2":"0","_rn_":"903"},{"1":"proc.time","2":"0","_rn_":"946"},{"1":"prod","2":"0","_rn_":"947"},{"1":"quote","2":"0","_rn_":"970"},{"1":"R.Version","2":"0","_rn_":"973"},{"1":"range","2":"0","_rn_":"974"},{"1":"Re","2":"0","_rn_":"987"},{"1":"rep","2":"0","_rn_":"1006"},{"1":"repeat","2":"0","_rn_":"1015"},{"1":"retracemem","2":"0","_rn_":"1022"},{"1":"return","2":"0","_rn_":"1023"},{"1":"round","2":"0","_rn_":"1031"},{"1":"search","2":"0","_rn_":"1057"},{"1":"searchpaths","2":"0","_rn_":"1058"},{"1":"seq_along","2":"0","_rn_":"1062"},{"1":"seq_len","2":"0","_rn_":"1063"},{"1":"seq.int","2":"0","_rn_":"1066"},{"1":"sign","2":"0","_rn_":"1082"},{"1":"signif","2":"0","_rn_":"1084"},{"1":"sin","2":"0","_rn_":"1090"},{"1":"sinh","2":"0","_rn_":"1092"},{"1":"sinpi","2":"0","_rn_":"1095"},{"1":"sqrt","2":"0","_rn_":"1119"},{"1":"standardGeneric","2":"0","_rn_":"1125"},{"1":"stderr","2":"0","_rn_":"1127"},{"1":"stdin","2":"0","_rn_":"1128"},{"1":"stdout","2":"0","_rn_":"1129"},{"1":"storage.mode<-","2":"0","_rn_":"1133"},{"1":"substitute","2":"0","_rn_":"1149"},{"1":"sum","2":"0","_rn_":"1154"},{"1":"switch","2":"0","_rn_":"1183"},{"1":"sys.calls","2":"0","_rn_":"1185"},{"1":"Sys.Date","2":"0","_rn_":"1187"},{"1":"sys.frames","2":"0","_rn_":"1189"},{"1":"Sys.getpid","2":"0","_rn_":"1193"},{"1":"Sys.info","2":"0","_rn_":"1195"},{"1":"Sys.localeconv","2":"0","_rn_":"1197"},{"1":"sys.nframe","2":"0","_rn_":"1198"},{"1":"sys.on.exit","2":"0","_rn_":"1199"},{"1":"sys.parents","2":"0","_rn_":"1201"},{"1":"sys.status","2":"0","_rn_":"1210"},{"1":"Sys.time","2":"0","_rn_":"1211"},{"1":"tan","2":"0","_rn_":"1225"},{"1":"tanh","2":"0","_rn_":"1226"},{"1":"tanpi","2":"0","_rn_":"1227"},{"1":"tracemem","2":"0","_rn_":"1242"},{"1":"trigamma","2":"0","_rn_":"1247"},{"1":"trunc","2":"0","_rn_":"1249"},{"1":"unclass","2":"0","_rn_":"1258"},{"1":"untracemem","2":"0","_rn_":"1282"},{"1":"UseMethod","2":"0","_rn_":"1286"},{"1":"while","2":"0","_rn_":"1302"},{"1":"xtfrm","2":"0","_rn_":"1319"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># check if all functions with 0 arguments are primitive
fun_args2 &lt;- data.frame(
  name = names(funs),
  args = unname(vapply(funs, function(x) length(formals(x)), 1L)),
  prim = unname(vapply(funs, is.primitive, TRUE))
)
fun_args2[fun_args2$args == 0, ]</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["args"],"name":[2],"type":["int"],"align":["right"]},{"label":["prim"],"name":[3],"type":["lgl"],"align":["right"]}],"data":[{"1":"-","2":"0","3":"TRUE","_rn_":"1"},{"1":":","2":"0","3":"TRUE","_rn_":"4"},{"1":"::","2":"0","3":"TRUE","_rn_":"5"},{"1":":::","2":"0","3":"TRUE","_rn_":"6"},{"1":"!","2":"0","3":"TRUE","_rn_":"7"},{"1":"!=","2":"0","3":"TRUE","_rn_":"10"},{"1":"...elt","2":"0","3":"TRUE","_rn_":"13"},{"1":"...length","2":"0","3":"TRUE","_rn_":"14"},{"1":"...names","2":"0","3":"TRUE","_rn_":"15"},{"1":".C","2":"0","3":"TRUE","_rn_":"20"},{"1":".cache_class","2":"0","3":"TRUE","_rn_":"21"},{"1":".Call","2":"0","3":"TRUE","_rn_":"22"},{"1":".Call.graphics","2":"0","3":"TRUE","_rn_":"23"},{"1":".class2","2":"0","3":"TRUE","_rn_":"24"},{"1":".External","2":"0","3":"TRUE","_rn_":"41"},{"1":".External.graphics","2":"0","3":"TRUE","_rn_":"42"},{"1":".External2","2":"0","3":"TRUE","_rn_":"43"},{"1":".First.sys","2":"0","3":"FALSE","_rn_":"44"},{"1":".Fortran","2":"0","3":"TRUE","_rn_":"46"},{"1":".Internal","2":"0","3":"TRUE","_rn_":"54"},{"1":".isMethodsDispatchOn","2":"0","3":"TRUE","_rn_":"55"},{"1":".NotYetImplemented","2":"0","3":"FALSE","_rn_":"66"},{"1":".OptRequireMethods","2":"0","3":"FALSE","_rn_":"68"},{"1":".Primitive","2":"0","3":"TRUE","_rn_":"74"},{"1":".primTrace","2":"0","3":"TRUE","_rn_":"75"},{"1":".primUntrace","2":"0","3":"TRUE","_rn_":"76"},{"1":".standard_regexps","2":"0","3":"FALSE","_rn_":"87"},{"1":".subset","2":"0","3":"TRUE","_rn_":"88"},{"1":".subset2","2":"0","3":"TRUE","_rn_":"89"},{"1":".tryResumeInterrupt","2":"0","3":"FALSE","_rn_":"92"},{"1":"(","2":"0","3":"TRUE","_rn_":"94"},{"1":"[","2":"0","3":"TRUE","_rn_":"95"},{"1":"[[","2":"0","3":"TRUE","_rn_":"113"},{"1":"[[<-","2":"0","3":"TRUE","_rn_":"120"},{"1":"[<-","2":"0","3":"TRUE","_rn_":"125"},{"1":"{","2":"0","3":"TRUE","_rn_":"133"},{"1":"@","2":"0","3":"TRUE","_rn_":"134"},{"1":"@<-","2":"0","3":"TRUE","_rn_":"135"},{"1":"*","2":"0","3":"TRUE","_rn_":"136"},{"1":"/","2":"0","3":"TRUE","_rn_":"138"},{"1":"&","2":"0","3":"TRUE","_rn_":"140"},{"1":"&&","2":"0","3":"TRUE","_rn_":"143"},{"1":"%*%","2":"0","3":"TRUE","_rn_":"144"},{"1":"%/%","2":"0","3":"TRUE","_rn_":"145"},{"1":"%%","2":"0","3":"TRUE","_rn_":"146"},{"1":"^","2":"0","3":"TRUE","_rn_":"150"},{"1":"+","2":"0","3":"TRUE","_rn_":"151"},{"1":"<","2":"0","3":"TRUE","_rn_":"154"},{"1":"<-","2":"0","3":"TRUE","_rn_":"155"},{"1":"<<-","2":"0","3":"TRUE","_rn_":"156"},{"1":"<=","2":"0","3":"TRUE","_rn_":"157"},{"1":"=","2":"0","3":"TRUE","_rn_":"158"},{"1":"==","2":"0","3":"TRUE","_rn_":"159"},{"1":">","2":"0","3":"TRUE","_rn_":"160"},{"1":">=","2":"0","3":"TRUE","_rn_":"161"},{"1":"|","2":"0","3":"TRUE","_rn_":"162"},{"1":"||","2":"0","3":"TRUE","_rn_":"165"},{"1":"~","2":"0","3":"TRUE","_rn_":"166"},{"1":"$","2":"0","3":"TRUE","_rn_":"167"},{"1":"$<-","2":"0","3":"TRUE","_rn_":"170"},{"1":"abs","2":"0","3":"TRUE","_rn_":"173"},{"1":"acos","2":"0","3":"TRUE","_rn_":"174"},{"1":"acosh","2":"0","3":"TRUE","_rn_":"175"},{"1":"all","2":"0","3":"TRUE","_rn_":"182"},{"1":"any","2":"0","3":"TRUE","_rn_":"199"},{"1":"anyNA","2":"0","3":"TRUE","_rn_":"205"},{"1":"Arg","2":"0","3":"TRUE","_rn_":"214"},{"1":"as.call","2":"0","3":"TRUE","_rn_":"220"},{"1":"as.character","2":"0","3":"TRUE","_rn_":"221"},{"1":"as.complex","2":"0","3":"TRUE","_rn_":"232"},{"1":"as.double","2":"0","3":"TRUE","_rn_":"266"},{"1":"as.environment","2":"0","3":"TRUE","_rn_":"269"},{"1":"as.integer","2":"0","3":"TRUE","_rn_":"276"},{"1":"as.logical","2":"0","3":"TRUE","_rn_":"288"},{"1":"as.numeric","2":"0","3":"TRUE","_rn_":"298"},{"1":"as.raw","2":"0","3":"TRUE","_rn_":"317"},{"1":"asin","2":"0","3":"TRUE","_rn_":"327"},{"1":"asinh","2":"0","3":"TRUE","_rn_":"328"},{"1":"atan","2":"0","3":"TRUE","_rn_":"334"},{"1":"atanh","2":"0","3":"TRUE","_rn_":"336"},{"1":"attr","2":"0","3":"TRUE","_rn_":"339"},{"1":"attr<-","2":"0","3":"TRUE","_rn_":"341"},{"1":"attributes","2":"0","3":"TRUE","_rn_":"342"},{"1":"attributes<-","2":"0","3":"TRUE","_rn_":"343"},{"1":"baseenv","2":"0","3":"TRUE","_rn_":"347"},{"1":"break","2":"0","3":"TRUE","_rn_":"366"},{"1":"browser","2":"0","3":"TRUE","_rn_":"367"},{"1":"c","2":"0","3":"TRUE","_rn_":"376"},{"1":"call","2":"0","3":"TRUE","_rn_":"385"},{"1":"ceiling","2":"0","3":"TRUE","_rn_":"392"},{"1":"class","2":"0","3":"TRUE","_rn_":"404"},{"1":"class<-","2":"0","3":"TRUE","_rn_":"405"},{"1":"closeAllConnections","2":"0","3":"FALSE","_rn_":"411"},{"1":"Conj","2":"0","3":"TRUE","_rn_":"428"},{"1":"contributors","2":"0","3":"FALSE","_rn_":"429"},{"1":"cos","2":"0","3":"TRUE","_rn_":"430"},{"1":"cosh","2":"0","3":"TRUE","_rn_":"431"},{"1":"cospi","2":"0","3":"TRUE","_rn_":"432"},{"1":"Cstack_info","2":"0","3":"FALSE","_rn_":"434"},{"1":"cummax","2":"0","3":"TRUE","_rn_":"435"},{"1":"cummin","2":"0","3":"TRUE","_rn_":"436"},{"1":"cumprod","2":"0","3":"TRUE","_rn_":"437"},{"1":"cumsum","2":"0","3":"TRUE","_rn_":"438"},{"1":"date","2":"0","3":"FALSE","_rn_":"447"},{"1":"default.stringsAsFactors","2":"0","3":"FALSE","_rn_":"451"},{"1":"digamma","2":"0","3":"TRUE","_rn_":"468"},{"1":"dim","2":"0","3":"TRUE","_rn_":"469"},{"1":"dim<-","2":"0","3":"TRUE","_rn_":"471"},{"1":"dimnames","2":"0","3":"TRUE","_rn_":"472"},{"1":"dimnames<-","2":"0","3":"TRUE","_rn_":"474"},{"1":"emptyenv","2":"0","3":"TRUE","_rn_":"503"},{"1":"enc2native","2":"0","3":"TRUE","_rn_":"504"},{"1":"enc2utf8","2":"0","3":"TRUE","_rn_":"505"},{"1":"environment<-","2":"0","3":"TRUE","_rn_":"513"},{"1":"exp","2":"0","3":"TRUE","_rn_":"521"},{"1":"expm1","2":"0","3":"TRUE","_rn_":"523"},{"1":"expression","2":"0","3":"TRUE","_rn_":"524"},{"1":"extSoftVersion","2":"0","3":"FALSE","_rn_":"525"},{"1":"floor","2":"0","3":"TRUE","_rn_":"552"},{"1":"for","2":"0","3":"TRUE","_rn_":"555"},{"1":"forceAndCall","2":"0","3":"TRUE","_rn_":"557"},{"1":"function","2":"0","3":"TRUE","_rn_":"580"},{"1":"gamma","2":"0","3":"TRUE","_rn_":"581"},{"1":"gc.time","2":"0","3":"TRUE","_rn_":"583"},{"1":"getAllConnections","2":"0","3":"FALSE","_rn_":"589"},{"1":"geterrmessage","2":"0","3":"FALSE","_rn_":"597"},{"1":"getLoadedDLLs","2":"0","3":"FALSE","_rn_":"600"},{"1":"getRversion","2":"0","3":"FALSE","_rn_":"610"},{"1":"getTaskCallbackNames","2":"0","3":"FALSE","_rn_":"612"},{"1":"getwd","2":"0","3":"FALSE","_rn_":"615"},{"1":"globalenv","2":"0","3":"TRUE","_rn_":"618"},{"1":"iconvlist","2":"0","3":"FALSE","_rn_":"630"},{"1":"if","2":"0","3":"TRUE","_rn_":"635"},{"1":"Im","2":"0","3":"TRUE","_rn_":"637"},{"1":"interactive","2":"0","3":"TRUE","_rn_":"643"},{"1":"invisible","2":"0","3":"TRUE","_rn_":"648"},{"1":"is.array","2":"0","3":"TRUE","_rn_":"651"},{"1":"is.atomic","2":"0","3":"TRUE","_rn_":"652"},{"1":"is.call","2":"0","3":"TRUE","_rn_":"653"},{"1":"is.character","2":"0","3":"TRUE","_rn_":"654"},{"1":"is.complex","2":"0","3":"TRUE","_rn_":"655"},{"1":"is.double","2":"0","3":"TRUE","_rn_":"657"},{"1":"is.environment","2":"0","3":"TRUE","_rn_":"659"},{"1":"is.expression","2":"0","3":"TRUE","_rn_":"660"},{"1":"is.finite","2":"0","3":"TRUE","_rn_":"662"},{"1":"is.function","2":"0","3":"TRUE","_rn_":"663"},{"1":"is.infinite","2":"0","3":"TRUE","_rn_":"664"},{"1":"is.integer","2":"0","3":"TRUE","_rn_":"665"},{"1":"is.language","2":"0","3":"TRUE","_rn_":"666"},{"1":"is.list","2":"0","3":"TRUE","_rn_":"667"},{"1":"is.logical","2":"0","3":"TRUE","_rn_":"669"},{"1":"is.matrix","2":"0","3":"TRUE","_rn_":"670"},{"1":"is.na","2":"0","3":"TRUE","_rn_":"671"},{"1":"is.name","2":"0","3":"TRUE","_rn_":"679"},{"1":"is.nan","2":"0","3":"TRUE","_rn_":"680"},{"1":"is.null","2":"0","3":"TRUE","_rn_":"681"},{"1":"is.numeric","2":"0","3":"TRUE","_rn_":"682"},{"1":"is.object","2":"0","3":"TRUE","_rn_":"687"},{"1":"is.pairlist","2":"0","3":"TRUE","_rn_":"690"},{"1":"is.R","2":"0","3":"FALSE","_rn_":"693"},{"1":"is.raw","2":"0","3":"TRUE","_rn_":"694"},{"1":"is.recursive","2":"0","3":"TRUE","_rn_":"695"},{"1":"is.single","2":"0","3":"TRUE","_rn_":"696"},{"1":"is.symbol","2":"0","3":"TRUE","_rn_":"697"},{"1":"isS4","2":"0","3":"TRUE","_rn_":"713"},{"1":"l10n_info","2":"0","3":"FALSE","_rn_":"727"},{"1":"La_library","2":"0","3":"FALSE","_rn_":"728"},{"1":"La_version","2":"0","3":"FALSE","_rn_":"729"},{"1":"lazyLoadDBfetch","2":"0","3":"TRUE","_rn_":"736"},{"1":"length","2":"0","3":"TRUE","_rn_":"739"},{"1":"length<-","2":"0","3":"TRUE","_rn_":"741"},{"1":"levels<-","2":"0","3":"TRUE","_rn_":"750"},{"1":"lgamma","2":"0","3":"TRUE","_rn_":"753"},{"1":"libcurlVersion","2":"0","3":"FALSE","_rn_":"754"},{"1":"licence","2":"0","3":"FALSE","_rn_":"758"},{"1":"license","2":"0","3":"FALSE","_rn_":"759"},{"1":"list","2":"0","3":"TRUE","_rn_":"760"},{"1":"loadedNamespaces","2":"0","3":"FALSE","_rn_":"766"},{"1":"loadingNamespaceInfo","2":"0","3":"FALSE","_rn_":"767"},{"1":"log","2":"0","3":"TRUE","_rn_":"772"},{"1":"log10","2":"0","3":"TRUE","_rn_":"773"},{"1":"log1p","2":"0","3":"TRUE","_rn_":"774"},{"1":"log2","2":"0","3":"TRUE","_rn_":"775"},{"1":"max","2":"0","3":"TRUE","_rn_":"798"},{"1":"memory.profile","2":"0","3":"FALSE","_rn_":"810"},{"1":"min","2":"0","3":"TRUE","_rn_":"816"},{"1":"missing","2":"0","3":"TRUE","_rn_":"817"},{"1":"Mod","2":"0","3":"TRUE","_rn_":"818"},{"1":"names","2":"0","3":"TRUE","_rn_":"827"},{"1":"names<-","2":"0","3":"TRUE","_rn_":"829"},{"1":"nargs","2":"0","3":"TRUE","_rn_":"836"},{"1":"next","2":"0","3":"TRUE","_rn_":"842"},{"1":"nullfile","2":"0","3":"FALSE","_rn_":"851"},{"1":"nzchar","2":"0","3":"TRUE","_rn_":"856"},{"1":"oldClass","2":"0","3":"TRUE","_rn_":"858"},{"1":"oldClass<-","2":"0","3":"TRUE","_rn_":"859"},{"1":"on.exit","2":"0","3":"TRUE","_rn_":"861"},{"1":"pcre_config","2":"0","3":"FALSE","_rn_":"894"},{"1":"pos.to.env","2":"0","3":"TRUE","_rn_":"903"},{"1":"proc.time","2":"0","3":"TRUE","_rn_":"946"},{"1":"prod","2":"0","3":"TRUE","_rn_":"947"},{"1":"quote","2":"0","3":"TRUE","_rn_":"970"},{"1":"R.Version","2":"0","3":"FALSE","_rn_":"973"},{"1":"range","2":"0","3":"TRUE","_rn_":"974"},{"1":"Re","2":"0","3":"TRUE","_rn_":"987"},{"1":"rep","2":"0","3":"TRUE","_rn_":"1006"},{"1":"repeat","2":"0","3":"TRUE","_rn_":"1015"},{"1":"retracemem","2":"0","3":"TRUE","_rn_":"1022"},{"1":"return","2":"0","3":"TRUE","_rn_":"1023"},{"1":"round","2":"0","3":"TRUE","_rn_":"1031"},{"1":"search","2":"0","3":"FALSE","_rn_":"1057"},{"1":"searchpaths","2":"0","3":"FALSE","_rn_":"1058"},{"1":"seq_along","2":"0","3":"TRUE","_rn_":"1062"},{"1":"seq_len","2":"0","3":"TRUE","_rn_":"1063"},{"1":"seq.int","2":"0","3":"TRUE","_rn_":"1066"},{"1":"sign","2":"0","3":"TRUE","_rn_":"1082"},{"1":"signif","2":"0","3":"TRUE","_rn_":"1084"},{"1":"sin","2":"0","3":"TRUE","_rn_":"1090"},{"1":"sinh","2":"0","3":"TRUE","_rn_":"1092"},{"1":"sinpi","2":"0","3":"TRUE","_rn_":"1095"},{"1":"sqrt","2":"0","3":"TRUE","_rn_":"1119"},{"1":"standardGeneric","2":"0","3":"TRUE","_rn_":"1125"},{"1":"stderr","2":"0","3":"FALSE","_rn_":"1127"},{"1":"stdin","2":"0","3":"FALSE","_rn_":"1128"},{"1":"stdout","2":"0","3":"FALSE","_rn_":"1129"},{"1":"storage.mode<-","2":"0","3":"TRUE","_rn_":"1133"},{"1":"substitute","2":"0","3":"TRUE","_rn_":"1149"},{"1":"sum","2":"0","3":"TRUE","_rn_":"1154"},{"1":"switch","2":"0","3":"TRUE","_rn_":"1183"},{"1":"sys.calls","2":"0","3":"FALSE","_rn_":"1185"},{"1":"Sys.Date","2":"0","3":"FALSE","_rn_":"1187"},{"1":"sys.frames","2":"0","3":"FALSE","_rn_":"1189"},{"1":"Sys.getpid","2":"0","3":"FALSE","_rn_":"1193"},{"1":"Sys.info","2":"0","3":"FALSE","_rn_":"1195"},{"1":"Sys.localeconv","2":"0","3":"FALSE","_rn_":"1197"},{"1":"sys.nframe","2":"0","3":"FALSE","_rn_":"1198"},{"1":"sys.on.exit","2":"0","3":"FALSE","_rn_":"1199"},{"1":"sys.parents","2":"0","3":"FALSE","_rn_":"1201"},{"1":"sys.status","2":"0","3":"FALSE","_rn_":"1210"},{"1":"Sys.time","2":"0","3":"FALSE","_rn_":"1211"},{"1":"tan","2":"0","3":"TRUE","_rn_":"1225"},{"1":"tanh","2":"0","3":"TRUE","_rn_":"1226"},{"1":"tanpi","2":"0","3":"TRUE","_rn_":"1227"},{"1":"tracemem","2":"0","3":"TRUE","_rn_":"1242"},{"1":"trigamma","2":"0","3":"TRUE","_rn_":"1247"},{"1":"trunc","2":"0","3":"TRUE","_rn_":"1249"},{"1":"unclass","2":"0","3":"TRUE","_rn_":"1258"},{"1":"untracemem","2":"0","3":"TRUE","_rn_":"1282"},{"1":"UseMethod","2":"0","3":"TRUE","_rn_":"1286"},{"1":"while","2":"0","3":"TRUE","_rn_":"1302"},{"1":"xtfrm","2":"0","3":"TRUE","_rn_":"1319"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answers:</p>
<ol style="list-style-type: lower-alpha">
<li><code>scan()</code> has the most arguments, 22</li>
<li>most (but not all) are primitive functions (204 of 254)</li>
<li>the <code>ls()</code> in the original code could be expanded to
search all packages</li>
</ol>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>What are the three important components of a function?</li>
</ol>
<p>Answer: the <code>formals()</code>, <code>body()</code> and
<code>environment()</code>.</p>
<hr />
<ol start="7" style="list-style-type: decimal">
<li>When does printing a function not show the environment it was
created in?</li>
</ol>
<p>Answer: when it is created in the global environment.</p>
<hr />
</div>
<div id="exercises-15" class="section level2">
<h2>6.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What does the following code return? Why? Describe how each of the
three <code>c</code>’s is interpreted.</li>
</ol>
<pre class="r"><code>c &lt;- 10
c(c = c)</code></pre>
<pre><code>#&gt;  c 
#&gt; 10</code></pre>
<p>Answer: a named vector, <code>c 10</code>. The first and final c is a
variable. The second c is a function name. the third c is a name.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What are the four principles that govern how R looks for
values?</li>
</ol>
<p>Answer: name masking, functions versus variables, a fresh start,
dynamic lookup.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does the following function return? Make a prediction before
running the code yourself.</li>
</ol>
<pre class="r"><code>f &lt;- function(x) {
  f &lt;- function(x) { # return value of this is 101
    f &lt;- function() {
      x^2
    }
    f() + 1
  }
  f(x) * 2
}
f(10)</code></pre>
<pre><code>#&gt; [1] 202</code></pre>
<p>Answer: 202. Correct!</p>
<hr />
</div>
<div id="exercises-16" class="section level2">
<h2>6.5.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What important property of <code>&amp;&amp;</code> makes
<code>x_ok()</code> work?</li>
</ol>
<pre class="r"><code>x_ok &lt;- function(x) {
  !is.null(x) &amp;&amp; length(x) == 1 &amp;&amp; x &gt; 0
}

x_ok(NULL)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>x_ok(1)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>x_ok(1:3)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<p>Answer: From the <code>&amp;&amp;</code> docs, “The longer forms
evaluates left to right, proceeding only until the result is
determined.”</p>
<p>What is different with this code? Why is this behaviour undesirable
here?</p>
<pre class="r"><code>x_ok &lt;- function(x) {
  !is.null(x) &amp; length(x) == 1 &amp; x &gt; 0
}

x_ok(NULL)</code></pre>
<pre><code>#&gt; logical(0)</code></pre>
<pre class="r"><code>x_ok(1)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>x_ok(1:3)</code></pre>
<pre><code>#&gt; [1] FALSE FALSE FALSE</code></pre>
<p>Answer: “The shorter forms performs elementwise comparisons in much
the same way as arithmetic operators.” This is undesirable because the
intent of the function is to return <code>TRUE</code> or
<code>FALSE</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What does this function return? Why? Which principle does it
illustrate?</li>
</ol>
<pre class="r"><code>f2 &lt;- function(x = z) {
  z &lt;- 100
  x
}
f2()</code></pre>
<pre><code>#&gt; [1] 100</code></pre>
<p>Answer: 100, lazy evaluation. <code>x = z</code> isn’t evaluated
until <code>x</code>.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does this function return? Why? Which principle does it
illustrate?</li>
</ol>
<pre class="r"><code>y &lt;- 10
# styler: off
f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { # nolint brace_linter, semicolon_linter.
  # styler: on
  c(x, y)
}
f1()</code></pre>
<pre><code>#&gt; [1] 2 1</code></pre>
<pre class="r"><code>y</code></pre>
<pre><code>#&gt; [1] 10</code></pre>
<p>Answer: <code>c(2, 1)</code>. default arguments.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>In <code>hist()</code>, the default value of <code>xlim</code> is
<code>range(breaks)</code>, the default value for <code>breaks</code> is
<code>"Sturges"</code>, and</li>
</ol>
<pre class="r"><code>range(&quot;Sturges&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;Sturges&quot; &quot;Sturges&quot;</code></pre>
<p>Explain how <code>hist()</code> works to get a correct
<code>xlim</code> value.</p>
<p>Answer: from the docs, “Note that <code>xlim</code> is <em>not</em>
used to define the histogram (breaks), but only for plotting (when
<code>plot = TRUE</code>).” So, the breakpoints are calculated when the
object is created, and <code>xlim</code> is calculated when the
histogram is plotted, in the second step.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Explain why this function works. Why is it confusing?</li>
</ol>
<pre class="r"><code>show_time &lt;- function(x = stop(&quot;Error!&quot;)) {
  stop &lt;- function(...) Sys.time()
  print(x)
}
show_time()</code></pre>
<pre><code>#&gt; [1] &quot;2022-07-20 16:35:08 CDT&quot;</code></pre>
<p>Answer: <code>stop</code> is redefined before <code>x</code> is
evaluated. This is a confusing use of lazy evaluation.</p>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>How many arguments are required when calling
<code>library()</code>?</li>
</ol>
<p>Answer: zero. <code>library()</code> uses <code>missing()</code> to
return the list of available packages if there are no arguments.</p>
<hr />
</div>
<div id="exercises-17" class="section level2">
<h2>6.6.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Explain the following results:</li>
</ol>
<pre class="r"><code>sum(1, 2, 3)</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>mean(1, 2, 3)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>sum(1, 2, 3, na.omit = TRUE)</code></pre>
<pre><code>#&gt; [1] 7</code></pre>
<pre class="r"><code>mean(1, 2, 3, na.omit = TRUE)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<p>Answer:</p>
<ul>
<li>“<code>sum()</code> returns the sum of all the values present in its
arguments.” The first example is straightforward. In the second sum
example, <code>na.omit</code> isn’t a valid argument (<code>na.rm</code>
is), so the <code>TRUE</code> value is passed to <code>...</code>,
coerced to 1, and included in the sum.</li>
<li><code>mean()</code> takes a single parameter, and passes on
remaining arguments to <code>...</code>. In both cases, the arguments
after the <code>1</code> are silently dropped. The correct form would be
<code>mean(c(1, 2, 3))</code>.</li>
</ul>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Explain how to find the documentation for the named arguments in the
following function call:</li>
</ol>
<!-- TODO: bugfix: the figure below renders incorrectly,
     possibly due to https://github.com/rstudio/rstudio/issues/4521
     see also: https://github.com/hadley/adv-r/blob/master/common.R
     and: https://yihui.org/knitr/options/#plots
     workaround: use {r, fig.asp = 1}.
     {r, fig.asp = 1, fig.width = 3} looks correct in RStudio, but doesn't render properly for
     build_analysis_site(). {r, fig.asp = 1} works with build_analysis_site() but is not sized
     properly in RStudio. {r, fig.asp = 1} is the best option for now.
  -->
<pre class="r"><code>plot(1:10, col = &quot;red&quot;, pch = 20, xlab = &quot;x&quot;, col.lab = &quot;blue&quot;)</code></pre>
<p><img src="advanced-r-1_files/figure-html/unnamed-chunk-76-1.png" width="768" style="display: block; margin: auto;" /></p>
<p>Answer: in other functions, specifically <code>par()</code> and
<code>plot.default()</code>.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Why does <code>plot(1:10, col = "red")</code> only colour the
points, not the axes or labels? Read the source code of
<code>plot.default()</code> to find out.</li>
</ol>
<pre class="r"><code>localAxis &lt;- function(..., col, bg, pch, cex, lty, lwd) Axis(...)
localBox &lt;- function(..., col, bg, pch, cex, lty, lwd) box(...)
localWindow &lt;- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)
localTitle &lt;- function(..., col, bg, pch, cex, lty, lwd) title(...)</code></pre>
<p>Answer: <code>plot.default()</code> discards <code>col</code> and
several other arguments when calling <code>Axis()</code>,
<code>box()</code>, <code>plot.window()</code>, and
<code>title()</code>.</p>
<hr />
</div>
<div id="exercises-18" class="section level2">
<h2>6.7.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What does <code>load()</code> return? Why don’t you normally see
these values?</li>
</ol>
<p>Answer: from the docs, <code>load()</code> returns “A character
vector of the names of objects created, invisibly.”</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What does <code>write.table()</code> return? What would be more
useful?</li>
</ol>
<p>Answer: it returns <code>invisible(NULL)</code>. Returning the
written table or the argument <code>x</code> would be more useful.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>How does the <code>chdir</code> parameter of <code>source()</code>
compare to <code>with_dir()</code>? Why might you prefer one to the
other?</li>
</ol>
<p>Answer: both temporarily change the working directory.
<code>chdir</code> is preferable since this is expected behavior for the
function, unless you need to set a working directory other than the
directory containing <code>file</code>.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Write a function that opens a graphics device, runs the supplied
code, and closes the graphics device (always, regardless of whether or
not the plotting code works).</li>
</ol>
<pre class="r"><code>with_png &lt;- function(code, ...) {
  png(...)
  on.exit(dev.off(), add = TRUE, after = TRUE)
  force(code)
}

with_png(
  plot(1:10),
  filename = &quot;rendered/withpng-example.png&quot;,
  # use 3 times default resolution which is close to retina display ppi (218-254 depending on model)
  # https://support.apple.com/en-us/HT202471
  width = 480 * 3, height = 480 * 3, res = 72 * 3
)</code></pre>
<div class="figure">
<img src="rendered/withpng-example.png" alt="" />
<p class="caption">with_png output</p>
</div>
<p>Answer: code example above.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>We can use <code>on.exit()</code> to implement a simple version of
<code>capture.output()</code>.</li>
</ol>
<pre class="r"><code># nolint start: object_name_linter, undesirable_function_linter.
capture.output2 &lt;- function(code) {
  temp &lt;- tempfile()
  on.exit(file.remove(temp), add = TRUE, after = TRUE)
  sink(temp)
  on.exit(sink(), add = TRUE, after = TRUE)
  force(code)
  readLines(temp)
}
# nolint end
capture.output2(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\n&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<p>Compare <code>capture.output()</code> to
<code>capture.output2()</code>. How do the functions differ? What
features have I removed to make the key ideas easier to see? How have I
rewritten the key ideas so they’re easier to understand?</p>
<p>Answer: <code>capture.output2()</code> has fewer features and uses
two separate calls to <code>on.exit()</code>. It simply returns the
output (by line) from the executed code, and highlights the key idea,
using <code>sink()</code> to capture output to a temporary file.</p>
<hr />
</div>
<div id="exercises-19" class="section level2">
<h2>6.8.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Rewrite the following code snippets into prefix form:</li>
</ol>
<pre class="r"><code>1 + 2 + 3</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>`+`(`+`(1, 2), 3)</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>1 + (2 + 3)</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>`+`(1, `+`(2, 3))</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>fxn &lt;- function(x, n) if (length(x) &lt;= 5) x[[5]] else x[[n]]
fxn(1:5, 2)</code></pre>
<pre><code>#&gt; [1] 5</code></pre>
<pre class="r"><code>fxn(1:10, 2)</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<pre class="r"><code>fxn2 &lt;- function(x, n) `if`(`&lt;=`(length(x), 5), `[[`(x, 5), `[[`(x, n))
fxn2(1:5, 2)</code></pre>
<pre><code>#&gt; [1] 5</code></pre>
<pre class="r"><code>fxn2(1:10, 2)</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<p>Answer: inline above.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Clarify the following list of odd function calls:</li>
</ol>
<pre class="r"><code>x &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))
y &lt;- runif(min = 0, max = 1, 20)
cor(m = &quot;k&quot;, y = y, u = &quot;p&quot;, x = x)</code></pre>
<p>Answers: improved code below.</p>
<pre class="r"><code>x &lt;- sample(c(1:10, NA), 20, replace = TRUE)
y &lt;- runif(20)
cor(x, y, use = &quot;pairwise.complete.obs&quot;, method = &quot;kendall&quot;)</code></pre>
<pre><code>#&gt; [1] -0.1209961</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Explain why the following code fails:</li>
</ol>
<pre class="r"><code>`modify&lt;-` &lt;- function(x, position, value) {
  x[position] &lt;- value
  x
}

try(modify(get(&quot;x&quot;), 1) &lt;- 10)</code></pre>
<pre><code>#&gt; Error in modify(get(&quot;x&quot;), 1) &lt;- 10 : 
#&gt;   target of assignment expands to non-language object</code></pre>
<pre class="r"><code>#&gt; Error: target of assignment expands to non-language object</code></pre>
<p>Answer: as explained on <a
href="https://stackoverflow.com/questions/27662162/error-in-my-code-target-of-assignment-expands-to-non-language-object">stack
overflow</a>, the error is caused when assigning to an object directly,
instead of a name that refers to the object (like <code>x</code>).</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Create a replacement function that modifies a random location in a
vector.</li>
</ol>
<pre class="r"><code>`modrand&lt;-` &lt;- function(x, value) {
  x[sample(length(x), 1)] &lt;- value
  x
}

v &lt;- 1:20
modrand(v) &lt;- NA
v</code></pre>
<pre><code>#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 NA 18 19 20</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Write your own version of <code>+</code> that pastes its inputs
together if they are character vectors but behaves as usual otherwise.
In other words, make this code work:</li>
</ol>
<pre class="r"><code>`+` &lt;- function(x, y) {
  if (is.character(x) &amp;&amp; is.character(y)) {
    return(paste0(x, y))
  }
  base::`+`(x, y)
}

1 + 2</code></pre>
<pre><code>#&gt; [1] 3</code></pre>
<pre class="r"><code>#&gt; [1] 3

&quot;a&quot; + &quot;b&quot;</code></pre>
<pre><code>#&gt; [1] &quot;ab&quot;</code></pre>
<pre class="r"><code>#&gt; [1] &quot;ab&quot;

rm(`+`)</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>Create a list of all the replacement functions found in the base
package. Which ones are primitive functions? (Hint: use
<code>apropos()</code>.)</li>
</ol>
<pre class="r"><code># all replacement functions in base
fun_args2[endsWith(fun_args2$name, &quot;&lt;-&quot;), ]$name</code></pre>
<pre><code>#&gt;  [1] &quot;.rowNamesDF&lt;-&quot;    &quot;[[&lt;-&quot;             &quot;[&lt;-&quot;              &quot;@&lt;-&quot;              &quot;&lt;-&quot;              
#&gt;  [6] &quot;&lt;&lt;-&quot;              &quot;$&lt;-&quot;              &quot;attr&lt;-&quot;           &quot;attributes&lt;-&quot;     &quot;body&lt;-&quot;          
#&gt; [11] &quot;class&lt;-&quot;          &quot;colnames&lt;-&quot;       &quot;comment&lt;-&quot;        &quot;diag&lt;-&quot;           &quot;dim&lt;-&quot;           
#&gt; [16] &quot;dimnames&lt;-&quot;       &quot;Encoding&lt;-&quot;       &quot;environment&lt;-&quot;    &quot;formals&lt;-&quot;        &quot;is.na&lt;-&quot;         
#&gt; [21] &quot;length&lt;-&quot;         &quot;levels&lt;-&quot;         &quot;mode&lt;-&quot;           &quot;mostattributes&lt;-&quot; &quot;names&lt;-&quot;         
#&gt; [26] &quot;oldClass&lt;-&quot;       &quot;parent.env&lt;-&quot;     &quot;regmatches&lt;-&quot;     &quot;row.names&lt;-&quot;      &quot;rownames&lt;-&quot;      
#&gt; [31] &quot;split&lt;-&quot;          &quot;storage.mode&lt;-&quot;   &quot;substr&lt;-&quot;         &quot;substring&lt;-&quot;      &quot;units&lt;-&quot;</code></pre>
<pre class="r"><code># all replacement primitive functions in base
fun_args2[endsWith(fun_args2$name, &quot;&lt;-&quot;) &amp; fun_args2$prim, ]$name</code></pre>
<pre><code>#&gt;  [1] &quot;[[&lt;-&quot;           &quot;[&lt;-&quot;            &quot;@&lt;-&quot;            &quot;&lt;-&quot;             &quot;&lt;&lt;-&quot;           
#&gt;  [6] &quot;$&lt;-&quot;            &quot;attr&lt;-&quot;         &quot;attributes&lt;-&quot;   &quot;class&lt;-&quot;        &quot;dim&lt;-&quot;         
#&gt; [11] &quot;dimnames&lt;-&quot;     &quot;environment&lt;-&quot;  &quot;length&lt;-&quot;       &quot;levels&lt;-&quot;       &quot;names&lt;-&quot;       
#&gt; [16] &quot;oldClass&lt;-&quot;     &quot;storage.mode&lt;-&quot;</code></pre>
<p>Answer: while you could use <code>apropos("&lt;-")</code>, I
leveraged the existing code from 6.2.5 #5.</p>
<hr />
<ol start="7" style="list-style-type: decimal">
<li>What are valid names for user-created infix functions?</li>
</ol>
<p>Answer: they must begin and end with <code>%</code>, and can contain
any sequence of characters except <code>%</code>.</p>
<hr />
<ol start="8" style="list-style-type: decimal">
<li>Create an infix <code>xor()</code> operator.</li>
</ol>
<pre class="r"><code>`%xor%` &lt;- function(x, y) xor(x, y)

xor(0, 0)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>xor(1, 0)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>xor(1, 1)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>0 %xor% 0</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>1 %xor% 0</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>1 %xor% 1</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="9" style="list-style-type: decimal">
<li>Create infix versions of the set functions <code>intersect()</code>,
<code>union()</code>, and <code>setdiff()</code>. You might call them
<code>%n%</code>, <code>%u%</code>, and <code>%/%</code> to match
conventions from mathematics.</li>
</ol>
<pre class="r"><code>`%n%` &lt;- function(x, y) intersect(x, y)
`%u%` &lt;- function(x, y) union(x, y)
`%s%` &lt;- function(x, y) setdiff(x, y)

# taken from docs examples
(x &lt;- c(sort(sample(1:20, 9)), NA))</code></pre>
<pre><code>#&gt;  [1]  1  4  6  9 12 14 15 18 19 NA</code></pre>
<pre class="r"><code>(y &lt;- c(sort(sample(3:23, 7)), NA))</code></pre>
<pre><code>#&gt; [1]  6  8 11 12 14 17 20 NA</code></pre>
<pre class="r"><code>x %u% y</code></pre>
<pre><code>#&gt;  [1]  1  4  6  9 12 14 15 18 19 NA  8 11 17 20</code></pre>
<pre class="r"><code>x %n% y</code></pre>
<pre><code>#&gt; [1]  6 12 14 NA</code></pre>
<pre class="r"><code>x %s% y</code></pre>
<pre><code>#&gt; [1]  1  4  9 15 18 19</code></pre>
<pre class="r"><code>y %s% x</code></pre>
<pre><code>#&gt; [1]  8 11 17 20</code></pre>
<p>Answer: code above.</p>
<hr />
</div>
</div>
<div id="environments" class="section level1">
<h1>7 Environments</h1>
<p>The environment is the data structure that powers scoping. This
chapter dives deep into environments, describing their structure in
depth, and using them to improve your understanding of the four scoping
rules described in Section 6.4. Understanding environments is not
necessary for day-to-day use of R. But they are important to understand
because they power many important R features like lexical scoping,
namespaces, and R6 classes, and interact with evaluation to give you
powerful tools for making domain specific languages, like dplyr and
ggplot2.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-20" class="section level2">
<h2>7.2.7 Exercises</h2>
<ol style="list-style-type: decimal">
<li>List three ways in which an environment differs from a list.</li>
</ol>
<p>Answer:</p>
<ul>
<li>Every name in an environment must be unique</li>
<li>Environment names are not ordered</li>
<li>Environments have parents (except the empty environment)</li>
<li>Environments are not copied when modified</li>
</ul>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Create an environment as illustrated by this picture.</li>
</ol>
<p><img src="assets/recursive-1.png" /></p>
<pre class="r"><code>e1 &lt;- env()
e1$loop &lt;- e1</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Create a pair of environments as illustrated by this picture.</li>
</ol>
<p><img src="assets/recursive-2.png" /></p>
<pre class="r"><code>e2 &lt;- env()
e3 &lt;- env()

e2$loop &lt;- e3
e3$dedoop &lt;- e2</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Explain why <code>e[[1]]</code> and <code>e[c("a", "b")]</code>
don’t make sense when <code>e</code> is an environment.</li>
</ol>
<p>Answer: environment names are not ordered, and aren’t copied when
modified, so they aren’t subsettable.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Create a version of <code>env_poke()</code> that will only bind new
names, never re-bind old names. Some programming languages only do this,
and are known as <a
href="https://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment">single
assignment languages</a>.</li>
</ol>
<pre class="r"><code>env_poke_new &lt;- function(env, nm, value) {
  if (!is.environment(env)) stop(&quot;env is not an enviornment&quot;)
  if (nm %in% names(env)) stop(&quot;nm &#39;&quot;, nm, &quot;&#39; already bound&quot;)
  env[[nm]] &lt;- value
}

e_test &lt;- env(a = NULL, b = 2, c = &quot;three&quot;)

env_poke_new(e_test, &quot;d&quot;, &quot;success&quot;)
try(env_poke_new(e_test, &quot;a&quot;, &quot;fail&quot;))</code></pre>
<pre><code>#&gt; Error in env_poke_new(e_test, &quot;a&quot;, &quot;fail&quot;) : nm &#39;a&#39; already bound</code></pre>
<pre class="r"><code>env_print(e_test)</code></pre>
<pre><code>#&gt; &lt;environment: 0x7faa85ff5f90&gt;
#&gt; Parent: &lt;environment: 0x7faa9191fba0&gt;
#&gt; Bindings:
#&gt; • a: &lt;NULL&gt;
#&gt; • b: &lt;dbl&gt;
#&gt; • c: &lt;chr&gt;
#&gt; • d: &lt;chr&gt;</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>What does this function do? How does it differ from
<code>&lt;&lt;-</code> and why might you prefer it?</li>
</ol>
<pre class="r"><code>rm(a)</code></pre>
<pre><code>#&gt; Warning in rm(a): object &#39;a&#39; not found</code></pre>
<pre class="r"><code>rebind &lt;- function(name, value, env = caller_env()) {
  if (identical(env, empty_env())) {
    stop(&quot;Can&#39;t find `&quot;, name, &quot;`&quot;, call. = FALSE)
  } else if (env_has(env, name)) {
    env_poke(env, name, value)
  } else {
    rebind(name, value, env_parent(env))
  }
}
try(rebind(&quot;a&quot;, 10))</code></pre>
<pre><code>#&gt; Error : Can&#39;t find `a`</code></pre>
<pre class="r"><code>(a &lt;- 5)</code></pre>
<pre><code>#&gt; [1] 5</code></pre>
<pre class="r"><code>rebind(&quot;a&quot;, 10)
a</code></pre>
<pre><code>#&gt; [1] 10</code></pre>
<p>Answer: <code>&lt;&lt;-</code> will assign a value to the name in the
global environment if the name is not found, <code>rebind()</code> does
not.</p>
<hr />
</div>
<div id="exercises-21" class="section level2">
<h2>7.3.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Modify <code>where()</code> to return <em>all</em> environments that
contain a binding for <code>name</code>. Carefully think through what
type of object the function will need to return.</li>
</ol>
<pre class="r"><code>where &lt;- function(name, env = caller_env()) {
  if (identical(env, empty_env())) {
    # Base case
    stop(&quot;Can&#39;t find &quot;, name, call. = FALSE)
  } else if (env_has(env, name)) {
    # Success case
    env
  } else {
    # Recursive case
    where(name, env_parent(env))
  }
}

x &lt;- 5
try(where(&quot;yyy&quot;))</code></pre>
<pre><code>#&gt; Error : Can&#39;t find yyy</code></pre>
<pre class="r"><code>where(&quot;x&quot;)</code></pre>
<pre><code>#&gt; &lt;environment: 0x7faa9191fba0&gt;</code></pre>
<pre class="r"><code>where(&quot;mean&quot;)</code></pre>
<pre><code>#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>all_where &lt;- function(name, env = caller_env(), found = list()) {
  if (identical(env, empty_env())) {
    # Base case
    found
  } else if (env_has(env, name)) {
    # Success case
    all_where(name, env_parent(env), append(env, found, after = 0))
  } else {
    # Recursive case
    all_where(name, env_parent(env), found)
  }
}

all_where(&quot;x&quot;)</code></pre>
<pre><code>#&gt; [[1]]
#&gt; &lt;environment: 0x7faa9191fba0&gt;</code></pre>
<pre class="r"><code>local({
  x &lt;- 10
  all_where(&quot;x&quot;)
})</code></pre>
<pre><code>#&gt; [[1]]
#&gt; &lt;environment: 0x7faa84c9dda8&gt;
#&gt; 
#&gt; [[2]]
#&gt; &lt;environment: 0x7faa9191fba0&gt;</code></pre>
<p>Answer: code above.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Write a function called <code>fget()</code> that finds only function
objects. It should have two arguments, <code>name</code> and
<code>env</code>, and should obey the regular scoping rules for
functions: if there’s an object with a matching name that’s not a
function, look in the parent. For an added challenge, also add an
<code>inherits</code> argument which controls whether the function
recurses up the parents or only looks in one environment.</li>
</ol>
<pre class="r"><code>fget &lt;- function(name, env = caller_env(), inherits = TRUE) {
  if (identical(env, empty_env())) {
    # Base case
    stop(&quot;Can&#39;t find &quot;, name, call. = FALSE)
  } else if (env_has(env, name) &amp;&amp; is.function(env[[name]])) {
    # Success case
    env
  } else if (inherits) {
    # Recursive case
    fget(name, env_parent(env))
  } else {
    stop(&quot;Can&#39;t find &quot;, name, call. = FALSE)
  }
}

try(fget(&quot;x&quot;))</code></pre>
<pre><code>#&gt; Error : Can&#39;t find x</code></pre>
<pre class="r"><code>fget(&quot;print&quot;)</code></pre>
<pre><code>#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>try(fget(&quot;print&quot;, inherits = FALSE))</code></pre>
<pre><code>#&gt; Error : Can&#39;t find print</code></pre>
<pre class="r"><code>fget(&quot;all_where&quot;, inherits = FALSE)</code></pre>
<pre><code>#&gt; &lt;environment: 0x7faa9191fba0&gt;</code></pre>
<p>Answer: code above.</p>
<hr />
</div>
<div id="exercises-22" class="section level2">
<h2>7.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How is <code>search_envs()</code> different from
<code>env_parents(global_env())</code>?</li>
</ol>
<p>Answer: <code>search_envs()</code> includes the global environment.
<code>env_parents(global_env())</code> doesn’t include the global
environment and also returns the empty environment (the top parent).</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Draw a diagram that shows the enclosing environments of this
function:</li>
</ol>
<pre class="r"><code>f1 &lt;- function(x1) {
  f2 &lt;- function(x2) {
    f3 &lt;- function(x3) {
      x1 + x2 + x3
    }
    f3(3)
  }
  f2(2)
}
f1(1)</code></pre>
<p>Answer: No.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Write an enhanced version of <code>str()</code> that provides more
information about functions. Show where the function was found and what
environment it was defined in.</li>
</ol>
<pre class="r"><code>e_str &lt;- function(object, ...) {
  str(object, ...)
  if (is.function(object)) {
    message(&quot;fn_env():&quot;)
    print(fn_env(object))
    message(&quot;environment():&quot;)
    print(environment(object))
  }
}

e_str(print)</code></pre>
<pre><code>#&gt; function (x, ...)</code></pre>
<pre><code>#&gt; fn_env():</code></pre>
<pre><code>#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre><code>#&gt; environment():</code></pre>
<pre><code>#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>e_str(fget)</code></pre>
<pre><code>#&gt; function (name, env = caller_env(), inherits = TRUE)  
#&gt;  - attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 1 9 14 1 9 1 1 14
#&gt;   ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7faa91ecdc98&gt;</code></pre>
<pre><code>#&gt; fn_env():</code></pre>
<pre><code>#&gt; &lt;environment: 0x7faa9191fba0&gt;</code></pre>
<pre><code>#&gt; environment():</code></pre>
<pre><code>#&gt; &lt;environment: 0x7faa9191fba0&gt;</code></pre>
<p>Answer: code above.</p>
<hr />
</div>
<div id="exercises-23" class="section level2">
<h2>7.5.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Write a function that lists all the variables defined in the
environment in which it was called. It should return the same results as
<code>ls()</code>.</li>
</ol>
<pre class="r"><code>my_ls &lt;- function() {
  vars &lt;- sort(names(parent.frame()))
  vars[!startsWith(vars, &quot;.&quot;)]
}

ls()</code></pre>
<pre><code>#&gt;  [1] &quot;a&quot;            &quot;all_where&quot;    &quot;e_str&quot;        &quot;e_test&quot;       &quot;e1&quot;           &quot;e2&quot;          
#&gt;  [7] &quot;e3&quot;           &quot;env_poke_new&quot; &quot;fget&quot;         &quot;my_ls&quot;        &quot;rebind&quot;       &quot;where&quot;       
#&gt; [13] &quot;x&quot;</code></pre>
<pre class="r"><code>my_ls()</code></pre>
<pre><code>#&gt;  [1] &quot;a&quot;            &quot;all_where&quot;    &quot;e_str&quot;        &quot;e_test&quot;       &quot;e1&quot;           &quot;e2&quot;          
#&gt;  [7] &quot;e3&quot;           &quot;env_poke_new&quot; &quot;fget&quot;         &quot;my_ls&quot;        &quot;rebind&quot;       &quot;where&quot;       
#&gt; [13] &quot;x&quot;</code></pre>
<p>Answer: code above.</p>
<hr />
</div>
</div>
<div id="conditions" class="section level1">
<h1>8 Conditions</h1>
<p>The <strong>condition</strong> system provides a paired set of tools
that allow the author of a function to indicate that something unusual
is happening, and the user of that function to deal with it. The
function author <strong>signals</strong> conditions with functions like
<code>stop()</code> (for errors), <code>warning()</code> (for warnings),
and <code>message()</code> (for messages), then the function user can
handle them with functions like <code>tryCatch()</code> and
<code>withCallingHandlers()</code>. Understanding the condition system
is important because you’ll often need to play both roles: signalling
conditions from the functions you create, and handle conditions
signalled by the functions you call.</p>
<p>R offers a very powerful condition system based on ideas from Common
Lisp. Like R’s approach to object-oriented programming, it is rather
different to currently popular programming languages so it is easy to
misunderstand, and there has been relatively little written about how to
use it effectively. Historically, this has meant that few people (myself
included) have taken full advantage of its power. The goal of this
chapter is to remedy that situation. Here you will learn about the big
ideas of R’s condition system, as well as learning a bunch of practical
tools that will make your code stronger.</p>
<p>I found two resources particularly useful when writing this chapter.
You may also want to read them if you want to learn more about the
inspirations and motivations for the system:</p>
<ul>
<li><p><a
href="https://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html"><em>A
prototype of a condition system for R</em></a> by Robert Gentleman and
Luke Tierney. This describes an early version of R’s condition system.
While the implementation has changed somewhat since this document was
written, it provides a good overview of how the pieces fit together, and
some motivation for its design.</p></li>
<li><p><a
href="https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html"><em>Beyond
exception handling: conditions and restarts</em></a> by Peter Seibel.
This describes exception handling in Lisp, which happens to be very
similar to R’s approach. It provides useful motivation and more
sophisticated examples. I have provided an R translation of the chapter
at <a href="http://adv-r.had.co.nz/beyond-exception-handling.html"
class="uri">http://adv-r.had.co.nz/beyond-exception-handling.html</a>.</p></li>
</ul>
<p>I also found it helpful to work through the underlying C code that
implements these ideas. If you’re interested in understanding how it all
works, you might find <a
href="https://gist.github.com/hadley/4278d0a6d3a10e42533d59905fbed0ac">my
notes</a> to be useful.</p>
<pre class="r"><code>rm(list = ls())</code></pre>
<div id="exercises-24" class="section level2">
<h2>8.2.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Write a wrapper around <code>file.remove()</code> that throws an
error if the file to be deleted does not exist.</li>
</ol>
<pre class="r"><code>safe_file_remove &lt;- function(...) {
  if (!file.exists(...)) stop(&quot;file &#39;&quot;, ..., &quot;&#39; does not exist&quot;)
  file.remove(...)
}

tmp &lt;- tempfile()

file.create(tmp)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>safe_file_remove(tmp)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>file.remove(tmp)</code></pre>
<pre><code>#&gt; Warning in file.remove(tmp): cannot remove file &#39;/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//
#&gt; Rtmp42RE5z/filee82278582005&#39;, reason &#39;No such file or directory&#39;</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>try(safe_file_remove(tmp))</code></pre>
<pre><code>#&gt; Error in safe_file_remove(tmp) : 
#&gt;   file &#39;/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T//Rtmp42RE5z/filee82278582005&#39; does not exist</code></pre>
<p>Answer:</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What does the <code>appendLF</code> argument to
<code>message()</code> do? How is it related to <code>cat()</code>?</li>
</ol>
<p>Answer: <code>appendLF</code> controls whether or not a newline is
added to the message; by default, <code>cat()</code> does not add a
newline.</p>
<hr />
</div>
<div id="exercises-25" class="section level2">
<h2>8.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What extra information does the condition generated by
<code>abort()</code> contain compared to the condition generated by
<code>stop()</code> i.e. what’s the difference between these two
objects? Read the help for <code>?abort</code> to learn more.</li>
</ol>
<pre class="r"><code>catch_cnd(stop(&quot;An error&quot;))</code></pre>
<pre><code>#&gt; &lt;simpleError in force(expr): An error&gt;</code></pre>
<pre class="r"><code>catch_cnd(abort(&quot;An error&quot;))</code></pre>
<pre><code>#&gt; &lt;error/rlang_error&gt;
#&gt; Error:
#&gt; ! An error
#&gt; ---
#&gt; Backtrace:</code></pre>
<p>Answer: <code>abort()</code> includes the error message and backtrace
in the condition object. <code>abort()</code> uses the custom class
<code>rlang_error</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Predict the results of evaluating the following code</li>
</ol>
<pre class="r"><code>show_condition &lt;- function(code) {
  tryCatch(
    error = function(cnd) &quot;error&quot;,
    warning = function(cnd) &quot;warning&quot;,
    message = function(cnd) &quot;message&quot;,
    {
      code
      NULL
    }
  )
}

show_condition(stop(&quot;!&quot;)) #&gt; &quot;error&quot;</code></pre>
<pre><code>#&gt; [1] &quot;error&quot;</code></pre>
<pre class="r"><code>show_condition(10) #&gt; 10 [NULL]</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>show_condition(warning(&quot;?!&quot;)) #&gt; &quot;warning&quot;</code></pre>
<pre><code>#&gt; [1] &quot;warning&quot;</code></pre>
<pre class="r"><code>show_condition({
  10
  message(&quot;?&quot;)
  warning(&quot;?!&quot;)
})</code></pre>
<pre><code>#&gt; [1] &quot;message&quot;</code></pre>
<pre class="r"><code>#&gt; 10
#&gt; &quot;message&quot;
#&gt; &quot;warning&quot;</code></pre>
<p>Answer: predictions in comments. The prediction for
<code>show_condition(10)</code> was incorrect; the correct answer is
<code>NULL</code> as that’s what’s returned when there is no condition.
The final prediction was also incorrect; the <code>tryCatch()</code>
call stops further execution when the <code>message()</code> is
caught.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Explain the results of running this code:</li>
</ol>
<pre class="r"><code>withCallingHandlers(
  message = function(cnd) message(&quot;b&quot;), # handler 1
  withCallingHandlers(
    message = function(cnd) message(&quot;a&quot;), # handler 2
    message(&quot;c&quot;)
  )
)</code></pre>
<pre><code>#&gt; b</code></pre>
<pre><code>#&gt; a</code></pre>
<pre><code>#&gt; b</code></pre>
<pre><code>#&gt; c</code></pre>
<p>Answer:</p>
<ol style="list-style-type: decimal">
<li><code>message("c")</code> is caught, handler 2 is called</li>
<li>in handler 2, <code>message("a")</code> is caught and handler 1 is
called</li>
<li>handler 1 writes message <code>b</code></li>
<li>code resumes and handler 2 writes message <code>a</code></li>
<li><code>message("c")</code> propagates to the parent, is caught, and
handler 1 is called</li>
<li>handler 1 writes message <code>b</code></li>
<li>code resumes and the code writes message <code>c</code></li>
</ol>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Read the source code for <code>catch_cnd()</code> and explain how it
works.</li>
</ol>
<pre class="r"><code>catch_cnd</code></pre>
<pre><code>#&gt; function (expr, classes = &quot;condition&quot;) 
#&gt; {
#&gt;     stopifnot(is_character(classes))
#&gt;     handlers &lt;- rep_named(classes, list(identity))
#&gt;     eval_bare(rlang::expr(tryCatch(!!!handlers, {
#&gt;         force(expr)
#&gt;         return(NULL)
#&gt;     })))
#&gt; }
#&gt; &lt;bytecode: 0x7faa87569208&gt;
#&gt; &lt;environment: namespace:rlang&gt;</code></pre>
<pre class="r"><code>catch_cnd(stop(&quot;error&quot;))</code></pre>
<pre><code>#&gt; &lt;simpleError in force(expr): error&gt;</code></pre>
<pre class="r"><code># replicate the core functionality
tryCatch(condition = function(x) x, force(stop(&quot;error&quot;)))</code></pre>
<pre><code>#&gt; &lt;simpleError in force(stop(&quot;error&quot;)): error&gt;</code></pre>
<p>Answer: <code>catch_cnd()</code> uses <code>tryCatch()</code> to
catch any condition and return itself using <code>identity()</code>.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>How could you rewrite <code>show_condition()</code> to use a single
handler?</li>
</ol>
<pre class="r"><code>show_condition2 &lt;- function(code) {
  tryCatch(
    condition = function(cnd) {
      if (is_error(cnd)) {
        return(&quot;error&quot;)
      }
      if (is_warning(cnd)) {
        return(&quot;warning&quot;)
      }
      if (is_message(cnd)) {
        return(&quot;message&quot;)
      }
    },
    {
      code
      NULL
    }
  )
}

show_condition2(stop(&quot;!&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;error&quot;</code></pre>
<pre class="r"><code>show_condition2(10)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>show_condition2(warning(&quot;?!&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;warning&quot;</code></pre>
<pre class="r"><code>show_condition2({
  10
  message(&quot;?&quot;)
  warning(&quot;?!&quot;)
})</code></pre>
<pre><code>#&gt; [1] &quot;message&quot;</code></pre>
<p>Answer: code above.</p>
<hr />
</div>
<div id="exercises-26" class="section level2">
<h2>8.5.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Inside a package, it’s occasionally useful to check that a package
is installed before using it. Write a function that checks if a package
is installed (with
<code>requireNamespace("pkg", quietly = FALSE))</code> and if not,
throws a custom condition that includes the package name in the
metadata.</li>
</ol>
<pre class="r"><code>my_check_installed &lt;- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    abort(
      &quot;error_not_found&quot;,
      message = paste0(&quot;package &#39;&quot;, pkg, &quot;&#39; not found&quot;),
      pkg = pkg
    )
  }
}

my_check_installed(&quot;rlang&quot;)
# NOTE: this code causes renv::dependencies() to mistakenly report package &#39;pkg&#39; as a dependency
requireNamespace(&quot;pkg&quot;, quietly = FALSE)</code></pre>
<pre><code>#&gt; Loading required namespace: pkg</code></pre>
<pre class="r"><code>err &lt;- catch_cnd(my_check_installed(&quot;pkg&quot;))
err</code></pre>
<pre><code>#&gt; &lt;error/error_not_found&gt;
#&gt; Error in `my_check_installed()`:
#&gt; ! package &#39;pkg&#39; not found
#&gt; ---
#&gt; Backtrace:
#&gt;  1. rlang::catch_cnd(my_check_installed(&quot;pkg&quot;))
#&gt;  8. rdev (local) my_check_installed(&quot;pkg&quot;)</code></pre>
<pre class="r"><code>err$pkg</code></pre>
<pre><code>#&gt; [1] &quot;pkg&quot;</code></pre>
<p>Answer: code above. The question specifies to use
<code>quietly = FALSE</code>, but this approach makes more sense (to
me). The alternative is to catch the ‘Failed with error:’ message which
seems less reliable.</p>
<pre class="r"><code>my_check_installed2 &lt;- function(pkg) {
  tryCatch(
    condition = function(cnd) {
      abort(
        &quot;error_not_found&quot;,
        message = paste0(&quot;package &#39;&quot;, pkg, &quot;&#39; not found&quot;),
        pkg = pkg
      )
    },
    requireNamespace(pkg, quietly = FALSE)
  )
}

my_check_installed2(&quot;rlang&quot;)
err2 &lt;- catch_cnd(my_check_installed2(&quot;pkg&quot;))
err2</code></pre>
<pre><code>#&gt; &lt;error/error_not_found&gt;
#&gt; Error in `value[[3L]]()`:
#&gt; ! package &#39;pkg&#39; not found
#&gt; ---
#&gt; Backtrace:
#&gt;   1. rlang::catch_cnd(my_check_installed2(&quot;pkg&quot;))
#&gt;   8. rdev (local) my_check_installed2(&quot;pkg&quot;)
#&gt;   9. base::tryCatch(...)
#&gt;  10. base (local) tryCatchList(expr, classes, parentenv, handlers)
#&gt;  11. base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt;  12. value[[3L]](cond)</code></pre>
<pre class="r"><code>err2$pkg</code></pre>
<pre><code>#&gt; [1] &quot;pkg&quot;</code></pre>
<p>The alternative version, <code>my_check_installed2()</code> works but
its Backtrace is harder to read.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Inside a package you often need to stop with an error when something
is not right. Other packages that depend on your package might be
tempted to check these errors in their unit tests. How could you help
these packages to avoid relying on the error message which is part of
the user interface rather than the API and might change without
notice?</li>
</ol>
<p>Answer: return custom error objects that aren’t dependent on the
error text (like in 8.5.3)</p>
<hr />
</div>
<div id="exercises-27" class="section level2">
<h2>8.6.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Create <code>suppressConditions()</code> that works like
<code>suppressMessages()</code> and <code>suppressWarnings()</code> but
suppresses everything. Think carefully about how you should handle
errors.</li>
</ol>
<pre class="r"><code>suppressConditions &lt;- function(expr) { # nolint: object_name_linter.
  tryCatch(
    error = function(cnd) invisible(cnd),
    withCallingHandlers(
      condition = function(cnd) {
        cnd_muffle(cnd)
      },
      expr
    )
  )
}

sup &lt;- suppressConditions({
  message(&quot;processing...&quot;)
  warning(&quot;something went wrong&quot;)
  print(&quot;still running&quot;)
  stop(&quot;error&quot;)
  print(&quot;this shouldn&#39;t run&quot;)
})</code></pre>
<pre><code>#&gt; [1] &quot;still running&quot;</code></pre>
<pre class="r"><code>str(sup)</code></pre>
<pre><code>#&gt; List of 2
#&gt;  $ message: chr &quot;error&quot;
#&gt;  $ call   : language withCallingHandlers(condition = function(cnd) {     cnd_muffle(cnd) ...
#&gt;  - attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</code></pre>
<p>Answer: code above. Errors are not printed, but are returned,
invisibly.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Compare the following two implementations of
<code>message2error()</code>. What is the main advantage of
<code>withCallingHandlers()</code> in this scenario? (Hint: look
carefully at the traceback.)</li>
</ol>
<pre class="r"><code>message2error &lt;- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}

message2error2 &lt;- function(code) {
  tryCatch(code, message = function(e) stop(e))
}</code></pre>
<p>Answer: <code>message2error()</code> shows the invocation of
<code>message()</code> in the traceback, but
<code>message2error2()</code> does not.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>How would you modify the <code>catch_cnds()</code> definition if you
wanted to recreate the original intermingling of warnings and
messages?</li>
</ol>
<p>Answer: as noted in <a
href="https://advanced-r-solutions.rbind.io/conditions.html#applications-1">Advanced
R Solutions</a>, “It looks like Hadley wrote a part of the chapter after
the exercises, as the <code>catch_cnds()</code> function defined in the
chapter already solves this problem by storing all messages and warnings
in their original order within a list.”</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Why is catching interrupts dangerous? Run this code to find
out.</li>
</ol>
<pre class="r"><code>bottles_of_beer &lt;- function(i = 99) {
  message(
    &quot;There are &quot;, i, &quot; bottles of beer on the wall, &quot;,
    i, &quot; bottles of beer.&quot;
  )
  while (i &gt; 0) {
    tryCatch(
      Sys.sleep(1),
      interrupt = function(err) {
        i &lt;&lt;- i - 1 # nolint: undesirable_operator_linter.
        if (i &gt; 0) {
          message(
            &quot;Take one down, pass it around, &quot;, i,
            &quot; bottle&quot;, if (i &gt; 1) &quot;s&quot;, &quot; of beer on the wall.&quot;
          )
        }
      }
    )
  }
  message(
    &quot;No more bottles of beer on the wall, &quot;,
    &quot;no more bottles of beer.&quot;
  )
}</code></pre>
<p>Answer: this prevents user interrupts (control-c) from halting the
code, which in this case can be pretty annoying if run with the
defaults, requiring 99 interrupts (or just “Restart R”).</p>
<hr />
</div>
</div>
<div id="solutions" class="section level1">
<h1>Solutions</h1>
<p>Notes on comparing exercise solutions here against <a
href="https://advanced-r-solutions.rbind.io/index.html">Advanced R
Solutions</a>.</p>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiBBZHZhbmNlZCBSIFdvcmtib29rIChGb3VuZGF0aW9ucykKZGF0ZTogJzIwMjItMDYtMTInCm91dHB1dDoKICBodG1sX2RvY3VtZW50OgogICAgdGhlbWU6CiAgICAgIHZlcnNpb246IDUKICAgIHRvYzogeWVzCiAgICB0b2NfZmxvYXQ6CiAgICAgIGNvbGxhcHNlZDogbm8KICAgICAgc21vb3RoX3Njcm9sbDogbm8KLS0tCgpXb3JrYm9vayBmb3IgY29tcGxldGluZyBxdWl6emVzIGFuZCBleGVyY2lzZXMgZnJvbSB0aGUgIkZvdW5kYXRpb25zIiBjaGFwdGVycyBvZiBbQWR2YW5jZWQgUl0oaHR0cHM6Ly9hZHYtci5oYWRsZXkubnovaW5kZXguaHRtbCksIHNlY29uZCBlZGl0aW9uLCB3aXRoIGNvbXBhcmlzb25zIHRvIHNvbHV0aW9ucyBmcm9tIFtBZHZhbmNlZCBSIFNvbHV0aW9uc10oaHR0cHM6Ly9hZHZhbmNlZC1yLXNvbHV0aW9ucy5yYmluZC5pbykuCgpgYGB7ciBzZXR1cCwgbWVzc2FnZSA9IEZBTFNFLCB3YXJuaW5nID0gRkFMU0V9CmxpYnJhcnkobG9ic3RyKQpsaWJyYXJ5KGJlbmNoKQpsaWJyYXJ5KHJsYW5nKQoKIyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9oYWRsZXkvYWR2LXIvYmxvYi9tYXN0ZXIvY29tbW9uLlIKa25pdHI6Om9wdHNfY2h1bmskc2V0KAogIGNvbW1lbnQgPSAiIz4iLAogIGZpZy5hbGlnbiA9ICJjZW50ZXIiCikKCmtuaXRyOjprbml0X2hvb2tzJHNldCgKICBzbWFsbF9tYXIgPSBmdW5jdGlvbihiZWZvcmUsIG9wdGlvbnMsIGVudmlyKSB7CiAgICBpZiAoYmVmb3JlKSB7CiAgICAgIHBhcihtYXIgPSBjKDQuMSwgNC4xLCAwLjUsIDAuNSkpICMgbm9saW50OiB1bmRlc2lyYWJsZV9mdW5jdGlvbl9saW50ZXIuCiAgICB9CiAgfQopCmBgYAoKIyBJbnRyb2R1Y3Rpb24KClRoaXMgd29ya2Jvb2sgaW5jbHVkZXMgYW5zd2VycyBhbmQgc29sdXRpb25zIHRvIHRoZSBxdWl6emVzIGFuZCBleGVyY2lzZXMgZnJvbSBbQWR2YW5jZWQgUl0oaHR0cHM6Ly9hZHYtci5oYWRsZXkubnovaW5kZXguaHRtbCksIG9yZ2FuaXplZCBieSBjaGFwdGVyLiBJdCBpbmNsdWRlcyBleGNlcnB0cyBmcm9tIHRoZSBib29rLCBjb3BpZWQgaGVyZS4KCioqV0FSTklORywgU1BPSUxFUlMhKiogSWYgeW91IGhhdmVuJ3QgcmVhZCBBZHZhbmNlZCBSIGFuZCBpbnRlbmQgdG8gY29tcGxldGUgdGhlIHF1aXp6ZXMgYW5kIGV4ZXJjaXNlcywgZG9uJ3QgcmVhZCB0aGlzIG5vdGVib29rLiBJdCBjb250YWlucyBteSAocG90ZW50aWFsbHkgd3JvbmcpIGFuc3dlcnMgdG8gYm90aC4KCiMgMiBOYW1lcyBhbmQgdmFsdWVzCgpJbiBSLCBpdCBpcyBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBhbiBvYmplY3QgYW5kIGl0cyBuYW1lLiBEb2luZyBzbyB3aWxsIGhlbHAgeW91OgoKKiBNb3JlIGFjY3VyYXRlbHkgcHJlZGljdCB0aGUgcGVyZm9ybWFuY2UgYW5kIG1lbW9yeSB1c2FnZSBvZiB5b3VyIGNvZGUuIAoqIFdyaXRlIGZhc3RlciBjb2RlIGJ5IGF2b2lkaW5nIGFjY2lkZW50YWwgY29waWVzLCBhIG1ham9yIHNvdXJjZSBvZiBzbG93IGNvZGUuIAoqIEJldHRlciB1bmRlcnN0YW5kIFIncyBmdW5jdGlvbmFsIHByb2dyYW1taW5nIHRvb2xzLgoKVGhlIGdvYWwgb2YgdGhpcyBjaGFwdGVyIGlzIHRvIGhlbHAgeW91IHVuZGVyc3RhbmQgdGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gbmFtZXMgYW5kIHZhbHVlcywgYW5kIHdoZW4gUiB3aWxsIGNvcHkgYW4gb2JqZWN0LgoKIyMgMiBRdWl6CgoxLiAgR2l2ZW4gdGhlIGZvbGxvd2luZyBkYXRhIGZyYW1lLCBob3cgZG8gSSBjcmVhdGUgYSBuZXcgY29sdW1uIGNhbGxlZCAiMyIKICAgIHRoYXQgY29udGFpbnMgdGhlIHN1bSBvZiBgMWAgYW5kIGAyYD8gWW91IG1heSBvbmx5IHVzZSBgJGAsIG5vdCBgW1tgLgogICAgV2hhdCBtYWtlcyBgMWAsIGAyYCwgYW5kIGAzYCBjaGFsbGVuZ2luZyBhcyB2YXJpYWJsZSBuYW1lcz8KCmBgYHtyfQpkZiA8LSBkYXRhLmZyYW1lKHJ1bmlmKDMpLCBydW5pZigzKSkKbmFtZXMoZGYpIDwtIGMoMSwgMikKYGBgCgpBbnN3ZXI6IHVzZSB0aGUgZm9sbG93aW5nIGNvZGUuCgpgYGB7cn0KZGYyIDwtIGRhdGEuZnJhbWUoZGYsIGRmJGAxYCArIGRmJGAyYCkKbmFtZXMoZGYyKSA8LSBjKDEsIDIsIDMpCmBgYAoKVXNpbmcgbnVtYmVycyBhcyBuYW1lcyBpcyBwcm9ibGVtYXRpYyBkdWUgdG8gdGhlbSBiZWluZyBpbnRlcnByZXRlZCBhcyBudW1lcmljIGNvbnN0YW50cyBieSBkZWZhdWx0LgoKLS0tCgoyLiAgSW4gdGhlIGZvbGxvd2luZyBjb2RlLCBob3cgbXVjaCBtZW1vcnkgZG9lcyBgeWAgb2NjdXB5PwogICAKYGBge3J9CnggPC0gcnVuaWYoMWU2KQp5IDwtIGxpc3QoeCwgeCwgeCkKYGBgCgpBbnN3ZXI6IDMgdGltZXMgdGhlIHNpemUgb2YgeCwgMjQgTUIuIE5vdGU6IHRoaXMgaXMgaW5jb3JyZWN0LCBhcyBzaG93biBieSBgb2JqX3NpemVgIGFuZCBgb2JqX2FkZHJgOgoKYGBge3J9Cm9ial9zaXplKHgpCm9ial9zaXplKHkpCm9ial9hZGRyKHlbWzFdXSkKb2JqX2FkZHIoeVtbMl1dKQpvYmpfYWRkcih5W1szXV0pCmBgYAoKLS0tCgozLiAgT24gd2hpY2ggbGluZSBkb2VzIGBhYCBnZXQgY29waWVkIGluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZT8KCmBgYHtyfQphIDwtIGMoMSwgNSwgMywgMikKb2JqX2FkZHIoYSkKCmIgPC0gYQpvYmpfYWRkcihiKQoKYltbMV1dIDwtIDEwCm9ial9hZGRyKGIpCmBgYAoKQW5zd2VyOiB0aGUgdGhpcmQgbGluZSAoY29weS1vbi13cml0ZSkuIFtjb3B5LW9uLW1vZGlmeV0KCiMjIDIuMi4yIEV4ZXJjaXNlcwoKMS4gIEV4cGxhaW4gdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGBhYCwgYGJgLCBgY2AgYW5kIGBkYCBpbiB0aGUgZm9sbG93aW5nIAogICAgY29kZToKCmBgYHtyfQphIDwtIDE6MTAKYiA8LSBhCmMgPC0gYgpkIDwtIDE6MTAKYGBgCgpBbnN3ZXI6IGEsIGIsIGFuZCBjIGFsbCBwb2ludCB0byB0aGUgc2FtZSBvYmplY3QgKDE6MTApLiBkIHBvaW50cyB0byBhbiBpZGVudGljYWwgb2JqZWN0IGF0IGEgZGlmZmVyZW50IGFkZHJlc3MuCgpBUiBTb2x1dGlvbnM6IGBhYCwgYGJgLCBhbmQgYGNgIHBvaW50IHRvIHRoZSBzYW1lIG9iamVjdCAod2l0aCB0aGUgc2FtZSBhZGRyZXNzIGluIG1lbW9yeSkuIFRoaXMgb2JqZWN0IGhhcyB0aGUgdmFsdWUgYDE6MTBgLiBgZGAgcG9pbnRzIHRvIGEgZGlmZmVyZW50IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlLgoKCmBgYHtyfQpvYmpfYWRkcihhKQpvYmpfYWRkcihiKQpvYmpfYWRkcihjKQpvYmpfYWRkcihkKQpgYGAKCi0tLQoKMi4gIFRoZSBmb2xsb3dpbmcgY29kZSBhY2Nlc3NlcyB0aGUgbWVhbiBmdW5jdGlvbiBpbiBtdWx0aXBsZSB3YXlzLiBEbyB0aGV5IGFsbCAKICAgIHBvaW50IHRvIHRoZSBzYW1lIHVuZGVybHlpbmcgZnVuY3Rpb24gb2JqZWN0PyBWZXJpZnkgdGhpcyB3aXRoIAogICAgYGxvYnN0cjo6b2JqX2FkZHIoKWAuCiAgICAKYGBge3IsIGV2YWwgPSBGQUxTRX0KbWVhbgpiYXNlOjptZWFuCmdldCgibWVhbiIpCmV2YWxxKG1lYW4pCm1hdGNoLmZ1bigibWVhbiIpCmBgYAoKQ2hlY2sgdGhlIGBvYmpfYWRkcmA6CgpgYGB7cn0Kb2JqX2FkZHIobWVhbikKb2JqX2FkZHIoYmFzZTo6bWVhbikKb2JqX2FkZHIoZ2V0KCJtZWFuIikpCm9ial9hZGRyKGV2YWxxKG1lYW4pKQpvYmpfYWRkcihtYXRjaC5mdW4oIm1lYW4iKSkKYGBgCgpBbnN3ZXI6IHRoZXkgZG8uCgpBUiBTb2x1dGlvbnM6IFllcywgdGhleSBwb2ludCB0byB0aGUgc2FtZSBvYmplY3QuIFdlIGNvbmZpcm0gdGhpcyBieSBpbnNwZWN0aW5nIHRoZSBhZGRyZXNzIG9mIHRoZSB1bmRlcmx5aW5nIGZ1bmN0aW9uIG9iamVjdC4KCi0tLQoKMy4gIEJ5IGRlZmF1bHQsIGJhc2UgUiBkYXRhIGltcG9ydCBmdW5jdGlvbnMsIGxpa2UgYHJlYWQuY3N2KClgLCB3aWxsIAogICAgYXV0b21hdGljYWxseSBjb252ZXJ0IG5vbi1zeW50YWN0aWMgbmFtZXMgdG8gc3ludGFjdGljIG9uZXMuIFdoeSBtaWdodCAKICAgIHRoaXMgYmUgcHJvYmxlbWF0aWM/IFdoYXQgb3B0aW9uIGFsbG93cyB5b3UgdG8gc3VwcHJlc3MgdGhpcyBiZWhhdmlvdXI/CgpBbnN3ZXI6IHRoaXMgY291bGQgaW50cm9kdWNlIHByb2JsZW1hdGljIG5hbWVzLCBsaWtlIGAxYC4gU2V0dGluZyBgY2hlY2submFtZXMgPSBGQUxTRWAgc3VwcHJlc3NlcyB0aGlzIGJlaGF2aW9yLgoKQVIgU29sdXRpb25zOiBDb2x1bW4gbmFtZXMgYXJlIG9mdGVuIGRhdGEsIGFuZCB0aGUgdW5kZXJseWluZyBgbWFrZS5uYW1lcygpYCB0cmFuc2Zvcm1hdGlvbiBpcyBub24taW52ZXJ0aWJsZSwgc28gdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGNvcnJ1cHRzIGRhdGEuIFRvIGF2b2lkIHRoaXMsIHNldCBgY2hlY2submFtZXMgPSBGQUxTRWAuCgotLS0KCjQuICBXaGF0IHJ1bGVzIGRvZXMgYG1ha2UubmFtZXMoKWAgdXNlIHRvIGNvbnZlcnQgbm9uLXN5bnRhY3RpYyBuYW1lcyBpbnRvCiAgICBzeW50YWN0aWMgb25lcz8KCkFuc3dlcjogZnJvbSBgP21ha2UubmFtZXNgOgoKPiBUaGUgY2hhcmFjdGVyICJYIiBpcyBwcmVwZW5kZWQgaWYgbmVjZXNzYXJ5LiBBbGwgaW52YWxpZCBjaGFyYWN0ZXJzIGFyZSB0cmFuc2xhdGVkIHRvICIuIi4gQSBtaXNzaW5nIHZhbHVlIGlzIHRyYW5zbGF0ZWQgdG8gIk5BIi4gTmFtZXMgd2hpY2ggbWF0Y2ggUiBrZXl3b3JkcyBoYXZlIGEgZG90IGFwcGVuZGVkIHRvIHRoZW0uIER1cGxpY2F0ZWQgdmFsdWVzIGFyZSBhbHRlcmVkIGJ5IG1ha2UudW5pcXVlLgoKQVIgU29sdXRpb25zOiBBIHZhbGlkIG5hbWUgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyIG9yIGEgZG90IChub3QgZm9sbG93ZWQgYnkgYSBudW1iZXIpIGFuZCBtYXkgZnVydGhlciBjb250YWluIG51bWJlcnMgYW5kIHVuZGVyc2NvcmVzIChgIl8iYHMgYXJlIGFsbG93ZWQgc2luY2UgUiB2ZXJzaW9uIDEuOS4wKS4KClRocmVlIG1haW4gbWVjaGFuaXNtcyBlbnN1cmUgc3ludGFjdGljYWxseSB2YWxpZCBuYW1lcyAoc2VlIGA/bWFrZS5uYW1lc2ApOgoKMS4gTmFtZXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIGxldHRlciBvciBhIGRvdCB3aWxsIGJlIHByZXBlbmRlZCB3aXRoIGFuIGAiWCJgLgogICBUaGUgc2FtZSBob2xkcyBmb3IgbmFtZXMgdGhhdCBiZWdpbiB3aXRoIGEgZG90IGZvbGxvd2VkIGJ5IGEgbnVtYmVyLgoyLiBBZGRpdGlvbmFsbHksIG5vbi12YWxpZCBjaGFyYWN0ZXJzIGFyZSByZXBsYWNlZCBieSBhIGRvdC4KMy4gUmVzZXJ2ZWQgUiBrZXl3b3JkcyAoc2VlIGA/cmVzZXJ2ZWRgKSBhcmUgc3VmZml4ZWQgYnkgYSBkb3QuCgpJbnRlcmVzdGluZ2x5LCBzb21lIG9mIHRoZXNlIHRyYW5zZm9ybWF0aW9ucyBhcmUgaW5mbHVlbmNlZCBieSB0aGUgY3VycmVudCBsb2NhbGUuIEZyb20gYD9tYWtlLm5hbWVzYDoKCj4gVGhlIGRlZmluaXRpb24gb2YgYSBsZXR0ZXIgZGVwZW5kcyBvbiB0aGUgY3VycmVudCBsb2NhbGUsIGJ1dCBvbmx5IEFTQ0lJIGRpZ2l0cyBhcmUgY29uc2lkZXJlZCB0byBiZSBkaWdpdHMuCgotLS0KCjUuICBJIHNsaWdodGx5IHNpbXBsaWZpZWQgdGhlIHJ1bGVzIHRoYXQgZ292ZXJuIHN5bnRhY3RpYyBuYW1lcy4gV2h5IGlzIGAuMTIzZTFgCiAgICBub3QgYSBzeW50YWN0aWMgbmFtZT8gUmVhZCBgP21ha2UubmFtZXNgIGZvciB0aGUgZnVsbCBkZXRhaWxzLgoKQW5zd2VyOiBmcm9tIGA/bWFrZS5uYW1lc2A6Cgo+IEEgc3ludGFjdGljYWxseSB2YWxpZCBuYW1lIGNvbnNpc3RzIG9mIGxldHRlcnMsIG51bWJlcnMgYW5kIHRoZSBkb3Qgb3IgdW5kZXJsaW5lIGNoYXJhY3RlcnMgYW5kCnN0YXJ0cyB3aXRoIGEgbGV0dGVyIG9yIHRoZSBkb3Qgbm90IGZvbGxvd2VkIGJ5IGEgbnVtYmVyLiBOYW1lcyBzdWNoIGFzICIuMndheSIgYXJlIG5vdCB2YWxpZCwgYW5kCm5laXRoZXIgYXJlIHRoZSByZXNlcnZlZCB3b3Jkcy4KCkFSIFNvbHV0aW9uczogYC4xMjNlMWAgaXMgbm90IGEgc3ludGFjdGljIG5hbWUsIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggb25lIGRvdCB3aGljaCBpcyBmb2xsb3dlZCBieSBhIG51bWJlci4gVGhpcyBtYWtlcyBpdCBhIGRvdWJsZSwgYDEuMjNgLgoKLS0tCgojIyAyLjMuNiBFeGVyY2lzZXMKCjEuICBXaHkgaXMgYHRyYWNlbWVtKDE6MTApYCBub3QgdXNlZnVsPwoKQW5zd2VyOiB0aGlzIGlzIHRyYWNpbmcgYW4gJ2ltbXV0YWJsZScgb2JqZWN0IHdoaWNoIHdpbGwgYWx3YXlzIGhhdmUgdGhlIHNhbWUgYWRkcmVzcy4KCkFSIFNvbHV0aW9uczogV2hlbiBgMToxMGAgaXMgY2FsbGVkIGFuIG9iamVjdCB3aXRoIGFuIGFkZHJlc3MgaW4gbWVtb3J5IGlzIGNyZWF0ZWQsIGJ1dCBpdCBpcyBub3QgYm91bmQgdG8gYSBuYW1lLiBUaGVyZWZvcmUsIHRoZSBvYmplY3QgY2Fubm90IGJlIGNhbGxlZCBvciBtYW5pcHVsYXRlZCBmcm9tIFIuIEFzIG5vIGNvcGllcyB3aWxsIGJlIG1hZGUsIGl0IGlzIG5vdCB1c2VmdWwgdG8gdHJhY2sgdGhlIG9iamVjdCBmb3IgY29weWluZy4KCi0tLQoKMi4gIEV4cGxhaW4gd2h5IGB0cmFjZW1lbSgpYCBzaG93cyB0d28gY29waWVzIHdoZW4geW91IHJ1biB0aGlzIGNvZGUuCiAgICBIaW50OiBjYXJlZnVsbHkgbG9vayBhdCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgY29kZSBhbmQgdGhlIGNvZGUgCiAgICBzaG93biBlYXJsaWVyIGluIHRoZSBzZWN0aW9uLgogICAgIApgYGB7cn0Kcm0obGlzdCA9IGxzKCkpCnggPC0gYygxTCwgMkwsIDNMKQp0cmFjZW1lbSh4KQoKeFtbM11dIDwtIDQKdW50cmFjZW1lbSh4KQpgYGAKCkFuc3dlcjogdW5jbGVhci4gVGhlIGJlaGF2aW9yIGluIFIgNC4yLjAgc2VlbXMgdG8gaGF2ZSBjaGFuZ2VkLCBzaW5jZSB0aGlzIGNvZGUgc2hvd3MgdHdvIGNvcGllczoKCmBgYHtyfQpybShsaXN0ID0gbHMoKSkKeCA8LSBjKDEsIDIsIDMpCnRyYWNlbWVtKHgpCgp5IDwtIHgKeVtbM11dIDwtIDRMCnlbWzNdXSA8LSA1TAp1bnRyYWNlbWVtKHgpCmBgYAoKQVIgU29sdXRpb25zOiBJbml0aWFsbHkgdGhlIHZlY3RvciBgeGAgaGFzIGludGVnZXIgdHlwZS4gVGhlIHJlcGxhY2VtZW50IGNhbGwgYXNzaWducyBhIGRvdWJsZSB0byB0aGUgdGhpcmQgZWxlbWVudCBvZiBgeGAsIHdoaWNoIHRyaWdnZXJzIGNvcHktb24tbW9kaWZ5LgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KeCA8LSBjKDFMLCAyTCwgM0wpCnRyYWNlbWVtKHgpCiM+IDwweDY2YTRhNzA+Cgp4W1szXV0gPC0gNAojPiB0cmFjZW1lbVsweDU1ZWVjN2IzYWYzOCAtPiAweDU1ZWVjNzc0Y2MxOF06CmBgYAoKV2UgY2FuIGF2b2lkIHRoZSBjb3B5IGJ5IHN1Yi1hc3NpZ25pbmcgYW4gaW50ZWdlciBpbnN0ZWFkIG9mIGEgZG91YmxlOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KeCA8LSBjKDFMLCAyTCwgM0wpCnRyYWNlbWVtKHgpCiM+IDwweDU1ZWVjNjk0MGFlMD4KCnhbWzNdXSA8LSA0TApgYGAKClBsZWFzZSBiZSBhd2FyZSB0aGF0IHJ1bm5pbmcgdGhpcyBjb2RlIGluIFJTdHVkaW8gd2lsbCByZXN1bHQgaW4gYWRkaXRpb25hbCBjb3BpZXMgYmVjYXVzZSBvZiB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGVudmlyb25tZW50IHBhbmUuCgotLS0KCjMuICBTa2V0Y2ggb3V0IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgZm9sbG93aW5nIG9iamVjdHM6CgpgYGB7cn0KYSA8LSAxOjEwCmIgPC0gbGlzdChhLCBhKQpjIDwtIGxpc3QoYiwgYSwgMToxMCkKCnByaW50KCJmaXJzdCBvYmplY3QiKQpvYmpfYWRkcihhKQpvYmpfYWRkcihiW1sxXV0pCm9ial9hZGRyKGJbWzJdXSkKb2JqX2FkZHIoY1tbMl1dKQoKcHJpbnQoInNlY29uZCBvYmplY3QiKQpvYmpfYWRkcihiKQpvYmpfYWRkcihjW1sxXV0pCgpwcmludCgidGhpcmQgb2JqZWN0IikKb2JqX2FkZHIoYykKCnByaW50KCJmb3VydGggb2JqZWN0ICg/KSIpCm9ial9hZGRyKGNbWzNdXSkKYGBgCgpBbnN3ZXI6IGZvdXIgZGlmZmVyZW50IG9iamVjdHMgd2l0aCBtdWx0aXBsZSBuYW1lcy4KCkFSIFNvbHV0aW9uczogYGFgIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIGFuIGFkZHJlc3Mgd2l0aCB0aGUgdmFsdWUgYDE6MTBgLiBgYmAgY29udGFpbnMgYSBsaXN0IG9mIHR3byByZWZlcmVuY2VzIHRvIHRoZSBzYW1lIGFkZHJlc3MgYXMgYGFgLiBgY2AgY29udGFpbnMgYSBsaXN0IG9mIGBiYCAoY29udGFpbmluZyB0d28gcmVmZXJlbmNlcyB0byBgYWApLCBgYWAgKGNvbnRhaW5pbmcgdGhlIHNhbWUgcmVmZXJlbmNlIGFnYWluKSBhbmQgYSByZWZlcmVuY2UgcG9pbnRpbmcgdG8gYSBkaWZmZXJlbnQgYWRkcmVzcyBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlIChgMToxMGApLgoKLS0tCgo0LiAgV2hhdCBoYXBwZW5zIHdoZW4geW91IHJ1biB0aGlzIGNvZGU/IERyYXcgYSBwaWN0dXJlLgoKYGBge3J9CnggPC0gbGlzdCgxOjEwKQoKeFtbMl1dIDwtIHgKCnJlZih4KQpgYGAKCkluaXRpYWxseSB4IGlzIGEgbGlzdCBvZiBvbmUgZWxlbWVudCwgYW4gaW50IHZlY3RvciAxOjEwLiBUaGVuIGEgc2Vjb25kIGxpc3QgZWxlbWVudCBpcyBhZGRlZCwgd2hpY2gKcG9pbnRzIHRvIHRoZSBvcmlnaW5hbCBpbnQgdmVjdG9yLgoKQVIgU29sdXRpb25zOiBUaGUgaW5pdGlhbCByZWZlcmVuY2UgdHJlZSBvZiBgeGAgc2hvd3MgdGhhdCB0aGUgbmFtZSBgeGAgYmluZHMgdG8gYSBsaXN0IG9iamVjdC4gVGhpcyBvYmplY3QgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGludGVnZXIgdmVjdG9yIGAxOjEwYC4gV2hlbiBgeGAgaXMgYXNzaWduZWQgdG8gYW4gZWxlbWVudCBvZiBpdHNlbGYsIGNvcHktb24tbW9kaWZ5IHRha2VzIHBsYWNlIGFuZCB0aGUgbGlzdCBpcyBjb3BpZWQgdG8gYSBuZXcgYWRkcmVzcyBpbiBtZW1vcnkuIFRoZSBsaXN0IG9iamVjdCBwcmV2aW91c2x5IGJvdW5kIHRvIGB4YCBpcyBub3cgcmVmZXJlbmNlZCBpbiB0aGUgbmV3bHkgY3JlYXRlZCBsaXN0IG9iamVjdC4gSXQgaXMgbm8gbG9uZ2VyIGJvdW5kIHRvIGEgbmFtZS4gVGhlIGludGVnZXIgdmVjdG9yIGlzIHJlZmVyZW5jZWQgdHdpY2UuCgotLS0KCiMjIDIuNC4xIEV4ZXJjaXNlcwoKMS4gIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgd2h5IGFyZSBgb2JqZWN0LnNpemUoeSlgIGFuZCBgb2JqX3NpemUoeSlgCiAgICBzbyByYWRpY2FsbHkgZGlmZmVyZW50PyBDb25zdWx0IHRoZSBkb2N1bWVudGF0aW9uIG9mIGBvYmplY3Quc2l6ZSgpYC4KCmBgYHtyfQp5IDwtIHJlcChsaXN0KHJ1bmlmKDFlNCkpLCAxMDApCgpvYmplY3Quc2l6ZSh5KQpvYmpfc2l6ZSh5KQpgYGAKCkFuc3dlcjogYG9iamVjdC5zaXplKClgICJkb2VzIG5vdCBkZXRlY3QgaWYgZWxlbWVudHMgb2YgYSBsaXN0IGFyZSBzaGFyZWQiLCB3aGljaCBpcyB0aGUgY2FzZSBoZXJlLiBUaGF0IGlzLCBpdCBkb2VzIG5vdCBkZXRlY3QgdGhlIGxpc3QgaGFzIGJlZW4gcmVwbGljYXRlZCAxMDAgdGltZXMsIGFuZCBvdmVyZXN0aW1hdGVzIGJ5IGEgZmFjdG9yIG9mIDEwMCBjb21wYXJlZCB0byBgb2JqZWN0X3NpemUoKWAuCgpBUiBTb2x1dGlvbnM6IGBvYmplY3Quc2l6ZSgpYCBkb2Vzbid0IGFjY291bnQgZm9yIHNoYXJlZCBlbGVtZW50cyB3aXRoaW4gbGlzdHMuIFRoZXJlZm9yZSwgdGhlIHJlc3VsdHMgZGlmZmVyIGJ5IGEgZmFjdG9yIG9mIH4gMTAwLgoKCi0tLQoKMi4gIFRha2UgdGhlIGZvbGxvd2luZyBsaXN0LiBXaHkgaXMgaXRzIHNpemUgc29tZXdoYXQgbWlzbGVhZGluZz8KCmBgYHtyfQpmdW5zIDwtIGxpc3QobWVhbiwgc2QsIHZhcikKb2JqX3NpemUoZnVucykKYGBgCgpBbnN3ZXI6IGl0IGRvZXNuJ3Qgc2VlbSBtaXNsZWFkaW5nIHRvIG1lLCBidXQgdGhlIGxpc3QgaW5jbHVkZXMgdGhlIGZ1bmN0aW9uIG9iamVjdHMsIG5vdCB0aGUgcmV0dXJuIHZhbHVlcy4gQWxzbywgaXQgY2FsY3VsYXRlcyB0aGUgc2l6ZSBkaXNjYXJkaW5nIHRoZSBvdmVybGFwIGJldHdlZW4gdGhlIGZ1bmN0aW9ucy4gUGVyIHRoZSBjb2RlIGJlbG93LCB0aGVyZSBpcyBzb21lOgoKYGBge3J9Cm9ial9zaXplKG1lYW4pICsgb2JqX3NpemUoc2QpICsgb2JqX3NpemUodmFyKQpgYGAKCkFSIFNvbHV0aW9uczogQWxsIHRocmVlIGZ1bmN0aW9ucyBhcmUgYnVpbHQtaW4gdG8gUiBhcyBwYXJ0IG9mIHRoZSBge2Jhc2V9YCBhbmQgYHtzdGF0c31gIHBhY2thZ2VzIGFuZCBoZW5jZSBhbHdheXMgYXZhaWxhYmxlLiBTbywgd2hhdCBkb2VzIGl0IG1lYW4gdG8gbWVhc3VyZSB0aGUgc2l6ZSBvZiBzb21ldGhpbmcgdGhhdCdzIGFscmVhZHkgaW5jbHVkZWQgaW4gUj8KCihUaGVyZSdzIHR5cGljYWxseSBhIG1vcmUgZ2VuZXJhbCBxdWVzdGlvbiBhYm91dCB3aGF0IHlvdSB3YW50IHRvIGtub3cgd2hlbiB5b3UgYXNrIGZvciB0aGUgc2l6ZSBvZiBzb21ldGhpbmcg4oCUIGRvIHlvdSB3YW50IHRvIGtub3cgaG93IG11Y2ggZGF0YSB5b3UnZCBuZWVkIHRvIHNlbmQgdG8gY29tbXVuaWNhdGUgdGhlIG9iamVjdCB0byBzb21lb25lIGVsc2UgKGUuZy4gc2VyaWFsaXNlIGl0KSwgb3IgZG8geW91IHdhbnQgdG8ga25vdyBob3cgbXVjaCBtZW1vcnkgeW91J2QgZnJlZSBpZiB5b3UgZGVsZXRlZCBpdD8pCgotLS0KCjMuICBQcmVkaWN0IHRoZSBvdXRwdXQgb2YgdGhlIGZvbGxvd2luZyBjb2RlOgoKYGBge3J9CmEgPC0gcnVuaWYoMWU2KQpvYmpfc2l6ZShhKSAjIDgsMDAwLDA0OCBCIH4gOE1CCiMgY29ycmVjdDogZnJvbSBleGFtcGxlIGFib3ZlLCBydW5pZigxZTYpIH49IDhNQgoKYiA8LSBsaXN0KGEsIGEpCm9ial9zaXplKGIpICMgc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gb2JqX3NpemUoYSkKIyBjb3JyZWN0OiB0d28gbGlzdHMgY29udGFpbmluZyBudW1lcmljIHZlY3RvcnMKb2JqX3NpemUoYSwgYikgIyBzbGlnaHRseSBsYXJnZXIgdGhhbiBvYmpfc2l6ZShiKQojIHdyb25nOiBhIGlzIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gYgoKYltbMV1dW1sxXV0gPC0gMTAKb2JqX3NpemUoYikgIyBjb3B5IG9mIGIsIHNhbWUgc2l6ZQojIHdyb25nOiBkb3VibGUsIHNpbmNlIFIgY29waWVzIGFuIGVudGlyZSBjb2x1bW4sIHRoaXMgYWRkcyB0aGUgc2l6ZSBvZiBydW5pZigxZTYpCm9ial9zaXplKGEsIGIpICMgc3RpbGwgbW9zdGx5IG92ZXJsYXBzLCBzbGlnaHRseSBsYXJnZXIgdGhhbiBwcmV2aW91cyBvYmpfc2l6ZShhLCBiKQojIHdyb25nOiBhIGlzIHN0aWxsIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoIGIKCmJbWzJdXVtbMV1dIDwtIDEwCm9ial9zaXplKGIpICMgY29weSBvZiBiLCBzYW1lIHNpemUKIyB3cm9uZzogc2FtZSBzaXplIHNpbmNlIGl0J3Mgc3RpbGwgMiBudW1lcmljIHZlY3RvcnMgb2YgMWU2IGxlbmd0aApvYmpfc2l6ZShhLCBiKSAjIHN0aWxsIG1vc3RseSBvdmVybGFwcywgc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gcHJldmlvdXMgb2JqX3NpemUoYSwgYikKIyB3cm9uZzogdGhlcmUgaXMgbm8gbG9uZ2VyIGFueSBvdmVybGFwLCBzbyB0aGUgc2l6ZSBvZiBvYmpfc2l6ZShhLCBiKSA9IG9ial9zaXplKGEpID0gb2JqX3NpemUoYikKYGBgCgpBbnN3ZXI6IGFuc3dlcnMgaW5saW5lLgoKQVIgU29sdXRpb25zOgoKYGEgPC0gcnVuaWYoMWU2KWA6CgotIEluIFIgKG9uIG1vc3QgcGxhdGZvcm1zKSBhIGxlbmd0aC0wIHZlY3RvciBoYXMgNDggYnl0ZXMgb2Ygb3ZlcmhlYWQuCi0gQSBzaW5nbGUgZG91YmxlIHRha2VzIHVwIGFuIGFkZGl0aW9uYWwgOCBieXRlcyBvZiBtZW1vcnkuCi0gU28sIGEgMSBtaWxsaW9uIGRvdWJsZSBzaG91bGQgdGFrZSB1cCA4LDAwMCwwNDggYnl0ZXMuCgpGb3IgYGIgPC0gbGlzdChhLCBhKWAgYm90aCBsaXN0IGVsZW1lbnRzIGNvbnRhaW4gcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBtZW1vcnkgYWRkcmVzcy4gVGhlcmVmb3JlLCBubyBhZGRpdGlvbmFsIG1lbW9yeSBpcyByZXF1aXJlZCBmb3IgdGhlIHNlY29uZCBsaXN0IGVsZW1lbnQuIFRoZSBsaXN0IGl0c2VsZiByZXF1aXJlcyA2NCBieXRlcywgNDggYnl0ZXMgZm9yIGFuIGVtcHR5IGxpc3QgYW5kIDggYnl0ZXMgZm9yIGVhY2ggZWxlbWVudCAoYG9ial9zaXplKHZlY3RvcigibGlzdCIsIDIpKWApLiBUaGlzIGxldHMgdXMgcHJlZGljdCA4LDAwMCwwNDggQiArIDY0IEIgPSA4LDAwMCwxMTIgQi4KCmBiW1sxXV1bWzFdXSA8LSAxMGA6IFdoZW4gd2UgbW9kaWZ5IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBiW1sxXV1gIGNvcHktb24tbW9kaWZ5IG9jY3Vycy4gQm90aCBlbGVtZW50cyB3aWxsIHN0aWxsIGhhdmUgdGhlIHNhbWUgc2l6ZSAoOCwwMDAsMDQwIEIpLCBidXQgdGhlIGZpcnN0IG9uZSBnZXRzIGEgbmV3IGFkZHJlc3MgaW4gbWVtb3J5LiBBcyBgYmAncyBlbGVtZW50cyBkb24ndCBzaGFyZSByZWZlcmVuY2VzIGFueW1vcmUsIGl0cyBvYmplY3Qgc2l6ZSBhZGRzIHVwIHRvIHRoZSBzdW0gb2YgdGhlIGVsZW1lbnRzIGFuZCB0aGUgbGVuZ3RoLTIgbGlzdDogOCwwMDAsMDQ4IEIgKyA4LDAwMCwwNDggQiArIDY0IEIgPSAxNiwwMDAsMTYwIEIgKDE2IE1CKS4gVGhlIHNlY29uZCBlbGVtZW50IG9mIGBiYCBzdGlsbCByZWZlcmVuY2VzIHRoZSBzYW1lIGFkZHJlc3MgYXMgYGFgLCBzbyB0aGUgY29tYmluZWQgc2l6ZSBvZiBgYWAgYW5kIGBiYCBpcyB0aGUgc2FtZSBhcyBgYmAuCgpgYltbMl1dW1sxXV0gPC0gMTBgOiBXaGVuIHdlIG1vZGlmeSB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgYGJgLCB0aGlzIGVsZW1lbnQgd2lsbCBhbHNvIHBvaW50IHRvIGEgbmV3IG1lbW9yeSBhZGRyZXNzLiBUaGlzIGRvZXMgbm90IGFmZmVjdCB0aGUgc2l6ZSBvZiB0aGUgbGlzdC4gSG93ZXZlciwgYXMgYGJgIGRvZXNuJ3Qgc2hhcmUgcmVmZXJlbmNlcyB3aXRoIGBhYCBhbnltb3JlLCB0aGUgbWVtb3J5IHVzYWdlIG9mIHRoZSBjb21iaW5lZCBvYmplY3RzIGluY3JlYXNlcy4KCi0tLQoKIyMgMi41LjMgRXhlcmNpc2VzCgoxLiAgRXhwbGFpbiB3aHkgdGhlIGZvbGxvd2luZyBjb2RlIGRvZXNuJ3QgY3JlYXRlIGEgY2lyY3VsYXIgbGlzdC4KCmBgYHtyfQp4IDwtIGxpc3QoKQp4W1sxXV0gPC0geApgYGAKCkFuc3dlcjogdGhlIG5hbWUgeCBpcyBhc3NpZ25lZCB0byB0aGUgZW1wdHkgbGlzdCwgYW5kIHRoZW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeCBpcyBtYXBwZWQgdG8gdGhlIG9iamVjdCB0aGF0IHggcG9pbnRzIHRvLCB0aGUgZW1wdHkgbGlzdC4KCkFSIFNvbHV0aW9uczogSW4gdGhpcyBzaXR1YXRpb24gY29weS1vbi1tb2RpZnkgcHJldmVudHMgdGhlIGNyZWF0aW9uIG9mIGEgY2lyY3VsYXIgbGlzdC4gTGV0IHVzIHN0ZXAgdGhyb3VnaCB0aGUgZGV0YWlsczoKCmBgYHtyLCBldmFsID0gRkFMU0V9CnggPC0gbGlzdCgpICMgY3JlYXRlcyBpbml0aWFsIG9iamVjdApvYmpfYWRkcih4KQojPiBbMV0gIjB4NTU4NjJmMjNhYjgwIgp0cmFjZW1lbSh4KQojPiBbMV0gIjwweDU1ODYyZjIzYWI4MD4iCnhbWzFdXSA8LSB4ICMgQ29weS1vbi1tb2RpZnkgdHJpZ2dlcnMgbmV3IGNvcHkKIz4gdHJhY2VtZW1bMHg1NTg2MmYyM2FiODAgLT4gMHg1NTg2MmU4Y2UwMjhdOgpvYmpfYWRkcih4KSAjIGNvcGllZCBvYmplY3QgaGFzIG5ldyBtZW1vcnkgYWRkcmVzcwojPiBbMV0gIjB4NTU4NjJlOGNlMDI4IgpvYmpfYWRkcih4W1sxXV0pICMgbGlzdCBlbGVtZW50IGNvbnRhaW5zIG9sZCBtZW1vcnkgYWRkcmVzcwojPiBbMV0gIjB4NTU4NjJmMjNhYjgwIgpgYGAKCi0tLQoKMi4gIFdyYXAgdGhlIHR3byBtZXRob2RzIGZvciBzdWJ0cmFjdGluZyBtZWRpYW5zIGludG8gdHdvIGZ1bmN0aW9ucywgdGhlbgogICAgdXNlIHRoZSAnYmVuY2gnIHBhY2thZ2UgW0BiZW5jaF0gdG8gY2FyZWZ1bGx5IGNvbXBhcmUgdGhlaXIgc3BlZWRzLiBIb3cgZG9lcwogICAgcGVyZm9ybWFuY2UgY2hhbmdlIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbmNyZWFzZT8KCmBgYHtyfQp4X21lZGlhbnMgPC0gZnVuY3Rpb24obmNvbCkgewogIHggPC0gZGF0YS5mcmFtZShtYXRyaXgocnVuaWYoNSAqIDFlNCksIG5jb2wgPSBuY29sKSkKICBtZWRpYW5zIDwtIHZhcHBseSh4LCBtZWRpYW4sIG51bWVyaWMoMSkpCiAgcmV0dXJuKGxpc3QoeCA9IHgsIG1lZGlhbnMgPSBtZWRpYW5zKSkKfQoKZGZfbWVkaWFucyA8LSBmdW5jdGlvbih4LCBtZWRpYW5zKSB7CiAgIyBzdWJ0cmFjdCBtZWRpYW5zIHVzaW5nIGRhdGEuZnJhbWUgbWV0aG9kCiAgZm9yIChpIGluIHNlcV9hbG9uZyhtZWRpYW5zKSkgewogICAgeFtbaV1dIDwtIHhbW2ldXSAtIG1lZGlhbnNbW2ldXQogIH0KICB4Cn0KCmxzX21lZGlhbnMgPC0gZnVuY3Rpb24oeCwgbWVkaWFucykgewogIHkgPC0gYXMubGlzdCh4KQoKICBmb3IgKGkgaW4gc2VxX2Fsb25nKG1lZGlhbnMpKSB7CiAgICB5W1tpXV0gPC0geVtbaV1dIC0gbWVkaWFuc1tbaV1dCiAgfQogIHkKfQoKIyBjb25maXJtIHRoZXkgYm90aCB3b3JrCnhtIDwtIHhfbWVkaWFucyg1KQpoZWFkKGRmX21lZGlhbnMoeG0keCwgeG0kbWVkaWFucyksIDEwKQpoZWFkKGFzLmRhdGEuZnJhbWUobHNfbWVkaWFucyh4bSR4LCB4bSRtZWRpYW5zKSksIDEwKQoKIyBiZW5jaG1hcmsKbWFyayhkZl9tZWRpYW5zKHhtJHgsIHhtJG1lZGlhbnMpKQptYXJrKGxzX21lZGlhbnMoeG0keCwgeG0kbWVkaWFucykpCm1hcmsoYXMuZGF0YS5mcmFtZShsc19tZWRpYW5zKHhtJHgsIHhtJG1lZGlhbnMpKSkgIyBhcy5kYXRhLmZyYW1lIGludHJvZHVjZXMgc2lnbmlmaWNhbnQgb3ZlcmhlYWQKYGBgCgpBbnN3ZXI6IHdpdGggNSBjb2x1bW5zLCB0aGUgbGlzdCBtZXRob2QgaXMgYWJvdXQgdHdpY2UgYXMgZmFzdC4KCmBgYHtyfQp4bSA8LSB4X21lZGlhbnMoMTApCm1hcmsoZGZfbWVkaWFucyh4bSR4LCB4bSRtZWRpYW5zKSkKbWFyayhsc19tZWRpYW5zKHhtJHgsIHhtJG1lZGlhbnMpKQoKeG0gPC0geF9tZWRpYW5zKDIwKQptYXJrKGRmX21lZGlhbnMoeG0keCwgeG0kbWVkaWFucykpCm1hcmsobHNfbWVkaWFucyh4bSR4LCB4bSRtZWRpYW5zKSkKYGBgCgpXaXRoIDEwIGNvbHVtbnMsIHRoZSBsaXN0IG1ldGhvZCBpcyAzIHRpbWVzIGFzIGZhc3QuIFdpdGggMjAsIHRoZSBsaXN0IG1ldGhvZCBpcyA1IHRpbWVzIGFzIGZhc3QuIFNvLCB0aGUgbGlzdCBtZXRob2QgaXMgbmVhciBjb25zdGFudCB0aW1lIHJlZ2FyZGxlc3Mgb2YgY29sdW1ucywgd2hlcmVhcyB0aGUgZGF0YS5mcmFtZSBtZXRob2Qgc2NhbGVzIGxpbmVhcmx5IHdpdGggdGhlIG51bWJlciBvZiBjb2x1bW5zLgoKQVIgU29sdXRpb25zOgoKV2hlbiB3b3JraW5nIGRpcmVjdGx5IHdpdGggdGhlIGRhdGEgZnJhbWUsIHRoZSBleGVjdXRpb24gdGltZSBncm93cyBxdWFkcmF0aWNhbGx5IHdpdGggdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBpbnB1dCBkYXRhLiBUaGlzIGlzIGJlY2F1c2UgKGUuZy4pIHRoZSBmaXJzdCBjb2x1bW4gbXVzdCBiZSBjb3BpZWQgbiB0aW1lcywgdGhlIHNlY29uZCBjb2x1bW4gbi0xIHRpbWVzLCBhbmQgc28gb24uIFdoZW4gd29ya2luZyB3aXRoIGEgbGlzdCwgdGhlIGV4ZWN1dGlvbiB0aW1lIGluY3JlYXNlcyBvbmx5IGxpbmVhcmx5LgoKT2J2aW91c2x5IGluIHRoZSBsb25nIHJ1biwgbGluZWFyIGdyb3d0aCBjcmVhdGVzIHNob3J0ZXIgcnVuLXRpbWVzLCBidXQgdGhlcmUgaXMgc29tZSBjb3N0IHRvIHRoaXMgc3RyYXRlZ3kg4oCUIHdlIGhhdmUgdG8gY29udmVydCBiZXR3ZWVuIGRhdGEgc3RydWN0dXJlcyB3aXRoIGFzLmxpc3QoKSBhbmQgbGlzdDJERigpLiBFdmVuIHRob3VnaCB0aGlzIGlzIGZhc3QgYW5kIHByb2JhYmx5IGRvZXNu4oCZdCBodXJ0IG11Y2gsIHRoZSBpbXByb3ZlZCBhcHByb2FjaCBkb2VzbuKAmXQgcmVhbGx5IHBheSBvZmYgaW4gdGhpcyBzY2VuYXJpbyB1bnRpbCB3ZSBnZXQgdG8gYSBkYXRhIGZyYW1lIHRoYXQgaXMgYWJvdXQgMzAwIGNvbHVtbnMgd2lkZSAod2l0aCB0aGUgZXhhY3QgdmFsdWUgZGVwZW5kaW5nIG9uIHRoZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgdGhlIHN5c3RlbSBydW5uaW5nIHRoZSBjb2RlKS4KCi0tLQoKMy4gIFdoYXQgaGFwcGVucyBpZiB5b3UgYXR0ZW1wdCB0byB1c2UgYHRyYWNlbWVtKClgIG9uIGFuIGVudmlyb25tZW50PwoKYGBge3J9CmUgPC0gcmxhbmc6OmVudigpCnRyeSh0cmFjZW1lbShlKSkKYGBgCgpBbnN3ZXI6IGl0IHRocm93cyBhbiBlcnJvciEKCkFSIFNvbHV0aW9uczogYHRyYWNlbWVtKClgIGNhbm5vdCBiZSB1c2VkIHRvIG1hcmsgYW5kIHRyYWNlIGVudmlyb25tZW50cy4KClRoZSBlcnJvciBvY2N1cnMgYmVjYXVzZSAiaXQgaXMgbm90IHVzZWZ1bCB0byB0cmFjZSBOVUxMLCBlbnZpcm9ubWVudHMsIHByb21pc2VzLCB3ZWFrIHJlZmVyZW5jZXMsIG9yIGV4dGVybmFsIHBvaW50ZXIgb2JqZWN0cywgYXMgdGhlc2UgYXJlIG5vdCBkdXBsaWNhdGVkIiAoc2VlIGA/dHJhY2VtZW1gKS4gRW52aXJvbm1lbnRzIGFyZSBhbHdheXMgbW9kaWZpZWQgaW4gcGxhY2UuCgotLS0KCiMgMyBWZWN0b3JzCgpUaGlzIGNoYXB0ZXIgZGlzY3Vzc2VzIHRoZSBtb3N0IGltcG9ydGFudCBmYW1pbHkgb2YgZGF0YSB0eXBlcyBpbiBiYXNlIFI6IHZlY3RvcnMuIFdoaWxlIHlvdSd2ZSBwcm9iYWJseSBhbHJlYWR5IHVzZWQgbWFueSAoaWYgbm90IGFsbCkgb2YgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiB2ZWN0b3JzLCB5b3UgbWF5IG5vdCBoYXZlIHRob3VnaHQgZGVlcGx5IGFib3V0IGhvdyB0aGV5J3JlIGludGVycmVsYXRlZC4gSW4gdGhpcyBjaGFwdGVyLCBJIHdvbid0IGNvdmVyIGluZGl2aWR1YWwgdmVjdG9ycyB0eXBlcyBpbiB0b28gbXVjaCBkZXRhaWwsIGJ1dCBJIHdpbGwgc2hvdyB5b3UgaG93IGFsbCB0aGUgdHlwZXMgZml0IHRvZ2V0aGVyIGFzIGEgd2hvbGUuIElmIHlvdSBuZWVkIG1vcmUgZGV0YWlscywgeW91IGNhbiBmaW5kIHRoZW0gaW4gUidzIGRvY3VtZW50YXRpb24uCgpWZWN0b3JzIGNvbWUgaW4gdHdvIGZsYXZvdXJzOiBhdG9taWMgdmVjdG9ycyBhbmQgbGlzdHMuIFRoZXkgZGlmZmVyIGluIHRlcm1zIG9mIHRoZWlyIGVsZW1lbnRzJyB0eXBlczogZm9yIGF0b21pYyB2ZWN0b3JzLCBhbGwgZWxlbWVudHMgbXVzdCBoYXZlIHRoZSBzYW1lIHR5cGU7IGZvciBsaXN0cywgZWxlbWVudHMgY2FuIGhhdmUgZGlmZmVyZW50IHR5cGVzLiBXaGlsZSBub3QgYSB2ZWN0b3IsIGBOVUxMYCBpcyBjbG9zZWx5IHJlbGF0ZWQgdG8gdmVjdG9ycyBhbmQgb2Z0ZW4gc2VydmVzIHRoZSByb2xlIG9mIGEgZ2VuZXJpYyB6ZXJvIGxlbmd0aCB2ZWN0b3IuIFRoaXMgZGlhZ3JhbSwgd2hpY2ggd2UnbGwgYmUgZXhwYW5kaW5nIG9uIHRocm91Z2hvdXQgdGhpcyBjaGFwdGVyLCBpbGx1c3RyYXRlcyB0aGUgYmFzaWMgcmVsYXRpb25zaGlwczoKCkV2ZXJ5IHZlY3RvciBjYW4gYWxzbyBoYXZlIF9fYXR0cmlidXRlc19fLCB3aGljaCB5b3UgY2FuIHRoaW5rIG9mIGFzIGEgbmFtZWQgbGlzdCBvZiBhcmJpdHJhcnkgbWV0YWRhdGEuIFR3byBhdHRyaWJ1dGVzIGFyZSBwYXJ0aWN1bGFybHkgaW1wb3J0YW50LiBUaGUgX19kaW1lbnNpb25fXyBhdHRyaWJ1dGUgdHVybnMgdmVjdG9ycyBpbnRvIG1hdHJpY2VzIGFuZCBhcnJheXMgYW5kIHRoZSBfX2NsYXNzX18gYXR0cmlidXRlIHBvd2VycyB0aGUgUzMgb2JqZWN0IHN5c3RlbS4gV2hpbGUgeW91J2xsIGxlYXJuIGhvdyB0byB1c2UgUzMgaW4gQ2hhcHRlciAxMywgaGVyZSB5b3UnbGwgbGVhcm4gYWJvdXQgc29tZSBvZiB0aGUgbW9zdCBpbXBvcnRhbnQgUzMgdmVjdG9yczogZmFjdG9ycywgZGF0ZSBhbmQgdGltZXMsIGRhdGEgZnJhbWVzLCBhbmQgdGliYmxlcy4gQW5kIHdoaWxlIDJEIHN0cnVjdHVyZXMgbGlrZSBtYXRyaWNlcyBhbmQgZGF0YSBmcmFtZXMgYXJlIG5vdCBuZWNlc3NhcmlseSB3aGF0IGNvbWUgdG8gbWluZCB3aGVuIHlvdSB0aGluayBvZiB2ZWN0b3JzLCB5b3UnbGwgYWxzbyBsZWFybiB3aHkgUiBjb25zaWRlcnMgdGhlbSB0byBiZSB2ZWN0b3JzLgoKYGBge3J9CnJtKGxpc3QgPSBscygpKQpgYGAKCiMjIDMuMi41IEV4ZXJjaXNlcwoKMS4gSG93IGRvIHlvdSBjcmVhdGUgcmF3IGFuZCBjb21wbGV4IHNjYWxhcnM/IChTZWUgYD9yYXdgIGFuZCAKICAgYD9jb21wbGV4YC4pCgpBbnN3ZXI6IHVzaW5nIGVpdGhlciBgcmF3KClgLCBgY29tcGxleCgpYCwgb3IgYGFzLnJhdygpYCwgYGFzLmNvbXBsZXgoKWAuCgotLS0KCjIuIFRlc3QgeW91ciBrbm93bGVkZ2Ugb2YgdGhlIHZlY3RvciBjb2VyY2lvbiBydWxlcyBieSBwcmVkaWN0aW5nIHRoZSBvdXRwdXQgb2YKICAgdGhlIGZvbGxvd2luZyB1c2VzIG9mIGBjKClgOgoKYGBge3J9CmMoMSwgRkFMU0UpICMgMS4wLCAwLjAgLSBkb3VibGUKYygiYSIsIDEpICMgImEiLCAiMSIgLSBjaGFyYWN0ZXIKYyhUUlVFLCAxTCkgIyAxTCwgMUwgLSBpbnRlZ2VyCgp0eXBlb2YoYygxLCBGQUxTRSkpCnR5cGVvZihjKCJhIiwgMSkpCnR5cGVvZihjKFRSVUUsIDFMKSkKYGBgCgpBbnN3ZXI6IGd1ZXNzZXMgaW5saW5lLiBbY29ycmVjdCFdCgotLS0KCjMuIFdoeSBpcyBgMSA9PSAiMSJgIHRydWU/IFdoeSBpcyBgLTEgPCBGQUxTRWAgdHJ1ZT8gV2h5IGlzIGAib25lIiA8IDJgIGZhbHNlPwoKQW5zd2VyczoKCi0gYDEgPT0gIjEiYDogdGhlIDEgaXMgY29lcmNlZCB0byAiMSIKLSBgLTEgPCBGQUxTRWA6IEZBTFNFIGlzIGNvZXJjZWQgdG8gMAotIGAib25lIiA8IDI6IHRoZSAyIGlzIGNvZXJjZWQgdG8gIjIiCgotLS0KCjQuIFdoeSBpcyB0aGUgZGVmYXVsdCBtaXNzaW5nIHZhbHVlLCBgTkFgLCBhIGxvZ2ljYWwgdmVjdG9yPyBXaGF0J3Mgc3BlY2lhbAogICBhYm91dCBsb2dpY2FsIHZlY3RvcnM/IChIaW50OiB0aGluayBhYm91dCBgYyhGQUxTRSwgTkFfY2hhcmFjdGVyXylgLikKCkFuc3dlcjogTkEgbXVzdCBiZSBsb2dpY2FsIHNvIHRoYXQgaXQgY2FuIGV4aXN0IGluIGEgbG9naWNhbCB2ZWN0b3IuCgotLS0KCjUuIFByZWNpc2VseSB3aGF0IGRvIGBpcy5hdG9taWMoKWAsIGBpcy5udW1lcmljKClgLCBhbmQgYGlzLnZlY3RvcigpYCB0ZXN0IGZvcj8KCkFuc3dlcnM6CgotIGBpcy5hdG9taWMoeClgOiB0ZXN0cyBpZiB4IGlzIGFuIGF0b21pYyB2ZWN0b3IgKGxvZ2ljYWwsIGludGVnZXIsIG51bWVyaWMsIGNvbXBsZXgsIGNoYXJhY3RlciwKICBhbmQgcmF3KSAtIGlzIGBGQUxTRWAgZm9yIGxpc3RzCi0gYGlzLm51bWVyaWMoeClgOiB0ZXN0cyBpZiB4IGlzIGFuIGF0b21pYyBudW1lcmljIHZlY3RvcgotIGBpcy52ZWN0b3IoeCwgbW9kZSA9ICJhbnkiKWA6IHRlc3RzIGlmIHggaXMgYW4gYXRvbWljIHZlY3RvciBPUiBhIGxpc3Qgb3IgZXhwcmVzc2lvbgoKLS0tCgojIyAzLjMuNCBFeGVyY2lzZXMKCjEuICBIb3cgaXMgYHNldE5hbWVzKClgIGltcGxlbWVudGVkPyBIb3cgaXMgYHVubmFtZSgpYCBpbXBsZW1lbnRlZD8KICAgIFJlYWQgdGhlIHNvdXJjZSBjb2RlLgoKYGBge3J9CnNldE5hbWVzCnVubmFtZQpgYGAKCkFuc3dlcjogdXNpbmcgYG5hbWVzKClgLCBhbmQgYGRpbW5hbWVzKClgIGZvciBgdW5uYW1lKClgLgoKLS0tCgoyLiAgV2hhdCBkb2VzIGBkaW0oKWAgcmV0dXJuIHdoZW4gYXBwbGllZCB0byBhIDEtZGltZW5zaW9uYWwgdmVjdG9yPwogICAgV2hlbiBtaWdodCB5b3UgdXNlIGBOUk9XKClgIG9yIGBOQ09MKClgPwoKYGBge3J9CmRpbSgxOjMpCm5yb3coMToxMikKTlJPVygxOjEyKQpuY29sKDE6MTIpCk5DT0woMToxMikKYGBgCgpBbnN3ZXJzOiBgTlVMTGAuIGBOUk9XYCBhbmQgYE5DT0xgIGFyZSB1c2VmdWwgd2hlbiBjb21wYXJpbmcgYE5VTExgIGRpbWVuc2lvbmFsIHZlY3RvcnMgd2l0aAptYXRyaWNlcyBhbmQgYXJyYXlzLgoKLS0tCgozLiAgSG93IHdvdWxkIHlvdSBkZXNjcmliZSB0aGUgZm9sbG93aW5nIHRocmVlIG9iamVjdHM/IFdoYXQgbWFrZXMgdGhlbQogICAgZGlmZmVyZW50IGZyb20gYDE6NWA/CgpgYGB7cn0KeDEgPC0gYXJyYXkoMTo1LCBjKDEsIDEsIDUpKQp4MiA8LSBhcnJheSgxOjUsIGMoMSwgNSwgMSkpCngzIDwtIGFycmF5KDE6NSwgYyg1LCAxLCAxKSkKCngxCngyCngzCmBgYAoKVGhleSBoYXZlIGEgMy1kaW1lbnNpb25hbCBzdHJ1Y3R1cmUsIGFycmFuZ2VkIGluIGRpZmZlcmVudCB3YXlzLCBhbG9uZyB0aGUgeiwgeCwgYW5kIHkgYXhpcy4KCi0tLQoKNC4gIEFuIGVhcmx5IGRyYWZ0IHVzZWQgdGhpcyBjb2RlIHRvIGlsbHVzdHJhdGUgYHN0cnVjdHVyZSgpYDoKCmBgYHtyfQpzdHJ1Y3R1cmUoMTo1LCBjb21tZW50ID0gIm15IGF0dHJpYnV0ZSIpCmBgYAoKICAgIEJ1dCB3aGVuIHlvdSBwcmludCB0aGF0IG9iamVjdCB5b3UgZG9uJ3Qgc2VlIHRoZSBjb21tZW50IGF0dHJpYnV0ZS4KICAgIFdoeT8gSXMgdGhlIGF0dHJpYnV0ZSBtaXNzaW5nLCBvciBpcyB0aGVyZSBzb21ldGhpbmcgZWxzZSBzcGVjaWFsIGFib3V0CiAgICBpdD8gKEhpbnQ6IHRyeSB1c2luZyBoZWxwLikKCmBgYHtyfQpmYWN0b3IoImdyZWVuIiwgbGV2ZWxzID0gYygicmVkIiwgImFtYmVyIiwgImdyZWVuIikpCmRwdXQoZmFjdG9yKCJncmVlbiIsIGxldmVscyA9IGMoInJlZCIsICJhbWJlciIsICJncmVlbiIpKSkKYGBgCgpBbnN3ZXI6IHByaW50IGRvZXNuJ3QgZGlzcGxheSB0aGUgYXR0cmlidXRlcyBmb3IgYXJiaXRyYXJ5IHN0cnVjdHVyZXMsIG9ubHkgZGVmaW5lZCBjbGFzc2VzLCBsaWtlCmZhY3RvcnMgKGZvciBleGFtcGxlLCBhYm92ZSkuCgotLS0KCiMjIDMuNC41IEV4ZXJjaXNlcwoKMS4gIFdoYXQgc29ydCBvZiBvYmplY3QgZG9lcyBgdGFibGUoKWAgcmV0dXJuPyBXaGF0IGlzIGl0cyB0eXBlPyBXaGF0IAogICAgYXR0cmlidXRlcyBkb2VzIGl0IGhhdmU/IEhvdyBkb2VzIHRoZSBkaW1lbnNpb25hbGl0eSBjaGFuZ2UgYXMgeW91CiAgICB0YWJ1bGF0ZSBtb3JlIHZhcmlhYmxlcz8KCmBgYHtyfQphIDwtIGxldHRlcnNbMTozXQphX3RhYmxlIDwtIHRhYmxlKGEsIHNhbXBsZShhKSkKYV90YWJsZQoKdHlwZW9mKGFfdGFibGUpCmF0dHJpYnV0ZXMoYV90YWJsZSkKCmIgPC0gbGV0dGVyc1sxOjRdCmJfdGFibGUgPC0gdGFibGUoYiwgc2FtcGxlKGIpKQpiX3RhYmxlCgphdHRyaWJ1dGVzKGJfdGFibGUpCmBgYAoKQW5zd2VyOiBhbiBvYmplY3Qgb2YgY2xhc3MgInRhYmxlIiwgYW4gYXJyYXkgb2YgaW50ZWdlciB2YWx1ZXMsIHdpdGggdHlwZSAiaW50ZWdlciIuIEF0dHJpYnV0ZXMKbGlzdGVkIGFib3ZlLCB0aGUgZGltZW5zaW9uYWxpdHkgaXMgYWx3YXlzIG4gYnkgbiwgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIHZhcmlhYmxlcyB0YWJ1bGF0ZWQuCgotLS0KCjIuICBXaGF0IGhhcHBlbnMgdG8gYSBmYWN0b3Igd2hlbiB5b3UgbW9kaWZ5IGl0cyBsZXZlbHM/IAoKYGBge3J9CmYxIDwtIGZhY3RvcihsZXR0ZXJzKQpmMQpsZXZlbHMoZjEpIDwtIHJldihsZXZlbHMoZjEpKQpmMQpgYGAKCkFuc3dlcjogfn50aGUgZmFjdG9yIHdpbGwgcmVtYWluIHRoZSBzYW1lLCBidXQgdGhlIGF0dHJpYnV0ZXMgd2lsbCBjaGFuZ2Uufn4gdGhlIGZhY3RvciBhbmQgaXRzCmxldmVscyBhcmUgcmV2ZXJzZWQuCgotLS0KCjMuICBXaGF0IGRvZXMgdGhpcyBjb2RlIGRvPyBIb3cgZG8gYGYyYCBhbmQgYGYzYCBkaWZmZXIgZnJvbSBgZjFgPwoKYGBge3J9CmYyIDwtIHJldihmYWN0b3IobGV0dGVycykpCmYyCmYzIDwtIGZhY3RvcihsZXR0ZXJzLCBsZXZlbHMgPSByZXYobGV0dGVycykpCmYzCmBgYAoKQW5zd2VyOiBib3RoIGNyZWF0ZSBhIHJldmVyc2VkIGxpc3Qgb2YgbGV0dGVycy4gZjMgYWxzbyBoYXMgcmV2ZXJzZWQgbGV2ZWxzIGJ1dCBmMiBkb2VzIG5vdC4KKGNvcnJlY3QhKQoKLS0tCgojIyAzLjUuNCBFeGVyY2lzZXMKCjEuICBMaXN0IGFsbCB0aGUgd2F5cyB0aGF0IGEgbGlzdCBkaWZmZXJzIGZyb20gYW4gYXRvbWljIHZlY3Rvci4KCkFuc3dlcnM6CgotIEVhY2ggZWxlbWVudCBjYW4gYmUgYSBkaWZmZXJlbnQgdHlwZQotIEVhY2ggZWxlbWVudCBpcyBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3QKLSBMaXN0IHNpemUgY2FuIGJlIHNtYWxsZXIgc2luY2UgZWxlbWVudHMgYXJlIHJlZmVyZW5jZXMKLSBMaXN0cyBjYW4gY29udGFpbiBvdGhlciBsaXN0cwoKLS0tCgoyLiAgV2h5IGRvIHlvdSBuZWVkIHRvIHVzZSBgdW5saXN0KClgIHRvIGNvbnZlcnQgYSBsaXN0IHRvIGFuIAogICAgYXRvbWljIHZlY3Rvcj8gV2h5IGRvZXNuJ3QgYGFzLnZlY3RvcigpYCB3b3JrPyAKCmBgYHtyfQppcy52ZWN0b3IobGlzdCgxOjQpKQpkcHV0KGFzLnZlY3RvcihsaXN0KDE6NCkpKQpgYGAKCkFuc3dlcjogYSBsaXN0IGlzIGNvbnNpZGVyZWQgYSB2ZWN0b3IgYnkgYGFzLnZlY3RvcigpYC4KCi0tLQoKMy4gIENvbXBhcmUgYW5kIGNvbnRyYXN0IGBjKClgIGFuZCBgdW5saXN0KClgIHdoZW4gY29tYmluaW5nIGEgCiAgICBkYXRlIGFuZCBkYXRlLXRpbWUgaW50byBhIHNpbmdsZSB2ZWN0b3IuCgpgYGB7cn0KZCA8LSBsaXN0KGRhdGUgPSBhcy5EYXRlKCIyMDIyLTA2LTI1IiksIGRhdGV0aW1lID0gYXMuUE9TSVhjdCgiMjAyMi0wNi0yNSAwOTo1OTo0MCBDRFQiKSkKZHB1dChkKQoKZHB1dChjKGQpKSAjIG5vbGludDogdW5uZWVkZWRfY29uY2F0ZW5hdGlvbl9saW50ZXIuCmRwdXQodW5saXN0KGQpKQpgYGAKCkFuc3dlcjogYGMoKWAgcHJlc2VydmVzIHRoZSBsaXN0IHN0cnVjdHVyZS4gYHVubGlzdCgpYCBjb252ZXJ0cyBib3RoIHRvIGBkb3VibGVgLgoKLS0tCgojIyAzLjYuOCBFeGVyY2lzZXMKCjEuICBDYW4geW91IGhhdmUgYSBkYXRhIGZyYW1lIHdpdGggemVybyByb3dzPyBXaGF0IGFib3V0IHplcm8gY29sdW1ucz8KCmBgYHtyfQojIGZyb20gZGF0YS5mcmFtZSgpIGV4YW1wbGVzOgpkZiA8LSBkYXRhLmZyYW1lKHggPSAxOjMsIHkgPSA0OjYsIHogPSA3OjkpCgpkZgpkZlssIEZBTFNFXQpkZltGQUxTRSwgXQpkZltGQUxTRSwgRkFMU0VdCmBgYAoKQW5zd2VyOiB5ZXMhCgotLS0KCjIuICBXaGF0IGhhcHBlbnMgaWYgeW91IGF0dGVtcHQgdG8gc2V0IHJvd25hbWVzIHRoYXQgYXJlIG5vdCB1bmlxdWU/CgpgYGB7cn0Kcm93bmFtZXMoZGYpCnRyeShyb3duYW1lcyhkZikgPC0gYygiYSIsICJhIiwgImIiKSkKYGBgCgpBbnN3ZXI6IGVycm9yLCBkdXBsaWNhdGVzIG5vdCBhbGxvd2VkLgoKLS0tCgozLiAgSWYgYGRmYCBpcyBhIGRhdGEgZnJhbWUsIHdoYXQgY2FuIHlvdSBzYXkgYWJvdXQgYHQoZGYpYCwgYW5kIGB0KHQoZGYpKWA/IAogICAgUGVyZm9ybSBzb21lIGV4cGVyaW1lbnRzLCBtYWtpbmcgc3VyZSB0byB0cnkgZGlmZmVyZW50IGNvbHVtbiB0eXBlcy4KCmBgYHtyfQp0KGRmKQp0KHQoZGYpKQoKZGYyIDwtIGRhdGEuZnJhbWUoeCA9IDE6MywgeSA9IGMoImEiLCAiYiIsICJjIiksIHogPSA0TDo2TCwgc3RyaW5nc0FzRmFjdG9ycyA9IEZBTFNFKQpkZjIKdChkZjIpCnQodChkZjIpKQpgYGAKCkFuc3dlcjogYHQoKWAgY29lcmNlcyB0aGUgdmVjdG9yIHR5cGVzLCBzbyBgdCh0KGRmKSlgIGlzIHRoZSBzYW1lIGFzIGBkZmAgb25seSB3aGVuIGFsbCBjb2x1bW5zIGFyZQp0aGUgc2FtZSB0eXBlLgoKLS0tCgo0LiAgV2hhdCBkb2VzIGBhcy5tYXRyaXgoKWAgZG8gd2hlbiBhcHBsaWVkIHRvIGEgZGF0YSBmcmFtZSB3aXRoIAogICAgY29sdW1ucyBvZiBkaWZmZXJlbnQgdHlwZXM/IEhvdyBkb2VzIGl0IGRpZmZlciBmcm9tIGBkYXRhLm1hdHJpeCgpYD8KCmBgYHtyfQphcy5tYXRyaXgoZGYpCmFzLm1hdHJpeChkZjIpCmRhdGEubWF0cml4KGRmMikKYXMuZGF0YS5mcmFtZShkYXRhLm1hdHJpeChkZjIpKQphcy5kYXRhLmZyYW1lKGRhdGEubWF0cml4KGRhdGEuZnJhbWUoeCA9IDE6MywgeSA9IGMoMCwgMC41LCAxKSwgeiA9IDQ6NikpKQpgYGAKCkFuc3dlcjogYGFzLm1hdHJpeCgpYCBjb2VyY2VzIGFsbCBlbGVtZW50cyB0byB0aGUgc2FtZSB0eXBlLiBgZGF0YS5tYXRyaXgoKWAgY29lcmNlcyBlbGVtZW50cyB0bwplaXRoZXIgaW50ZWdlciAod2hlbiBwb3NzaWJsZSkgb3IgZG91YmxlICh3aGVuIG5vdCkuCgotLS0KCiMgNCBTdWJzZXR0aW5nCgpSJ3Mgc3Vic2V0dGluZyBvcGVyYXRvcnMgYXJlIGZhc3QgYW5kIHBvd2VyZnVsLiBNYXN0ZXJpbmcgdGhlbSBhbGxvd3MgeW91IHRvIHN1Y2NpbmN0bHkgcGVyZm9ybSBjb21wbGV4IG9wZXJhdGlvbnMgaW4gYSB3YXkgdGhhdCBmZXcgb3RoZXIgbGFuZ3VhZ2VzIGNhbiBtYXRjaC4gU3Vic2V0dGluZyBpbiBSIGlzIGVhc3kgdG8gbGVhcm4gYnV0IGhhcmQgdG8gbWFzdGVyIGJlY2F1c2UgeW91IG5lZWQgdG8gaW50ZXJuYWxpc2UgYSBudW1iZXIgb2YgaW50ZXJyZWxhdGVkIGNvbmNlcHRzOgoKKiBUaGVyZSBhcmUgc2l4IHdheXMgdG8gc3Vic2V0IGF0b21pYyB2ZWN0b3JzLgoKKiBUaGVyZSBhcmUgdGhyZWUgc3Vic2V0dGluZyBvcGVyYXRvcnMsIGBbW2AsIGBbYCwgYW5kIGAkYC4KCiogU3Vic2V0dGluZyBvcGVyYXRvcnMgaW50ZXJhY3QgZGlmZmVyZW50bHkgd2l0aCBkaWZmZXJlbnQgdmVjdG9yIAogIHR5cGVzIChlLmcuLCBhdG9taWMgdmVjdG9ycywgbGlzdHMsIGZhY3RvcnMsIG1hdHJpY2VzLCBhbmQgZGF0YSBmcmFtZXMpLgoKKiBTdWJzZXR0aW5nIGNhbiBiZSBjb21iaW5lZCB3aXRoIGFzc2lnbm1lbnQuCgpTdWJzZXR0aW5nIGlzIGEgbmF0dXJhbCBjb21wbGVtZW50IHRvIGBzdHIoKWAuIFdoaWxlIGBzdHIoKWAgc2hvd3MgeW91IGFsbCB0aGUgcGllY2VzIG9mIGFueSBvYmplY3QgKGl0cyBzdHJ1Y3R1cmUpLCBzdWJzZXR0aW5nIGFsbG93cyB5b3UgdG8gcHVsbCBvdXQgdGhlIHBpZWNlcyB0aGF0IHlvdSdyZSBpbnRlcmVzdGVkIGluLiBGb3IgbGFyZ2UsIGNvbXBsZXggb2JqZWN0cywgSSBoaWdobHkgcmVjb21tZW5kIHVzaW5nIHRoZSBpbnRlcmFjdGl2ZSBSU3R1ZGlvIFZpZXdlciwgd2hpY2ggeW91IGNhbiBhY3RpdmF0ZSB3aXRoIGBWaWV3KG15X29iamVjdClgLgoKYGBge3J9CnJtKGxpc3QgPSBscygpKQpgYGAKCiMjIDQuMi42IEV4ZXJjaXNlcwoKMS4gIEZpeCBlYWNoIG9mIHRoZSBmb2xsb3dpbmcgY29tbW9uIGRhdGEgZnJhbWUgc3Vic2V0dGluZyBlcnJvcnM6CgpgYGB7cn0KIyBub2xpbnQgc3RhcnQ6IGNvbW1lbnRlZF9jb2RlX2xpbnRlci4KIyBtdGNhcnNbbXRjYXJzJGN5bCA9IDQsIF0KbXRjYXJzW210Y2FycyRjeWwgPT0gNCwgXQoKIyBtdGNhcnNbLTE6NCwgXQptdGNhcnNbLSgxOjQpLCBdCgojIG10Y2Fyc1ttdGNhcnMkY3lsIDw9IDVdCm10Y2Fyc1ttdGNhcnMkY3lsIDw9IDUsIF0KCiMgbXRjYXJzW210Y2FycyRjeWwgPT0gNCB8IDYsIF0KbXRjYXJzW210Y2FycyRjeWwgPT0gNCB8IG10Y2FycyRjeWwgPT0gNiwgXQojIG5vbGludCBlbmQKYGBgCgpBbnN3ZXI6IGZpeGVkIQoKLS0tCgoyLiAgV2h5IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHlpZWxkIGZpdmUgbWlzc2luZyB2YWx1ZXM/IChIaW50OiB3aHkgaXMgCiAgICBpdCBkaWZmZXJlbnQgZnJvbSBgeFtOQV9yZWFsX11gPykKCmBgYHtyfQp4IDwtIDE6NQp4W05BXQoKeFtOQV9yZWFsX10KeFtUUlVFXQpgYGAKCkFuc3dlcjogTkEgaXMgYSBsb2dpY2FsIGNvbnN0YW50IG9mIGxlbmd0aCAxLgoKLS0tCgozLiAgV2hhdCBkb2VzIGB1cHBlci50cmkoKWAgcmV0dXJuPyBIb3cgZG9lcyBzdWJzZXR0aW5nIGEgbWF0cml4IHdpdGggaXQgCiAgICB3b3JrPyBEbyB3ZSBuZWVkIGFueSBhZGRpdGlvbmFsIHN1YnNldHRpbmcgcnVsZXMgdG8gZGVzY3JpYmUgaXRzIGJlaGF2aW91cj8KCmBgYHtyfQp4IDwtIG91dGVyKDE6NSwgMTo1LCBGVU4gPSAiKiIpCngKeFt1cHBlci50cmkoeCldCmBgYAoKQW5zd2VyOiBgdXBwZXIudHJpKClgIHJldHVybnMgYSBtYXRyaXggb2YgbG9naWNhbHMsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHN1YnNldCB0aGUgdXBwZXIgdHJpYW5nbGUuClRoaXMgaXMgc3Vic2V0dGluZyBieSBtYXRyaXgsIHdoaWNoIGlzIG5ldy4KCi0tLQoKNC4gIFdoeSBkb2VzIGBtdGNhcnNbMToyMF1gIHJldHVybiBhbiBlcnJvcj8gSG93IGRvZXMgaXQgZGlmZmVyIGZyb20gdGhlIAogICAgc2ltaWxhciBgbXRjYXJzWzE6MjAsIF1gPwoKYGBge3J9CnRyeShtdGNhcnNbMToyMF0pCm10Y2Fyc1sxOjIwLCBdCmBgYAoKQW5zd2VyOiBgbXRjYXJzWzE6MjBdYCBzZWxlY3RzIHRoZSBmaXJzdCAyMCBjb2x1bW5zLCBidXQgdGhlcmUgYXJlIG9ubHkgMTEuIGBtdGNhcnNbMToyMCwgXWAgc2VsZWN0cwp0aGUgZmlyc3QgMjAgcm93cyBvZiBgciBucm93KG10Y2FycylgLgoKLS0tCgo1LiAgSW1wbGVtZW50IHlvdXIgb3duIGZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgdGhlIGRpYWdvbmFsIGVudHJpZXMgZnJvbSBhCiAgICBtYXRyaXggKGl0IHNob3VsZCBiZWhhdmUgbGlrZSBgZGlhZyh4KWAgd2hlcmUgYHhgIGlzIGEgbWF0cml4KS4KCmBgYHtyfQptIDwtIG1hdHJpeChuY29sID0gMywgYnlyb3cgPSBUUlVFLCBjKAogIDEsIDQsIDcsCiAgMiwgNSwgOCwKICAzLCA2LCA5CikpCm0KZGlhZyhtKQoKbXlfZGlhZyA8LSBmdW5jdGlvbih4KSB7CiAgZGlhZ19lbGVtZW50IDwtIGZ1bmN0aW9uKG4sIHgpIHsKICAgIHhbbiwgbl0KICB9CiAgdmFwcGx5KHNlcV9sZW4obnJvdyhtKSksIGRpYWdfZWxlbWVudCwgMSwgeCkKfQpteV9kaWFnKG0pCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLgoKLS0tCgo1LiAgV2hhdCBkb2VzIGBkZltpcy5uYShkZildIDwtIDBgIGRvPyBIb3cgZG9lcyBpdCB3b3JrPwoKQW5zd2VyOiBzZXRzIHRoZSBgTkFgIHZhbHVlcyBpbiBgZGZgIHRvIGAwYCwgYnkgZmlyc3Qgc2VsZWN0aW5nIGBOQWAgdmFsdWVzIHRoZW4gYXNzaWduaW5nIGAwYC4KCmBgYHtyfQpkZiA8LSBkYXRhLmZyYW1lKHggPSBjKDEsIDIsIE5BKSwgeSA9IGMoNCwgTkEsIDYpLCB6ID0gYyhOQSwgOCwgOSkpCmRmCmRmW2lzLm5hKGRmKV0gPC0gMApkZgpgYGAKCkNvcnJlY3QhCgotLS0KCiMjIDQuMy41IEV4ZXJjaXNlcwoKMS4gIEJyYWluc3Rvcm0gYXMgbWFueSB3YXlzIGFzIHBvc3NpYmxlIHRvIGV4dHJhY3QgdGhlIHRoaXJkIHZhbHVlIGZyb20gdGhlCiAgICBgY3lsYCB2YXJpYWJsZSBpbiB0aGUgYG10Y2Fyc2AgZGF0YXNldC4KCmBgYHtyfQptdGNhcnMkY3lsWzNdCm10Y2FycyRjeWxbWzNdXQptdGNhcnNbWyJjeWwiXV1bWzNdXQptdGNhcnNbMywgMl0KbXRjYXJzW1szLCAyXV0KbXRjYXJzW1siRGF0c3VuIDcxMCIsICJjeWwiXV0KbXRjYXJzWy1jKDE6MiwgNDozMiksIC1jKDEsIDM6MTEpXQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZSAoc29tZSB2YXJpYXRpb25zIG9taXR0ZWQpLiBUaGVyZSBhcmUgbWFueSBtb3JlLgoKLS0tCgoyLiAgR2l2ZW4gYSBsaW5lYXIgbW9kZWwsIGUuZy4sIGBtb2QgPC0gbG0obXBnIH4gd3QsIGRhdGEgPSBtdGNhcnMpYCwgZXh0cmFjdAogICAgdGhlIHJlc2lkdWFsIGRlZ3JlZXMgb2YgZnJlZWRvbS4gVGhlbiBleHRyYWN0IHRoZSBSIHNxdWFyZWQgZnJvbSB0aGUgbW9kZWwKICAgIHN1bW1hcnkgKGBzdW1tYXJ5KG1vZClgKQoKYGBge3J9Cm1vZCA8LSBsbShtcGcgfiB3dCwgZGF0YSA9IG10Y2FycykKbW9kJGRmLnJlc2lkdWFsCgptb2Rfc3VtIDwtIHN1bW1hcnkobW9kKQptb2Rfc3VtJHIuc3F1YXJlZAoKbW9kX3N1bQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCi0tLQoKIyMgNC41LjkgRXhlcmNpc2VzCgoxLiAgSG93IHdvdWxkIHlvdSByYW5kb21seSBwZXJtdXRlIHRoZSBjb2x1bW5zIG9mIGEgZGF0YSBmcmFtZT8gKFRoaXMgaXMgYW4KICAgIGltcG9ydGFudCB0ZWNobmlxdWUgaW4gcmFuZG9tIGZvcmVzdHMuKSBDYW4geW91IHNpbXVsdGFuZW91c2x5IHBlcm11dGUgCiAgICB0aGUgcm93cyBhbmQgY29sdW1ucyBpbiBvbmUgc3RlcD8KCmBgYHtyfQpkZiA8LSBkYXRhLmZyYW1lKHggPSAxOjUsIHkgPSA1OjEsIHogPSBsZXR0ZXJzWzE6NV0sIHJvdy5uYW1lcyA9IDE6NSkKCmRmWywgc2FtcGxlKG5jb2woZGYpKV0KCmRmW3NhbXBsZShucm93KGRmKSksIHNhbXBsZShuY29sKGRmKSldCmBgYAoKQW5zd2VyOiB1c2luZyBgc2FtcGxlKClgLiBZZXMhCgotLS0KCjIuICBIb3cgd291bGQgeW91IHNlbGVjdCBhIHJhbmRvbSBzYW1wbGUgb2YgYG1gIHJvd3MgZnJvbSBhIGRhdGEgZnJhbWU/IAogICAgV2hhdCBpZiB0aGUgc2FtcGxlIGhhZCB0byBiZSBjb250aWd1b3VzIChpLmUuLCB3aXRoIGFuIGluaXRpYWwgcm93LCBhIAogICAgZmluYWwgcm93LCBhbmQgZXZlcnkgcm93IGluIGJldHdlZW4pPwoKYGBge3J9CnNhbXBsZV9yb3dzIDwtIGZ1bmN0aW9uKGRmLCBtLCBjb250aWd1b3VzID0gRkFMU0UpIHsKICBpZiAobSA+IG5yb3coZGYpKSB7CiAgICBzdG9wKCJzYW1wbGUgc2l6ZSAnIiwgbSwgIicgaXMgbGFyZ2VyIHRoYW4gdGhlIG51bWJlciBvZiByb3dzLCAnIiwgbnJvdyhkZiksICInIikKICB9CiAgaWYgKGNvbnRpZ3VvdXMpIHsKICAgIGZpcnN0X3JvdyA8LSBzYW1wbGUobnJvdyhkZikgLSBtICsgMSwgMSkKICAgIGxhc3Rfcm93IDwtIGZpcnN0X3JvdyArIG0gLSAxCiAgICByZXR1cm4oZGZbZmlyc3Rfcm93Omxhc3Rfcm93LCBdKQogIH0KICBkZltzYW1wbGUobnJvdyhkZiksIG0pLCBdCn0KCnNhbXBsZV9yb3dzKGRmLCAzKQpzYW1wbGVfcm93cyhkZiwgMywgY29udGlndW91cyA9IFRSVUUpCnRyeShzYW1wbGVfcm93cyhkZiwgNikpCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLgoKLS0tCiAgICAKMy4gIEhvdyBjb3VsZCB5b3UgcHV0IHRoZSBjb2x1bW5zIGluIGEgZGF0YSBmcmFtZSBpbiBhbHBoYWJldGljYWwgb3JkZXI/CgpgYGB7cn0KbXRjYXJzW3NvcnQoY29sbmFtZXMobXRjYXJzKSldCmBgYAoKQW5zd2VyOiB1c2luZyBgc29ydChjb2xuYW1lcylgLgoKLS0tCgojIDUgQ29udHJvbCBmbG93CgpUaGVyZSBhcmUgdHdvIHByaW1hcnkgdG9vbHMgb2YgY29udHJvbCBmbG93OiBjaG9pY2VzIGFuZCBsb29wcy4gQ2hvaWNlcywgbGlrZSBgaWZgIHN0YXRlbWVudHMgYW5kIGBzd2l0Y2goKWAgY2FsbHMsIGFsbG93IHlvdSB0byBydW4gZGlmZmVyZW50IGNvZGUgZGVwZW5kaW5nIG9uIHRoZSBpbnB1dC4gTG9vcHMsIGxpa2UgYGZvcmAgYW5kIGB3aGlsZWAsIGFsbG93IHlvdSB0byByZXBlYXRlZGx5IHJ1biBjb2RlLCB0eXBpY2FsbHkgd2l0aCBjaGFuZ2luZyBvcHRpb25zLiBJJ2QgZXhwZWN0IHRoYXQgeW91J3JlIGFscmVhZHkgZmFtaWxpYXIgd2l0aCB0aGUgYmFzaWNzIG9mIHRoZXNlIGZ1bmN0aW9ucyBzbyBJJ2xsIGJyaWVmbHkgY292ZXIgc29tZSB0ZWNobmljYWwgZGV0YWlscyBhbmQgdGhlbiBpbnRyb2R1Y2Ugc29tZSB1c2VmdWwsIGJ1dCBsZXNzZXIga25vd24sIGZlYXR1cmVzLgoKVGhlIGNvbmRpdGlvbiBzeXN0ZW0gKG1lc3NhZ2VzLCB3YXJuaW5ncywgYW5kIGVycm9ycyksIHdoaWNoIHlvdSdsbCBsZWFybiBhYm91dCBpbiBDaGFwdGVyIDgsIGFsc28gcHJvdmlkZXMgbm9uLWxvY2FsIGNvbnRyb2wgZmxvdy4gCgpgYGB7cn0Kcm0obGlzdCA9IGxzKCkpCmBgYAoKIyMgNS4yLjQgRXhlcmNpc2VzCgoxLiAgV2hhdCB0eXBlIG9mIHZlY3RvciBkb2VzIGVhY2ggb2YgdGhlIGZvbGxvd2luZyBjYWxscyB0byBgaWZlbHNlKClgCiAgICByZXR1cm4/IFJlYWQgdGhlIGRvY3VtZW50YXRpb24gYW5kIHdyaXRlIGRvd24gdGhlIHJ1bGVzIGluIHlvdXIgb3duIHdvcmRzLgoKYGBge3J9CmlmZWxzZShUUlVFLCAxLCAibm8iKQp0eXBlb2YoaWZlbHNlKFRSVUUsIDEsICJubyIpKSAjIGRvdWJsZQppZmVsc2UoRkFMU0UsIDEsICJubyIpCnR5cGVvZihpZmVsc2UoRkFMU0UsIDEsICJubyIpKSAjIGNoYXJhY3RlcgppZmVsc2UoTkEsIDEsICJubyIpCnR5cGVvZihpZmVsc2UoTkEsIDEsICJubyIpKSAjIGxvZ2ljYWwKaWZlbHNlKE5VTEwsIDEsICJubyIpCmBgYAoKCkFuc3dlcjoKCi0gaWYgYHRlc3RgIGlzIHRydWUsIHJldHVybiBhIHZlY3RvciBvZiB0aGUgc2FtZSBsZW5ndGggYXMgYHRlc3RgICgxKSBwb3B1bGF0ZWQgd2l0aCAieWVzIiAtIGhlcmUgMQogIGlzIGEgZG91YmxlLCAxTCB3b3VsZCBiZSBpbnRlZ2VyCi0gaWYgYHRlc3RgIGlzIGZhbHNlLCByZXR1cm4gYSB2ZWN0b3Igb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIGB0ZXN0YCAoMSkgcG9wdWxhdGVkIHdpdGggIm5vIiAtIGhlcmUKICAibm8iIGlzIGEgY2hhcmFjdGVyCi0gaWYgYHRlc3RgIGlzIGBOQWAsIHJldHVybiBgTkFgLCBhbmQgaWYgYHRlc3RgIGlzIGBOVUxMYCwgcmV0dXJuIGBsb2dpY2FsKDApYAoKLS0tCgoyLiAgV2h5IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHdvcms/CgpgYGB7cn0KeCA8LSAxOjEwCmlmIChsZW5ndGgoeCkpICJub3QgZW1wdHkiIGVsc2UgImVtcHR5IgoKeCA8LSBudW1lcmljKCkKaWYgKGxlbmd0aCh4KSkgIm5vdCBlbXB0eSIgZWxzZSAiZW1wdHkiCmBgYAoKQW5zd2VyOiBpbiB0aGUgZmlyc3QgZXhhbXBsZSwgYGxlbmd0aCh4KWAgaXMgbm9uemVybywgd2hpY2ggZXZhbHVhdGVzIHRvIGBUUlVFYC4gSW4gdGhlIHNlY29uZApleGFtcGxlLCBgbnVtZXJpYygpYCByZXR1cm5zIGEgdmVjdG9yIG9mIGxlbmd0aCAwICh0aGUgZGVmYXVsdCksIGBsZW5ndGgoeClgIGlzIHplcm8sIHdoaWNoCmV2YWx1YXRlcyB0byBgRkFMU0VgLgoKLS0tCgojIyA1LjMuMyBFeGVyY2lzZXMKCjEuICBXaHkgZG9lcyB0aGlzIGNvZGUgc3VjY2VlZCB3aXRob3V0IGVycm9ycyBvciB3YXJuaW5ncz8gCgpgYGB7cn0KeCA8LSBudW1lcmljKCkgIyB4IGlzIG51bWVyaWMoMCkKb3V0IDwtIHZlY3RvcigibGlzdCIsIGxlbmd0aCh4KSkgIyBvdXQgaXMgbGlzdCgwKQpmb3IgKGkgaW4gMTpsZW5ndGgoeCkpIHsgIyBub2xpbnQ6IHNlcV9saW50ZXIuIGkgaXMgMSwgdGhlbiAwLgogIG91dFtpXSA8LSB4W2ldXjIgIyB3aGVuIGkgPSAxIHhbMV0gaXMgTkEsIHNldHMgb3V0WzFdIHRvIE5BLiB3aGVuIGkgPSAwIG5vdGhpbmcgaGFwcGVucwp9Cm91dApgYGAKCkFuc3dlcjogaW4gYWRkaXRpb24gdG8gbm90ZXMgYWJvdmUsIGBvdXRbMF1gIGFuZCBgeFswXWAgcmV0dXJuIGEgemVyby1sZW5ndGggdmVjdG9yLgoKLS0tCgoyLiAgV2hlbiB0aGUgZm9sbG93aW5nIGNvZGUgaXMgZXZhbHVhdGVkLCB3aGF0IGNhbiB5b3Ugc2F5IGFib3V0IHRoZSAKICAgIHZlY3RvciBiZWluZyBpdGVyYXRlZD8KCmBgYHtyfQp4cyA8LSBjKDEsIDIsIDMpCmZvciAoeCBpbiB4cykgewogIHhzIDwtIGMoeHMsIHggKiAyKQp9CnhzCmBgYAoKQW5zd2VyOiBgeGAgaXRlcmF0ZXMgZnJvbSAxIHRvIDMsIGFuZCBpcyBub3QgYWZmZWN0ZWQgYnkgY2hhbmdlcyB0byBgeHNgIGR1cmluZyB0aGUgbG9vcCwgd2hpbGUgYHhzYAppcyB1cGRhdGVkLgoKLS0tCgozLiAgV2hhdCBkb2VzIHRoZSBmb2xsb3dpbmcgY29kZSB0ZWxsIHlvdSBhYm91dCB3aGVuIHRoZSBpbmRleCBpcyB1cGRhdGVkPwoKYGBge3J9CmZvciAoaSBpbiAxOjMpIHsKICBpIDwtIGkgKiAyCiAgcHJpbnQoaSkKfQpgYGAKCkFuc3dlcjogdGhlIGluZGV4IGlzIHVwZGF0ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBlYWNoIGxvb3AuCgotLS0KCiMgNiBGdW5jdGlvbnMKCklmIHlvdSdyZSByZWFkaW5nIHRoaXMgYm9vaywgeW91J3ZlIHByb2JhYmx5IGFscmVhZHkgY3JlYXRlZCBtYW55IFIgZnVuY3Rpb25zIGFuZCBrbm93IGhvdyB0byB1c2UgdGhlbSB0byByZWR1Y2UgZHVwbGljYXRpb24gaW4geW91ciBjb2RlLiBJbiB0aGlzIGNoYXB0ZXIsIHlvdSdsbCBsZWFybiBob3cgdG8gdHVybiB0aGF0IGluZm9ybWFsLCB3b3JraW5nIGtub3dsZWRnZSBpbnRvIG1vcmUgcmlnb3JvdXMsIHRoZW9yZXRpY2FsIHVuZGVyc3RhbmRpbmcuIEFuZCB3aGlsZSB5b3UnbGwgc2VlIHNvbWUgaW50ZXJlc3RpbmcgdHJpY2tzIGFuZCB0ZWNobmlxdWVzIGFsb25nIHRoZSB3YXksIGtlZXAgaW4gbWluZCB0aGF0IHdoYXQgeW91J2xsIGxlYXJuIGhlcmUgd2lsbCBiZSBpbXBvcnRhbnQgZm9yIHVuZGVyc3RhbmRpbmcgdGhlIG1vcmUgYWR2YW5jZWQgdG9waWNzIGRpc2N1c3NlZCBsYXRlciBpbiB0aGUgYm9vay4KCmBgYHtyfQpybShsaXN0ID0gbHMoKSkKYGBgCgojIyA2IFF1aXoKCkFuc3dlciB0aGUgZm9sbG93aW5nIHF1ZXN0aW9ucyB0byBzZWUgaWYgeW91IGNhbiBzYWZlbHkgc2tpcCB0aGlzIGNoYXB0ZXIuIFlvdSBjYW4gZmluZCB0aGUgYW5zd2VycyBpbiBTZWN0aW9uIFxAcmVmKGZ1bmN0aW9uLWFuc3dlcnMpLgoKMS4gIFdoYXQgYXJlIHRoZSB0aHJlZSBjb21wb25lbnRzIG9mIGEgZnVuY3Rpb24/IGE6IGFyZ3VtZW50cywgY29kZSwgcmV0dXJuIHZhbHVlIFtib2R5LCBhcmd1bWVudHMsCiAgICBlbnZpcm9ubWVudF0KCjIuICBXaGF0IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHJldHVybj8gYTogMTEgW2NvcnJlY3QhXQoKYGBge3J9CnggPC0gMTAKZjEgPC0gZnVuY3Rpb24oeCkgewogIGZ1bmN0aW9uKCkgewogICAgeCArIDEwCiAgfQp9CmYxKDEpKCkKYGBgCgozLiAgSG93IHdvdWxkIHlvdSB1c3VhbGx5IHdyaXRlIHRoaXMgY29kZT8gYTogYDEgKyAyICogM2AgW2NvcnJlY3QhIC4uLiBgMSArICgyICogMylgXQoKYGBge3IsIGV2YWwgPSBGQUxTRX0KYCtgKDEsIGAqYCgyLCAzKSkKYGBgCgo0LiAgSG93IGNvdWxkIHlvdSBtYWtlIHRoaXMgY2FsbCBlYXNpZXIgdG8gcmVhZD8gYG1lYW4oYygxOjEwLCBOQSksIG5hLnJtID0gVFJVRSlgIFtjb3JyZWN0IV0KCmBgYHtyLCBldmFsID0gRkFMU0V9Cm1lYW4oLCBUUlVFLCB4ID0gYygxOjEwLCBOQSkpICMgbm9saW50OiBtaXNzaW5nX2FyZ3VtZW50X2xpbnRlci4KYGBgCgo1LiAgRG9lcyB0aGUgZm9sbG93aW5nIGNvZGUgdGhyb3cgYW4gZXJyb3Igd2hlbiBleGVjdXRlZD8gV2h5IG9yIHdoeSBub3Q/IGE6IG5vLCBkdWUgdG8gbGF6eQogICAgZXZhbHVhdGlvbiwgdGhlIGBzdG9wKClgIGlzIG5ldmVyIHJ1biBbY29ycmVjdCEgLi4uIHNlY29uZCBhcmd1bWVudCBpcyBuZXZlciB1c2VkXQoKYGBge3J9CmYyIDwtIGZ1bmN0aW9uKGEsIGIpIHsKICBhICogMTAKfQpmMigxMCwgc3RvcCgiVGhpcyBpcyBhbiBlcnJvciEiKSkKYGBgCgo2LiAgV2hhdCBpcyBhbiBpbmZpeCBmdW5jdGlvbj8gSG93IGRvIHlvdSB3cml0ZSBpdD8gV2hhdCdzIGEgcmVwbGFjZW1lbnQgCiAgICBmdW5jdGlvbj8gSG93IGRvIHlvdSB3cml0ZSBpdD8gYTogYGZ1bmN0aW9uKHgpIHhgLiA/Pz8gW3NlZSA2LjguMyBhbmQgNi44LjRdCgo3LiAgSG93IGRvIHlvdSBlbnN1cmUgdGhhdCBjbGVhbnVwIGFjdGlvbiBvY2N1cnMgcmVnYXJkbGVzcyBvZiBob3cgYSBmdW5jdGlvbiAKICAgIGV4aXRzPyBhOiA/Pz8gW2Bvbi5leGl0KClgXQoKIyMgNi4yLjUgRXhlcmNpc2VzCgoxLiBHaXZlbiBhIG5hbWUsIGxpa2UgYCJtZWFuImAsIGBtYXRjaC5mdW4oKWAgbGV0cyB5b3UgZmluZCBhIGZ1bmN0aW9uLiAKICAgR2l2ZW4gYSBmdW5jdGlvbiwgY2FuIHlvdSBmaW5kIGl0cyBuYW1lPyBXaHkgZG9lc24ndCB0aGF0IG1ha2Ugc2Vuc2UgaW4gUj8KCkFuc3dlcjogYSBmdW5jdGlvbiBpcyBhbiBvYmplY3QgYW5kIGNvdWxkIGhhdmUgbXVsdGlwbGUgbmFtZXMgcG9pbnRpbmcgdG8gaXQuCgotLS0KCjIuICBJdCdzIHBvc3NpYmxlIChhbHRob3VnaCB0eXBpY2FsbHkgbm90IHVzZWZ1bCkgdG8gY2FsbCBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uCiAgICBXaGljaCBvZiB0aGUgdHdvIGFwcHJvYWNoZXMgYmVsb3cgaXMgY29ycmVjdD8gV2h5PwoKYGBge3IsIHJlc3VsdCA9ICJoaWRlIn0KZnVuY3Rpb24oeCkgMygpCihmdW5jdGlvbih4KSAzKSgpCmBgYAoKQW5zd2VyOiBUaGUgc2Vjb25kIGlzIGNvcnJlY3QsIGFzIHRoZSBmaXJzdCBpcyB0aGUgZm9ybSBvZiBkZWZpbmluZyBhIGZ1bmN0aW9uLgoKLS0tCgozLiBBIGdvb2QgcnVsZSBvZiB0aHVtYiBpcyB0aGF0IGFuIGFub255bW91cyBmdW5jdGlvbiBzaG91bGQgZml0IG9uIG9uZSBsaW5lIAogICBhbmQgc2hvdWxkbid0IG5lZWQgdG8gdXNlIGB7fWAuIFJldmlldyB5b3VyIGNvZGUuIFdoZXJlIGNvdWxkIHlvdSBoYXZlIAogICB1c2VkIGFuIGFub255bW91cyBmdW5jdGlvbiBpbnN0ZWFkIG9mIGEgbmFtZWQgZnVuY3Rpb24/IFdoZXJlIHNob3VsZCB5b3UgCiAgIGhhdmUgdXNlZCBhIG5hbWVkIGZ1bmN0aW9uIGluc3RlYWQgb2YgYW4gYW5vbnltb3VzIGZ1bmN0aW9uPwoKQW5zd2VyOiBpbiBgcmRldjo6YnVpbGRfYW5hbHlzaXNfc2l0ZSgpYCwgYGFuYWx5c2lzX21lbnVfaXRlbSgpYCBpcyBwcm9wZXJseSB3cml0dGVuIGFzIGEgbmFtZWQKZnVuY3Rpb24sIHdoZXJlIGBnZXRfY29tcG9uZW50KClgIGNvdWxkIGJlIHdyaXR0ZW4gYXMgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLCB3aXRoIGBkaXJfY2hlY2tfY29weSgpYAphbmQgYGRpcl9jaGVja19kZWxldGUoKWAgcG90ZW50aWFsbHkgZWl0aGVyLgoKLS0tCgo0LiAgV2hhdCBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHRlbGwgaWYgYW4gb2JqZWN0IGlzIGEgZnVuY3Rpb24/IFdoYXQgZnVuY3Rpb24KICAgIGFsbG93cyB5b3UgdG8gdGVsbCBpZiBhIGZ1bmN0aW9uIGlzIGEgcHJpbWl0aXZlIGZ1bmN0aW9uPwoKQW5zd2VyOiBgaXMuZnVuY3Rpb24oKWAgYW5kIGBpcy5wcmltaXRpdmUoKWAuCgotLS0KCjUuICBUaGlzIGNvZGUgbWFrZXMgYSBsaXN0IG9mIGFsbCBmdW5jdGlvbnMgaW4gdGhlIGJhc2UgcGFja2FnZS4gCgpgYGB7cn0Kb2JqcyA8LSBtZ2V0KGxzKCJwYWNrYWdlOmJhc2UiLCBhbGwgPSBUUlVFKSwgaW5oZXJpdHMgPSBUUlVFKQpmdW5zIDwtIEZpbHRlcihpcy5mdW5jdGlvbiwgb2JqcykKYGBgCgpVc2UgaXQgdG8gYW5zd2VyIHRoZSBmb2xsb3dpbmcgcXVlc3Rpb25zOgoKYS4gV2hpY2ggYmFzZSBmdW5jdGlvbiBoYXMgdGhlIG1vc3QgYXJndW1lbnRzPwphLiBIb3cgbWFueSBiYXNlIGZ1bmN0aW9ucyBoYXZlIG5vIGFyZ3VtZW50cz8gV2hhdCdzIHNwZWNpYWwgYWJvdXQgdGhvc2UKICAgZnVuY3Rpb25zPwphLiBIb3cgY291bGQgeW91IGFkYXB0IHRoZSBjb2RlIHRvIGZpbmQgYWxsIHByaW1pdGl2ZSBmdW5jdGlvbnM/CgpgYGB7cn0KZnVuX2FyZ3MgPC0gZGF0YS5mcmFtZSgKICBuYW1lID0gbmFtZXMoZnVucyksCiAgYXJncyA9IHVubmFtZSh2YXBwbHkoZnVucywgZnVuY3Rpb24oeCkgbGVuZ3RoKGZvcm1hbHMoeCkpLCAxTCkpCikKaGVhZChmdW5fYXJnc1tvcmRlcihmdW5fYXJncyRhcmdzLCBkZWNyZWFzaW5nID0gVFJVRSksIF0sIDEwKQpmdW5fYXJnc1tmdW5fYXJncyRhcmdzID09IDAsIF0KIyBjaGVjayBpZiBhbGwgZnVuY3Rpb25zIHdpdGggMCBhcmd1bWVudHMgYXJlIHByaW1pdGl2ZQpmdW5fYXJnczIgPC0gZGF0YS5mcmFtZSgKICBuYW1lID0gbmFtZXMoZnVucyksCiAgYXJncyA9IHVubmFtZSh2YXBwbHkoZnVucywgZnVuY3Rpb24oeCkgbGVuZ3RoKGZvcm1hbHMoeCkpLCAxTCkpLAogIHByaW0gPSB1bm5hbWUodmFwcGx5KGZ1bnMsIGlzLnByaW1pdGl2ZSwgVFJVRSkpCikKZnVuX2FyZ3MyW2Z1bl9hcmdzMiRhcmdzID09IDAsIF0KYGBgCgpBbnN3ZXJzOgoKYS4gYHNjYW4oKWAgaGFzIHRoZSBtb3N0IGFyZ3VtZW50cywgMjIKYS4gbW9zdCAoYnV0IG5vdCBhbGwpIGFyZSBwcmltaXRpdmUgZnVuY3Rpb25zICgyMDQgb2YgMjU0KQphLiB0aGUgYGxzKClgIGluIHRoZSBvcmlnaW5hbCBjb2RlIGNvdWxkIGJlIGV4cGFuZGVkIHRvIHNlYXJjaCBhbGwgcGFja2FnZXMKCi0tLQoKNi4gV2hhdCBhcmUgdGhlIHRocmVlIGltcG9ydGFudCBjb21wb25lbnRzIG9mIGEgZnVuY3Rpb24/CgpBbnN3ZXI6IHRoZSBgZm9ybWFscygpYCwgYGJvZHkoKWAgYW5kIGBlbnZpcm9ubWVudCgpYC4KCi0tLQoKNy4gV2hlbiBkb2VzIHByaW50aW5nIGEgZnVuY3Rpb24gbm90IHNob3cgdGhlIGVudmlyb25tZW50IGl0IHdhcyBjcmVhdGVkIGluPwoKQW5zd2VyOiB3aGVuIGl0IGlzIGNyZWF0ZWQgaW4gdGhlIGdsb2JhbCBlbnZpcm9ubWVudC4KCi0tLQoKIyMgNi40LjUgRXhlcmNpc2VzCgoxLiBXaGF0IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHJldHVybj8gV2h5PyBEZXNjcmliZSBob3cgZWFjaCBvZiB0aGUgdGhyZWUKICAgYGNgJ3MgaXMgaW50ZXJwcmV0ZWQuCgpgYGB7cn0KYyA8LSAxMApjKGMgPSBjKQpgYGAKCkFuc3dlcjogYSBuYW1lZCB2ZWN0b3IsIGBjIDEwYC4gVGhlIGZpcnN0IGFuZCBmaW5hbCBjIGlzIGEgdmFyaWFibGUuIFRoZSBzZWNvbmQgYyBpcyBhIGZ1bmN0aW9uCm5hbWUuIHRoZSB0aGlyZCBjIGlzIGEgbmFtZS4KCi0tLQoKMi4gV2hhdCBhcmUgdGhlIGZvdXIgcHJpbmNpcGxlcyB0aGF0IGdvdmVybiBob3cgUiBsb29rcyBmb3IgdmFsdWVzPwoKQW5zd2VyOiBuYW1lIG1hc2tpbmcsIGZ1bmN0aW9ucyB2ZXJzdXMgdmFyaWFibGVzLCBhIGZyZXNoIHN0YXJ0LCBkeW5hbWljIGxvb2t1cC4KCi0tLQoKMy4gV2hhdCBkb2VzIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gcmV0dXJuPyBNYWtlIGEgcHJlZGljdGlvbiBiZWZvcmUgCiAgIHJ1bm5pbmcgdGhlIGNvZGUgeW91cnNlbGYuCgpgYGB7cn0KZiA8LSBmdW5jdGlvbih4KSB7CiAgZiA8LSBmdW5jdGlvbih4KSB7ICMgcmV0dXJuIHZhbHVlIG9mIHRoaXMgaXMgMTAxCiAgICBmIDwtIGZ1bmN0aW9uKCkgewogICAgICB4XjIKICAgIH0KICAgIGYoKSArIDEKICB9CiAgZih4KSAqIDIKfQpmKDEwKQpgYGAKCkFuc3dlcjogMjAyLiBDb3JyZWN0IQoKLS0tCgojIyA2LjUuNCBFeGVyY2lzZXMKCjEuICBXaGF0IGltcG9ydGFudCBwcm9wZXJ0eSBvZiBgJiZgIG1ha2VzIGB4X29rKClgIHdvcms/CgpgYGB7cn0KeF9vayA8LSBmdW5jdGlvbih4KSB7CiAgIWlzLm51bGwoeCkgJiYgbGVuZ3RoKHgpID09IDEgJiYgeCA+IDAKfQoKeF9vayhOVUxMKQp4X29rKDEpCnhfb2soMTozKQpgYGAKCkFuc3dlcjogRnJvbSB0aGUgYCYmYCBkb2NzLCAiVGhlIGxvbmdlciBmb3JtcyBldmFsdWF0ZXMgbGVmdCB0byByaWdodCwgcHJvY2VlZGluZyBvbmx5IHVudGlsIHRoZQpyZXN1bHQgaXMgZGV0ZXJtaW5lZC4iCgpXaGF0IGlzIGRpZmZlcmVudCB3aXRoIHRoaXMgY29kZT8gV2h5IGlzIHRoaXMgYmVoYXZpb3VyIHVuZGVzaXJhYmxlIGhlcmU/CgpgYGB7cn0KeF9vayA8LSBmdW5jdGlvbih4KSB7CiAgIWlzLm51bGwoeCkgJiBsZW5ndGgoeCkgPT0gMSAmIHggPiAwCn0KCnhfb2soTlVMTCkKeF9vaygxKQp4X29rKDE6MykKYGBgCgpBbnN3ZXI6ICJUaGUgc2hvcnRlciBmb3JtcyBwZXJmb3JtcyBlbGVtZW50d2lzZSBjb21wYXJpc29ucyBpbiBtdWNoIHRoZSBzYW1lIHdheSBhcyBhcml0aG1ldGljCm9wZXJhdG9ycy4iIFRoaXMgaXMgdW5kZXNpcmFibGUgYmVjYXVzZSB0aGUgaW50ZW50IG9mIHRoZSBmdW5jdGlvbiBpcyB0byByZXR1cm4gYFRSVUVgIG9yIGBGQUxTRWAuCgotLS0KCjIuICBXaGF0IGRvZXMgdGhpcyBmdW5jdGlvbiByZXR1cm4/IFdoeT8gV2hpY2ggcHJpbmNpcGxlIGRvZXMgaXQgaWxsdXN0cmF0ZT8KCmBgYHtyfQpmMiA8LSBmdW5jdGlvbih4ID0geikgewogIHogPC0gMTAwCiAgeAp9CmYyKCkKYGBgCgpBbnN3ZXI6IDEwMCwgbGF6eSBldmFsdWF0aW9uLiBgeCA9IHpgIGlzbid0IGV2YWx1YXRlZCB1bnRpbCBgeGAuCgotLS0KCjMuICBXaGF0IGRvZXMgdGhpcyBmdW5jdGlvbiByZXR1cm4/IFdoeT8gV2hpY2ggcHJpbmNpcGxlIGRvZXMgaXQgaWxsdXN0cmF0ZT8KCmBgYHtyfQp5IDwtIDEwCiMgc3R5bGVyOiBvZmYKZjEgPC0gZnVuY3Rpb24oeCA9IHt5IDwtIDE7IDJ9LCB5ID0gMCkgeyAjIG5vbGludCBicmFjZV9saW50ZXIsIHNlbWljb2xvbl9saW50ZXIuCiAgIyBzdHlsZXI6IG9uCiAgYyh4LCB5KQp9CmYxKCkKeQpgYGAKCkFuc3dlcjogYGMoMiwgMSlgLiBkZWZhdWx0IGFyZ3VtZW50cy4KCi0tLQoKNC4gIEluIGBoaXN0KClgLCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgeGxpbWAgaXMgYHJhbmdlKGJyZWFrcylgLCB0aGUgZGVmYXVsdCAKICAgIHZhbHVlIGZvciBgYnJlYWtzYCBpcyBgIlN0dXJnZXMiYCwgYW5kCgpgYGB7cn0KcmFuZ2UoIlN0dXJnZXMiKQpgYGAKCkV4cGxhaW4gaG93IGBoaXN0KClgIHdvcmtzIHRvIGdldCBhIGNvcnJlY3QgYHhsaW1gIHZhbHVlLgoKQW5zd2VyOiBmcm9tIHRoZSBkb2NzLCAiTm90ZSB0aGF0IGB4bGltYCBpcyAqbm90KiB1c2VkIHRvIGRlZmluZSB0aGUgaGlzdG9ncmFtIChicmVha3MpLCBidXQgb25seQpmb3IgcGxvdHRpbmcgKHdoZW4gYHBsb3QgPSBUUlVFYCkuIiBTbywgdGhlIGJyZWFrcG9pbnRzIGFyZSBjYWxjdWxhdGVkIHdoZW4gdGhlIG9iamVjdCBpcyBjcmVhdGVkLAphbmQgYHhsaW1gIGlzIGNhbGN1bGF0ZWQgd2hlbiB0aGUgaGlzdG9ncmFtIGlzIHBsb3R0ZWQsIGluIHRoZSBzZWNvbmQgc3RlcC4KCi0tLQogICAgCjUuICBFeHBsYWluIHdoeSB0aGlzIGZ1bmN0aW9uIHdvcmtzLiBXaHkgaXMgaXQgY29uZnVzaW5nPwoKYGBge3J9CnNob3dfdGltZSA8LSBmdW5jdGlvbih4ID0gc3RvcCgiRXJyb3IhIikpIHsKICBzdG9wIDwtIGZ1bmN0aW9uKC4uLikgU3lzLnRpbWUoKQogIHByaW50KHgpCn0Kc2hvd190aW1lKCkKYGBgCgpBbnN3ZXI6IGBzdG9wYCBpcyByZWRlZmluZWQgYmVmb3JlIGB4YCBpcyBldmFsdWF0ZWQuIFRoaXMgaXMgYSBjb25mdXNpbmcgdXNlIG9mIGxhenkgZXZhbHVhdGlvbi4KCi0tLQoKNi4gIEhvdyBtYW55IGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgd2hlbiBjYWxsaW5nIGBsaWJyYXJ5KClgPwoKQW5zd2VyOiB6ZXJvLiBgbGlicmFyeSgpYCB1c2VzIGBtaXNzaW5nKClgIHRvIHJldHVybiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgcGFja2FnZXMgaWYgdGhlcmUgYXJlIG5vCmFyZ3VtZW50cy4KCi0tLQoKIyMgNi42LjEgRXhlcmNpc2VzCgoxLiAgRXhwbGFpbiB0aGUgZm9sbG93aW5nIHJlc3VsdHM6CgpgYGB7cn0Kc3VtKDEsIDIsIDMpCm1lYW4oMSwgMiwgMykKCnN1bSgxLCAyLCAzLCBuYS5vbWl0ID0gVFJVRSkKbWVhbigxLCAyLCAzLCBuYS5vbWl0ID0gVFJVRSkKYGBgCgpBbnN3ZXI6CgotICJgc3VtKClgIHJldHVybnMgdGhlIHN1bSBvZiBhbGwgdGhlIHZhbHVlcyBwcmVzZW50IGluIGl0cyBhcmd1bWVudHMuIiBUaGUgZmlyc3QgZXhhbXBsZSBpcwogIHN0cmFpZ2h0Zm9yd2FyZC4gSW4gdGhlIHNlY29uZCBzdW0gZXhhbXBsZSwgYG5hLm9taXRgIGlzbid0IGEgdmFsaWQgYXJndW1lbnQgKGBuYS5ybWAgaXMpLCBzbyB0aGUKICBgVFJVRWAgdmFsdWUgaXMgcGFzc2VkIHRvIGAuLi5gLCBjb2VyY2VkIHRvIDEsIGFuZCBpbmNsdWRlZCBpbiB0aGUgc3VtLgotIGBtZWFuKClgIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciwgYW5kIHBhc3NlcyBvbiByZW1haW5pbmcgYXJndW1lbnRzIHRvIGAuLi5gLiBJbiBib3RoIGNhc2VzLCB0aGUKICBhcmd1bWVudHMgYWZ0ZXIgdGhlIGAxYCBhcmUgc2lsZW50bHkgZHJvcHBlZC4gVGhlIGNvcnJlY3QgZm9ybSB3b3VsZCBiZSBgbWVhbihjKDEsIDIsIDMpKWAuCgotLS0KCjIuICBFeHBsYWluIGhvdyB0byBmaW5kIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgbmFtZWQgYXJndW1lbnRzIGluIHRoZSAKICAgIGZvbGxvd2luZyBmdW5jdGlvbiBjYWxsOgoKPCEtLSBUT0RPOiBidWdmaXg6IHRoZSBmaWd1cmUgYmVsb3cgcmVuZGVycyBpbmNvcnJlY3RseSwKICAgICBwb3NzaWJseSBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL3JzdHVkaW8vcnN0dWRpby9pc3N1ZXMvNDUyMQogICAgIHNlZSBhbHNvOiBodHRwczovL2dpdGh1Yi5jb20vaGFkbGV5L2Fkdi1yL2Jsb2IvbWFzdGVyL2NvbW1vbi5SCiAgICAgYW5kOiBodHRwczovL3lpaHVpLm9yZy9rbml0ci9vcHRpb25zLyNwbG90cwogICAgIHdvcmthcm91bmQ6IHVzZSB7ciwgZmlnLmFzcCA9IDF9LgogICAgIHtyLCBmaWcuYXNwID0gMSwgZmlnLndpZHRoID0gM30gbG9va3MgY29ycmVjdCBpbiBSU3R1ZGlvLCBidXQgZG9lc24ndCByZW5kZXIgcHJvcGVybHkgZm9yCiAgICAgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpLiB7ciwgZmlnLmFzcCA9IDF9IHdvcmtzIHdpdGggYnVpbGRfYW5hbHlzaXNfc2l0ZSgpIGJ1dCBpcyBub3Qgc2l6ZWQKICAgICBwcm9wZXJseSBpbiBSU3R1ZGlvLiB7ciwgZmlnLmFzcCA9IDF9IGlzIHRoZSBiZXN0IG9wdGlvbiBmb3Igbm93LgogIC0tPgoKYGBge3IsIHNtYWxsX21hciA9IFRSVUUsIGZpZy5hc3AgPSAxfQpwbG90KDE6MTAsIGNvbCA9ICJyZWQiLCBwY2ggPSAyMCwgeGxhYiA9ICJ4IiwgY29sLmxhYiA9ICJibHVlIikKYGBgCgpBbnN3ZXI6IGluIG90aGVyIGZ1bmN0aW9ucywgc3BlY2lmaWNhbGx5IGBwYXIoKWAgYW5kIGBwbG90LmRlZmF1bHQoKWAuCgotLS0KCjMuICBXaHkgZG9lcyBgcGxvdCgxOjEwLCBjb2wgPSAicmVkIilgIG9ubHkgY29sb3VyIHRoZSBwb2ludHMsIG5vdCB0aGUgYXhlcyAKICAgIG9yIGxhYmVscz8gUmVhZCB0aGUgc291cmNlIGNvZGUgb2YgYHBsb3QuZGVmYXVsdCgpYCB0byBmaW5kIG91dC4KCmBgYHIKbG9jYWxBeGlzIDwtIGZ1bmN0aW9uKC4uLiwgY29sLCBiZywgcGNoLCBjZXgsIGx0eSwgbHdkKSBBeGlzKC4uLikKbG9jYWxCb3ggPC0gZnVuY3Rpb24oLi4uLCBjb2wsIGJnLCBwY2gsIGNleCwgbHR5LCBsd2QpIGJveCguLi4pCmxvY2FsV2luZG93IDwtIGZ1bmN0aW9uKC4uLiwgY29sLCBiZywgcGNoLCBjZXgsIGx0eSwgbHdkKSBwbG90LndpbmRvdyguLi4pCmxvY2FsVGl0bGUgPC0gZnVuY3Rpb24oLi4uLCBjb2wsIGJnLCBwY2gsIGNleCwgbHR5LCBsd2QpIHRpdGxlKC4uLikKYGBgCgpBbnN3ZXI6IGBwbG90LmRlZmF1bHQoKWAgZGlzY2FyZHMgYGNvbGAgYW5kIHNldmVyYWwgb3RoZXIgYXJndW1lbnRzIHdoZW4gY2FsbGluZyBgQXhpcygpYCwgYGJveCgpYCwKYHBsb3Qud2luZG93KClgLCBhbmQgYHRpdGxlKClgLgoKLS0tCgojIyA2LjcuNSBFeGVyY2lzZXMKCjEuICBXaGF0IGRvZXMgYGxvYWQoKWAgcmV0dXJuPyBXaHkgZG9uJ3QgeW91IG5vcm1hbGx5IHNlZSB0aGVzZSB2YWx1ZXM/CgpBbnN3ZXI6IGZyb20gdGhlIGRvY3MsIGBsb2FkKClgIHJldHVybnMgIkEgY2hhcmFjdGVyIHZlY3RvciBvZiB0aGUgbmFtZXMgb2Ygb2JqZWN0cyBjcmVhdGVkLAppbnZpc2libHkuIgoKLS0tCgoyLiAgV2hhdCBkb2VzIGB3cml0ZS50YWJsZSgpYCByZXR1cm4/IFdoYXQgd291bGQgYmUgbW9yZSB1c2VmdWw/CgpBbnN3ZXI6IGl0IHJldHVybnMgYGludmlzaWJsZShOVUxMKWAuIFJldHVybmluZyB0aGUgd3JpdHRlbiB0YWJsZSBvciB0aGUgYXJndW1lbnQgYHhgIHdvdWxkIGJlIG1vcmUKdXNlZnVsLgoKLS0tCgozLiAgSG93IGRvZXMgdGhlIGBjaGRpcmAgcGFyYW1ldGVyIG9mIGBzb3VyY2UoKWAgY29tcGFyZSB0byBgd2l0aF9kaXIoKWA/IFdoeSAKICAgIG1pZ2h0IHlvdSBwcmVmZXIgb25lIHRvIHRoZSBvdGhlcj8KCkFuc3dlcjogYm90aCB0ZW1wb3JhcmlseSBjaGFuZ2UgdGhlIHdvcmtpbmcgZGlyZWN0b3J5LiBgY2hkaXJgIGlzIHByZWZlcmFibGUgc2luY2UgdGhpcyBpcyBleHBlY3RlZApiZWhhdmlvciBmb3IgdGhlIGZ1bmN0aW9uLCB1bmxlc3MgeW91IG5lZWQgdG8gc2V0IGEgd29ya2luZyBkaXJlY3Rvcnkgb3RoZXIgdGhhbiB0aGUgZGlyZWN0b3J5CmNvbnRhaW5pbmcgYGZpbGVgLgoKLS0tCgo0LiAgV3JpdGUgYSBmdW5jdGlvbiB0aGF0IG9wZW5zIGEgZ3JhcGhpY3MgZGV2aWNlLCBydW5zIHRoZSBzdXBwbGllZCBjb2RlLCBhbmQgCiAgICBjbG9zZXMgdGhlIGdyYXBoaWNzIGRldmljZSAoYWx3YXlzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSAKICAgIHBsb3R0aW5nIGNvZGUgd29ya3MpLgoKYGBge3J9CndpdGhfcG5nIDwtIGZ1bmN0aW9uKGNvZGUsIC4uLikgewogIHBuZyguLi4pCiAgb24uZXhpdChkZXYub2ZmKCksIGFkZCA9IFRSVUUsIGFmdGVyID0gVFJVRSkKICBmb3JjZShjb2RlKQp9Cgp3aXRoX3BuZygKICBwbG90KDE6MTApLAogIGZpbGVuYW1lID0gInJlbmRlcmVkL3dpdGhwbmctZXhhbXBsZS5wbmciLAogICMgdXNlIDMgdGltZXMgZGVmYXVsdCByZXNvbHV0aW9uIHdoaWNoIGlzIGNsb3NlIHRvIHJldGluYSBkaXNwbGF5IHBwaSAoMjE4LTI1NCBkZXBlbmRpbmcgb24gbW9kZWwpCiAgIyBodHRwczovL3N1cHBvcnQuYXBwbGUuY29tL2VuLXVzL0hUMjAyNDcxCiAgd2lkdGggPSA0ODAgKiAzLCBoZWlnaHQgPSA0ODAgKiAzLCByZXMgPSA3MiAqIDMKKQpgYGAKCiFbd2l0aF9wbmcgb3V0cHV0XShyZW5kZXJlZC93aXRocG5nLWV4YW1wbGUucG5nKQoKQW5zd2VyOiBjb2RlIGV4YW1wbGUgYWJvdmUuCgotLS0KCjUuICBXZSBjYW4gdXNlIGBvbi5leGl0KClgIHRvIGltcGxlbWVudCBhIHNpbXBsZSB2ZXJzaW9uIG9mIGBjYXB0dXJlLm91dHB1dCgpYC4KCmBgYHtyLCBldmFsID0gZ2V0UnZlcnNpb24oKSA+PSAiMy41In0KIyBub2xpbnQgc3RhcnQ6IG9iamVjdF9uYW1lX2xpbnRlciwgdW5kZXNpcmFibGVfZnVuY3Rpb25fbGludGVyLgpjYXB0dXJlLm91dHB1dDIgPC0gZnVuY3Rpb24oY29kZSkgewogIHRlbXAgPC0gdGVtcGZpbGUoKQogIG9uLmV4aXQoZmlsZS5yZW1vdmUodGVtcCksIGFkZCA9IFRSVUUsIGFmdGVyID0gVFJVRSkKICBzaW5rKHRlbXApCiAgb24uZXhpdChzaW5rKCksIGFkZCA9IFRSVUUsIGFmdGVyID0gVFJVRSkKICBmb3JjZShjb2RlKQogIHJlYWRMaW5lcyh0ZW1wKQp9CiMgbm9saW50IGVuZApjYXB0dXJlLm91dHB1dDIoY2F0KCJhIiwgImIiLCAiYyIsIHNlcCA9ICJcbiIpKQpgYGAKCkNvbXBhcmUgYGNhcHR1cmUub3V0cHV0KClgIHRvIGBjYXB0dXJlLm91dHB1dDIoKWAuIEhvdyBkbyB0aGUgZnVuY3Rpb25zIApkaWZmZXI/IFdoYXQgZmVhdHVyZXMgaGF2ZSBJIHJlbW92ZWQgdG8gbWFrZSB0aGUga2V5IGlkZWFzIGVhc2llciB0byBzZWU/IApIb3cgaGF2ZSBJIHJld3JpdHRlbiB0aGUga2V5IGlkZWFzIHNvIHRoZXkncmUgZWFzaWVyIHRvIHVuZGVyc3RhbmQ/CgpBbnN3ZXI6IGBjYXB0dXJlLm91dHB1dDIoKWAgaGFzIGZld2VyIGZlYXR1cmVzIGFuZCB1c2VzIHR3byBzZXBhcmF0ZSBjYWxscyB0byBgb24uZXhpdCgpYC4gSXQgc2ltcGx5CnJldHVybnMgdGhlIG91dHB1dCAoYnkgbGluZSkgZnJvbSB0aGUgZXhlY3V0ZWQgY29kZSwgYW5kIGhpZ2hsaWdodHMgdGhlIGtleSBpZGVhLCB1c2luZyBgc2luaygpYCB0bwpjYXB0dXJlIG91dHB1dCB0byBhIHRlbXBvcmFyeSBmaWxlLgoKLS0tCgojIyA2LjguNiBFeGVyY2lzZXMKCjEuIFJld3JpdGUgdGhlIGZvbGxvd2luZyBjb2RlIHNuaXBwZXRzIGludG8gcHJlZml4IGZvcm06CgpgYGB7cn0KMSArIDIgKyAzCmArYChgK2AoMSwgMiksIDMpCgoxICsgKDIgKyAzKQpgK2AoMSwgYCtgKDIsIDMpKQoKZnhuIDwtIGZ1bmN0aW9uKHgsIG4pIGlmIChsZW5ndGgoeCkgPD0gNSkgeFtbNV1dIGVsc2UgeFtbbl1dCmZ4bigxOjUsIDIpCmZ4bigxOjEwLCAyKQoKZnhuMiA8LSBmdW5jdGlvbih4LCBuKSBgaWZgKGA8PWAobGVuZ3RoKHgpLCA1KSwgYFtbYCh4LCA1KSwgYFtbYCh4LCBuKSkKZnhuMigxOjUsIDIpCmZ4bjIoMToxMCwgMikKYGBgCgpBbnN3ZXI6IGlubGluZSBhYm92ZS4KCi0tLQoKMi4gIENsYXJpZnkgdGhlIGZvbGxvd2luZyBsaXN0IG9mIG9kZCBmdW5jdGlvbiBjYWxsczoKCmBgYHtyLCBldmFsID0gRkFMU0V9CnggPC0gc2FtcGxlKHJlcGxhY2UgPSBUUlVFLCAyMCwgeCA9IGMoMToxMCwgTkEpKQp5IDwtIHJ1bmlmKG1pbiA9IDAsIG1heCA9IDEsIDIwKQpjb3IobSA9ICJrIiwgeSA9IHksIHUgPSAicCIsIHggPSB4KQpgYGAKCkFuc3dlcnM6IGltcHJvdmVkIGNvZGUgYmVsb3cuCgpgYGB7cn0KeCA8LSBzYW1wbGUoYygxOjEwLCBOQSksIDIwLCByZXBsYWNlID0gVFJVRSkKeSA8LSBydW5pZigyMCkKY29yKHgsIHksIHVzZSA9ICJwYWlyd2lzZS5jb21wbGV0ZS5vYnMiLCBtZXRob2QgPSAia2VuZGFsbCIpCmBgYAoKLS0tCgozLiBFeHBsYWluIHdoeSB0aGUgZm9sbG93aW5nIGNvZGUgZmFpbHM6CgpgYGB7cn0KYG1vZGlmeTwtYCA8LSBmdW5jdGlvbih4LCBwb3NpdGlvbiwgdmFsdWUpIHsKICB4W3Bvc2l0aW9uXSA8LSB2YWx1ZQogIHgKfQoKdHJ5KG1vZGlmeShnZXQoIngiKSwgMSkgPC0gMTApCiM+IEVycm9yOiB0YXJnZXQgb2YgYXNzaWdubWVudCBleHBhbmRzIHRvIG5vbi1sYW5ndWFnZSBvYmplY3QKYGBgCgpBbnN3ZXI6IGFzIGV4cGxhaW5lZCBvbiBbc3RhY2sgb3ZlcmZsb3ddKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI3NjYyMTYyL2Vycm9yLWluLW15LWNvZGUtdGFyZ2V0LW9mLWFzc2lnbm1lbnQtZXhwYW5kcy10by1ub24tbGFuZ3VhZ2Utb2JqZWN0KSwKdGhlIGVycm9yIGlzIGNhdXNlZCB3aGVuIGFzc2lnbmluZyB0byBhbiBvYmplY3QgZGlyZWN0bHksIGluc3RlYWQgb2YgYSBuYW1lIHRoYXQgcmVmZXJzIHRvIHRoZQpvYmplY3QgKGxpa2UgYHhgKS4KCi0tLQoKNC4gQ3JlYXRlIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gdGhhdCBtb2RpZmllcyBhIHJhbmRvbSBsb2NhdGlvbiBpbiBhIHZlY3Rvci4KCmBgYHtyfQpgbW9kcmFuZDwtYCA8LSBmdW5jdGlvbih4LCB2YWx1ZSkgewogIHhbc2FtcGxlKGxlbmd0aCh4KSwgMSldIDwtIHZhbHVlCiAgeAp9Cgp2IDwtIDE6MjAKbW9kcmFuZCh2KSA8LSBOQQp2CmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLgoKLS0tCgo1LiBXcml0ZSB5b3VyIG93biB2ZXJzaW9uIG9mIGArYCB0aGF0IHBhc3RlcyBpdHMgaW5wdXRzIHRvZ2V0aGVyIGlmIHRoZXkgYXJlIAogICBjaGFyYWN0ZXIgdmVjdG9ycyBidXQgYmVoYXZlcyBhcyB1c3VhbCBvdGhlcndpc2UuIEluIG90aGVyIHdvcmRzLCBtYWtlIHRoaXMgCiAgIGNvZGUgd29yazoKCmBgYHtyfQpgK2AgPC0gZnVuY3Rpb24oeCwgeSkgewogIGlmIChpcy5jaGFyYWN0ZXIoeCkgJiYgaXMuY2hhcmFjdGVyKHkpKSB7CiAgICByZXR1cm4ocGFzdGUwKHgsIHkpKQogIH0KICBiYXNlOjpgK2AoeCwgeSkKfQoKMSArIDIKIz4gWzFdIDMKCiJhIiArICJiIgojPiBbMV0gImFiIgoKcm0oYCtgKQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCi0tLQoKNi4gQ3JlYXRlIGEgbGlzdCBvZiBhbGwgdGhlIHJlcGxhY2VtZW50IGZ1bmN0aW9ucyBmb3VuZCBpbiB0aGUgYmFzZSBwYWNrYWdlLiAKICAgV2hpY2ggb25lcyBhcmUgcHJpbWl0aXZlIGZ1bmN0aW9ucz8gKEhpbnQ6IHVzZSBgYXByb3BvcygpYC4pCgpgYGB7cn0KIyBhbGwgcmVwbGFjZW1lbnQgZnVuY3Rpb25zIGluIGJhc2UKZnVuX2FyZ3MyW2VuZHNXaXRoKGZ1bl9hcmdzMiRuYW1lLCAiPC0iKSwgXSRuYW1lCgojIGFsbCByZXBsYWNlbWVudCBwcmltaXRpdmUgZnVuY3Rpb25zIGluIGJhc2UKZnVuX2FyZ3MyW2VuZHNXaXRoKGZ1bl9hcmdzMiRuYW1lLCAiPC0iKSAmIGZ1bl9hcmdzMiRwcmltLCBdJG5hbWUKYGBgCgpBbnN3ZXI6IHdoaWxlIHlvdSBjb3VsZCB1c2UgYGFwcm9wb3MoIjwtIilgLCBJIGxldmVyYWdlZCB0aGUgZXhpc3RpbmcgY29kZSBmcm9tIDYuMi41ICM1LgoKLS0tCgo3LiBXaGF0IGFyZSB2YWxpZCBuYW1lcyBmb3IgdXNlci1jcmVhdGVkIGluZml4IGZ1bmN0aW9ucz8KCkFuc3dlcjogdGhleSBtdXN0IGJlZ2luIGFuZCBlbmQgd2l0aCBgJWAsIGFuZCBjYW4gY29udGFpbiBhbnkgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBleGNlcHQgYCVgLgoKLS0tCgo4LiBDcmVhdGUgYW4gaW5maXggYHhvcigpYCBvcGVyYXRvci4KCmBgYHtyfQpgJXhvciVgIDwtIGZ1bmN0aW9uKHgsIHkpIHhvcih4LCB5KQoKeG9yKDAsIDApCnhvcigxLCAwKQp4b3IoMSwgMSkKCjAgJXhvciUgMAoxICV4b3IlIDAKMSAleG9yJSAxCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLgoKLS0tCgo5LiBDcmVhdGUgaW5maXggdmVyc2lvbnMgb2YgdGhlIHNldCBmdW5jdGlvbnMgYGludGVyc2VjdCgpYCwgYHVuaW9uKClgLCBhbmQKICAgYHNldGRpZmYoKWAuIFlvdSBtaWdodCBjYWxsIHRoZW0gYCVuJWAsIGAldSVgLCBhbmQgYCUvJWAgdG8gbWF0Y2ggCiAgIGNvbnZlbnRpb25zIGZyb20gbWF0aGVtYXRpY3MuCgpgYGB7cn0KYCVuJWAgPC0gZnVuY3Rpb24oeCwgeSkgaW50ZXJzZWN0KHgsIHkpCmAldSVgIDwtIGZ1bmN0aW9uKHgsIHkpIHVuaW9uKHgsIHkpCmAlcyVgIDwtIGZ1bmN0aW9uKHgsIHkpIHNldGRpZmYoeCwgeSkKCiMgdGFrZW4gZnJvbSBkb2NzIGV4YW1wbGVzCih4IDwtIGMoc29ydChzYW1wbGUoMToyMCwgOSkpLCBOQSkpCih5IDwtIGMoc29ydChzYW1wbGUoMzoyMywgNykpLCBOQSkpCnggJXUlIHkKeCAlbiUgeQp4ICVzJSB5CnkgJXMlIHgKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgotLS0KCiMgNyBFbnZpcm9ubWVudHMKClRoZSBlbnZpcm9ubWVudCBpcyB0aGUgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBwb3dlcnMgc2NvcGluZy4gVGhpcyBjaGFwdGVyIGRpdmVzIGRlZXAgaW50byBlbnZpcm9ubWVudHMsIGRlc2NyaWJpbmcgdGhlaXIgc3RydWN0dXJlIGluIGRlcHRoLCBhbmQgdXNpbmcgdGhlbSB0byBpbXByb3ZlIHlvdXIgdW5kZXJzdGFuZGluZyBvZiB0aGUgZm91ciBzY29waW5nIHJ1bGVzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDYuNC4gClVuZGVyc3RhbmRpbmcgZW52aXJvbm1lbnRzIGlzIG5vdCBuZWNlc3NhcnkgZm9yIGRheS10by1kYXkgdXNlIG9mIFIuIEJ1dCB0aGV5IGFyZSBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCBiZWNhdXNlIHRoZXkgcG93ZXIgbWFueSBpbXBvcnRhbnQgUiBmZWF0dXJlcyBsaWtlIGxleGljYWwgc2NvcGluZywgbmFtZXNwYWNlcywgYW5kIFI2IGNsYXNzZXMsIGFuZCBpbnRlcmFjdCB3aXRoIGV2YWx1YXRpb24gdG8gZ2l2ZSB5b3UgcG93ZXJmdWwgdG9vbHMgZm9yIG1ha2luZyBkb21haW4gc3BlY2lmaWMgbGFuZ3VhZ2VzLCBsaWtlIGRwbHlyIGFuZCBnZ3Bsb3QyLgoKYGBge3J9CnJtKGxpc3QgPSBscygpKQpgYGAKCiMjIDcuMi43IEV4ZXJjaXNlcwoKMS4gIExpc3QgdGhyZWUgd2F5cyBpbiB3aGljaCBhbiBlbnZpcm9ubWVudCBkaWZmZXJzIGZyb20gYSBsaXN0LgoKQW5zd2VyOgoKLSBFdmVyeSBuYW1lIGluIGFuIGVudmlyb25tZW50IG11c3QgYmUgdW5pcXVlCi0gRW52aXJvbm1lbnQgbmFtZXMgYXJlIG5vdCBvcmRlcmVkCi0gRW52aXJvbm1lbnRzIGhhdmUgcGFyZW50cyAoZXhjZXB0IHRoZSBlbXB0eSBlbnZpcm9ubWVudCkKLSBFbnZpcm9ubWVudHMgYXJlIG5vdCBjb3BpZWQgd2hlbiBtb2RpZmllZAoKLS0tCgoyLiAgQ3JlYXRlIGFuIGVudmlyb25tZW50IGFzIGlsbHVzdHJhdGVkIGJ5IHRoaXMgcGljdHVyZS4KCiFbXShhc3NldHMvcmVjdXJzaXZlLTEucG5nKQoKYGBge3J9CmUxIDwtIGVudigpCmUxJGxvb3AgPC0gZTEKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgotLS0KCjMuICBDcmVhdGUgYSBwYWlyIG9mIGVudmlyb25tZW50cyBhcyBpbGx1c3RyYXRlZCBieSB0aGlzIHBpY3R1cmUuCgohW10oYXNzZXRzL3JlY3Vyc2l2ZS0yLnBuZykKCmBgYHtyfQplMiA8LSBlbnYoKQplMyA8LSBlbnYoKQoKZTIkbG9vcCA8LSBlMwplMyRkZWRvb3AgPC0gZTIKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgotLS0KCjQuICBFeHBsYWluIHdoeSBgZVtbMV1dYCBhbmQgYGVbYygiYSIsICJiIildYCBkb24ndCBtYWtlIHNlbnNlIHdoZW4gYGVgIGlzCiAgICBhbiBlbnZpcm9ubWVudC4KCkFuc3dlcjogZW52aXJvbm1lbnQgbmFtZXMgYXJlIG5vdCBvcmRlcmVkLCBhbmQgYXJlbid0IGNvcGllZCB3aGVuIG1vZGlmaWVkLCBzbyB0aGV5IGFyZW4ndApzdWJzZXR0YWJsZS4KCi0tLQoKNS4gIENyZWF0ZSBhIHZlcnNpb24gb2YgYGVudl9wb2tlKClgIHRoYXQgd2lsbCBvbmx5IGJpbmQgbmV3IG5hbWVzLCBuZXZlciAKICAgIHJlLWJpbmQgb2xkIG5hbWVzLiBTb21lIHByb2dyYW1taW5nIGxhbmd1YWdlcyBvbmx5IGRvIHRoaXMsIGFuZCBhcmUga25vd24gCiAgICBhcyBbc2luZ2xlIGFzc2lnbm1lbnQgbGFuZ3VhZ2VzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bc3NpZ25tZW50Xyhjb21wdXRlcl9zY2llbmNlKSNTaW5nbGVfYXNzaWdubWVudCkuCgpgYGB7cn0KZW52X3Bva2VfbmV3IDwtIGZ1bmN0aW9uKGVudiwgbm0sIHZhbHVlKSB7CiAgaWYgKCFpcy5lbnZpcm9ubWVudChlbnYpKSBzdG9wKCJlbnYgaXMgbm90IGFuIGVudmlvcm5tZW50IikKICBpZiAobm0gJWluJSBuYW1lcyhlbnYpKSBzdG9wKCJubSAnIiwgbm0sICInIGFscmVhZHkgYm91bmQiKQogIGVudltbbm1dXSA8LSB2YWx1ZQp9CgplX3Rlc3QgPC0gZW52KGEgPSBOVUxMLCBiID0gMiwgYyA9ICJ0aHJlZSIpCgplbnZfcG9rZV9uZXcoZV90ZXN0LCAiZCIsICJzdWNjZXNzIikKdHJ5KGVudl9wb2tlX25ldyhlX3Rlc3QsICJhIiwgImZhaWwiKSkKZW52X3ByaW50KGVfdGVzdCkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgotLS0KCjYuICBXaGF0IGRvZXMgdGhpcyBmdW5jdGlvbiBkbz8gSG93IGRvZXMgaXQgZGlmZmVyIGZyb20gYDw8LWAgYW5kIHdoeQogICAgbWlnaHQgeW91IHByZWZlciBpdD8KCmBgYHtyLCBlcnJvciA9IFRSVUV9CnJtKGEpCnJlYmluZCA8LSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgZW52ID0gY2FsbGVyX2VudigpKSB7CiAgaWYgKGlkZW50aWNhbChlbnYsIGVtcHR5X2VudigpKSkgewogICAgc3RvcCgiQ2FuJ3QgZmluZCBgIiwgbmFtZSwgImAiLCBjYWxsLiA9IEZBTFNFKQogIH0gZWxzZSBpZiAoZW52X2hhcyhlbnYsIG5hbWUpKSB7CiAgICBlbnZfcG9rZShlbnYsIG5hbWUsIHZhbHVlKQogIH0gZWxzZSB7CiAgICByZWJpbmQobmFtZSwgdmFsdWUsIGVudl9wYXJlbnQoZW52KSkKICB9Cn0KdHJ5KHJlYmluZCgiYSIsIDEwKSkKKGEgPC0gNSkKcmViaW5kKCJhIiwgMTApCmEKYGBgCgpBbnN3ZXI6IGA8PC1gIHdpbGwgYXNzaWduIGEgdmFsdWUgdG8gdGhlIG5hbWUgaW4gdGhlIGdsb2JhbCBlbnZpcm9ubWVudCBpZiB0aGUgbmFtZSBpcyBub3QgZm91bmQsCmByZWJpbmQoKWAgZG9lcyBub3QuCgotLS0KCiMjIDcuMy4xIEV4ZXJjaXNlcwoKMS4gIE1vZGlmeSBgd2hlcmUoKWAgdG8gcmV0dXJuIF9hbGxfIGVudmlyb25tZW50cyB0aGF0IGNvbnRhaW4gYSBiaW5kaW5nIGZvcgogICAgYG5hbWVgLiBDYXJlZnVsbHkgdGhpbmsgdGhyb3VnaCB3aGF0IHR5cGUgb2Ygb2JqZWN0IHRoZSBmdW5jdGlvbiB3aWxsCiAgICBuZWVkIHRvIHJldHVybi4KCmBgYHtyfQp3aGVyZSA8LSBmdW5jdGlvbihuYW1lLCBlbnYgPSBjYWxsZXJfZW52KCkpIHsKICBpZiAoaWRlbnRpY2FsKGVudiwgZW1wdHlfZW52KCkpKSB7CiAgICAjIEJhc2UgY2FzZQogICAgc3RvcCgiQ2FuJ3QgZmluZCAiLCBuYW1lLCBjYWxsLiA9IEZBTFNFKQogIH0gZWxzZSBpZiAoZW52X2hhcyhlbnYsIG5hbWUpKSB7CiAgICAjIFN1Y2Nlc3MgY2FzZQogICAgZW52CiAgfSBlbHNlIHsKICAgICMgUmVjdXJzaXZlIGNhc2UKICAgIHdoZXJlKG5hbWUsIGVudl9wYXJlbnQoZW52KSkKICB9Cn0KCnggPC0gNQp0cnkod2hlcmUoInl5eSIpKQp3aGVyZSgieCIpCndoZXJlKCJtZWFuIikKCmFsbF93aGVyZSA8LSBmdW5jdGlvbihuYW1lLCBlbnYgPSBjYWxsZXJfZW52KCksIGZvdW5kID0gbGlzdCgpKSB7CiAgaWYgKGlkZW50aWNhbChlbnYsIGVtcHR5X2VudigpKSkgewogICAgIyBCYXNlIGNhc2UKICAgIGZvdW5kCiAgfSBlbHNlIGlmIChlbnZfaGFzKGVudiwgbmFtZSkpIHsKICAgICMgU3VjY2VzcyBjYXNlCiAgICBhbGxfd2hlcmUobmFtZSwgZW52X3BhcmVudChlbnYpLCBhcHBlbmQoZW52LCBmb3VuZCwgYWZ0ZXIgPSAwKSkKICB9IGVsc2UgewogICAgIyBSZWN1cnNpdmUgY2FzZQogICAgYWxsX3doZXJlKG5hbWUsIGVudl9wYXJlbnQoZW52KSwgZm91bmQpCiAgfQp9CgphbGxfd2hlcmUoIngiKQpsb2NhbCh7CiAgeCA8LSAxMAogIGFsbF93aGVyZSgieCIpCn0pCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLgoKLS0tCgoyLiAgV3JpdGUgYSBmdW5jdGlvbiBjYWxsZWQgYGZnZXQoKWAgdGhhdCBmaW5kcyBvbmx5IGZ1bmN0aW9uIG9iamVjdHMuIEl0IAogICAgc2hvdWxkIGhhdmUgdHdvIGFyZ3VtZW50cywgYG5hbWVgIGFuZCBgZW52YCwgYW5kIHNob3VsZCBvYmV5IHRoZSByZWd1bGFyIAogICAgc2NvcGluZyBydWxlcyBmb3IgZnVuY3Rpb25zOiBpZiB0aGVyZSdzIGFuIG9iamVjdCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSAKICAgIHRoYXQncyBub3QgYSBmdW5jdGlvbiwgbG9vayBpbiB0aGUgcGFyZW50LiBGb3IgYW4gYWRkZWQgY2hhbGxlbmdlLCBhbHNvIAogICAgYWRkIGFuIGBpbmhlcml0c2AgYXJndW1lbnQgd2hpY2ggY29udHJvbHMgd2hldGhlciB0aGUgZnVuY3Rpb24gcmVjdXJzZXMgdXAgCiAgICB0aGUgcGFyZW50cyBvciBvbmx5IGxvb2tzIGluIG9uZSBlbnZpcm9ubWVudC4KCmBgYHtyfQpmZ2V0IDwtIGZ1bmN0aW9uKG5hbWUsIGVudiA9IGNhbGxlcl9lbnYoKSwgaW5oZXJpdHMgPSBUUlVFKSB7CiAgaWYgKGlkZW50aWNhbChlbnYsIGVtcHR5X2VudigpKSkgewogICAgIyBCYXNlIGNhc2UKICAgIHN0b3AoIkNhbid0IGZpbmQgIiwgbmFtZSwgY2FsbC4gPSBGQUxTRSkKICB9IGVsc2UgaWYgKGVudl9oYXMoZW52LCBuYW1lKSAmJiBpcy5mdW5jdGlvbihlbnZbW25hbWVdXSkpIHsKICAgICMgU3VjY2VzcyBjYXNlCiAgICBlbnYKICB9IGVsc2UgaWYgKGluaGVyaXRzKSB7CiAgICAjIFJlY3Vyc2l2ZSBjYXNlCiAgICBmZ2V0KG5hbWUsIGVudl9wYXJlbnQoZW52KSkKICB9IGVsc2UgewogICAgc3RvcCgiQ2FuJ3QgZmluZCAiLCBuYW1lLCBjYWxsLiA9IEZBTFNFKQogIH0KfQoKdHJ5KGZnZXQoIngiKSkKZmdldCgicHJpbnQiKQp0cnkoZmdldCgicHJpbnQiLCBpbmhlcml0cyA9IEZBTFNFKSkKZmdldCgiYWxsX3doZXJlIiwgaW5oZXJpdHMgPSBGQUxTRSkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgotLS0KCiMjIDcuNC41IEV4ZXJjaXNlcwoKMS4gIEhvdyBpcyBgc2VhcmNoX2VudnMoKWAgZGlmZmVyZW50IGZyb20gYGVudl9wYXJlbnRzKGdsb2JhbF9lbnYoKSlgPwoKQW5zd2VyOiBgc2VhcmNoX2VudnMoKWAgaW5jbHVkZXMgdGhlIGdsb2JhbCBlbnZpcm9ubWVudC4gYGVudl9wYXJlbnRzKGdsb2JhbF9lbnYoKSlgIGRvZXNuJ3QgaW5jbHVkZQp0aGUgZ2xvYmFsIGVudmlyb25tZW50IGFuZCBhbHNvIHJldHVybnMgdGhlIGVtcHR5IGVudmlyb25tZW50ICh0aGUgdG9wIHBhcmVudCkuCgotLS0KCjIuICBEcmF3IGEgZGlhZ3JhbSB0aGF0IHNob3dzIHRoZSBlbmNsb3NpbmcgZW52aXJvbm1lbnRzIG9mIHRoaXMgZnVuY3Rpb246CgpgYGB7ciwgZXZhbCA9IEZBTFNFfQpmMSA8LSBmdW5jdGlvbih4MSkgewogIGYyIDwtIGZ1bmN0aW9uKHgyKSB7CiAgICBmMyA8LSBmdW5jdGlvbih4MykgewogICAgICB4MSArIHgyICsgeDMKICAgIH0KICAgIGYzKDMpCiAgfQogIGYyKDIpCn0KZjEoMSkKYGBgCgpBbnN3ZXI6IE5vLgoKLS0tCgozLiAgV3JpdGUgYW4gZW5oYW5jZWQgdmVyc2lvbiBvZiBgc3RyKClgIHRoYXQgcHJvdmlkZXMgbW9yZSBpbmZvcm1hdGlvbiAKICAgIGFib3V0IGZ1bmN0aW9ucy4gU2hvdyB3aGVyZSB0aGUgZnVuY3Rpb24gd2FzIGZvdW5kIGFuZCB3aGF0IGVudmlyb25tZW50IAogICAgaXQgd2FzIGRlZmluZWQgaW4uCgpgYGB7cn0KZV9zdHIgPC0gZnVuY3Rpb24ob2JqZWN0LCAuLi4pIHsKICBzdHIob2JqZWN0LCAuLi4pCiAgaWYgKGlzLmZ1bmN0aW9uKG9iamVjdCkpIHsKICAgIG1lc3NhZ2UoImZuX2VudigpOiIpCiAgICBwcmludChmbl9lbnYob2JqZWN0KSkKICAgIG1lc3NhZ2UoImVudmlyb25tZW50KCk6IikKICAgIHByaW50KGVudmlyb25tZW50KG9iamVjdCkpCiAgfQp9CgplX3N0cihwcmludCkKZV9zdHIoZmdldCkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgotLS0KCiMjIDcuNS41IEV4ZXJjaXNlcwoKMS4gIFdyaXRlIGEgZnVuY3Rpb24gdGhhdCBsaXN0cyBhbGwgdGhlIHZhcmlhYmxlcyBkZWZpbmVkIGluIHRoZSBlbnZpcm9ubWVudAogICAgaW4gd2hpY2ggaXQgd2FzIGNhbGxlZC4gSXQgc2hvdWxkIHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIGBscygpYC4KCmBgYHtyfQpteV9scyA8LSBmdW5jdGlvbigpIHsKICB2YXJzIDwtIHNvcnQobmFtZXMocGFyZW50LmZyYW1lKCkpKQogIHZhcnNbIXN0YXJ0c1dpdGgodmFycywgIi4iKV0KfQoKbHMoKQpteV9scygpCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLgoKLS0tCgojIDggQ29uZGl0aW9ucwoKVGhlIF9fY29uZGl0aW9uX18gc3lzdGVtIHByb3ZpZGVzIGEgcGFpcmVkIHNldCBvZiB0b29scyB0aGF0IGFsbG93IHRoZSBhdXRob3Igb2YgYSBmdW5jdGlvbiB0byBpbmRpY2F0ZSB0aGF0IHNvbWV0aGluZyB1bnVzdWFsIGlzIGhhcHBlbmluZywgYW5kIHRoZSB1c2VyIG9mIHRoYXQgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGl0LiBUaGUgZnVuY3Rpb24gYXV0aG9yIF9fc2lnbmFsc19fIGNvbmRpdGlvbnMgd2l0aCBmdW5jdGlvbnMgbGlrZSBgc3RvcCgpYCAoZm9yIGVycm9ycyksIGB3YXJuaW5nKClgIChmb3Igd2FybmluZ3MpLCBhbmQgYG1lc3NhZ2UoKWAgKGZvciBtZXNzYWdlcyksIHRoZW4gdGhlIGZ1bmN0aW9uIHVzZXIgY2FuIGhhbmRsZSB0aGVtIHdpdGggZnVuY3Rpb25zIGxpa2UgYHRyeUNhdGNoKClgIGFuZCBgd2l0aENhbGxpbmdIYW5kbGVycygpYC4gVW5kZXJzdGFuZGluZyB0aGUgY29uZGl0aW9uIHN5c3RlbSBpcyBpbXBvcnRhbnQgYmVjYXVzZSB5b3UnbGwgb2Z0ZW4gbmVlZCB0byBwbGF5IGJvdGggcm9sZXM6IHNpZ25hbGxpbmcgY29uZGl0aW9ucyBmcm9tIHRoZSBmdW5jdGlvbnMgeW91IGNyZWF0ZSwgYW5kIGhhbmRsZSBjb25kaXRpb25zIHNpZ25hbGxlZCBieSB0aGUgZnVuY3Rpb25zIHlvdSBjYWxsLgoKUiBvZmZlcnMgYSB2ZXJ5IHBvd2VyZnVsIGNvbmRpdGlvbiBzeXN0ZW0gYmFzZWQgb24gaWRlYXMgZnJvbSBDb21tb24gTGlzcC4gTGlrZSBSJ3MgYXBwcm9hY2ggdG8gb2JqZWN0LW9yaWVudGVkIHByb2dyYW1taW5nLCBpdCBpcyByYXRoZXIgZGlmZmVyZW50IHRvIGN1cnJlbnRseSBwb3B1bGFyIHByb2dyYW1taW5nIGxhbmd1YWdlcyBzbyBpdCBpcyBlYXN5IHRvIG1pc3VuZGVyc3RhbmQsIGFuZCB0aGVyZSBoYXMgYmVlbiByZWxhdGl2ZWx5IGxpdHRsZSB3cml0dGVuIGFib3V0IGhvdyB0byB1c2UgaXQgZWZmZWN0aXZlbHkuIEhpc3RvcmljYWxseSwgdGhpcyBoYXMgbWVhbnQgdGhhdCBmZXcgcGVvcGxlIChteXNlbGYgaW5jbHVkZWQpIGhhdmUgdGFrZW4gZnVsbCBhZHZhbnRhZ2Ugb2YgaXRzIHBvd2VyLiBUaGUgZ29hbCBvZiB0aGlzIGNoYXB0ZXIgaXMgdG8gcmVtZWR5IHRoYXQgc2l0dWF0aW9uLiBIZXJlIHlvdSB3aWxsIGxlYXJuIGFib3V0IHRoZSBiaWcgaWRlYXMgb2YgUidzIGNvbmRpdGlvbiBzeXN0ZW0sIGFzIHdlbGwgYXMgbGVhcm5pbmcgYSBidW5jaCBvZiBwcmFjdGljYWwgdG9vbHMgdGhhdCB3aWxsIG1ha2UgeW91ciBjb2RlIHN0cm9uZ2VyLgoKSSBmb3VuZCB0d28gcmVzb3VyY2VzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiB3cml0aW5nIHRoaXMgY2hhcHRlci4gWW91IG1heSBhbHNvIHdhbnQgdG8gcmVhZCB0aGVtIGlmIHlvdSB3YW50IHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIGluc3BpcmF0aW9ucyBhbmQgbW90aXZhdGlvbnMgZm9yIHRoZSBzeXN0ZW06CgoqIFtfQSBwcm90b3R5cGUgb2YgYSBjb25kaXRpb24gc3lzdGVtIGZvciBSX10oaHR0cHM6Ly9ob21lcGFnZS5zdGF0LnVpb3dhLmVkdS9+bHVrZS9SL2V4Y2VwdGlvbnMvc2ltcGNvbmQuaHRtbCkgYnkgUm9iZXJ0IEdlbnRsZW1hbiAKICBhbmQgTHVrZSBUaWVybmV5LiBUaGlzIGRlc2NyaWJlcyBhbiBlYXJseSB2ZXJzaW9uIG9mIFIncyBjb25kaXRpb24gc3lzdGVtLiAKICBXaGlsZSB0aGUgaW1wbGVtZW50YXRpb24gaGFzIGNoYW5nZWQgc29tZXdoYXQgc2luY2UgdGhpcyBkb2N1bWVudCB3YXMgCiAgd3JpdHRlbiwgaXQgcHJvdmlkZXMgYSBnb29kIG92ZXJ2aWV3IG9mIGhvdyB0aGUgcGllY2VzIGZpdCB0b2dldGhlciwgYW5kIAogIHNvbWUgbW90aXZhdGlvbiBmb3IgaXRzIGRlc2lnbi4KCiogW19CZXlvbmQgZXhjZXB0aW9uIGhhbmRsaW5nOiBjb25kaXRpb25zIGFuZCByZXN0YXJ0c19dKGh0dHBzOi8vZ2lnYW1vbmtleXMuY29tL2Jvb2svYmV5b25kLWV4Y2VwdGlvbi1oYW5kbGluZy1jb25kaXRpb25zLWFuZC1yZXN0YXJ0cy5odG1sKQogIGJ5IFBldGVyIFNlaWJlbC4gVGhpcyBkZXNjcmliZXMgZXhjZXB0aW9uIGhhbmRsaW5nIGluIExpc3AsIHdoaWNoIGhhcHBlbnMgCiAgdG8gYmUgdmVyeSBzaW1pbGFyIHRvIFIncyBhcHByb2FjaC4gSXQgcHJvdmlkZXMgdXNlZnVsIG1vdGl2YXRpb24gYW5kIAogIG1vcmUgc29waGlzdGljYXRlZCBleGFtcGxlcy4gSSBoYXZlIHByb3ZpZGVkIGFuIFIgdHJhbnNsYXRpb24gb2YgdGhlIAogIGNoYXB0ZXIgYXQgPGh0dHA6Ly9hZHYtci5oYWQuY28ubnovYmV5b25kLWV4Y2VwdGlvbi1oYW5kbGluZy5odG1sPi4KCkkgYWxzbyBmb3VuZCBpdCBoZWxwZnVsIHRvIHdvcmsgdGhyb3VnaCB0aGUgdW5kZXJseWluZyBDIGNvZGUgdGhhdCBpbXBsZW1lbnRzIHRoZXNlIGlkZWFzLiBJZiB5b3UncmUgaW50ZXJlc3RlZCBpbiB1bmRlcnN0YW5kaW5nIGhvdyBpdCBhbGwgd29ya3MsIHlvdSBtaWdodCBmaW5kIFtteSBub3Rlc10oaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vaGFkbGV5LzQyNzhkMGE2ZDNhMTBlNDI1MzNkNTk5MDVmYmVkMGFjKSB0byBiZSB1c2VmdWwuCgpgYGB7cn0Kcm0obGlzdCA9IGxzKCkpCmBgYAoKIyMgOC4yLjQgRXhlcmNpc2VzCgoxLiAgV3JpdGUgYSB3cmFwcGVyIGFyb3VuZCBgZmlsZS5yZW1vdmUoKWAgdGhhdCB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIGZpbGUKICAgIHRvIGJlIGRlbGV0ZWQgZG9lcyBub3QgZXhpc3QuCgpgYGB7cn0Kc2FmZV9maWxlX3JlbW92ZSA8LSBmdW5jdGlvbiguLi4pIHsKICBpZiAoIWZpbGUuZXhpc3RzKC4uLikpIHN0b3AoImZpbGUgJyIsIC4uLiwgIicgZG9lcyBub3QgZXhpc3QiKQogIGZpbGUucmVtb3ZlKC4uLikKfQoKdG1wIDwtIHRlbXBmaWxlKCkKCmZpbGUuY3JlYXRlKHRtcCkKc2FmZV9maWxlX3JlbW92ZSh0bXApCmZpbGUucmVtb3ZlKHRtcCkKdHJ5KHNhZmVfZmlsZV9yZW1vdmUodG1wKSkKYGBgCgpBbnN3ZXI6CgotLS0KCjIuICBXaGF0IGRvZXMgdGhlIGBhcHBlbmRMRmAgYXJndW1lbnQgdG8gYG1lc3NhZ2UoKWAgZG8/IEhvdyBpcyBpdCByZWxhdGVkIHRvCiAgICBgY2F0KClgPwoKQW5zd2VyOiBgYXBwZW5kTEZgIGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGEgbmV3bGluZSBpcyBhZGRlZCB0byB0aGUgbWVzc2FnZTsgYnkgZGVmYXVsdCwgYGNhdCgpYApkb2VzIG5vdCBhZGQgYSBuZXdsaW5lLgoKLS0tCgojIyA4LjQuNSBFeGVyY2lzZXMKCjEuICBXaGF0IGV4dHJhIGluZm9ybWF0aW9uIGRvZXMgdGhlIGNvbmRpdGlvbiBnZW5lcmF0ZWQgYnkgYGFib3J0KClgIGNvbnRhaW4KICAgIGNvbXBhcmVkIHRvIHRoZSBjb25kaXRpb24gZ2VuZXJhdGVkIGJ5IGBzdG9wKClgIGkuZS4gd2hhdCdzIHRoZSBkaWZmZXJlbmNlCiAgICBiZXR3ZWVuIHRoZXNlIHR3byBvYmplY3RzPyBSZWFkIHRoZSBoZWxwIGZvciBgP2Fib3J0YCB0byBsZWFybiBtb3JlLgoKYGBge3J9CmNhdGNoX2NuZChzdG9wKCJBbiBlcnJvciIpKQpjYXRjaF9jbmQoYWJvcnQoIkFuIGVycm9yIikpCmBgYAoKQW5zd2VyOiBgYWJvcnQoKWAgaW5jbHVkZXMgdGhlIGVycm9yIG1lc3NhZ2UgYW5kIGJhY2t0cmFjZSBpbiB0aGUgY29uZGl0aW9uIG9iamVjdC4gYGFib3J0KClgIHVzZXMKdGhlIGN1c3RvbSBjbGFzcyBgcmxhbmdfZXJyb3JgLgoKLS0tCgoyLiAgUHJlZGljdCB0aGUgcmVzdWx0cyBvZiBldmFsdWF0aW5nIHRoZSBmb2xsb3dpbmcgY29kZQoKYGBge3J9CnNob3dfY29uZGl0aW9uIDwtIGZ1bmN0aW9uKGNvZGUpIHsKICB0cnlDYXRjaCgKICAgIGVycm9yID0gZnVuY3Rpb24oY25kKSAiZXJyb3IiLAogICAgd2FybmluZyA9IGZ1bmN0aW9uKGNuZCkgIndhcm5pbmciLAogICAgbWVzc2FnZSA9IGZ1bmN0aW9uKGNuZCkgIm1lc3NhZ2UiLAogICAgewogICAgICBjb2RlCiAgICAgIE5VTEwKICAgIH0KICApCn0KCnNob3dfY29uZGl0aW9uKHN0b3AoIiEiKSkgIz4gImVycm9yIgpzaG93X2NvbmRpdGlvbigxMCkgIz4gMTAgW05VTExdCnNob3dfY29uZGl0aW9uKHdhcm5pbmcoIj8hIikpICM+ICJ3YXJuaW5nIgpzaG93X2NvbmRpdGlvbih7CiAgMTAKICBtZXNzYWdlKCI/IikKICB3YXJuaW5nKCI/ISIpCn0pCiM+IDEwCiM+ICJtZXNzYWdlIgojPiAid2FybmluZyIKYGBgCgpBbnN3ZXI6IHByZWRpY3Rpb25zIGluIGNvbW1lbnRzLiBUaGUgcHJlZGljdGlvbiBmb3IgYHNob3dfY29uZGl0aW9uKDEwKWAgd2FzIGluY29ycmVjdDsgdGhlIGNvcnJlY3QKYW5zd2VyIGlzIGBOVUxMYCBhcyB0aGF0J3Mgd2hhdCdzIHJldHVybmVkIHdoZW4gdGhlcmUgaXMgbm8gY29uZGl0aW9uLiBUaGUgZmluYWwgcHJlZGljdGlvbiB3YXMgYWxzbwppbmNvcnJlY3Q7IHRoZSBgdHJ5Q2F0Y2goKWAgY2FsbCBzdG9wcyBmdXJ0aGVyIGV4ZWN1dGlvbiB3aGVuIHRoZSBgbWVzc2FnZSgpYCBpcyBjYXVnaHQuCgotLS0KCjMuICBFeHBsYWluIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgdGhpcyBjb2RlOgoKYGBge3J9CndpdGhDYWxsaW5nSGFuZGxlcnMoCiAgbWVzc2FnZSA9IGZ1bmN0aW9uKGNuZCkgbWVzc2FnZSgiYiIpLCAjIGhhbmRsZXIgMQogIHdpdGhDYWxsaW5nSGFuZGxlcnMoCiAgICBtZXNzYWdlID0gZnVuY3Rpb24oY25kKSBtZXNzYWdlKCJhIiksICMgaGFuZGxlciAyCiAgICBtZXNzYWdlKCJjIikKICApCikKYGBgCgpBbnN3ZXI6CgoxLiBgbWVzc2FnZSgiYyIpYCBpcyBjYXVnaHQsIGhhbmRsZXIgMiBpcyBjYWxsZWQKMS4gaW4gaGFuZGxlciAyLCBgbWVzc2FnZSgiYSIpYCBpcyBjYXVnaHQgYW5kIGhhbmRsZXIgMSBpcyBjYWxsZWQKMS4gaGFuZGxlciAxIHdyaXRlcyBtZXNzYWdlIGBiYAoxLiBjb2RlIHJlc3VtZXMgYW5kIGhhbmRsZXIgMiB3cml0ZXMgbWVzc2FnZSBgYWAKMS4gYG1lc3NhZ2UoImMiKWAgcHJvcGFnYXRlcyB0byB0aGUgcGFyZW50LCBpcyBjYXVnaHQsIGFuZCBoYW5kbGVyIDEgaXMgY2FsbGVkCjEuIGhhbmRsZXIgMSB3cml0ZXMgbWVzc2FnZSBgYmAKMS4gY29kZSByZXN1bWVzIGFuZCB0aGUgY29kZSB3cml0ZXMgbWVzc2FnZSBgY2AKCi0tLQoKNC4gIFJlYWQgdGhlIHNvdXJjZSBjb2RlIGZvciBgY2F0Y2hfY25kKClgIGFuZCBleHBsYWluIGhvdyBpdCB3b3Jrcy4KCmBgYHtyfQpjYXRjaF9jbmQKCmNhdGNoX2NuZChzdG9wKCJlcnJvciIpKQoKIyByZXBsaWNhdGUgdGhlIGNvcmUgZnVuY3Rpb25hbGl0eQp0cnlDYXRjaChjb25kaXRpb24gPSBmdW5jdGlvbih4KSB4LCBmb3JjZShzdG9wKCJlcnJvciIpKSkKYGBgCgpBbnN3ZXI6IGBjYXRjaF9jbmQoKWAgdXNlcyBgdHJ5Q2F0Y2goKWAgdG8gY2F0Y2ggYW55IGNvbmRpdGlvbiBhbmQgcmV0dXJuIGl0c2VsZiB1c2luZyBgaWRlbnRpdHkoKWAuCgotLS0KCjUuICBIb3cgY291bGQgeW91IHJld3JpdGUgYHNob3dfY29uZGl0aW9uKClgIHRvIHVzZSBhIHNpbmdsZSBoYW5kbGVyPwoKYGBge3J9CnNob3dfY29uZGl0aW9uMiA8LSBmdW5jdGlvbihjb2RlKSB7CiAgdHJ5Q2F0Y2goCiAgICBjb25kaXRpb24gPSBmdW5jdGlvbihjbmQpIHsKICAgICAgaWYgKGlzX2Vycm9yKGNuZCkpIHsKICAgICAgICByZXR1cm4oImVycm9yIikKICAgICAgfQogICAgICBpZiAoaXNfd2FybmluZyhjbmQpKSB7CiAgICAgICAgcmV0dXJuKCJ3YXJuaW5nIikKICAgICAgfQogICAgICBpZiAoaXNfbWVzc2FnZShjbmQpKSB7CiAgICAgICAgcmV0dXJuKCJtZXNzYWdlIikKICAgICAgfQogICAgfSwKICAgIHsKICAgICAgY29kZQogICAgICBOVUxMCiAgICB9CiAgKQp9CgpzaG93X2NvbmRpdGlvbjIoc3RvcCgiISIpKQpzaG93X2NvbmRpdGlvbjIoMTApCnNob3dfY29uZGl0aW9uMih3YXJuaW5nKCI/ISIpKQpzaG93X2NvbmRpdGlvbjIoewogIDEwCiAgbWVzc2FnZSgiPyIpCiAgd2FybmluZygiPyEiKQp9KQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCi0tLQoKIyMgOC41LjQgRXhlcmNpc2VzCgoxLiAgSW5zaWRlIGEgcGFja2FnZSwgaXQncyBvY2Nhc2lvbmFsbHkgdXNlZnVsIHRvIGNoZWNrIHRoYXQgYSBwYWNrYWdlIGlzIAogICAgaW5zdGFsbGVkIGJlZm9yZSB1c2luZyBpdC4gV3JpdGUgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIHBhY2thZ2UgaXMgCiAgICBpbnN0YWxsZWQgKHdpdGggYHJlcXVpcmVOYW1lc3BhY2UoInBrZyIsIHF1aWV0bHkgPSBGQUxTRSkpYCBhbmQgaWYgbm90LAogICAgdGhyb3dzIGEgY3VzdG9tIGNvbmRpdGlvbiB0aGF0IGluY2x1ZGVzIHRoZSBwYWNrYWdlIG5hbWUgaW4gdGhlIG1ldGFkYXRhLgoKYGBge3J9Cm15X2NoZWNrX2luc3RhbGxlZCA8LSBmdW5jdGlvbihwa2cpIHsKICBpZiAoIXJlcXVpcmVOYW1lc3BhY2UocGtnLCBxdWlldGx5ID0gVFJVRSkpIHsKICAgIGFib3J0KAogICAgICAiZXJyb3Jfbm90X2ZvdW5kIiwKICAgICAgbWVzc2FnZSA9IHBhc3RlMCgicGFja2FnZSAnIiwgcGtnLCAiJyBub3QgZm91bmQiKSwKICAgICAgcGtnID0gcGtnCiAgICApCiAgfQp9CgpteV9jaGVja19pbnN0YWxsZWQoInJsYW5nIikKIyBOT1RFOiB0aGlzIGNvZGUgY2F1c2VzIHJlbnY6OmRlcGVuZGVuY2llcygpIHRvIG1pc3Rha2VubHkgcmVwb3J0IHBhY2thZ2UgJ3BrZycgYXMgYSBkZXBlbmRlbmN5CnJlcXVpcmVOYW1lc3BhY2UoInBrZyIsIHF1aWV0bHkgPSBGQUxTRSkKZXJyIDwtIGNhdGNoX2NuZChteV9jaGVja19pbnN0YWxsZWQoInBrZyIpKQplcnIKZXJyJHBrZwpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4gVGhlIHF1ZXN0aW9uIHNwZWNpZmllcyB0byB1c2UgYHF1aWV0bHkgPSBGQUxTRWAsIGJ1dCB0aGlzIGFwcHJvYWNoIG1ha2VzIG1vcmUKc2Vuc2UgKHRvIG1lKS4gVGhlIGFsdGVybmF0aXZlIGlzIHRvIGNhdGNoIHRoZSAnRmFpbGVkIHdpdGggZXJyb3I6JyBtZXNzYWdlIHdoaWNoIHNlZW1zIGxlc3MKcmVsaWFibGUuCgpgYGB7cn0KbXlfY2hlY2tfaW5zdGFsbGVkMiA8LSBmdW5jdGlvbihwa2cpIHsKICB0cnlDYXRjaCgKICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKGNuZCkgewogICAgICBhYm9ydCgKICAgICAgICAiZXJyb3Jfbm90X2ZvdW5kIiwKICAgICAgICBtZXNzYWdlID0gcGFzdGUwKCJwYWNrYWdlICciLCBwa2csICInIG5vdCBmb3VuZCIpLAogICAgICAgIHBrZyA9IHBrZwogICAgICApCiAgICB9LAogICAgcmVxdWlyZU5hbWVzcGFjZShwa2csIHF1aWV0bHkgPSBGQUxTRSkKICApCn0KCm15X2NoZWNrX2luc3RhbGxlZDIoInJsYW5nIikKZXJyMiA8LSBjYXRjaF9jbmQobXlfY2hlY2tfaW5zdGFsbGVkMigicGtnIikpCmVycjIKZXJyMiRwa2cKYGBgCgpUaGUgYWx0ZXJuYXRpdmUgdmVyc2lvbiwgYG15X2NoZWNrX2luc3RhbGxlZDIoKWAgd29ya3MgYnV0IGl0cyBCYWNrdHJhY2UgaXMgaGFyZGVyIHRvIHJlYWQuCgotLS0KCjIuICBJbnNpZGUgYSBwYWNrYWdlIHlvdSBvZnRlbiBuZWVkIHRvIHN0b3Agd2l0aCBhbiBlcnJvciB3aGVuIHNvbWV0aGluZwogICAgaXMgbm90IHJpZ2h0LiBPdGhlciBwYWNrYWdlcyB0aGF0IGRlcGVuZCBvbiB5b3VyIHBhY2thZ2UgbWlnaHQgYmUKICAgIHRlbXB0ZWQgdG8gY2hlY2sgdGhlc2UgZXJyb3JzIGluIHRoZWlyIHVuaXQgdGVzdHMuIEhvdyBjb3VsZCB5b3UgaGVscAogICAgdGhlc2UgcGFja2FnZXMgdG8gYXZvaWQgcmVseWluZyBvbiB0aGUgZXJyb3IgbWVzc2FnZSB3aGljaCBpcyBwYXJ0IG9mCiAgICB0aGUgdXNlciBpbnRlcmZhY2UgcmF0aGVyIHRoYW4gdGhlIEFQSSBhbmQgbWlnaHQgY2hhbmdlIHdpdGhvdXQgbm90aWNlPwoKQW5zd2VyOiByZXR1cm4gY3VzdG9tIGVycm9yIG9iamVjdHMgdGhhdCBhcmVuJ3QgZGVwZW5kZW50IG9uIHRoZSBlcnJvciB0ZXh0IChsaWtlIGluIDguNS4zKQoKLS0tCgojIyA4LjYuNiBFeGVyY2lzZXMKCjEuICBDcmVhdGUgYHN1cHByZXNzQ29uZGl0aW9ucygpYCB0aGF0IHdvcmtzIGxpa2UgYHN1cHByZXNzTWVzc2FnZXMoKWAgYW5kIAogICAgYHN1cHByZXNzV2FybmluZ3MoKWAgYnV0IHN1cHByZXNzZXMgZXZlcnl0aGluZy4gVGhpbmsgY2FyZWZ1bGx5IGFib3V0IGhvdyB5b3UKICAgIHNob3VsZCBoYW5kbGUgZXJyb3JzLgoKYGBge3J9CnN1cHByZXNzQ29uZGl0aW9ucyA8LSBmdW5jdGlvbihleHByKSB7ICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgdHJ5Q2F0Y2goCiAgICBlcnJvciA9IGZ1bmN0aW9uKGNuZCkgaW52aXNpYmxlKGNuZCksCiAgICB3aXRoQ2FsbGluZ0hhbmRsZXJzKAogICAgICBjb25kaXRpb24gPSBmdW5jdGlvbihjbmQpIHsKICAgICAgICBjbmRfbXVmZmxlKGNuZCkKICAgICAgfSwKICAgICAgZXhwcgogICAgKQogICkKfQoKc3VwIDwtIHN1cHByZXNzQ29uZGl0aW9ucyh7CiAgbWVzc2FnZSgicHJvY2Vzc2luZy4uLiIpCiAgd2FybmluZygic29tZXRoaW5nIHdlbnQgd3JvbmciKQogIHByaW50KCJzdGlsbCBydW5uaW5nIikKICBzdG9wKCJlcnJvciIpCiAgcHJpbnQoInRoaXMgc2hvdWxkbid0IHJ1biIpCn0pCgpzdHIoc3VwKQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4gRXJyb3JzIGFyZSBub3QgcHJpbnRlZCwgYnV0IGFyZSByZXR1cm5lZCwgaW52aXNpYmx5LgoKLS0tCgoyLiAgQ29tcGFyZSB0aGUgZm9sbG93aW5nIHR3byBpbXBsZW1lbnRhdGlvbnMgb2YgYG1lc3NhZ2UyZXJyb3IoKWAuIFdoYXQgaXMgdGhlCiAgICBtYWluIGFkdmFudGFnZSBvZiBgd2l0aENhbGxpbmdIYW5kbGVycygpYCBpbiB0aGlzIHNjZW5hcmlvPyAoSGludDogbG9vawogICAgY2FyZWZ1bGx5IGF0IHRoZSB0cmFjZWJhY2suKQoKYGBge3J9Cm1lc3NhZ2UyZXJyb3IgPC0gZnVuY3Rpb24oY29kZSkgewogIHdpdGhDYWxsaW5nSGFuZGxlcnMoY29kZSwgbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHN0b3AoZSkpCn0KCm1lc3NhZ2UyZXJyb3IyIDwtIGZ1bmN0aW9uKGNvZGUpIHsKICB0cnlDYXRjaChjb2RlLCBtZXNzYWdlID0gZnVuY3Rpb24oZSkgc3RvcChlKSkKfQpgYGAKCkFuc3dlcjogYG1lc3NhZ2UyZXJyb3IoKWAgc2hvd3MgdGhlIGludm9jYXRpb24gb2YgYG1lc3NhZ2UoKWAgaW4gdGhlIHRyYWNlYmFjaywgYnV0CmBtZXNzYWdlMmVycm9yMigpYCBkb2VzIG5vdC4KCi0tLQoKMy4gIEhvdyB3b3VsZCB5b3UgbW9kaWZ5IHRoZSBgY2F0Y2hfY25kcygpYCBkZWZpbml0aW9uIGlmIHlvdSB3YW50ZWQgdG8gcmVjcmVhdGUKICAgIHRoZSBvcmlnaW5hbCBpbnRlcm1pbmdsaW5nIG9mIHdhcm5pbmdzIGFuZCBtZXNzYWdlcz8KCkFuc3dlcjogYXMgbm90ZWQgaW4KW0FkdmFuY2VkIFIgU29sdXRpb25zXShodHRwczovL2FkdmFuY2VkLXItc29sdXRpb25zLnJiaW5kLmlvL2NvbmRpdGlvbnMuaHRtbCNhcHBsaWNhdGlvbnMtMSksCiJJdCBsb29rcyBsaWtlIEhhZGxleSB3cm90ZSBhIHBhcnQgb2YgdGhlIGNoYXB0ZXIgYWZ0ZXIgdGhlIGV4ZXJjaXNlcywgYXMgdGhlIGBjYXRjaF9jbmRzKClgCmZ1bmN0aW9uIGRlZmluZWQgaW4gdGhlIGNoYXB0ZXIgYWxyZWFkeSBzb2x2ZXMgdGhpcyBwcm9ibGVtIGJ5IHN0b3JpbmcgYWxsIG1lc3NhZ2VzIGFuZCB3YXJuaW5ncyBpbgp0aGVpciBvcmlnaW5hbCBvcmRlciB3aXRoaW4gYSBsaXN0LiIKCi0tLQoKNC4gIFdoeSBpcyBjYXRjaGluZyBpbnRlcnJ1cHRzIGRhbmdlcm91cz8gUnVuIHRoaXMgY29kZSB0byBmaW5kIG91dC4KCmBgYHtyLCBldmFsID0gRkFMU0V9CmJvdHRsZXNfb2ZfYmVlciA8LSBmdW5jdGlvbihpID0gOTkpIHsKICBtZXNzYWdlKAogICAgIlRoZXJlIGFyZSAiLCBpLCAiIGJvdHRsZXMgb2YgYmVlciBvbiB0aGUgd2FsbCwgIiwKICAgIGksICIgYm90dGxlcyBvZiBiZWVyLiIKICApCiAgd2hpbGUgKGkgPiAwKSB7CiAgICB0cnlDYXRjaCgKICAgICAgU3lzLnNsZWVwKDEpLAogICAgICBpbnRlcnJ1cHQgPSBmdW5jdGlvbihlcnIpIHsKICAgICAgICBpIDw8LSBpIC0gMSAjIG5vbGludDogdW5kZXNpcmFibGVfb3BlcmF0b3JfbGludGVyLgogICAgICAgIGlmIChpID4gMCkgewogICAgICAgICAgbWVzc2FnZSgKICAgICAgICAgICAgIlRha2Ugb25lIGRvd24sIHBhc3MgaXQgYXJvdW5kLCAiLCBpLAogICAgICAgICAgICAiIGJvdHRsZSIsIGlmIChpID4gMSkgInMiLCAiIG9mIGJlZXIgb24gdGhlIHdhbGwuIgogICAgICAgICAgKQogICAgICAgIH0KICAgICAgfQogICAgKQogIH0KICBtZXNzYWdlKAogICAgIk5vIG1vcmUgYm90dGxlcyBvZiBiZWVyIG9uIHRoZSB3YWxsLCAiLAogICAgIm5vIG1vcmUgYm90dGxlcyBvZiBiZWVyLiIKICApCn0KYGBgCgpBbnN3ZXI6IHRoaXMgcHJldmVudHMgdXNlciBpbnRlcnJ1cHRzIChjb250cm9sLWMpIGZyb20gaGFsdGluZyB0aGUgY29kZSwgd2hpY2ggaW4gdGhpcyBjYXNlIGNhbiBiZQpwcmV0dHkgYW5ub3lpbmcgaWYgcnVuIHdpdGggdGhlIGRlZmF1bHRzLCByZXF1aXJpbmcgOTkgaW50ZXJydXB0cyAob3IganVzdCAiUmVzdGFydCBSIikuCgotLS0KCiMgU29sdXRpb25zCgpOb3RlcyBvbiBjb21wYXJpbmcgZXhlcmNpc2Ugc29sdXRpb25zIGhlcmUgYWdhaW5zdApbQWR2YW5jZWQgUiBTb2x1dGlvbnNdKGh0dHBzOi8vYWR2YW5jZWQtci1zb2x1dGlvbnMucmJpbmQuaW8vaW5kZXguaHRtbCkuCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("advanced-r-1.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
