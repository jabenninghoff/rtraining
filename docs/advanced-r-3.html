<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2022-08-15" />

<title>Advanced R Workbook (Object-oriented programming)</title>

<script src="site_libs/header-attrs-2.20/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link href="site_libs/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-5.2.2/bootstrap.bundle.min.js"></script>
<script src="site_libs/bs3compat-0.4.2/transition.js"></script>
<script src="site_libs/bs3compat-0.4.2/tabs.js"></script>
<script src="site_libs/bs3compat-0.4.2/bs3compat.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">rtraining notebooks</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="reference/index.html">Reference</a>
</li>
<li>
  <a href="news/index.html">Changelog</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="FaultTree.html">FaultTree.widget Test</a>
    </li>
    <li>
      <a href="advanced-r-1.html">Advanced R Workbook (Foundations)</a>
    </li>
    <li>
      <a href="advanced-r-2.html">Advanced R Workbook (Functional programming)</a>
    </li>
    <li>
      <a href="advanced-r-3.html">Advanced R Workbook (Object-oriented programming)</a>
    </li>
    <li>
      <a href="ggplot2-1.html">ggplot2 (Getting started)</a>
    </li>
    <li>
      <a href="ggplot2-2.html">ggplot2 (Layers)</a>
    </li>
    <li>
      <a href="ggplot2-3.html">ggplot2 (Scales)</a>
    </li>
    <li>
      <a href="ggplot2-4.html">ggplot2 (Grammar)</a>
    </li>
    <li>
      <a href="ggplot2-5.html">ggplot2 (Extending)</a>
    </li>
    <li>
      <a href="r-setup-log.html">R Setup Log</a>
    </li>
    <li>
      <a href="r-training-log.html">R Training Log</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/jabenninghoff/rtraining/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Advanced R Workbook (Object-oriented
programming)</h1>
<h4 class="date">2022-08-15</h4>

</div>


<p>Workbook for completing quizzes and exercises from the
“Object-oriented programming” chapters of <a
href="https://adv-r.hadley.nz/index.html">Advanced R</a>, second
edition, with comparisons to solutions from <a
href="https://advanced-r-solutions.rbind.io">Advanced R
Solutions</a>.</p>
<pre class="r"><code>library(sloop)
library(purrr)
library(dplyr)
library(R6)
library(methods)

# from https://github.com/hadley/adv-r/blob/master/common.R
knitr::opts_chunk$set(
  comment = &quot;#&gt;&quot;,
  fig.align = &quot;center&quot;
)

knitr::knit_hooks$set(
  small_mar = function(before, options, envir) {
    if (before) {
      par(mar = c(4.1, 4.1, 0.5, 0.5)) # nolint: undesirable_function_linter.
    }
  }
)</code></pre>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This workbook includes answers and solutions to the quizzes and
exercises from <a href="https://adv-r.hadley.nz/index.html">Advanced
R</a> and <a href="https://advanced-r-solutions.rbind.io">Advanced R
Solutions</a>, organized by chapter. It includes excerpts from both
books, copied here.</p>
<p><strong>WARNING, SPOILERS!</strong> If you haven’t read Advanced R
and intend to complete the quizzes and exercises, don’t read this
notebook. It contains my (potentially wrong) answers to both.</p>
</div>
<div id="base-types" class="section level1">
<h1>12 Base types</h1>
<p>To talk about objects and OOP in R we first need to clear up a
fundamental confusion about two uses of the word “object”. So far in
this book, we’ve used the word in the general sense captured by John
Chambers’ pithy quote: “Everything that exists in R is an object”.
However, while everything <em>is</em> an object, not everything is
object-oriented. This confusion arises because the base objects come
from S, and were developed before anyone thought that S might need an
OOP system. The tools and nomenclature evolved organically over many
years without a single guiding principle.</p>
<p>Most of the time, the distinction between objects and object-oriented
objects is not important. But here we need to get into the nitty gritty
details so we’ll use the terms <strong>base objects</strong> and
<strong>OO objects</strong> to distinguish them.</p>
</div>
<div id="s3" class="section level1">
<h1>13 S3</h1>
<p>S3 is R’s first and simplest OO system. S3 is informal and ad hoc,
but there is a certain elegance in its minimalism: you can’t take away
any part of it and still have a useful OO system. For these reasons, you
should use it, unless you have a compelling reason to do otherwise. S3
is the only OO system used in the base and stats packages, and it’s the
most commonly used system in CRAN packages.</p>
<p>S3 is very flexible, which means it allows you to do things that are
quite ill-advised. If you’re coming from a strict environment like Java
this will seem pretty frightening, but it gives R programmers a
tremendous amount of freedom. It may be very difficult to prevent people
from doing something you don’t want them to do, but your users will
never be held back because there is something you haven’t implemented
yet. Since S3 has few built-in constraints, the key to its successful
use is applying the constraints yourself. This chapter will therefore
teach you the conventions you should (almost) always follow.</p>
<p>The goal of this chapter is to show you how the S3 system works, not
how to use it effectively to create new classes and generics. I’d
recommend coupling the theoretical knowledge from this chapter with the
practical knowledge encoded in the <a
href="https://vctrs.r-lib.org">vctrs package</a>.</p>
<div id="exercises" class="section level2">
<h2>13.2.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Describe the difference between <code>t.test()</code> and
<code>t.data.frame()</code>. When is each function called?</li>
</ol>
<pre class="r"><code>ftype(t.test)</code></pre>
<pre><code>#&gt; [1] &quot;S3&quot;      &quot;generic&quot;</code></pre>
<pre class="r"><code>ftype(t.data.frame)</code></pre>
<pre><code>#&gt; [1] &quot;S3&quot;     &quot;method&quot;</code></pre>
<pre class="r"><code>s3_dispatch(t.test(formula()))</code></pre>
<pre><code>#&gt; =&gt; t.test.formula
#&gt;  * t.test.default</code></pre>
<pre class="r"><code>s3_dispatch(t(data.frame()))</code></pre>
<pre><code>#&gt; =&gt; t.data.frame
#&gt; -&gt; t.default</code></pre>
<p>Answer: As noted by <code>sloop::ftype()</code> and the docs,
<code>t.test()</code> is a S3 generic, and <code>t.data.frame()</code>
is an S3 method for <code>t()</code> (transpose).
<code>t.data.frame()</code> is called as a method when calling
<code>t(x)</code> when <code>x</code> is a <code>data.frame</code>.
<code>t.test()</code> calls either <code>t.test.default</code> or
<code>t.test.formula</code>.</p>
<p>AR Solutions: Because of S3’s <code>generic.class()</code> naming
scheme, both functions may initially look similar, while they are in
fact unrelated.</p>
<ul>
<li><code>t.test()</code> is a <em>generic</em> function that performs a
t-test.</li>
<li><code>t.data.frame()</code> is a <em>method</em> that gets called by
the generic <code>t()</code> to transpose data frame input.</li>
</ul>
<p>Due to R’s S3 dispatch rules, <code>t.test()</code> would also get
called when <code>t()</code> is applied to an object of class
<code>test</code></p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Make a list of commonly used base R functions that contain
<code>.</code> in their name but are not S3 methods.</li>
</ol>
<pre class="r"><code>ftype(as.character)</code></pre>
<pre><code>#&gt; [1] &quot;primitive&quot; &quot;generic&quot;</code></pre>
<pre class="r"><code>ftype(as.data.frame)</code></pre>
<pre><code>#&gt; [1] &quot;S3&quot;      &quot;generic&quot;</code></pre>
<pre class="r"><code>ftype(data.frame)</code></pre>
<pre><code>#&gt; [1] &quot;function&quot;</code></pre>
<pre class="r"><code>ftype(eval.parent)</code></pre>
<pre><code>#&gt; [1] &quot;function&quot;</code></pre>
<pre class="r"><code>ftype(file.path)</code></pre>
<pre><code>#&gt; [1] &quot;internal&quot;</code></pre>
<pre class="r"><code>ftype(file.copy)</code></pre>
<pre><code>#&gt; [1] &quot;internal&quot;</code></pre>
<pre class="r"><code>ftype(is.null)</code></pre>
<pre><code>#&gt; [1] &quot;primitive&quot;</code></pre>
<pre class="r"><code>ftype(is.data.frame)</code></pre>
<pre><code>#&gt; [1] &quot;function&quot;</code></pre>
<pre class="r"><code>ftype(Sys.localeconv)</code></pre>
<pre><code>#&gt; [1] &quot;internal&quot;</code></pre>
<pre class="r"><code>ftype(Sys.time)</code></pre>
<pre><code>#&gt; [1] &quot;internal&quot;</code></pre>
<p>Answer:</p>
<ul>
<li>All of the <code>as.</code> functions</li>
<li><code>data.frame</code></li>
<li>All of the <code>file.</code> functions</li>
<li>All of the <code>is.</code> functions</li>
<li>All of the <code>Sys.</code> functions</li>
</ul>
<p>AR Solutions: In recent years “snake_case”-style has become
increasingly common when naming functions and variables in R. But many
functions in base R will continue to be “point.separated”, which is why
some inconsistency in your R code most likely cannot be avoided.
(<code>install.packages(), read.csv(), list.files(), download.file(), data.frame(), as.character(), Sys.Date(), all.equal(), do.call(), on.exit()</code>)</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What does the <code>as.data.frame.data.frame()</code> method do? Why
is it confusing? How could you avoid this confusion in your own
code?</li>
</ol>
<pre class="r"><code>s3_dispatch(as.data.frame(data.frame()))</code></pre>
<pre><code>#&gt; =&gt; as.data.frame.data.frame
#&gt;  * as.data.frame.default</code></pre>
<p>Answer: <code>as.data.frame.data.frame()</code> is the method used to
coerce a <code>data.frame</code> to a <code>data.frame</code>. This is
confusing because the class contains a period (as does the function
call); avoiding periods improves readability:
<code>as_dataframe.dataframe</code> makes the generic and method
clear.</p>
<p>AR Solutions: The function <code>as.data.frame.data.frame()</code>
implements the <code>data.frame()</code> <em>method</em> for the
<code>as.data.frame()</code> <em>generic</em>, which coerces objects to
data frames.</p>
<p>The name is confusing, because it does not clearly communicate the
type of the function, which could be a regular function, a generic or a
method. Even if we assume a method, the amount of <code>.</code>’s makes
it difficult to separate the generic- and the class-part of the name. Is
it the <code>data.frame.data.frame()</code> method for the
<code>as()</code> generic? Is it the <code>frame.data.frame()</code>
method for the <code>as.data()</code> generic?</p>
<p>We could avoid this confusion by applying a different naming
convention (e.g. “snake_case”) for our class and function names.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Describe the difference in behaviour in these two calls.</li>
</ol>
<pre class="r"><code>set.seed(1014)
some_days &lt;- as.Date(&quot;2017-01-31&quot;) + sample(10, 5)
mean(some_days)</code></pre>
<pre><code>#&gt; [1] &quot;2017-02-06&quot;</code></pre>
<pre class="r"><code>mean(unclass(some_days))</code></pre>
<pre><code>#&gt; [1] 17203.4</code></pre>
<pre class="r"><code>s3_dispatch(mean(some_days))</code></pre>
<pre><code>#&gt; =&gt; mean.Date
#&gt;  * mean.default</code></pre>
<pre class="r"><code>s3_dispatch(mean(unclass(some_days)))</code></pre>
<pre><code>#&gt;    mean.double
#&gt;    mean.numeric
#&gt; =&gt; mean.default</code></pre>
<p>Answer: the first call calculates the mean using
<code>mean.Date()</code>, and so returns a date. using
<code>unclass()</code> changes the date to its underlying value (double)
which calculates the mean using <code>mean.default()</code>.</p>
<p>AR Solutions: <code>mean()</code> is a generic function, which will
select the appropriate method based on the class of the input.
<code>some_days</code> has the class <code>Date</code> and
<code>mean.Date(some_days)</code> will be used to calculate the mean
date of <code>some_days</code>.</p>
<p>After <code>unclass()</code> has removed the class attribute from
<code>some_date</code>, the default method is chosen.
<code>mean.default(unclass(some_days))</code> then calculates the mean
of the underlying double.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>What class of object does the following code return? What base type
is it built on? What attributes does it use?</li>
</ol>
<pre class="r"><code>x &lt;- ecdf(rpois(100, 10))
x</code></pre>
<pre><code>#&gt; Empirical CDF 
#&gt; Call: ecdf(rpois(100, 10))
#&gt;  x[1:18] =      2,      3,      4,  ...,     18,     19</code></pre>
<pre class="r"><code>str(x)</code></pre>
<pre><code>#&gt; function (v)  
#&gt;  - attr(*, &quot;class&quot;)= chr [1:3] &quot;ecdf&quot; &quot;stepfun&quot; &quot;function&quot;
#&gt;  - attr(*, &quot;call&quot;)= language ecdf(rpois(100, 10))</code></pre>
<p>Answer: the code returns an object of class <code>ecdf</code>, which
is build on the <code>stepfun</code> object, and the
<code>function</code> base type. It additionally includes the
<code>call</code> attribute.</p>
<p>AR Solutions: It returns an object of the class <code>ecdf</code>
(empirical cumulative distribution function) with the superclasses
<code>stepfun</code> and <code>function</code>. The <code>ecdf</code>
object is built on the base type <code>closure</code> (a function). The
expression, which was used to create it (<code>rpois(100, 10)</code>),
is stored in the <code>call</code> attribute.</p>
<pre class="r"><code>typeof(x)</code></pre>
<pre><code>#&gt; [1] &quot;closure&quot;</code></pre>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>What class of object does the following code return? What base type
is it built on? What attributes does it use?</li>
</ol>
<pre class="r"><code>x &lt;- table(rpois(100, 5))
x</code></pre>
<pre><code>#&gt; 
#&gt;  1  2  3  4  5  6  7  8  9 10 
#&gt;  7  5 18 14 15 15 14  4  5  3</code></pre>
<pre class="r"><code>str(x)</code></pre>
<pre><code>#&gt;  &#39;table&#39; int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3
#&gt;  - attr(*, &quot;dimnames&quot;)=List of 1
#&gt;   ..$ : chr [1:10] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</code></pre>
<pre class="r"><code>str(unclass(x))</code></pre>
<pre><code>#&gt;  int [1:10(1d)] 7 5 18 14 15 15 14 4 5 3
#&gt;  - attr(*, &quot;dimnames&quot;)=List of 1
#&gt;   ..$ : chr [1:10] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</code></pre>
<p>Answer: per the docs, the code returns an object of class
<code>table</code>, which is built on <code>array</code>, which uses the
<code>dimnames</code> attribute in combination with a vector.</p>
<p>AR Solutions: This code returns a <code>table</code> object, which is
built upon the <code>integer</code> type. The attribute
<code>dimnames</code> is used to name the elements of the integer
vector.</p>
<hr />
</div>
<div id="exercises-1" class="section level2">
<h2>13.3.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Write a constructor for <code>data.frame</code> objects. What base
type is a data frame built on? What attributes does it use? What are the
restrictions placed on the individual elements? What about the
names?</li>
</ol>
<pre class="r"><code>dput(data.frame())</code></pre>
<pre><code>#&gt; structure(list(), names = character(0), row.names = integer(0), class = &quot;data.frame&quot;)</code></pre>
<pre class="r"><code>dput(data.frame(a = 1:2, b = 3:4))</code></pre>
<pre><code>#&gt; structure(list(a = 1:2, b = 3:4), class = &quot;data.frame&quot;, row.names = c(NA, 
#&gt; -2L))</code></pre>
<pre class="r"><code>unclass(data.frame(a = 1:2, b = 3:4))</code></pre>
<pre><code>#&gt; $a
#&gt; [1] 1 2
#&gt; 
#&gt; $b
#&gt; [1] 3 4
#&gt; 
#&gt; attr(,&quot;row.names&quot;)
#&gt; [1] 1 2</code></pre>
<p>Answer: code below. The data frame is built on the list base type,
and includes the names, row.names, and class attributes. This
implementation requires values to be a list, names to be a character,
and row.names to be an integer.</p>
<pre class="r"><code>new_data.frame &lt;- function(values = list(), # nolint: object_name_linter.
                           names = character(length(values)),
                           row.names = integer(length(values))) { # nolint: object_name_linter.
  stopifnot(
    is.list(values),
    is.character(names),
    is.integer(row.names)
  )
  structure(values, names = names, row.names = row.names, class = &quot;data.frame&quot;)
}

new_data.frame()</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[],"data":[],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>new_data.frame(list(1:3, 4:6, 7:9))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":[""],"name":[1],"type":["int"],"align":["right"]},{"label":[""],"name":[2],"type":["int"],"align":["right"]},{"label":[""],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"7","_rn_":"0"},{"1":"2","2":"5","3":"8","_rn_":"0.1"},{"1":"3","2":"6","3":"9","_rn_":"0.2"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>new_data.frame(list(1:3, 4:6, 7:9), names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), row.names = 1:3)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["a"],"name":[1],"type":["int"],"align":["right"]},{"label":["b"],"name":[2],"type":["int"],"align":["right"]},{"label":["c"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"4","3":"7","_rn_":"1"},{"1":"2","2":"5","3":"8","_rn_":"2"},{"1":"3","2":"6","3":"9","_rn_":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>AR Solutions: Data frames are built on named lists of vectors, which
all have the same length. Besides the <code>class</code> and the column
names (<code>names</code>), the <code>row.names</code> are their only
further attribute. This must be a character vector with the same length
as the other vectors.</p>
<p>We need to provide the number of rows as an input to make it possible
to create data frames with 0 columns but multiple rows.</p>
<p>This leads to the following constructor:</p>
<pre class="r"><code>new_data.frame &lt;- function(x, n, row.names = NULL) { # nolint: object_name_linter.
  # nolint start: consecutive_stopifnot_linter.
  # Check if the underlying object is a list
  stopifnot(is.list(x))

  # Check all inputs are the same length
  # (This check also allows that x has length 0)
  stopifnot(all(lengths(x) == n))
  # nolint end

  if (is.null(row.names)) {
    # Use special row names helper from base R
    row.names &lt;- .set_row_names(n) # nolint: object_name_linter.
  } else {
    # Otherwise check that they&#39;re a character vector with the
    # correct length
    stopifnot(is.character(row.names), length(row.names) == n)
  }

  structure(
    x,
    class = &quot;data.frame&quot;,
    row.names = row.names
  )
}

# Test
x &lt;- list(a = 1, b = 2)
new_data.frame(x, n = 1)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["a"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["b"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"2"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>new_data.frame(x, n = 1, row.names = &quot;l1&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["a"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["b"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"2","_rn_":"l1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># Create a data frame with 0 columns and 2 rows
new_data.frame(list(), n = 2)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[],"data":[],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Note: AR Solutions approach also validates that all inputs are same
length, and supports creation of dataframes with 0 columns but multiple
rows.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Enhance my <code>factor()</code> helper to have better behaviour
when one or more <code>values</code> is not found in
<code>levels</code>. What does <code>base::factor()</code> do in this
situation?</li>
</ol>
<pre class="r"><code>new_factor &lt;- function(x = integer(), levels = character()) {
  stopifnot(
    is.integer(x),
    is.character(levels)
  )

  structure(
    x,
    levels = levels,
    class = &quot;factor&quot;
  )
}</code></pre>
<p>Answer: the fix is to update <code>validate_factor()</code> to allow
<code>NA</code> values, since the helper already fills in
<code>NA</code> when <code>values</code> is not found in
<code>levels</code>. This matches the behavior of
<code>base::factor()</code>.</p>
<pre class="r"><code>validate_factor &lt;- function(x) {
  values &lt;- unclass(x)
  levels &lt;- attr(x, &quot;levels&quot;)

  if (!all(is.na(values) | values &gt; 0)) {
    stop(
      &quot;All non-missing `x` values must be greater than zero&quot;,
      call. = FALSE
    )
  }

  if (length(levels) &lt; max(values, na.rm = TRUE)) {
    stop(
      &quot;There must be at least as many `levels` as possible values in `x`&quot;,
      call. = FALSE
    )
  }

  x
}

my_factor &lt;- function(x = character(), levels = unique(x)) {
  ind &lt;- match(x, levels)
  validate_factor(new_factor(ind, levels))
}

factor(c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;), levels = &quot;a&quot;)</code></pre>
<pre><code>#&gt; [1] a    a    &lt;NA&gt;
#&gt; Levels: a</code></pre>
<pre class="r"><code>my_factor(c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;), levels = &quot;a&quot;)</code></pre>
<pre><code>#&gt; [1] a    a    &lt;NA&gt;
#&gt; Levels: a</code></pre>
<p>AR Solutions: <code>base::factor()</code> converts these values
(silently) into <code>NA</code>s.</p>
<p>The <code>factor()</code> helper including the constructor
(<code>new_factor()</code>) and its validator
(<code>validate_factor()</code>) were given in <em>Advanced R</em>.
However, as the goal of this question is to throw an early error within
the helper, we only repeat the code for the helper:</p>
<p>To improve the <code>factor()</code> helper we choose to return an
informative error message instead.</p>
<pre class="r"><code>factor2 &lt;- function(x, levels = unique(x)) {
  new_levels &lt;- match(x, levels)

  # Error if levels don&#39;t include all values
  missing &lt;- unique(setdiff(x, levels))
  if (length(missing) &gt; 0) {
    stop(
      &quot;The following values do not occur in the levels of x: &quot;,
      paste0(&quot;&#39;&quot;, missing, &quot;&#39;&quot;, collapse = &quot;, &quot;), &quot;.&quot;,
      call. = FALSE
    )
  }

  validate_factor(new_factor(new_levels, levels))
}

# Test
try(factor2(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), levels = c(&quot;a&quot;, &quot;b&quot;)))</code></pre>
<pre><code>#&gt; Error : The following values do not occur in the levels of x: &#39;c&#39;.</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Carefully read the source code of <code>factor()</code>. What does
it do that my constructor does not?</li>
</ol>
<pre class="r"><code>factor(c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;), labels = c(&quot;alpha&quot;, &quot;beta&quot;, &quot;beta&quot;))</code></pre>
<pre><code>#&gt; [1] alpha alpha beta  beta 
#&gt; Levels: alpha beta</code></pre>
<pre class="r"><code>class(factor(1:10, ordered = TRUE))</code></pre>
<pre><code>#&gt; [1] &quot;ordered&quot; &quot;factor&quot;</code></pre>
<p>Answer: the base implementation:</p>
<ul>
<li>sets the value to <code>character(0)</code> if the value is
null</li>
<li>retains value names</li>
<li>allows an upper bound on the number of levels,
<code>nmax</code></li>
<li>coerces the value to character</li>
<li>provides a method for excluding values from levels,
<code>exclude</code></li>
<li>provides <code>labels</code> for remapping factors</li>
<li>adds an “ordered” class if the value is ordered
(<code>ordered = TRUE</code>)</li>
</ul>
<p>Note: labels are an interesting and unexpected feature of
<code>factor()</code></p>
<pre class="r"><code>factor</code></pre>
<pre><code>#&gt; function (x = character(), levels, labels = levels, exclude = NA, 
#&gt;     ordered = is.ordered(x), nmax = NA) 
#&gt; {
#&gt;     if (is.null(x)) 
#&gt;         x &lt;- character()
#&gt;     nx &lt;- names(x)
#&gt;     if (missing(levels)) {
#&gt;         y &lt;- unique(x, nmax = nmax)
#&gt;         ind &lt;- order(y)
#&gt;         levels &lt;- unique(as.character(y)[ind])
#&gt;     }
#&gt;     force(ordered)
#&gt;     if (!is.character(x)) 
#&gt;         x &lt;- as.character(x)
#&gt;     levels &lt;- levels[is.na(match(levels, exclude))]
#&gt;     f &lt;- match(x, levels)
#&gt;     if (!is.null(nx)) 
#&gt;         names(f) &lt;- nx
#&gt;     if (missing(labels)) {
#&gt;         levels(f) &lt;- as.character(levels)
#&gt;     }
#&gt;     else {
#&gt;         nlab &lt;- length(labels)
#&gt;         if (nlab == length(levels)) {
#&gt;             nlevs &lt;- unique(xlevs &lt;- as.character(labels))
#&gt;             at &lt;- attributes(f)
#&gt;             at$levels &lt;- nlevs
#&gt;             f &lt;- match(xlevs, nlevs)[f]
#&gt;             attributes(f) &lt;- at
#&gt;         }
#&gt;         else if (nlab == 1L) 
#&gt;             levels(f) &lt;- paste0(labels, seq_along(levels))
#&gt;         else stop(gettextf(&quot;invalid &#39;labels&#39;; length %d should be 1 or %d&quot;, 
#&gt;             nlab, length(levels)), domain = NA)
#&gt;     }
#&gt;     class(f) &lt;- c(if (ordered) &quot;ordered&quot;, &quot;factor&quot;)
#&gt;     f
#&gt; }
#&gt; &lt;bytecode: 0x7fb45126c2e8&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<p>AR Solutions: The original implementation
(<code>base::factor()</code>) allows more flexible input for
<code>x</code>. It coerces <code>x</code> to character or replaces it
with <code>character(0)</code> (in case of <code>NULL</code>). It also
ensures that the <code>levels</code> are unique. This is achieved by
setting them via <code>base::levels&lt;-</code>, which fails when
duplicate values are supplied.</p>
<p>Note: I missed the fact that <code>base::levels&lt;-</code> fails
when duplicate values are supplied.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Factors have an optional “contrasts” attribute. Read the help for
<code>C()</code>, and briefly describe the purpose of the attribute.
What type should it have? Rewrite the <code>new_factor()</code>
constructor to include this attribute.</li>
</ol>
<p>Answer: per the “contrast {stats}” documentation, contrast matrices
are used in fitting analysis of variance and regression models, so the
attribute should be a matrix.</p>
<pre class="r"><code>new_factor &lt;- function(x = integer(), levels = character(), contr = matrix()) {
  stopifnot(is.integer(x), is.character(levels), is.matrix(contr))

  structure(
    x,
    levels = levels,
    class = &quot;factor&quot;,
    contrasts = contr
  )
}</code></pre>
<p>AR Solutions: When factor variables (representing nominal or ordinal
information) are used in statistical models, they are typically encoded
as dummy variables and by default each level is compared with the first
factor level. However, many different encodings (“contrasts”) are
possible, see <a
href="https://en.wikipedia.org/wiki/Contrast_(statistics)">Contrast</a>.</p>
<p>Within R’s formula interface you can wrap a factor in
<code>stats::C()</code> and specify the contrast of your choice.
Alternatively, you can set the <code>contrasts</code> attribute of your
factor variable, which accepts matrix input. (See
<code>?contr.helmert</code> or similar for details.)</p>
<p>Our updated <code>new_factor()</code> constructor gets a
<code>contrasts</code> argument, which accepts a numeric matrix or
<code>NULL</code> (default).</p>
<pre class="r"><code># Updated new_factor() constructor
new_factor &lt;- function(x = integer(),
                       levels = character(),
                       contrasts = NULL) {
  # nolint start: consecutive_stopifnot_linter.
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))
  # nolint end

  if (!is.null(constrasts)) { # nolint: object_usage_linter. not sure why lintr flags this.
    stopifnot(is.matrix(contrasts) &amp;&amp; is.numeric(contrasts)) # nolint: conjunct_test_linter.
  }

  structure(
    x,
    levels = levels,
    class = &quot;factor&quot;,
    contrasts = contrasts
  )
}</code></pre>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Read the documentation for <code>utils::as.roman()</code>. How would
you write a constructor for this class? Does it need a validator? What
might a helper do?</li>
</ol>
<pre class="r"><code>dput(as.roman(3899))</code></pre>
<pre><code>#&gt; structure(3899L, class = &quot;roman&quot;)</code></pre>
<pre class="r"><code>new_roman &lt;- function(x = integer()) {
  stopifnot(is.integer(x))

  structure(
    x,
    class = &quot;roman&quot;
  )
}

new_roman(2022L)</code></pre>
<pre><code>#&gt; [1] MMXXII</code></pre>
<p>Answer: the structure of the class “roman” is simple, an integer with
a defined class. A simple constructor would take an integer and return
an object of class “roman” as above. A validator is probably not needed,
but could validate that the integer is within the supported range of
integers (1-3899). A helper might coerce the number to be an integer
using <code>as.integer()</code>.</p>
<p>AR Solutions: This function transforms numeric input into Roman
numbers. It is built on the integer type, which results in the following
constructor.</p>
<pre class="r"><code>new_roman &lt;- function(x = integer()) {
  stopifnot(is.integer(x))
  structure(x, class = &quot;roman&quot;)
}</code></pre>
<p>The documentation tells us, that only values between 1 and 3899 are
uniquely represented, which we then include in our validation
function.</p>
<pre class="r"><code>validate_roman &lt;- function(x) {
  values &lt;- unclass(x)

  if (any(values &lt; 1 | values &gt; 3899)) {
    stop(
      &quot;Roman numbers must fall between 1 and 3899.&quot;,
      call. = FALSE
    )
  }

  x
}</code></pre>
<p>For convenience, we allow the user to also pass real values to a
helper function.</p>
<pre class="r"><code>roman &lt;- function(x = integer()) {
  x &lt;- as.integer(x)

  validate_roman(new_roman(x))
}

# Test
roman(c(1, 753, 2019))</code></pre>
<pre><code>#&gt; [1] I       DCCLIII MMXIX</code></pre>
<pre class="r"><code>try(roman(0))</code></pre>
<pre><code>#&gt; Error : Roman numbers must fall between 1 and 3899.</code></pre>
<hr />
</div>
<div id="exercises-2" class="section level2">
<h2>13.4.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Read the source code for <code>t()</code> and <code>t.test()</code>
and confirm that <code>t.test()</code> is an S3 generic and not an S3
method. What happens if you create an object with class
<code>test</code> and call <code>t()</code> with it? Why?</li>
</ol>
<pre class="r"><code>x &lt;- structure(1:10, class = &quot;test&quot;)
t(x)</code></pre>
<pre><code>#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
#&gt; [1,]    1    2    3    4    5    6    7    8    9    10
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;test&quot;</code></pre>
<p>Answer: both <code>t()</code> and <code>t.test()</code> simply call
<code>UseMethod()</code>, and are S3 generics.</p>
<pre class="r"><code>t</code></pre>
<pre><code>#&gt; function (x) 
#&gt; UseMethod(&quot;t&quot;)
#&gt; &lt;bytecode: 0x7fb421be66f8&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>t.test</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; UseMethod(&quot;t.test&quot;)
#&gt; &lt;bytecode: 0x7fb440bf0a20&gt;
#&gt; &lt;environment: namespace:stats&gt;</code></pre>
<p>Creating an object with class <code>test</code> and calling
<code>t()</code> uses the default method since <code>t.test()</code> is
not a registered method for <code>t()</code>, as this code shows:</p>
<pre class="r"><code>methods(&quot;t&quot;)</code></pre>
<pre><code>#&gt; [1] t.data.frame  t.default     t.gtable*     t.ts*         t.vctrs_sclr* t.vctrs_vctr*
#&gt; see &#39;?methods&#39; for accessing help and source code</code></pre>
<pre class="r"><code>s3_dispatch(t(x))</code></pre>
<pre><code>#&gt; =&gt; t.test
#&gt;  * t.default</code></pre>
<p>AR Solutions: We can see that <code>t.test()</code> is a generic
because it calls <code>UseMethod()</code>.</p>
<pre class="r"><code># or simply call
ftype(t.test)</code></pre>
<pre><code>#&gt; [1] &quot;S3&quot;      &quot;generic&quot;</code></pre>
<p>Interestingly, R also provides helpers, which list functions that
look like methods, but in fact are not:</p>
<pre class="r"><code>tools::nonS3methods(&quot;stats&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;anova.lmlist&quot;        &quot;expand.model.frame&quot;  &quot;fitted.values&quot;       &quot;influence.measures&quot; 
#&gt; [5] &quot;lag.plot&quot;            &quot;t.test&quot;              &quot;plot.spec.phase&quot;     &quot;plot.spec.coherency&quot;</code></pre>
<p>When we create an object with class <code>test</code>,
<code>t()</code> dispatches to the <code>t.default()</code> method. This
happens, because <code>UseMethod()</code> simply searches for functions
named <code>paste0("generic", ".", c(class(x), "default"))</code>.</p>
<p>However, in older versions of R (pre R 4.0.0; when <em>Advanced
R</em> was written) this behaviour was slightly different. Instead of
dispatching to the <code>t.default()</code> method, the
<code>t.test()</code> generic was erroneously treated as a method of
<code>t()</code> which then dispatched to <code>t.test.default()</code>
or (when defined) to <code>t.test.test()</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What generics does the <code>table</code> class have methods
for?</li>
</ol>
<p>Answer: <code>s3_methods_class()</code> answers this question:</p>
<pre class="r"><code>s3_methods_class(&quot;table&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["generic"],"name":[1],"type":["chr"],"align":["left"]},{"label":["class"],"name":[2],"type":["chr"],"align":["left"]},{"label":["visible"],"name":[3],"type":["lgl"],"align":["right"]},{"label":["source"],"name":[4],"type":["chr"],"align":["left"]}],"data":[{"1":"[","2":"table","3":"TRUE","4":"base"},{"1":"aperm","2":"table","3":"TRUE","4":"base"},{"1":"as_tibble","2":"table","3":"FALSE","4":"registered S3method"},{"1":"as.data.frame","2":"table","3":"TRUE","4":"base"},{"1":"Axis","2":"table","3":"FALSE","4":"registered S3method"},{"1":"lines","2":"table","3":"FALSE","4":"registered S3method"},{"1":"plot","2":"table","3":"FALSE","4":"registered S3method"},{"1":"points","2":"table","3":"FALSE","4":"registered S3method"},{"1":"print","2":"table","3":"TRUE","4":"base"},{"1":"summary","2":"table","3":"TRUE","4":"base"},{"1":"tail","2":"table","3":"FALSE","4":"registered S3method"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>AR Solutions: This is a simple application of
<code>sloop::s3_methods_class()</code>.</p>
<p>Interestingly, the <code>table</code> class has a number of methods
designed to help plotting with base graphics.</p>
<pre class="r"><code>x &lt;- rpois(100, 5)
plot(table(x))</code></pre>
<p><img src="advanced-r-3_files/figure-html/unnamed-chunk-28-1.png" width="768" style="display: block; margin: auto;" /></p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What generics does the <code>ecdf</code> class have methods
for?</li>
</ol>
<p>Answer:</p>
<pre class="r"><code>s3_methods_class(&quot;ecdf&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["generic"],"name":[1],"type":["chr"],"align":["left"]},{"label":["class"],"name":[2],"type":["chr"],"align":["left"]},{"label":["visible"],"name":[3],"type":["lgl"],"align":["right"]},{"label":["source"],"name":[4],"type":["chr"],"align":["left"]}],"data":[{"1":"plot","2":"ecdf","3":"TRUE","4":"stats"},{"1":"print","2":"ecdf","3":"FALSE","4":"registered S3method"},{"1":"quantile","2":"ecdf","3":"FALSE","4":"registered S3method"},{"1":"summary","2":"ecdf","3":"FALSE","4":"registered S3method"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>AR Solutions: We use the same approach as above.</p>
<p>The methods are primarily designed for display (<code>plot()</code>,
<code>print()</code>, <code>summary()</code>), but you can also extract
quantiles with <code>quantile()</code>.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Which base generic has the greatest number of defined methods?</li>
</ol>
<p>Answer: using code from 6.2.5, identify generics and count defined
methods:</p>
<pre class="r"><code># from 6.2.5 exercises, this code makes a list of all functions in the base package
funs &lt;- Filter(is.function, mget(ls(&quot;package:base&quot;, all.names = TRUE), inherits = TRUE))

get_method_count &lt;- function(fname) {
  data.frame(
    name = fname,
    # this code should work but doesn&#39;t:
    # method_count = nrow(s3_methods_generic(fname)) # nolint: commented_code_linter.
    method_count = length(methods(fname))
  )
}

map_dfr(names(funs), get_method_count) |&gt;
  arrange(desc(method_count))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["name"],"name":[1],"type":["chr"],"align":["left"]},{"label":["method_count"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"print","2":"378"},{"1":"format","2":"180"},{"1":"[","2":"76"},{"1":"as.character","2":"54"},{"1":"summary","2":"44"},{"1":"[[","2":"38"},{"1":"plot","2":"37"},{"1":"as.data.frame","2":"34"},{"1":"$","2":"29"},{"1":"[<-","2":"26"},{"1":"$<-","2":"24"},{"1":"[[<-","2":"22"},{"1":"as.list","2":"20"},{"1":"c","2":"19"},{"1":"file","2":"17"},{"1":"all.equal","2":"12"},{"1":"rep","2":"12"},{"1":"xtfrm","2":"12"},{"1":"unique","2":"10"},{"1":"duplicated","2":"9"},{"1":"names","2":"9"},{"1":"as.Date","2":"8"},{"1":"as.matrix","2":"8"},{"1":"length","2":"8"},{"1":"mean","2":"8"},{"1":"names<-","2":"8"},{"1":"+","2":"7"},{"1":"as.double","2":"7"},{"1":"as.POSIXlt","2":"7"},{"1":"length<-","2":"7"},{"1":"row","2":"7"},{"1":"anyDuplicated","2":"6"},{"1":"as.POSIXct","2":"6"},{"1":"as.vector","2":"6"},{"1":"diff","2":"6"},{"1":"t","2":"6"},{"1":"write","2":"6"},{"1":"-","2":"5"},{"1":"|","2":"5"},{"1":"anyNA","2":"5"},{"1":"close","2":"5"},{"1":"conditionMessage","2":"5"},{"1":"is.na","2":"5"},{"1":"is.na<-","2":"5"},{"1":"labels","2":"5"},{"1":"max","2":"5"},{"1":"min","2":"5"},{"1":"subset","2":"5"},{"1":"!","2":"4"},{"1":"/","2":"4"},{"1":"&","2":"4"},{"1":"as.environment","2":"4"},{"1":"cbind","2":"4"},{"1":"cut","2":"4"},{"1":"dimnames<-","2":"4"},{"1":"open","2":"4"},{"1":"rbind","2":"4"},{"1":"split","2":"4"},{"1":"sum","2":"4"},{"1":"*","2":"3"},{"1":"==","2":"3"},{"1":"as.integer","2":"3"},{"1":"as.logical","2":"3"},{"1":"dim","2":"3"},{"1":"dimnames","2":"3"},{"1":"is.numeric","2":"3"},{"1":"kappa","2":"3"},{"1":"levels","2":"3"},{"1":"levels<-","2":"3"},{"1":"ls","2":"3"},{"1":"match","2":"3"},{"1":"merge","2":"3"},{"1":"pretty","2":"3"},{"1":"row.names<-","2":"3"},{"1":"seq","2":"3"},{"1":"sort","2":"3"},{"1":"!=","2":"2"},{"1":"%/%","2":"2"},{"1":"%%","2":"2"},{"1":"^","2":"2"},{"1":"<","2":"2"},{"1":"<=","2":"2"},{"1":">","2":"2"},{"1":">=","2":"2"},{"1":"aperm","2":"2"},{"1":"as.table","2":"2"},{"1":"body<-","2":"2"},{"1":"by","2":"2"},{"1":"dim<-","2":"2"},{"1":"dir","2":"2"},{"1":"drop","2":"2"},{"1":"droplevels","2":"2"},{"1":"formals<-","2":"2"},{"1":"getDLLRegisteredRoutines","2":"2"},{"1":"julian","2":"2"},{"1":"library","2":"2"},{"1":"list","2":"2"},{"1":"months","2":"2"},{"1":"qr","2":"2"},{"1":"quarters","2":"2"},{"1":"range","2":"2"},{"1":"rev","2":"2"},{"1":"round","2":"2"},{"1":"row.names","2":"2"},{"1":"rowsum","2":"2"},{"1":"solve","2":"2"},{"1":"split<-","2":"2"},{"1":"system","2":"2"},{"1":"toString","2":"2"},{"1":"transform","2":"2"},{"1":"trunc","2":"2"},{"1":"unlist","2":"2"},{"1":"weekdays","2":"2"},{"1":"which","2":"2"},{"1":"within","2":"2"},{"1":"as.array","2":"1"},{"1":"as.expression","2":"1"},{"1":"as.function","2":"1"},{"1":"as.null","2":"1"},{"1":"as.single","2":"1"},{"1":"attr","2":"1"},{"1":"chol","2":"1"},{"1":"conditionCall","2":"1"},{"1":"determinant","2":"1"},{"1":"dump","2":"1"},{"1":"eval","2":"1"},{"1":"factor","2":"1"},{"1":"flush","2":"1"},{"1":"gc","2":"1"},{"1":"interaction","2":"1"},{"1":"is.finite","2":"1"},{"1":"is.infinite","2":"1"},{"1":"is.nan","2":"1"},{"1":"isSymmetric","2":"1"},{"1":"kronecker","2":"1"},{"1":"lengths","2":"1"},{"1":"library.dynam","2":"1"},{"1":"mtfrm","2":"1"},{"1":"order","2":"1"},{"1":"remove","2":"1"},{"1":"save","2":"1"},{"1":"scale","2":"1"},{"1":"seek","2":"1"},{"1":"sequence","2":"1"},{"1":"sink","2":"1"},{"1":"source","2":"1"},{"1":"truncate","2":"1"},{"1":"units","2":"1"},{"1":"units<-","2":"1"},{"1":"url","2":"1"},{"1":"with","2":"1"},{"1":"-.Date","2":"0"},{"1":"-.POSIXt","2":"0"},{"1":":","2":"0"},{"1":"::","2":"0"},{"1":":::","2":"0"},{"1":"!.hexmode","2":"0"},{"1":"!.octmode","2":"0"},{"1":".__H__.cbind","2":"0"},{"1":".__H__.rbind","2":"0"},{"1":"...elt","2":"0"},{"1":"...length","2":"0"},{"1":"...names","2":"0"},{"1":"..getNamespace","2":"0"},{"1":".amatch_bounds","2":"0"},{"1":".amatch_costs","2":"0"},{"1":".bincode","2":"0"},{"1":".C","2":"0"},{"1":".cache_class","2":"0"},{"1":".Call","2":"0"},{"1":".Call.graphics","2":"0"},{"1":".class2","2":"0"},{"1":".col","2":"0"},{"1":".colMeans","2":"0"},{"1":".colSums","2":"0"},{"1":".Date","2":"0"},{"1":".decode_numeric_version","2":"0"},{"1":".Defunct","2":"0"},{"1":".deparseOpts","2":"0"},{"1":".Deprecated","2":"0"},{"1":".detach","2":"0"},{"1":".difftime","2":"0"},{"1":".doSortWrap","2":"0"},{"1":".doTrace","2":"0"},{"1":".doWrap","2":"0"},{"1":".dynLibs","2":"0"},{"1":".encode_numeric_version","2":"0"},{"1":".expand_R_libs_env_var","2":"0"},{"1":".External","2":"0"},{"1":".External.graphics","2":"0"},{"1":".External2","2":"0"},{"1":".First.sys","2":"0"},{"1":".format.zeros","2":"0"},{"1":".Fortran","2":"0"},{"1":".getNamespace","2":"0"},{"1":".getNamespaceInfo","2":"0"},{"1":".getRequiredPackages","2":"0"},{"1":".getRequiredPackages2","2":"0"},{"1":".gt","2":"0"},{"1":".gtn","2":"0"},{"1":".handleSimpleError","2":"0"},{"1":".Internal","2":"0"},{"1":".isMethodsDispatchOn","2":"0"},{"1":".isOpen","2":"0"},{"1":".kappa_tri","2":"0"},{"1":".kronecker","2":"0"},{"1":".libPaths","2":"0"},{"1":".make_numeric_version","2":"0"},{"1":".makeMessage","2":"0"},{"1":".mapply","2":"0"},{"1":".maskedMsg","2":"0"},{"1":".mergeExportMethods","2":"0"},{"1":".mergeImportMethods","2":"0"},{"1":".NotYetImplemented","2":"0"},{"1":".NotYetUsed","2":"0"},{"1":".OptRequireMethods","2":"0"},{"1":".packages","2":"0"},{"1":".packageStartupMessage","2":"0"},{"1":".POSIXct","2":"0"},{"1":".POSIXlt","2":"0"},{"1":".pretty","2":"0"},{"1":".Primitive","2":"0"},{"1":".primTrace","2":"0"},{"1":".primUntrace","2":"0"},{"1":".rmpkg","2":"0"},{"1":".row","2":"0"},{"1":".row_names_info","2":"0"},{"1":".rowMeans","2":"0"},{"1":".rowNamesDF<-","2":"0"},{"1":".rowSums","2":"0"},{"1":".S3method","2":"0"},{"1":".Script","2":"0"},{"1":".set_row_names","2":"0"},{"1":".signalSimpleWarning","2":"0"},{"1":".standard_regexps","2":"0"},{"1":".subset","2":"0"},{"1":".subset2","2":"0"},{"1":".TAOCP1997init","2":"0"},{"1":".traceback","2":"0"},{"1":".tryResumeInterrupt","2":"0"},{"1":".valid.factor","2":"0"},{"1":"(","2":"0"},{"1":"[.AsIs","2":"0"},{"1":"[.data.frame","2":"0"},{"1":"[.Date","2":"0"},{"1":"[.difftime","2":"0"},{"1":"[.Dlist","2":"0"},{"1":"[.DLLInfoList","2":"0"},{"1":"[.factor","2":"0"},{"1":"[.hexmode","2":"0"},{"1":"[.listof","2":"0"},{"1":"[.noquote","2":"0"},{"1":"[.numeric_version","2":"0"},{"1":"[.octmode","2":"0"},{"1":"[.POSIXct","2":"0"},{"1":"[.POSIXlt","2":"0"},{"1":"[.simple.list","2":"0"},{"1":"[.table","2":"0"},{"1":"[.warnings","2":"0"},{"1":"[[.data.frame","2":"0"},{"1":"[[.Date","2":"0"},{"1":"[[.factor","2":"0"},{"1":"[[.numeric_version","2":"0"},{"1":"[[.POSIXct","2":"0"},{"1":"[[.POSIXlt","2":"0"},{"1":"[[<-.data.frame","2":"0"},{"1":"[[<-.factor","2":"0"},{"1":"[[<-.numeric_version","2":"0"},{"1":"[[<-.POSIXlt","2":"0"},{"1":"[<-.data.frame","2":"0"},{"1":"[<-.Date","2":"0"},{"1":"[<-.difftime","2":"0"},{"1":"[<-.factor","2":"0"},{"1":"[<-.numeric_version","2":"0"},{"1":"[<-.POSIXct","2":"0"},{"1":"[<-.POSIXlt","2":"0"},{"1":"{","2":"0"},{"1":"@","2":"0"},{"1":"@<-","2":"0"},{"1":"*.difftime","2":"0"},{"1":"/.difftime","2":"0"},{"1":"&.hexmode","2":"0"},{"1":"&.octmode","2":"0"},{"1":"&&","2":"0"},{"1":"%*%","2":"0"},{"1":"%in%","2":"0"},{"1":"%o%","2":"0"},{"1":"%x%","2":"0"},{"1":"+.Date","2":"0"},{"1":"+.POSIXt","2":"0"},{"1":"<-","2":"0"},{"1":"<<-","2":"0"},{"1":"=","2":"0"},{"1":"|.hexmode","2":"0"},{"1":"|.octmode","2":"0"},{"1":"||","2":"0"},{"1":"~","2":"0"},{"1":"$.DLLInfo","2":"0"},{"1":"$.package_version","2":"0"},{"1":"$<-.data.frame","2":"0"},{"1":"abbreviate","2":"0"},{"1":"abs","2":"0"},{"1":"acos","2":"0"},{"1":"acosh","2":"0"},{"1":"activeBindingFunction","2":"0"},{"1":"addNA","2":"0"},{"1":"addTaskCallback","2":"0"},{"1":"agrep","2":"0"},{"1":"agrepl","2":"0"},{"1":"alist","2":"0"},{"1":"all","2":"0"},{"1":"all.equal.character","2":"0"},{"1":"all.equal.default","2":"0"},{"1":"all.equal.environment","2":"0"},{"1":"all.equal.envRefClass","2":"0"},{"1":"all.equal.factor","2":"0"},{"1":"all.equal.formula","2":"0"},{"1":"all.equal.function","2":"0"},{"1":"all.equal.language","2":"0"},{"1":"all.equal.list","2":"0"},{"1":"all.equal.numeric","2":"0"},{"1":"all.equal.POSIXt","2":"0"},{"1":"all.equal.raw","2":"0"},{"1":"all.names","2":"0"},{"1":"all.vars","2":"0"},{"1":"allowInterrupts","2":"0"},{"1":"any","2":"0"},{"1":"anyDuplicated.array","2":"0"},{"1":"anyDuplicated.data.frame","2":"0"},{"1":"anyDuplicated.default","2":"0"},{"1":"anyDuplicated.matrix","2":"0"},{"1":"anyNA.data.frame","2":"0"},{"1":"anyNA.numeric_version","2":"0"},{"1":"anyNA.POSIXlt","2":"0"},{"1":"aperm.default","2":"0"},{"1":"aperm.table","2":"0"},{"1":"append","2":"0"},{"1":"apply","2":"0"},{"1":"Arg","2":"0"},{"1":"args","2":"0"},{"1":"array","2":"0"},{"1":"arrayInd","2":"0"},{"1":"as.array.default","2":"0"},{"1":"as.call","2":"0"},{"1":"as.character.condition","2":"0"},{"1":"as.character.Date","2":"0"},{"1":"as.character.default","2":"0"},{"1":"as.character.error","2":"0"},{"1":"as.character.factor","2":"0"},{"1":"as.character.hexmode","2":"0"},{"1":"as.character.numeric_version","2":"0"},{"1":"as.character.octmode","2":"0"},{"1":"as.character.POSIXt","2":"0"},{"1":"as.character.srcref","2":"0"},{"1":"as.complex","2":"0"},{"1":"as.data.frame.array","2":"0"},{"1":"as.data.frame.AsIs","2":"0"},{"1":"as.data.frame.character","2":"0"},{"1":"as.data.frame.complex","2":"0"},{"1":"as.data.frame.data.frame","2":"0"},{"1":"as.data.frame.Date","2":"0"},{"1":"as.data.frame.default","2":"0"},{"1":"as.data.frame.difftime","2":"0"},{"1":"as.data.frame.factor","2":"0"},{"1":"as.data.frame.integer","2":"0"},{"1":"as.data.frame.list","2":"0"},{"1":"as.data.frame.logical","2":"0"},{"1":"as.data.frame.matrix","2":"0"},{"1":"as.data.frame.model.matrix","2":"0"},{"1":"as.data.frame.noquote","2":"0"},{"1":"as.data.frame.numeric","2":"0"},{"1":"as.data.frame.numeric_version","2":"0"},{"1":"as.data.frame.ordered","2":"0"},{"1":"as.data.frame.POSIXct","2":"0"},{"1":"as.data.frame.POSIXlt","2":"0"},{"1":"as.data.frame.raw","2":"0"},{"1":"as.data.frame.table","2":"0"},{"1":"as.data.frame.ts","2":"0"},{"1":"as.data.frame.vector","2":"0"},{"1":"as.Date.character","2":"0"},{"1":"as.Date.default","2":"0"},{"1":"as.Date.factor","2":"0"},{"1":"as.Date.numeric","2":"0"},{"1":"as.Date.POSIXct","2":"0"},{"1":"as.Date.POSIXlt","2":"0"},{"1":"as.difftime","2":"0"},{"1":"as.double.difftime","2":"0"},{"1":"as.double.POSIXlt","2":"0"},{"1":"as.expression.default","2":"0"},{"1":"as.factor","2":"0"},{"1":"as.function.default","2":"0"},{"1":"as.hexmode","2":"0"},{"1":"as.list.data.frame","2":"0"},{"1":"as.list.Date","2":"0"},{"1":"as.list.default","2":"0"},{"1":"as.list.difftime","2":"0"},{"1":"as.list.environment","2":"0"},{"1":"as.list.factor","2":"0"},{"1":"as.list.function","2":"0"},{"1":"as.list.numeric_version","2":"0"},{"1":"as.list.POSIXct","2":"0"},{"1":"as.list.POSIXlt","2":"0"},{"1":"as.logical.factor","2":"0"},{"1":"as.matrix.data.frame","2":"0"},{"1":"as.matrix.default","2":"0"},{"1":"as.matrix.noquote","2":"0"},{"1":"as.matrix.POSIXlt","2":"0"},{"1":"as.name","2":"0"},{"1":"as.null.default","2":"0"},{"1":"as.numeric","2":"0"},{"1":"as.numeric_version","2":"0"},{"1":"as.octmode","2":"0"},{"1":"as.ordered","2":"0"},{"1":"as.package_version","2":"0"},{"1":"as.pairlist","2":"0"},{"1":"as.POSIXct.Date","2":"0"},{"1":"as.POSIXct.default","2":"0"},{"1":"as.POSIXct.numeric","2":"0"},{"1":"as.POSIXct.POSIXlt","2":"0"},{"1":"as.POSIXlt.character","2":"0"},{"1":"as.POSIXlt.Date","2":"0"},{"1":"as.POSIXlt.default","2":"0"},{"1":"as.POSIXlt.factor","2":"0"},{"1":"as.POSIXlt.numeric","2":"0"},{"1":"as.POSIXlt.POSIXct","2":"0"},{"1":"as.qr","2":"0"},{"1":"as.raw","2":"0"},{"1":"as.single.default","2":"0"},{"1":"as.symbol","2":"0"},{"1":"as.table.default","2":"0"},{"1":"as.vector.data.frame","2":"0"},{"1":"as.vector.factor","2":"0"},{"1":"as.vector.POSIXlt","2":"0"},{"1":"asin","2":"0"},{"1":"asinh","2":"0"},{"1":"asNamespace","2":"0"},{"1":"asplit","2":"0"},{"1":"asS3","2":"0"},{"1":"asS4","2":"0"},{"1":"assign","2":"0"},{"1":"atan","2":"0"},{"1":"atan2","2":"0"},{"1":"atanh","2":"0"},{"1":"attach","2":"0"},{"1":"attachNamespace","2":"0"},{"1":"attr.all.equal","2":"0"},{"1":"attr<-","2":"0"},{"1":"attributes","2":"0"},{"1":"attributes<-","2":"0"},{"1":"autoload","2":"0"},{"1":"autoloader","2":"0"},{"1":"backsolve","2":"0"},{"1":"baseenv","2":"0"},{"1":"basename","2":"0"},{"1":"besselI","2":"0"},{"1":"besselJ","2":"0"},{"1":"besselK","2":"0"},{"1":"besselY","2":"0"},{"1":"beta","2":"0"},{"1":"bindingIsActive","2":"0"},{"1":"bindingIsLocked","2":"0"},{"1":"bindtextdomain","2":"0"},{"1":"bitwAnd","2":"0"},{"1":"bitwNot","2":"0"},{"1":"bitwOr","2":"0"},{"1":"bitwShiftL","2":"0"},{"1":"bitwShiftR","2":"0"},{"1":"bitwXor","2":"0"},{"1":"body","2":"0"},{"1":"bquote","2":"0"},{"1":"break","2":"0"},{"1":"browser","2":"0"},{"1":"browserCondition","2":"0"},{"1":"browserSetDebug","2":"0"},{"1":"browserText","2":"0"},{"1":"builtins","2":"0"},{"1":"by.data.frame","2":"0"},{"1":"by.default","2":"0"},{"1":"bzfile","2":"0"},{"1":"c.Date","2":"0"},{"1":"c.difftime","2":"0"},{"1":"c.factor","2":"0"},{"1":"c.noquote","2":"0"},{"1":"c.numeric_version","2":"0"},{"1":"c.POSIXct","2":"0"},{"1":"c.POSIXlt","2":"0"},{"1":"c.warnings","2":"0"},{"1":"call","2":"0"},{"1":"callCC","2":"0"},{"1":"capabilities","2":"0"},{"1":"casefold","2":"0"},{"1":"cat","2":"0"},{"1":"cbind.data.frame","2":"0"},{"1":"ceiling","2":"0"},{"1":"char.expand","2":"0"},{"1":"character","2":"0"},{"1":"charmatch","2":"0"},{"1":"charToRaw","2":"0"},{"1":"chartr","2":"0"},{"1":"check_tzones","2":"0"},{"1":"chkDots","2":"0"},{"1":"chol.default","2":"0"},{"1":"chol2inv","2":"0"},{"1":"choose","2":"0"},{"1":"class","2":"0"},{"1":"class<-","2":"0"},{"1":"clearPushBack","2":"0"},{"1":"close.connection","2":"0"},{"1":"close.srcfile","2":"0"},{"1":"close.srcfilealias","2":"0"},{"1":"closeAllConnections","2":"0"},{"1":"col","2":"0"},{"1":"colMeans","2":"0"},{"1":"colnames","2":"0"},{"1":"colnames<-","2":"0"},{"1":"colSums","2":"0"},{"1":"commandArgs","2":"0"},{"1":"comment","2":"0"},{"1":"comment<-","2":"0"},{"1":"complex","2":"0"},{"1":"computeRestarts","2":"0"},{"1":"conditionCall.condition","2":"0"},{"1":"conditionMessage.condition","2":"0"},{"1":"conflictRules","2":"0"},{"1":"conflicts","2":"0"},{"1":"Conj","2":"0"},{"1":"contributors","2":"0"},{"1":"cos","2":"0"},{"1":"cosh","2":"0"},{"1":"cospi","2":"0"},{"1":"crossprod","2":"0"},{"1":"Cstack_info","2":"0"},{"1":"cummax","2":"0"},{"1":"cummin","2":"0"},{"1":"cumprod","2":"0"},{"1":"cumsum","2":"0"},{"1":"curlGetHeaders","2":"0"},{"1":"cut.Date","2":"0"},{"1":"cut.default","2":"0"},{"1":"cut.POSIXt","2":"0"},{"1":"data.class","2":"0"},{"1":"data.frame","2":"0"},{"1":"data.matrix","2":"0"},{"1":"date","2":"0"},{"1":"debug","2":"0"},{"1":"debuggingState","2":"0"},{"1":"debugonce","2":"0"},{"1":"default.stringsAsFactors","2":"0"},{"1":"delayedAssign","2":"0"},{"1":"deparse","2":"0"},{"1":"deparse1","2":"0"},{"1":"det","2":"0"},{"1":"detach","2":"0"},{"1":"determinant.matrix","2":"0"},{"1":"dget","2":"0"},{"1":"diag","2":"0"},{"1":"diag<-","2":"0"},{"1":"diff.Date","2":"0"},{"1":"diff.default","2":"0"},{"1":"diff.difftime","2":"0"},{"1":"diff.POSIXt","2":"0"},{"1":"difftime","2":"0"},{"1":"digamma","2":"0"},{"1":"dim.data.frame","2":"0"},{"1":"dimnames.data.frame","2":"0"},{"1":"dimnames<-.data.frame","2":"0"},{"1":"dir.create","2":"0"},{"1":"dir.exists","2":"0"},{"1":"dirname","2":"0"},{"1":"do.call","2":"0"},{"1":"dontCheck","2":"0"},{"1":"double","2":"0"},{"1":"dput","2":"0"},{"1":"dQuote","2":"0"},{"1":"droplevels.data.frame","2":"0"},{"1":"droplevels.factor","2":"0"},{"1":"duplicated.array","2":"0"},{"1":"duplicated.data.frame","2":"0"},{"1":"duplicated.default","2":"0"},{"1":"duplicated.matrix","2":"0"},{"1":"duplicated.numeric_version","2":"0"},{"1":"duplicated.POSIXlt","2":"0"},{"1":"duplicated.warnings","2":"0"},{"1":"dyn.load","2":"0"},{"1":"dyn.unload","2":"0"},{"1":"dynGet","2":"0"},{"1":"eapply","2":"0"},{"1":"eigen","2":"0"},{"1":"emptyenv","2":"0"},{"1":"enc2native","2":"0"},{"1":"enc2utf8","2":"0"},{"1":"encodeString","2":"0"},{"1":"Encoding","2":"0"},{"1":"Encoding<-","2":"0"},{"1":"endsWith","2":"0"},{"1":"enquote","2":"0"},{"1":"env.profile","2":"0"},{"1":"environment","2":"0"},{"1":"environment<-","2":"0"},{"1":"environmentIsLocked","2":"0"},{"1":"environmentName","2":"0"},{"1":"errorCondition","2":"0"},{"1":"eval.parent","2":"0"},{"1":"evalq","2":"0"},{"1":"exists","2":"0"},{"1":"exp","2":"0"},{"1":"expand.grid","2":"0"},{"1":"expm1","2":"0"},{"1":"expression","2":"0"},{"1":"extSoftVersion","2":"0"},{"1":"factorial","2":"0"},{"1":"fifo","2":"0"},{"1":"file.access","2":"0"},{"1":"file.append","2":"0"},{"1":"file.choose","2":"0"},{"1":"file.copy","2":"0"},{"1":"file.create","2":"0"},{"1":"file.exists","2":"0"},{"1":"file.info","2":"0"},{"1":"file.link","2":"0"},{"1":"file.mode","2":"0"},{"1":"file.mtime","2":"0"},{"1":"file.path","2":"0"},{"1":"file.remove","2":"0"},{"1":"file.rename","2":"0"},{"1":"file.show","2":"0"},{"1":"file.size","2":"0"},{"1":"file.symlink","2":"0"},{"1":"Filter","2":"0"},{"1":"Find","2":"0"},{"1":"find.package","2":"0"},{"1":"findInterval","2":"0"},{"1":"findPackageEnv","2":"0"},{"1":"findRestart","2":"0"},{"1":"floor","2":"0"},{"1":"flush.connection","2":"0"},{"1":"for","2":"0"},{"1":"force","2":"0"},{"1":"forceAndCall","2":"0"},{"1":"formals","2":"0"},{"1":"format.AsIs","2":"0"},{"1":"format.data.frame","2":"0"},{"1":"format.Date","2":"0"},{"1":"format.default","2":"0"},{"1":"format.difftime","2":"0"},{"1":"format.factor","2":"0"},{"1":"format.hexmode","2":"0"},{"1":"format.info","2":"0"},{"1":"format.libraryIQR","2":"0"},{"1":"format.numeric_version","2":"0"},{"1":"format.octmode","2":"0"},{"1":"format.packageInfo","2":"0"},{"1":"format.POSIXct","2":"0"},{"1":"format.POSIXlt","2":"0"},{"1":"format.pval","2":"0"},{"1":"format.summaryDefault","2":"0"},{"1":"formatC","2":"0"},{"1":"formatDL","2":"0"},{"1":"forwardsolve","2":"0"},{"1":"function","2":"0"},{"1":"gamma","2":"0"},{"1":"gc.time","2":"0"},{"1":"gcinfo","2":"0"},{"1":"gctorture","2":"0"},{"1":"gctorture2","2":"0"},{"1":"get","2":"0"},{"1":"get0","2":"0"},{"1":"getAllConnections","2":"0"},{"1":"getCallingDLL","2":"0"},{"1":"getCallingDLLe","2":"0"},{"1":"getConnection","2":"0"},{"1":"getDLLRegisteredRoutines.character","2":"0"},{"1":"getDLLRegisteredRoutines.DLLInfo","2":"0"},{"1":"getElement","2":"0"},{"1":"geterrmessage","2":"0"},{"1":"getExportedValue","2":"0"},{"1":"getHook","2":"0"},{"1":"getLoadedDLLs","2":"0"},{"1":"getNamespace","2":"0"},{"1":"getNamespaceExports","2":"0"},{"1":"getNamespaceImports","2":"0"},{"1":"getNamespaceInfo","2":"0"},{"1":"getNamespaceName","2":"0"},{"1":"getNamespaceUsers","2":"0"},{"1":"getNamespaceVersion","2":"0"},{"1":"getNativeSymbolInfo","2":"0"},{"1":"getOption","2":"0"},{"1":"getRversion","2":"0"},{"1":"getSrcLines","2":"0"},{"1":"getTaskCallbackNames","2":"0"},{"1":"gettext","2":"0"},{"1":"gettextf","2":"0"},{"1":"getwd","2":"0"},{"1":"gl","2":"0"},{"1":"globalCallingHandlers","2":"0"},{"1":"globalenv","2":"0"},{"1":"gregexec","2":"0"},{"1":"gregexpr","2":"0"},{"1":"grep","2":"0"},{"1":"grepl","2":"0"},{"1":"grepRaw","2":"0"},{"1":"grouping","2":"0"},{"1":"gsub","2":"0"},{"1":"gzcon","2":"0"},{"1":"gzfile","2":"0"},{"1":"I","2":"0"},{"1":"iconv","2":"0"},{"1":"iconvlist","2":"0"},{"1":"icuGetCollate","2":"0"},{"1":"icuSetCollate","2":"0"},{"1":"identical","2":"0"},{"1":"identity","2":"0"},{"1":"if","2":"0"},{"1":"ifelse","2":"0"},{"1":"Im","2":"0"},{"1":"importIntoEnv","2":"0"},{"1":"infoRDS","2":"0"},{"1":"inherits","2":"0"},{"1":"integer","2":"0"},{"1":"interactive","2":"0"},{"1":"intersect","2":"0"},{"1":"intToBits","2":"0"},{"1":"intToUtf8","2":"0"},{"1":"inverse.rle","2":"0"},{"1":"invisible","2":"0"},{"1":"invokeRestart","2":"0"},{"1":"invokeRestartInteractively","2":"0"},{"1":"is.array","2":"0"},{"1":"is.atomic","2":"0"},{"1":"is.call","2":"0"},{"1":"is.character","2":"0"},{"1":"is.complex","2":"0"},{"1":"is.data.frame","2":"0"},{"1":"is.double","2":"0"},{"1":"is.element","2":"0"},{"1":"is.environment","2":"0"},{"1":"is.expression","2":"0"},{"1":"is.factor","2":"0"},{"1":"is.function","2":"0"},{"1":"is.integer","2":"0"},{"1":"is.language","2":"0"},{"1":"is.list","2":"0"},{"1":"is.loaded","2":"0"},{"1":"is.logical","2":"0"},{"1":"is.matrix","2":"0"},{"1":"is.na.data.frame","2":"0"},{"1":"is.na.numeric_version","2":"0"},{"1":"is.na.POSIXlt","2":"0"},{"1":"is.na<-.default","2":"0"},{"1":"is.na<-.factor","2":"0"},{"1":"is.na<-.numeric_version","2":"0"},{"1":"is.name","2":"0"},{"1":"is.null","2":"0"},{"1":"is.numeric_version","2":"0"},{"1":"is.numeric.Date","2":"0"},{"1":"is.numeric.difftime","2":"0"},{"1":"is.numeric.POSIXt","2":"0"},{"1":"is.object","2":"0"},{"1":"is.ordered","2":"0"},{"1":"is.package_version","2":"0"},{"1":"is.pairlist","2":"0"},{"1":"is.primitive","2":"0"},{"1":"is.qr","2":"0"},{"1":"is.R","2":"0"},{"1":"is.raw","2":"0"},{"1":"is.recursive","2":"0"},{"1":"is.single","2":"0"},{"1":"is.symbol","2":"0"},{"1":"is.table","2":"0"},{"1":"is.unsorted","2":"0"},{"1":"is.vector","2":"0"},{"1":"isa","2":"0"},{"1":"isatty","2":"0"},{"1":"isBaseNamespace","2":"0"},{"1":"isdebugged","2":"0"},{"1":"isFALSE","2":"0"},{"1":"isIncomplete","2":"0"},{"1":"isNamespace","2":"0"},{"1":"isNamespaceLoaded","2":"0"},{"1":"ISOdate","2":"0"},{"1":"ISOdatetime","2":"0"},{"1":"isOpen","2":"0"},{"1":"isRestart","2":"0"},{"1":"isS4","2":"0"},{"1":"isSeekable","2":"0"},{"1":"isSymmetric.matrix","2":"0"},{"1":"isTRUE","2":"0"},{"1":"jitter","2":"0"},{"1":"julian.Date","2":"0"},{"1":"julian.POSIXt","2":"0"},{"1":"kappa.default","2":"0"},{"1":"kappa.lm","2":"0"},{"1":"kappa.qr","2":"0"},{"1":"l10n_info","2":"0"},{"1":"La_library","2":"0"},{"1":"La_version","2":"0"},{"1":"La.svd","2":"0"},{"1":"labels.default","2":"0"},{"1":"lapply","2":"0"},{"1":"lazyLoad","2":"0"},{"1":"lazyLoadDBexec","2":"0"},{"1":"lazyLoadDBfetch","2":"0"},{"1":"lbeta","2":"0"},{"1":"lchoose","2":"0"},{"1":"length.POSIXlt","2":"0"},{"1":"length<-.Date","2":"0"},{"1":"length<-.difftime","2":"0"},{"1":"length<-.factor","2":"0"},{"1":"length<-.POSIXct","2":"0"},{"1":"length<-.POSIXlt","2":"0"},{"1":"levels.default","2":"0"},{"1":"levels<-.factor","2":"0"},{"1":"lfactorial","2":"0"},{"1":"lgamma","2":"0"},{"1":"libcurlVersion","2":"0"},{"1":"library.dynam.unload","2":"0"},{"1":"licence","2":"0"},{"1":"license","2":"0"},{"1":"list.dirs","2":"0"},{"1":"list.files","2":"0"},{"1":"list2DF","2":"0"},{"1":"list2env","2":"0"},{"1":"load","2":"0"},{"1":"loadedNamespaces","2":"0"},{"1":"loadingNamespaceInfo","2":"0"},{"1":"loadNamespace","2":"0"},{"1":"local","2":"0"},{"1":"lockBinding","2":"0"},{"1":"lockEnvironment","2":"0"},{"1":"log","2":"0"},{"1":"log10","2":"0"},{"1":"log1p","2":"0"},{"1":"log2","2":"0"},{"1":"logb","2":"0"},{"1":"logical","2":"0"},{"1":"lower.tri","2":"0"},{"1":"make.names","2":"0"},{"1":"make.unique","2":"0"},{"1":"makeActiveBinding","2":"0"},{"1":"Map","2":"0"},{"1":"mapply","2":"0"},{"1":"margin.table","2":"0"},{"1":"marginSums","2":"0"},{"1":"mat.or.vec","2":"0"},{"1":"match.arg","2":"0"},{"1":"match.call","2":"0"},{"1":"match.fun","2":"0"},{"1":"Math.data.frame","2":"0"},{"1":"Math.Date","2":"0"},{"1":"Math.difftime","2":"0"},{"1":"Math.factor","2":"0"},{"1":"Math.POSIXt","2":"0"},{"1":"matrix","2":"0"},{"1":"max.col","2":"0"},{"1":"mean.Date","2":"0"},{"1":"mean.default","2":"0"},{"1":"mean.difftime","2":"0"},{"1":"mean.POSIXct","2":"0"},{"1":"mean.POSIXlt","2":"0"},{"1":"mem.maxNSize","2":"0"},{"1":"mem.maxVSize","2":"0"},{"1":"memCompress","2":"0"},{"1":"memDecompress","2":"0"},{"1":"memory.profile","2":"0"},{"1":"merge.data.frame","2":"0"},{"1":"merge.default","2":"0"},{"1":"message","2":"0"},{"1":"mget","2":"0"},{"1":"missing","2":"0"},{"1":"Mod","2":"0"},{"1":"mode","2":"0"},{"1":"mode<-","2":"0"},{"1":"months.Date","2":"0"},{"1":"months.POSIXt","2":"0"},{"1":"mostattributes<-","2":"0"},{"1":"mtfrm.default","2":"0"},{"1":"names.POSIXlt","2":"0"},{"1":"names<-.POSIXlt","2":"0"},{"1":"namespaceExport","2":"0"},{"1":"namespaceImport","2":"0"},{"1":"namespaceImportClasses","2":"0"},{"1":"namespaceImportFrom","2":"0"},{"1":"namespaceImportMethods","2":"0"},{"1":"nargs","2":"0"},{"1":"nchar","2":"0"},{"1":"ncol","2":"0"},{"1":"NCOL","2":"0"},{"1":"Negate","2":"0"},{"1":"new.env","2":"0"},{"1":"next","2":"0"},{"1":"NextMethod","2":"0"},{"1":"ngettext","2":"0"},{"1":"nlevels","2":"0"},{"1":"noquote","2":"0"},{"1":"norm","2":"0"},{"1":"normalizePath","2":"0"},{"1":"nrow","2":"0"},{"1":"NROW","2":"0"},{"1":"nullfile","2":"0"},{"1":"numeric","2":"0"},{"1":"numeric_version","2":"0"},{"1":"numToBits","2":"0"},{"1":"numToInts","2":"0"},{"1":"nzchar","2":"0"},{"1":"objects","2":"0"},{"1":"oldClass","2":"0"},{"1":"oldClass<-","2":"0"},{"1":"OlsonNames","2":"0"},{"1":"on.exit","2":"0"},{"1":"open.connection","2":"0"},{"1":"open.srcfile","2":"0"},{"1":"open.srcfilealias","2":"0"},{"1":"open.srcfilecopy","2":"0"},{"1":"Ops.data.frame","2":"0"},{"1":"Ops.Date","2":"0"},{"1":"Ops.difftime","2":"0"},{"1":"Ops.factor","2":"0"},{"1":"Ops.numeric_version","2":"0"},{"1":"Ops.ordered","2":"0"},{"1":"Ops.POSIXt","2":"0"},{"1":"options","2":"0"},{"1":"ordered","2":"0"},{"1":"outer","2":"0"},{"1":"package_version","2":"0"},{"1":"packageEvent","2":"0"},{"1":"packageHasNamespace","2":"0"},{"1":"packageNotFoundError","2":"0"},{"1":"packageStartupMessage","2":"0"},{"1":"packBits","2":"0"},{"1":"pairlist","2":"0"},{"1":"parent.env","2":"0"},{"1":"parent.env<-","2":"0"},{"1":"parent.frame","2":"0"},{"1":"parse","2":"0"},{"1":"parseNamespaceFile","2":"0"},{"1":"paste","2":"0"},{"1":"paste0","2":"0"},{"1":"path.expand","2":"0"},{"1":"path.package","2":"0"},{"1":"pcre_config","2":"0"},{"1":"pipe","2":"0"},{"1":"pmatch","2":"0"},{"1":"pmax","2":"0"},{"1":"pmax.int","2":"0"},{"1":"pmin","2":"0"},{"1":"pmin.int","2":"0"},{"1":"polyroot","2":"0"},{"1":"pos.to.env","2":"0"},{"1":"Position","2":"0"},{"1":"pretty.default","2":"0"},{"1":"prettyNum","2":"0"},{"1":"print.AsIs","2":"0"},{"1":"print.by","2":"0"},{"1":"print.condition","2":"0"},{"1":"print.connection","2":"0"},{"1":"print.data.frame","2":"0"},{"1":"print.Date","2":"0"},{"1":"print.default","2":"0"},{"1":"print.difftime","2":"0"},{"1":"print.Dlist","2":"0"},{"1":"print.DLLInfo","2":"0"},{"1":"print.DLLInfoList","2":"0"},{"1":"print.DLLRegisteredRoutines","2":"0"},{"1":"print.eigen","2":"0"},{"1":"print.factor","2":"0"},{"1":"print.function","2":"0"},{"1":"print.hexmode","2":"0"},{"1":"print.libraryIQR","2":"0"},{"1":"print.listof","2":"0"},{"1":"print.NativeRoutineList","2":"0"},{"1":"print.noquote","2":"0"},{"1":"print.numeric_version","2":"0"},{"1":"print.octmode","2":"0"},{"1":"print.packageInfo","2":"0"},{"1":"print.POSIXct","2":"0"},{"1":"print.POSIXlt","2":"0"},{"1":"print.proc_time","2":"0"},{"1":"print.restart","2":"0"},{"1":"print.rle","2":"0"},{"1":"print.simple.list","2":"0"},{"1":"print.srcfile","2":"0"},{"1":"print.srcref","2":"0"},{"1":"print.summary.table","2":"0"},{"1":"print.summary.warnings","2":"0"},{"1":"print.summaryDefault","2":"0"},{"1":"print.table","2":"0"},{"1":"print.warnings","2":"0"},{"1":"prmatrix","2":"0"},{"1":"proc.time","2":"0"},{"1":"prod","2":"0"},{"1":"prop.table","2":"0"},{"1":"proportions","2":"0"},{"1":"provideDimnames","2":"0"},{"1":"psigamma","2":"0"},{"1":"pushBack","2":"0"},{"1":"pushBackLength","2":"0"},{"1":"q","2":"0"},{"1":"qr.coef","2":"0"},{"1":"qr.default","2":"0"},{"1":"qr.fitted","2":"0"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>This brute-force code unsurprisingly identifies <code>print()</code>
as having the greatest number of methods. A bug in
<code>s3_methods_generic()</code> prevents its use (error below).</p>
<pre><code>Error in gsub(paste0(&quot;^&quot;, generic_esc, &quot;[.,]&quot;), &quot;&quot;, info$method) : 
invalid regular expression &#39;^([.,]&#39;, reason &#39;Missing &#39;)&#39;&#39;</code></pre>
<p>AR Solutions: A little experimentation (and thinking about the most
popular functions) suggests that the <code>print()</code> generic has
the most defined methods.</p>
<p>Let’s verify this programmatically with the tools we have learned in
this and the previous chapters.</p>
<pre class="r"><code>ls(all.names = TRUE, envir = baseenv()) %&gt;%
  mget(envir = baseenv()) %&gt;%
  keep(is_function) %&gt;%
  names() %&gt;%
  keep(is_s3_generic) %&gt;%
  map(~ set_names(nrow(s3_methods_generic(.x)), .x)) %&gt;%
  flatten_int() %&gt;%
  sort(decreasing = TRUE) %&gt;%
  head()</code></pre>
<pre><code>#&gt;        print       format            [ as.character      summary           [[ 
#&gt;          378          180           74           54           42           38</code></pre>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Carefully read the documentation for <code>UseMethod()</code> and
explain why the following code returns the results that it does. What
two usual rules of function evaluation does <code>UseMethod()</code>
violate?</li>
</ol>
<pre class="r"><code>g &lt;- function(x) {
  x &lt;- 10
  y &lt;- 10 # nolint: object_usage_linter.
  UseMethod(&quot;g&quot;)
}
g.default &lt;- function(x) c(x = x, y = y)
x &lt;- 1
y &lt;- 1
g(x)</code></pre>
<pre><code>#&gt;  x  y 
#&gt;  1 10</code></pre>
<p>Answer: the documentation states in <strong>Technical
Details</strong>:</p>
<blockquote>
<p><code>UseMethod</code> creates a new function call with arguments
matched as they came in to the generic. Any local variables defined
before the call to <code>UseMethod</code> are retained (unlike S).</p>
</blockquote>
<p>So, <code>UseMethod()</code> creates a new function call where
<code>x</code> matches <code>x &lt;- 1</code> and the local variable
<code>y &lt;- 10</code> is retained. This is passed to
<code>g.default()</code>. This violates both lazy evaluation and lexical
scoping.</p>
<p>AR Solutions: Let’s take this step by step. If you call
<code>g.default(x)</code> directly you get <code>c(1, 1)</code> as you
might expect.</p>
<p>The value bound to <code>x</code> comes from the argument, the value
from <code>y</code> comes from the global environment.</p>
<p>But when we call <code>g(x)</code> we get <code>c(1, 10)</code>.</p>
<p>This is seemingly inconsistent: why does <code>x</code> come from the
value defined inside of <code>g()</code>, and <code>y</code> still come
from the global environment? It’s because <code>UseMethod()</code> calls
<code>g.default()</code> in a special way so that variables defined
inside the generic are available to methods. The exception are arguments
supplied to the function: they are passed on as is and cannot be
affected by code inside the generic.</p>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>What are the arguments to <code>[</code>? Why is this a hard
question to answer?</li>
</ol>
<p>Answer: the possible arguments include the <code>x</code>, the object
being extracted (or replaced), indices (<code>i</code>, <code>j</code>,
<code>...</code>), <code>name</code>, <code>drop</code>,
<code>exact</code>, and <code>value</code>.</p>
<p>This is a hard question to answer since <code>[</code> is an
irregular primitive function that can be called in multiple ways, none
of which support using all possible arguments.</p>
<p>AR Solutions: The subsetting operator <code>[</code> is a primitive
and a generic function, which can be confirmed via
<code>ftype()</code>.</p>
<pre class="r"><code>ftype(`[`)</code></pre>
<pre><code>#&gt; [1] &quot;primitive&quot; &quot;generic&quot;</code></pre>
<p>For primitive functions <code>formals([)</code> returns
<code>NULL</code> so we need to find another way to determine the
functions arguments. One possible way to figure out <code>[</code>’s
arguments would be to inspect the underlying C source code, which can be
searched for via <code>pryr::show_c_source(.Primitive("["))</code>. When
we inspect the arguments of some of <code>[</code>’s methods, we see
that the arguments vary with the class of <code>x</code>.</p>
<pre class="r"><code>names(formals(`[.data.frame`))</code></pre>
<pre><code>#&gt; [1] &quot;x&quot;    &quot;i&quot;    &quot;j&quot;    &quot;drop&quot;</code></pre>
<pre class="r"><code>names(formals(`[.table`))</code></pre>
<pre><code>#&gt; [1] &quot;x&quot;    &quot;i&quot;    &quot;j&quot;    &quot;...&quot;  &quot;drop&quot;</code></pre>
<pre class="r"><code>names(formals(`[.Date`))</code></pre>
<pre><code>#&gt; [1] &quot;x&quot;    &quot;...&quot;  &quot;drop&quot;</code></pre>
<pre class="r"><code>names(formals(`[.AsIs`))</code></pre>
<pre><code>#&gt; [1] &quot;x&quot;   &quot;i&quot;   &quot;...&quot;</code></pre>
<p>To finally get a better overview, we have to put in a little more
effort and also use <code>s3_methods_generic()</code> again.</p>
<pre class="r"><code>s3_methods_generic(&quot;[&quot;) %&gt;%
  filter(visible) %&gt;%
  mutate(
    method = paste0(&quot;[.&quot;, class),
    argnames = purrr::map(method, ~ names(formals(.x))),
    args = purrr::map(method, ~ formals(.x)),
    args = purrr::map2( # nolint: duplicate_argument_linter.
      argnames, args,
      ~ paste(.x, .y, sep = &quot; = &quot;)
    ),
    args = purrr::set_names(args, method) # nolint: duplicate_argument_linter.
  ) %&gt;%
  pull(args) %&gt;%
  head()</code></pre>
<pre><code>#&gt; $`[.AsIs`
#&gt; [1] &quot;x = &quot;   &quot;i = &quot;   &quot;... = &quot;
#&gt; 
#&gt; $`[.data.frame`
#&gt; [1] &quot;x = &quot;                                              
#&gt; [2] &quot;i = &quot;                                              
#&gt; [3] &quot;j = &quot;                                              
#&gt; [4] &quot;drop = if (missing(i)) TRUE else length(cols) == 1&quot;
#&gt; 
#&gt; $`[.Date`
#&gt; [1] &quot;x = &quot;        &quot;... = &quot;      &quot;drop = TRUE&quot;
#&gt; 
#&gt; $`[.difftime`
#&gt; [1] &quot;x = &quot;        &quot;... = &quot;      &quot;drop = TRUE&quot;
#&gt; 
#&gt; $`[.Dlist`
#&gt; [1] &quot;x = &quot;   &quot;i = &quot;   &quot;... = &quot;
#&gt; 
#&gt; $`[.DLLInfoList`
#&gt; [1] &quot;x = &quot;   &quot;... = &quot;</code></pre>
<hr />
</div>
<div id="exercises-3" class="section level2">
<h2>13.5.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Categorise the objects returned by <code>lm()</code>,
<code>factor()</code>, <code>table()</code>, <code>as.Date()</code>,
<code>as.POSIXct()</code>, <code>ecdf()</code>, <code>ordered()</code>,
<code>I()</code> into the styles described above.</li>
</ol>
<p>Answer:</p>
<ul>
<li><code>lm()</code>, <code>ecdf()</code>: scalar</li>
<li><code>factor()</code>, <code>as.Date()</code>,
<code>as.POSIXct()</code>, <code>ordered</code>: vector</li>
<li><code>table()</code>: data frame</li>
<li><code>I()</code>: same as the source object</li>
</ul>
<p>AR Solutions: We can categorise the return values into the various
object styles by observing how the <a
href="https://vctrs.r-lib.org/articles/type-size.html#size">number of
observations</a> is calculated: For vector style classes,
<code>length(x)</code> represents the number of observations. Record
style objects use a list of equal length elements to represent
individual components. For data frames and matrices, the observations
are represented by the rows. Scalar style objects use a list to
represent a single thing.</p>
<p>This leads us to:</p>
<ul>
<li>Vector object-style: <code>factor()</code>, <code>table()</code>,
<code>as.Date()</code>, <code>as.POSIXct()</code>,
<code>ordered()</code></li>
<li>Record object-style: not observed</li>
<li>Data frame object-style: not observed</li>
<li>Scalar object-style: <code>lm()</code>, <code>ecdf()</code></li>
</ul>
<p>The object style of <code>I()</code> depends on the input since this
function returns a “copy of the object with class <code>AsIs</code>
prepended to the class(es)”.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What would a constructor function for <code>lm</code> objects,
<code>new_lm()</code>, look like? Use <code>?lm</code> and
experimentation to figure out the required fields and their types.</li>
</ol>
<p>Answer: the only required field is <code>formula</code>, provided
that the variables listed in the formula exist (and are both vectors).
<code>formula</code> must be of type “<code>formula</code>”.</p>
<pre class="r"><code>mpg &lt;- pull(mtcars, mpg)
wt &lt;- pull(mtcars, wt)
lm(mpg ~ wt)</code></pre>
<pre><code>#&gt; 
#&gt; Call:
#&gt; lm(formula = mpg ~ wt)
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept)           wt  
#&gt;      37.285       -5.344</code></pre>
<p>AR Solutions: The constructor needs to populate the attributes of an
<code>lm</code> object and check their types for correctness. Let’s
start by creating a simple <code>lm</code> object and explore its
underlying base type and attributes:</p>
<pre class="r"><code>mod &lt;- lm(cyl ~ ., data = mtcars)
typeof(mod)</code></pre>
<pre><code>#&gt; [1] &quot;list&quot;</code></pre>
<pre class="r"><code>attributes(mod)</code></pre>
<pre><code>#&gt; $names
#&gt;  [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;          &quot;fitted.values&quot; &quot;assign&quot;       
#&gt;  [7] &quot;qr&quot;            &quot;df.residual&quot;   &quot;xlevels&quot;       &quot;call&quot;          &quot;terms&quot;         &quot;model&quot;        
#&gt; 
#&gt; $class
#&gt; [1] &quot;lm&quot;</code></pre>
<p>As <code>mod</code> is built upon a list, we can simply use
<code>map(mod, typeof)</code> to find out the base types of its
elements. (Additionally, we inspect <code>?lm</code>, to learn more
about the individual attributes.)</p>
<pre class="r"><code>map_chr(mod, typeof)</code></pre>
<pre><code>#&gt;  coefficients     residuals       effects          rank fitted.values        assign            qr 
#&gt;      &quot;double&quot;      &quot;double&quot;      &quot;double&quot;     &quot;integer&quot;      &quot;double&quot;     &quot;integer&quot;        &quot;list&quot; 
#&gt;   df.residual       xlevels          call         terms         model 
#&gt;     &quot;integer&quot;        &quot;list&quot;    &quot;language&quot;    &quot;language&quot;        &quot;list&quot;</code></pre>
<p>Now we should have enough information to write a constructor for new
<code>lm</code> objects.</p>
<pre class="r"><code>new_lm &lt;- function(coefficients, residuals, effects, rank, fitted.values, assign,
                   qr, df.residual, xlevels, call, terms, model # nolint: object_name_linter.
) {
  stopifnot(
    is.double(coefficients), is.double(residuals),
    is.double(effects), is.integer(rank), is.double(fitted.values),
    is.integer(assign), is.list(qr), is.integer(df.residual),
    is.list(xlevels), is.language(call), is.language(terms),
    is.list(model)
  )

  structure(
    list(
      coefficients = coefficients,
      residuals = residuals,
      effects = effects,
      rank = rank,
      fitted.values = fitted.values,
      assign = assign,
      qr = qr,
      df.residual = df.residual,
      xlevels = xlevels,
      call = call,
      terms = terms,
      model = model
    ),
    class = &quot;lm&quot;
  )
}</code></pre>
<hr />
</div>
<div id="exercises-4" class="section level2">
<h2>13.6.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How does <code>[.Date</code> support subclasses? How does it fail to
support subclasses?</li>
</ol>
<pre class="r"><code>`[.Date`</code></pre>
<pre><code>#&gt; function (x, ..., drop = TRUE) 
#&gt; {
#&gt;     .Date(NextMethod(&quot;[&quot;), oldClass(x))
#&gt; }
#&gt; &lt;bytecode: 0x7fb470b70258&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>`.Date`</code></pre>
<pre><code>#&gt; function (xx, cl = &quot;Date&quot;) 
#&gt; `class&lt;-`(xx, cl)
#&gt; &lt;bytecode: 0x7fb44743a198&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<p>Answer: by passing the object’s class to <code>.Date</code>,
<code>[.Date</code> avoids the problem of <code>[.secret</code> and can
return subclasses of <code>Date</code>. However, the <code>.Date</code>
method can return objects that don’t contain the class
<code>Date</code>.</p>
<p>AR Solutions: <code>[.Date</code> calls <code>.Date</code> with the
result of calling <code>[</code> on the parent class, along with
<code>oldClass()</code>:</p>
<p><code>.Date</code> is kind of like a constructor for date classes,
although it doesn’t check the input is the correct type:</p>
<p><code>oldClass()</code> is basically the same as
<code>class()</code>, except that it doesn’t return implicit classes,
i.e. it’s basically <code>attr(x, "class")</code> (looking at the C code
that’s exactly what it does, except that it also handles S4
objects).</p>
<p>As <code>oldClass()</code> is “basically” <code>class()</code>, we
can rewrite <code>[.Date</code> to make the implementation more
clear:</p>
<pre class="r"><code>`[.Date` &lt;- function(x, ..., drop = TRUE) {
  out &lt;- NextMethod(&quot;[&quot;)
  class(out) &lt;- class(x)
  out
}</code></pre>
<p>So, <code>[.Date</code> ensures that the output has the same class as
in the input. But what about other attributes that a subclass might
possess? They get lost:</p>
<pre class="r"><code>x &lt;- structure(1:4, test = &quot;test&quot;, class = c(&quot;myDate&quot;, &quot;Date&quot;))
attributes(x[1])</code></pre>
<pre><code>#&gt; $class
#&gt; [1] &quot;myDate&quot; &quot;Date&quot;</code></pre>
<p>Note: this is a better explanation of how it fails to support
subclasses; it drops non-class attributes.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>R has two classes for representing date time data,
<code>POSIXct</code> and <code>POSIXlt</code>, which both inherit from
<code>POSIXt</code>. Which generics have different behaviours for the
two classes? Which generics share the same behaviour?</li>
</ol>
<p>Answer: if a generic is defined for either class, it must have
different behaviors. Generics that aren’t defined for either class must
have the same behavior. We can get the list of generics defined for
either class using <code>sloop::s3_methods_class()</code>. These
generics have different behaviors for the two classes:</p>
<pre class="r"><code>ct_generics &lt;- s3_methods_class(&quot;POSIXct&quot;)$generic
lt_generics &lt;- s3_methods_class(&quot;POSIXlt&quot;)$generic
defined_generics &lt;- union(ct_generics, lt_generics)
defined_generics</code></pre>
<pre><code>#&gt;  [1] &quot;[&quot;             &quot;[[&quot;            &quot;[&lt;-&quot;           &quot;as.data.frame&quot; &quot;as.Date&quot;       &quot;as.list&quot;      
#&gt;  [7] &quot;as.POSIXlt&quot;    &quot;c&quot;             &quot;format&quot;        &quot;length&lt;-&quot;      &quot;mean&quot;          &quot;print&quot;        
#&gt; [13] &quot;rep&quot;           &quot;split&quot;         &quot;summary&quot;       &quot;Summary&quot;       &quot;weighted.mean&quot; &quot;xtfrm&quot;        
#&gt; [19] &quot;[[&lt;-&quot;          &quot;anyNA&quot;         &quot;as.double&quot;     &quot;as.matrix&quot;     &quot;as.POSIXct&quot;    &quot;as.vector&quot;    
#&gt; [25] &quot;duplicated&quot;    &quot;is.na&quot;         &quot;length&quot;        &quot;names&quot;         &quot;names&lt;-&quot;       &quot;sort&quot;         
#&gt; [31] &quot;unique&quot;</code></pre>
<p>We adapt work from previous exercises to get the list of all
generics, and identify S3 generics that aren’t defined for either class,
which must have the same behavior:</p>
<pre class="r"><code>s3_generic_funs &lt;- Filter(is_s3_generic, names(funs))
union(setdiff(defined_generics, s3_generic_funs), setdiff(s3_generic_funs, defined_generics))</code></pre>
<pre><code>#&gt;   [1] &quot;Summary&quot;                  &quot;weighted.mean&quot;            &quot;-&quot;                       
#&gt;   [4] &quot;!=&quot;                       &quot;*&quot;                        &quot;/&quot;                       
#&gt;   [7] &quot;&amp;&quot;                        &quot;%/%&quot;                      &quot;%%&quot;                      
#&gt;  [10] &quot;^&quot;                        &quot;+&quot;                        &quot;&lt;&quot;                       
#&gt;  [13] &quot;&lt;=&quot;                       &quot;==&quot;                       &quot;&gt;&quot;                       
#&gt;  [16] &quot;&gt;=&quot;                       &quot;|&quot;                        &quot;$&quot;                       
#&gt;  [19] &quot;$&lt;-&quot;                      &quot;abs&quot;                      &quot;acos&quot;                    
#&gt;  [22] &quot;acosh&quot;                    &quot;all&quot;                      &quot;all.equal&quot;               
#&gt;  [25] &quot;any&quot;                      &quot;anyDuplicated&quot;            &quot;aperm&quot;                   
#&gt;  [28] &quot;Arg&quot;                      &quot;as.array&quot;                 &quot;as.call&quot;                 
#&gt;  [31] &quot;as.character&quot;             &quot;as.complex&quot;               &quot;as.environment&quot;          
#&gt;  [34] &quot;as.expression&quot;            &quot;as.function&quot;              &quot;as.integer&quot;              
#&gt;  [37] &quot;as.logical&quot;               &quot;as.null&quot;                  &quot;as.numeric&quot;              
#&gt;  [40] &quot;as.raw&quot;                   &quot;as.single&quot;                &quot;as.table&quot;                
#&gt;  [43] &quot;asin&quot;                     &quot;asinh&quot;                    &quot;atan&quot;                    
#&gt;  [46] &quot;atanh&quot;                    &quot;by&quot;                       &quot;cbind&quot;                   
#&gt;  [49] &quot;ceiling&quot;                  &quot;chol&quot;                     &quot;close&quot;                   
#&gt;  [52] &quot;conditionCall&quot;            &quot;conditionMessage&quot;         &quot;Conj&quot;                    
#&gt;  [55] &quot;cos&quot;                      &quot;cosh&quot;                     &quot;cospi&quot;                   
#&gt;  [58] &quot;cummax&quot;                   &quot;cummin&quot;                   &quot;cumprod&quot;                 
#&gt;  [61] &quot;cumsum&quot;                   &quot;cut&quot;                      &quot;determinant&quot;             
#&gt;  [64] &quot;diff&quot;                     &quot;digamma&quot;                  &quot;dim&quot;                     
#&gt;  [67] &quot;dim&lt;-&quot;                    &quot;dimnames&quot;                 &quot;dimnames&lt;-&quot;              
#&gt;  [70] &quot;droplevels&quot;               &quot;exp&quot;                      &quot;expm1&quot;                   
#&gt;  [73] &quot;floor&quot;                    &quot;flush&quot;                    &quot;gamma&quot;                   
#&gt;  [76] &quot;getDLLRegisteredRoutines&quot; &quot;Im&quot;                       &quot;is.array&quot;                
#&gt;  [79] &quot;is.finite&quot;                &quot;is.infinite&quot;              &quot;is.matrix&quot;               
#&gt;  [82] &quot;is.na&lt;-&quot;                  &quot;is.nan&quot;                   &quot;is.numeric&quot;              
#&gt;  [85] &quot;isSymmetric&quot;              &quot;julian&quot;                   &quot;kappa&quot;                   
#&gt;  [88] &quot;labels&quot;                   &quot;levels&quot;                   &quot;levels&lt;-&quot;                
#&gt;  [91] &quot;lgamma&quot;                   &quot;log&quot;                      &quot;log10&quot;                   
#&gt;  [94] &quot;log1p&quot;                    &quot;log2&quot;                     &quot;max&quot;                     
#&gt;  [97] &quot;merge&quot;                    &quot;min&quot;                      &quot;Mod&quot;                     
#&gt; [100] &quot;months&quot;                   &quot;mtfrm&quot;                    &quot;open&quot;                    
#&gt; [103] &quot;plot&quot;                     &quot;pretty&quot;                   &quot;prod&quot;                    
#&gt; [106] &quot;qr&quot;                       &quot;quarters&quot;                 &quot;range&quot;                   
#&gt; [109] &quot;rbind&quot;                    &quot;Re&quot;                       &quot;rev&quot;                     
#&gt; [112] &quot;round&quot;                    &quot;row.names&quot;                &quot;row.names&lt;-&quot;             
#&gt; [115] &quot;rowsum&quot;                   &quot;scale&quot;                    &quot;seek&quot;                    
#&gt; [118] &quot;seq&quot;                      &quot;seq.int&quot;                  &quot;sequence&quot;                
#&gt; [121] &quot;sign&quot;                     &quot;signif&quot;                   &quot;sin&quot;                     
#&gt; [124] &quot;sinh&quot;                     &quot;sinpi&quot;                    &quot;solve&quot;                   
#&gt; [127] &quot;split&lt;-&quot;                  &quot;sqrt&quot;                     &quot;subset&quot;                  
#&gt; [130] &quot;sum&quot;                      &quot;t&quot;                        &quot;tan&quot;                     
#&gt; [133] &quot;tanh&quot;                     &quot;tanpi&quot;                    &quot;toString&quot;                
#&gt; [136] &quot;transform&quot;                &quot;trigamma&quot;                 &quot;trunc&quot;                   
#&gt; [139] &quot;truncate&quot;                 &quot;units&quot;                    &quot;units&lt;-&quot;                 
#&gt; [142] &quot;unlist&quot;                   &quot;weekdays&quot;                 &quot;with&quot;                    
#&gt; [145] &quot;within&quot;</code></pre>
<p>Note: this code doesn’t quite work, since <code>Summary</code> is a
generic according to <code>isGeneric</code> and is not according to
<code>is_s3_generic</code>, and <code>weighted.mean</code> is a non-base
S3 generic.</p>
<p>AR Solutions: To answer this question, we have to get the respective
generics</p>
<pre class="r"><code>generics_t &lt;- s3_methods_class(&quot;POSIXt&quot;)$generic
generics_ct &lt;- s3_methods_class(&quot;POSIXct&quot;)$generic
generics_lt &lt;- s3_methods_class(&quot;POSIXlt&quot;)$generic</code></pre>
<p>The generics in <code>generics_t</code> with a method for the
superclass <code>POSIXt</code> potentially share the same behaviour for
both subclasses. However, if a generic has a specific method for one of
the subclasses, it has to be subtracted:</p>
<pre class="r"><code># These generics provide subclass-specific methods
union(generics_ct, generics_lt)</code></pre>
<pre><code>#&gt;  [1] &quot;[&quot;             &quot;[[&quot;            &quot;[&lt;-&quot;           &quot;as.data.frame&quot; &quot;as.Date&quot;       &quot;as.list&quot;      
#&gt;  [7] &quot;as.POSIXlt&quot;    &quot;c&quot;             &quot;format&quot;        &quot;length&lt;-&quot;      &quot;mean&quot;          &quot;print&quot;        
#&gt; [13] &quot;rep&quot;           &quot;split&quot;         &quot;summary&quot;       &quot;Summary&quot;       &quot;weighted.mean&quot; &quot;xtfrm&quot;        
#&gt; [19] &quot;[[&lt;-&quot;          &quot;anyNA&quot;         &quot;as.double&quot;     &quot;as.matrix&quot;     &quot;as.POSIXct&quot;    &quot;as.vector&quot;    
#&gt; [25] &quot;duplicated&quot;    &quot;is.na&quot;         &quot;length&quot;        &quot;names&quot;         &quot;names&lt;-&quot;       &quot;sort&quot;         
#&gt; [31] &quot;unique&quot;</code></pre>
<pre class="r"><code># These generics share (inherited) methods for both subclasses
setdiff(generics_t, union(generics_ct, generics_lt))</code></pre>
<pre><code>#&gt;  [1] &quot;-&quot;            &quot;+&quot;            &quot;all.equal&quot;    &quot;as.character&quot; &quot;Axis&quot;         &quot;compare&quot;     
#&gt;  [7] &quot;cut&quot;          &quot;diff&quot;         &quot;fullseq&quot;      &quot;hist&quot;         &quot;is.numeric&quot;   &quot;julian&quot;      
#&gt; [13] &quot;Math&quot;         &quot;months&quot;       &quot;Ops&quot;          &quot;pretty&quot;       &quot;quantile&quot;     &quot;quarters&quot;    
#&gt; [19] &quot;rescale_mid&quot;  &quot;rescale&quot;      &quot;round&quot;        &quot;scale_type&quot;   &quot;seq&quot;          &quot;str&quot;         
#&gt; [25] &quot;trunc&quot;        &quot;weekdays&quot;</code></pre>
<p>Note: again, advanced R gives a better answer to this question, by
comparing to the generics supported by the parent class.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>What do you expect this code to return? What does it actually
return? Why?</li>
</ol>
<pre class="r"><code>generic2 &lt;- function(x) UseMethod(&quot;generic2&quot;)
generic2.a1 &lt;- function(x) &quot;a1&quot;
generic2.a2 &lt;- function(x) &quot;a2&quot;
generic2.b &lt;- function(x) {
  class(x) &lt;- &quot;a1&quot;
  NextMethod()
}
generic2(structure(list(), class = c(&quot;b&quot;, &quot;a2&quot;)))</code></pre>
<pre><code>#&gt; [1] &quot;a2&quot;</code></pre>
<p>Answer: I’d expect this code to return <code>"a2"</code> with a class
of <code>c("a1", "a2")</code>. It actually returns “a2” with a class of
<code>character</code>. This is because when <code>generic2.b</code>
calls <code>NextMethod()</code>, <code>generic2.a2</code> is called
which returns a bare <code>"a2"</code>, dropping the class assigned by
<code>generic2.b</code>.</p>
<pre class="r"><code>class(generic2(structure(list(), class = c(&quot;b&quot;, &quot;a2&quot;))))</code></pre>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
<p>AR Solutions: When we execute the code above, this is what is
happening:</p>
<ul>
<li><p>we pass an object of classes <code>b</code> and <code>a2</code>
to <code>generic2()</code>, which prompts R to look for a
method<code>generic2.b()</code></p></li>
<li><p>the method <code>generic2.b()</code> then changes the class to
<code>a1</code> and calls <code>NextMethod()</code></p></li>
<li><p>One would think that this will lead R to call
<code>generic2.a1()</code>, but in fact, as mentioned in <em>Advanced
R</em>, <code>NextMethod()</code> &gt; doesn’t actually work with the
class attribute of the object, but instead uses a special global
variable (.Class) to keep track of which method to call next.</p>
<p>This is why <code>generic2.a2()</code> is called instead.</p></li>
</ul>
<pre class="r"><code>generic2(structure(list(), class = c(&quot;b&quot;, &quot;a2&quot;)))</code></pre>
<pre><code>#&gt; [1] &quot;a2&quot;</code></pre>
<p>Let’s just double check the statement above and evaluate
<code>.Class</code> explicitly within the <code>generic2.b()</code>
method.</p>
<pre class="r"><code>generic2.b &lt;- function(x) {
  class(x) &lt;- &quot;a1&quot;
  print(.Class) # nolint: object_usage_linter.
  NextMethod()
}

generic2(structure(list(), class = c(&quot;b&quot;, &quot;a2&quot;)))</code></pre>
<pre><code>#&gt; [1] &quot;b&quot;  &quot;a2&quot;</code></pre>
<pre><code>#&gt; [1] &quot;a2&quot;</code></pre>
<hr />
</div>
<div id="exercises-5" class="section level2">
<h2>13.7.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Explain the differences in dispatch below:</li>
</ol>
<pre class="r"><code>length.integer &lt;- function(x) 10

x1 &lt;- 1:5
class(x1)</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>s3_dispatch(length(x1))</code></pre>
<pre><code>#&gt;  * length.integer
#&gt;    length.numeric
#&gt;    length.default
#&gt; =&gt; length (internal)</code></pre>
<pre class="r"><code>x2 &lt;- structure(x1, class = &quot;integer&quot;)
class(x2)</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>s3_dispatch(length(x2))</code></pre>
<pre><code>#&gt; =&gt; length.integer
#&gt;    length.default
#&gt;  * length (internal)</code></pre>
<p>Answer: <code>x1</code> dispatches using implicit class, which is
<code>c("integer", "numeric")</code>. <code>x2</code> has an explicit
class, so it is dispatched to <code>length.integer</code>.</p>
<pre class="r"><code>s3_class(x1)</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot; &quot;numeric&quot;</code></pre>
<pre class="r"><code>s3_class(x2)</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<p>AR Solutions: <code>class()</code> returns <code>integer</code> in
both cases. However, while the class of <code>x1</code> is created
implicitly and inherits from the <code>numeric</code> class, the class
of <code>x2</code> is set explicitly. This is important because
<code>length()</code> is an internal generic and internal generics only
dispatch to methods when the class attribute has been set, i.e. internal
generics do not use implicit classes.</p>
<p>An object has no explicit class if <code>attr(x, "class")</code>
returns <code>NULL</code>:</p>
<pre class="r"><code>attr(x1, &quot;class&quot;)</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>attr(x2, &quot;class&quot;)</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<p>To see the relevant classes for the S3 dispatch, one can use
<code>sloop::s3_class()</code>:</p>
<pre class="r"><code>s3_class(x1) # implicit</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot; &quot;numeric&quot;</code></pre>
<pre class="r"><code>s3_class(x2) # explicit</code></pre>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<p>For a better understanding of <code>s3_dipatch()</code>’s output we
quote from <code>?s3_dispatch</code>: - =&gt; method exists and is found
by <code>UseMethod()</code>. - -&gt; method exists and is used by
<code>NextMethod()</code>. - * method exists but is not used. - Nothing
(and greyed out in console): method does not exist.</p>
<p>Note: AR Solutions includes an additional important detail, that
“internal generics only dispatch to methods when the class attribute has
been set”, which explains why the internal generic is used for
<code>x1</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What classes have a method for the <code>Math</code> group generic
in base R? Read the source code. How do the methods work?</li>
</ol>
<p>Answer: four base classes have a method for <code>Math</code>:
<code>data.frame</code>, <code>Date</code>, <code>difftime</code>,
<code>factor</code>, and <code>POSIXt</code>.</p>
<pre class="r"><code>s3_methods_generic(&quot;Math&quot;) |&gt;
  filter(source == &quot;base&quot;) # nolint: undesirable_function_linter. source is not used as a function.</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["generic"],"name":[1],"type":["chr"],"align":["left"]},{"label":["class"],"name":[2],"type":["chr"],"align":["left"]},{"label":["visible"],"name":[3],"type":["lgl"],"align":["right"]},{"label":["source"],"name":[4],"type":["chr"],"align":["left"]}],"data":[{"1":"Math","2":"data.frame","3":"TRUE","4":"base"},{"1":"Math","2":"Date","3":"TRUE","4":"base"},{"1":"Math","2":"difftime","3":"TRUE","4":"base"},{"1":"Math","2":"factor","3":"TRUE","4":"base"},{"1":"Math","2":"POSIXt","3":"TRUE","4":"base"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>Math.data.frame</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; {
#&gt;     mode.ok &lt;- vapply(x, function(x) is.numeric(x) || is.logical(x) || 
#&gt;         is.complex(x), NA)
#&gt;     if (all(mode.ok)) {
#&gt;         x[] &lt;- lapply(X = x, FUN = .Generic, ...)
#&gt;         return(x)
#&gt;     }
#&gt;     else {
#&gt;         vnames &lt;- names(x)
#&gt;         if (is.null(vnames)) 
#&gt;             vnames &lt;- seq_along(x)
#&gt;         stop(&quot;non-numeric-alike variable(s) in data frame: &quot;, 
#&gt;             paste(vnames[!mode.ok], collapse = &quot;, &quot;))
#&gt;     }
#&gt; }
#&gt; &lt;bytecode: 0x7fb470e5bfa8&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>Math.Date</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; stop(gettextf(&quot;%s not defined for \&quot;Date\&quot; objects&quot;, .Generic), 
#&gt;     domain = NA)
#&gt; &lt;bytecode: 0x7fb470e61108&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>Math.difftime</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; {
#&gt;     switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , 
#&gt;         round = , signif = {
#&gt;             units &lt;- attr(x, &quot;units&quot;)
#&gt;             .difftime(NextMethod(), units)
#&gt;         }, stop(gettextf(&quot;&#39;%s&#39; not defined for \&quot;difftime\&quot; objects&quot;, 
#&gt;             .Generic), domain = NA))
#&gt; }
#&gt; &lt;bytecode: 0x7fb470e606c0&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>Math.factor</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; stop(gettextf(&quot;%s not meaningful for factors&quot;, sQuote(.Generic)))
#&gt; &lt;bytecode: 0x7fb470e678c0&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>Math.POSIXt</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; {
#&gt;     stop(gettextf(&quot;&#39;%s&#39; not defined for \&quot;POSIXt\&quot; objects&quot;, 
#&gt;         .Generic), domain = NA)
#&gt; }
#&gt; &lt;bytecode: 0x7fb470e66dd0&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<ul>
<li><code>Math.data.frame</code> performs math if all columns
(variables) are either numeric, logical or complex, and errors if any
are not</li>
<li><code>Math.difftime</code> performs only certain math functions:
<code>abs</code>, <code>sign</code>, <code>floor</code>,
<code>ceiling</code>, <code>trunc</code>, <code>round</code>, and
<code>signif</code>, and errors for other functions</li>
<li><code>Math.Date</code>, <code>Math.factor</code>, and
<code>Math.POSIXt</code> always error</li>
</ul>
<p>AR Solutions: : The following functions belong to this group (see
?<code>Math</code>):</p>
<ul>
<li><code>abs</code>, <code>sign</code>, <code>sqrt</code>,
<code>floor</code>, <code>ceiling</code>, <code>trunc</code>,
<code>round</code>, <code>signif</code></li>
<li><code>exp</code>, <code>log</code>, <code>expm1</code>,
<code>log1p</code>, <code>cos</code>, <code>sin</code>,
<code>tan</code>, <code>cospi</code>, <code>sinpi</code>,
<code>tanpi</code>, <code>acos</code>, <code>asin</code>,
<code>atan</code>, <code>cosh</code>, <code>sinh</code>,
<code>tanh</code>, <code>acosh</code>, <code>asinh</code>,
<code>atanh</code></li>
<li><code>lgamma</code>, <code>gamma</code>, <code>digamma</code>,
<code>trigamma</code></li>
<li><code>cumsum</code>, <code>cumprod</code>, <code>cummax</code>,
<code>cummin</code></li>
</ul>
<p>The following classes have a method for this group generic:</p>
<pre class="r"><code>s3_methods_generic(&quot;Math&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["generic"],"name":[1],"type":["chr"],"align":["left"]},{"label":["class"],"name":[2],"type":["chr"],"align":["left"]},{"label":["visible"],"name":[3],"type":["lgl"],"align":["right"]},{"label":["source"],"name":[4],"type":["chr"],"align":["left"]}],"data":[{"1":"Math","2":"data.frame","3":"TRUE","4":"base"},{"1":"Math","2":"Date","3":"TRUE","4":"base"},{"1":"Math","2":"difftime","3":"TRUE","4":"base"},{"1":"Math","2":"factor","3":"TRUE","4":"base"},{"1":"Math","2":"POSIXt","3":"TRUE","4":"base"},{"1":"Math","2":"quosure","3":"FALSE","4":"registered S3method"},{"1":"Math","2":"vctrs_sclr","3":"FALSE","4":"registered S3method"},{"1":"Math","2":"vctrs_vctr","3":"FALSE","4":"registered S3method"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>To explain the basic idea, we just overwrite the data frame
method:</p>
<pre class="r"><code>Math.data.frame &lt;- function(x) &quot;hello&quot;</code></pre>
<p>Now all functions from the math generic group, will return
<code>"hello"</code></p>
<pre class="r"><code>abs(mtcars)</code></pre>
<pre><code>#&gt; [1] &quot;hello&quot;</code></pre>
<pre class="r"><code>exp(mtcars)</code></pre>
<pre><code>#&gt; [1] &quot;hello&quot;</code></pre>
<pre class="r"><code>lgamma(mtcars)</code></pre>
<pre><code>#&gt; [1] &quot;hello&quot;</code></pre>
<p>Of course, different functions should perform different calculations.
Here <code>.Generic</code> comes into play, which provides us with the
calling generic as a string</p>
<pre class="r"><code>Math.data.frame &lt;- function(x, ...) {
  .Generic # nolint: object_usage_linter.
}
abs(mtcars)</code></pre>
<pre><code>#&gt; [1] &quot;abs&quot;</code></pre>
<pre class="r"><code>exp(mtcars)</code></pre>
<pre><code>#&gt; [1] &quot;exp&quot;</code></pre>
<pre class="r"><code>lgamma(mtcars)</code></pre>
<pre><code>#&gt; [1] &quot;lgamma&quot;</code></pre>
<pre class="r"><code>rm(Math.data.frame)</code></pre>
<p>The original source code of <code>Math.data.frame()</code> is a good
example on how to invoke the string returned by <code>.Generic</code>
into a specific method. <code>Math.factor()</code> is a good example of
a method, which is simply defined for better error messages.</p>
<p>Note: I prefer my answer to the AR Solutions answer.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li><code>Math.difftime()</code> is more complicated than I described.
Why?</li>
</ol>
<p>Answer: the explanation in the text omits the fact that
<code>Math.difftime()</code> first checks that the math function being
called.</p>
<p>AR Solutions: <code>Math.difftime()</code> also excludes cases apart
from <code>abs</code>, <code>sign</code>, <code>floor</code>,
<code>ceiling</code>, <code>trunc</code>, <code>round</code> and
<code>signif</code> and needs to return a fitting error message.</p>
<hr />
</div>
</div>
<div id="r6" class="section level1">
<h1>14 R6</h1>
<pre class="r"><code>rm(list = ls())</code></pre>
<p>This chapter describes the R6 OOP system. R6 has two special
properties:</p>
<ul>
<li><p>It uses the encapsulated OOP paradigm, which means that methods
belong to objects, not generics, and you call them like
<code>object$method()</code>.</p></li>
<li><p>R6 objects are <strong>mutable</strong>, which means that they
are modified in place, and hence have reference semantics.</p></li>
</ul>
<p>If you’ve learned OOP in another programming language, it’s likely
that R6 will feel very natural, and you’ll be inclined to prefer it over
S3. Resist the temptation to follow the path of least resistance: in
most cases R6 will lead you to non-idiomatic R code. We’ll come back to
this theme in Section 16.3.</p>
<p>R6 is very similar to a base OOP system called <strong>reference
classes</strong>, or RC for short. I describe why I teach R6 and not RC
in Section 14.5.</p>
<div id="exercises-6" class="section level2">
<h2>14.2.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Create a bank account R6 class that stores a balance and allows you
to deposit and withdraw money. Create a subclass that throws an error if
you attempt to go into overdraft. Create another subclass that allows
you to go into overdraft, but charges you a fee.</li>
</ol>
<p>Answer: <code>Account</code> stores a balance as an integer value of
cents, and prints in dollars (to avoid problems with floating point
math).</p>
<pre class="r"><code>Account &lt;- R6Class(&quot;Account&quot;, list( # nolint: object_name_linter.
  balance = 0L,
  initialize = function(balance = 0L) {
    stopifnot(is.integer(balance), length(balance) == 1)
    self$balance &lt;- balance
  },
  print = function(...) {
    cat(&quot;Account: \n&quot;)
    cat(&quot;  Balance: $&quot;, format(self$balance / 100, nsmall = 2), &quot;\n&quot;, sep = &quot;&quot;)
    invisible(self)
  },
  deposit = function(value) {
    stopifnot(is.integer(value), length(value) == 1)
    self$balance &lt;- self$balance + value
    invisible(self)
  },
  withdraw = function(value) {
    stopifnot(is.integer(value), length(value) == 1)
    self$balance &lt;- self$balance - value
    invisible(self)
  }
))

AccountOverdraft &lt;- R6Class(&quot;AccountOverdraft&quot;, # nolint: object_name_linter.
  inherit = Account,
  public = list(
    withdraw = function(value) {
      stopifnot(value &lt;= self$balance)
      super$withdraw(value)
    }
  )
)

AccountOverdraftFee &lt;- R6Class(&quot;AccountOverdraftFee&quot;, # nolint: object_name_linter.
  inherit = Account,
  public = list(
    withdraw = function(value) {
      if (value &gt; self$balance) value &lt;- value + 500L
      super$withdraw(value)
    }
  )
)

try(Account$new(1.5))</code></pre>
<pre><code>#&gt; Error in initialize(...) : is.integer(balance) is not TRUE</code></pre>
<pre class="r"><code>a &lt;- Account$new(100L)
a$deposit(100L)
a$withdraw(250L)
a</code></pre>
<pre><code>#&gt; Account: 
#&gt;   Balance: $-0.50</code></pre>
<pre class="r"><code>a2 &lt;- AccountOverdraft$new(200L)
try(a2$withdraw(250L))</code></pre>
<pre><code>#&gt; Error in a2$withdraw(250L) : value &lt;= self$balance is not TRUE</code></pre>
<pre class="r"><code>a2$withdraw(150L)
a2</code></pre>
<pre><code>#&gt; Account: 
#&gt;   Balance: $0.50</code></pre>
<pre class="r"><code>a3 &lt;- AccountOverdraftFee$new(200L)
a3$withdraw(250L)
a3</code></pre>
<pre><code>#&gt; Account: 
#&gt;   Balance: $-5.50</code></pre>
<p>AR Solutions: <code>BankAccount</code> is a similar, simpler
approach:</p>
<pre class="r"><code>BankAccount &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;BankAccount&quot;,
  public = list(
    balance = 0,
    deposit = function(dep = 0) {
      self$balance &lt;- self$balance + dep
      invisible(self)
    },
    withdraw = function(draw) {
      self$balance &lt;- self$balance - draw
      invisible(self)
    }
  )
)

BankAccountStrict &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;BankAccountStrict&quot;,
  inherit = BankAccount,
  public = list(
    withdraw = function(draw = 0) {
      if (self$balance - draw &lt; 0) {
        stop(&quot;Your `withdraw` must be smaller &quot;,
          &quot;than your `balance`.&quot;,
          call. = FALSE
        )
      }
      super$withdraw(draw = draw)
    }
  )
)

BankAccountCharging &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;BankAccountCharging&quot;,
  inherit = BankAccount,
  public = list(
    withdraw = function(draw = 0) {
      if (self$balance - draw &lt; 0) {
        draw &lt;- draw + 1
      }
      super$withdraw(draw = draw)
    }
  )
)</code></pre>
<p>Note: my object name, <code>AccountOverdraftFee</code> is misleading,
since it is not a subclass of <code>AccountOverdraft</code> - the R
Solutions naming convention is clearer.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Create an R6 class that represents a shuffled deck of cards. You
should be able to draw cards from the deck with <code>$draw(n)</code>,
and return all cards to the deck and reshuffle with
<code>$reshuffle()</code>. Use the following code to make a vector of
cards.</li>
</ol>
<pre class="r"><code>suit &lt;- c(&quot;♠&quot;, &quot;♥&quot;, &quot;♦&quot;, &quot;♣&quot;)
value &lt;- c(&quot;A&quot;, 2:10, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;)
cards &lt;- paste0(rep(value, 4), suit)</code></pre>
<p>Answer: <code>Cards</code> shuffles the deck using
<code>sample()</code>. The <code>draw()</code> function prints the cards
drawn and moves them into play.</p>
<pre class="r"><code>Cards &lt;- R6Class(&quot;Cards&quot;, list( # nolint: object_name_linter.
  deck = sample(cards, 52),
  play = NULL,
  print = function(...) {
    cat(&quot;Cards: \n&quot;)
    cat(&quot;  Deck:&quot;, self$deck, &quot;\n&quot;, sep = &quot; &quot;)
    cat(&quot;  Play:&quot;, self$play, &quot;\n&quot;, sep = &quot; &quot;)
    invisible(self)
  },
  draw = function(n = 1L) {
    stopifnot(is.integer(n), length(n) == 1, n &gt; 0, n &lt;= length(self$deck))
    d &lt;- head(self$deck, n)
    self$play &lt;- c(self$play, d)
    self$deck &lt;- tail(self$deck, -n)
    invisible(self)
  },
  reshuffle = function() {
    self$deck &lt;- sample(cards, 52)
    self$play &lt;- NULL
    invisible(self)
  }
))

d &lt;- Cards$new()
d</code></pre>
<pre><code>#&gt; Cards: 
#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ 
#&gt;   Play:</code></pre>
<pre class="r"><code>try(d$draw(1.5))</code></pre>
<pre><code>#&gt; Error in d$draw(1.5) : is.integer(n) is not TRUE</code></pre>
<pre class="r"><code>try(d$draw(0L))</code></pre>
<pre><code>#&gt; Error in d$draw(0L) : n &gt; 0 is not TRUE</code></pre>
<pre class="r"><code>try(d$draw(53L))</code></pre>
<pre><code>#&gt; Error in d$draw(53L) : n &lt;= length(self$deck) is not TRUE</code></pre>
<pre class="r"><code>d$draw(13L)
d</code></pre>
<pre><code>#&gt; Cards: 
#&gt;   Deck: 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ 
#&gt;   Play: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠</code></pre>
<pre class="r"><code>d$draw(13L)
d</code></pre>
<pre><code>#&gt; Cards: 
#&gt;   Deck: 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ 
#&gt;   Play: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠</code></pre>
<pre class="r"><code>d$reshuffle()
d</code></pre>
<pre><code>#&gt; Cards: 
#&gt;   Deck: K♠ Q♠ 9♠ 4♠ 5♣ 7♥ 10♥ 6♠ A♥ K♣ 8♦ 5♠ 6♣ J♠ J♦ 7♦ 2♠ 6♥ 2♦ 2♣ 10♣ A♣ 4♦ A♠ 8♠ J♥ K♥ 4♣ Q♥ 9♣ 9♥ 3♦ 6♦ 3♠ 8♣ 5♦ A♦ Q♦ 7♠ 3♣ 3♥ 4♥ 7♣ 5♥ J♣ 9♦ 2♥ 10♦ Q♣ 8♥ K♦ 10♠ 
#&gt;   Play:</code></pre>
<p>AR Solutions: Our new <code>ShuffledDeck</code> class will use
<code>sample()</code> and positive integer subsetting to implement the
reshuffling and drawing functionality. We also add a check, so you
cannot draw more cards than there are left in the deck.</p>
<pre class="r"><code>ShuffledDeck &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;ShuffledDeck&quot;,
  public = list(
    deck = NULL,
    initialize = function(deck = cards) {
      self$deck &lt;- sample(deck)
    },
    reshuffle = function() {
      self$deck &lt;- sample(cards)
      invisible(self)
    },
    n = function() {
      length(self$deck)
    },
    draw = function(n = 1) {
      if (n &gt; self$n()) {
        stop(&quot;Only &quot;, self$n(), &quot; cards remaining.&quot;, call. = FALSE)
      }

      output &lt;- self$deck[seq_len(n)]
      self$deck &lt;- self$deck[-seq_len(n)]
      output
    }
  )
)</code></pre>
<p>Notes: it seems simpler to set <code>deck</code> directly instead of
using an <code>initialize</code> function, although
<code>sample(cards)</code> is cleaner. <code>self$n()</code> is a useful
function, and the choice of removing and returning cards with
<code>draw()</code> is probably a better design. I prefer my approach
using <code>head()</code> and <code>tail()</code> over R Solutions use
of <code>seq_len()</code>.</p>
<p>Bug: per 14.4.3 setting fields directly fixes the order when the
class is <em>defined</em>. This results in a bug: <code>Cards</code> has
the same starting shuffle for each new object, but
<code>ShuffledDeck</code> does not:</p>
<pre class="r"><code>Cards$new()</code></pre>
<pre><code>#&gt; Cards: 
#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ 
#&gt;   Play:</code></pre>
<pre class="r"><code>Cards$new()</code></pre>
<pre><code>#&gt; Cards: 
#&gt;   Deck: 5♣ K♠ 2♣ 9♣ K♥ 2♥ 9♠ 3♥ Q♣ 6♥ 8♥ 8♦ 7♠ 4♠ A♠ J♥ A♣ 9♦ 3♣ 5♦ 7♥ K♣ 3♠ Q♦ A♥ 5♠ 8♣ 4♦ Q♥ 7♣ 10♥ 3♦ 5♥ 7♦ J♠ 9♥ K♦ 2♦ 2♠ A♦ Q♠ 6♠ 6♦ 10♣ 8♠ 4♣ 10♠ J♦ 10♦ 6♣ J♣ 4♥ 
#&gt;   Play:</code></pre>
<pre class="r"><code>ShuffledDeck$new()$draw(52)</code></pre>
<pre><code>#&gt;  [1] &quot;K♥&quot;  &quot;4♠&quot;  &quot;7♥&quot;  &quot;9♠&quot;  &quot;9♥&quot;  &quot;6♥&quot;  &quot;Q♦&quot;  &quot;4♦&quot;  &quot;9♦&quot;  &quot;J♦&quot;  &quot;A♠&quot;  &quot;10♠&quot; &quot;4♥&quot;  &quot;K♣&quot;  &quot;8♥&quot;  &quot;3♠&quot; 
#&gt; [17] &quot;8♣&quot;  &quot;3♣&quot;  &quot;A♦&quot;  &quot;6♣&quot;  &quot;K♠&quot;  &quot;J♠&quot;  &quot;3♥&quot;  &quot;2♥&quot;  &quot;3♦&quot;  &quot;5♥&quot;  &quot;J♥&quot;  &quot;J♣&quot;  &quot;2♠&quot;  &quot;7♠&quot;  &quot;A♥&quot;  &quot;5♠&quot; 
#&gt; [33] &quot;Q♥&quot;  &quot;Q♣&quot;  &quot;6♦&quot;  &quot;7♦&quot;  &quot;10♥&quot; &quot;5♣&quot;  &quot;5♦&quot;  &quot;6♠&quot;  &quot;4♣&quot;  &quot;2♦&quot;  &quot;9♣&quot;  &quot;10♣&quot; &quot;2♣&quot;  &quot;7♣&quot;  &quot;K♦&quot;  &quot;A♣&quot; 
#&gt; [49] &quot;10♦&quot; &quot;8♠&quot;  &quot;8♦&quot;  &quot;Q♠&quot;</code></pre>
<pre class="r"><code>ShuffledDeck$new()$draw(52)</code></pre>
<pre><code>#&gt;  [1] &quot;8♣&quot;  &quot;6♠&quot;  &quot;3♠&quot;  &quot;4♥&quot;  &quot;J♥&quot;  &quot;Q♣&quot;  &quot;J♣&quot;  &quot;8♦&quot;  &quot;5♦&quot;  &quot;K♠&quot;  &quot;10♣&quot; &quot;K♣&quot;  &quot;2♦&quot;  &quot;Q♥&quot;  &quot;A♦&quot;  &quot;9♠&quot; 
#&gt; [17] &quot;7♦&quot;  &quot;3♥&quot;  &quot;7♣&quot;  &quot;9♦&quot;  &quot;A♥&quot;  &quot;J♠&quot;  &quot;8♥&quot;  &quot;A♣&quot;  &quot;8♠&quot;  &quot;7♠&quot;  &quot;K♥&quot;  &quot;5♥&quot;  &quot;2♣&quot;  &quot;2♥&quot;  &quot;5♠&quot;  &quot;10♠&quot;
#&gt; [33] &quot;3♦&quot;  &quot;4♣&quot;  &quot;A♠&quot;  &quot;Q♠&quot;  &quot;9♥&quot;  &quot;9♣&quot;  &quot;6♥&quot;  &quot;10♥&quot; &quot;K♦&quot;  &quot;7♥&quot;  &quot;2♠&quot;  &quot;Q♦&quot;  &quot;3♣&quot;  &quot;10♦&quot; &quot;4♠&quot;  &quot;6♣&quot; 
#&gt; [49] &quot;4♦&quot;  &quot;5♣&quot;  &quot;6♦&quot;  &quot;J♦&quot;</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Why can’t you model a bank account or a deck of cards with an S3
class?</li>
</ol>
<p>Answer: because S3 classes are copied-on-modify, they lack state. R6
classes are stateful since they are modified in-place. Both bank
accounts and a deck of cards are stateful objects.</p>
<p>AR Solutions: Because S3 classes obey R’s usual semantics of
copy-on-modify: every time you deposit money into your bank account or
draw a card from the deck, you’d get a new copy of the object.</p>
<p>It is possible to combine S3 classes with an environment (which is
how R6 works), but it is ill-advised to create an object that looks like
a regular R object but has reference semantics.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Create an R6 class that allows you to get and set the current time
zone. You can access the current time zone with
<code>Sys.timezone()</code> and set it with
<code>Sys.setenv(TZ = "newtimezone")</code>. When setting the time zone,
make sure the new time zone is in the list provided by
<code>OlsonNames()</code>.</li>
</ol>
<p>Answer: <code>TimeZone</code> is initialized with the current time
zone, stored as <code>tz</code> in the object.</p>
<pre class="r"><code>orig_tz &lt;- Sys.timezone()

TimeZone &lt;- R6Class(&quot;TimeZone&quot;, list( # nolint: object_name_linter.
  tz = Sys.timezone(),
  get = function() {
    cat(&quot;Current time zone: &quot;, self$tz, &quot;\n&quot;, sep = &quot;&quot;)
    invisible(self)
  },
  set = function(tz) {
    stopifnot(tz %in% OlsonNames())
    Sys.setenv(TZ = tz) # nolint: undesirable_function_linter.
    self$tz &lt;- tz
    cat(&quot;Set time zone: &quot;, self$tz, &quot;\n&quot;, sep = &quot;&quot;)
    invisible(self)
  }
))

tz &lt;- TimeZone$new()
tz$get()</code></pre>
<pre><code>#&gt; Current time zone: America/Chicago</code></pre>
<pre class="r"><code>date()</code></pre>
<pre><code>#&gt; [1] &quot;Sun Jan 22 18:04:54 2023&quot;</code></pre>
<pre class="r"><code>tz$set(&quot;America/New_York&quot;)</code></pre>
<pre><code>#&gt; Set time zone: America/New_York</code></pre>
<pre class="r"><code>date()</code></pre>
<pre><code>#&gt; [1] &quot;Sun Jan 22 19:04:54 2023&quot;</code></pre>
<pre class="r"><code>Sys.setenv(TZ = orig_tz) # nolint: undesirable_function_linter.</code></pre>
<p>Bug: like <code>Cards</code>, <code>TimeZone</code> should set
<code>tz</code> in <code>initialize()</code>.</p>
<p>AR Solutions: To create an R6 class that allows us to get and set the
time zone, we provide the respective functions as public methods to the
R6 class.</p>
<pre class="r"><code>Timezone &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;Timezone&quot;,
  public = list(
    get = function() {
      Sys.timezone()
    },
    set = function(value) {
      stopifnot(value %in% OlsonNames())
      old &lt;- self$get()
      Sys.setenv(TZ = value) # nolint: undesirable_function_linter.
      invisible(old)
    }
  )
)</code></pre>
<p>(When setting, we return the old value invisibly because this makes
it easy to restore the previous value.)</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Create an R6 class that manages the current working directory. It
should have <code>$get()</code> and <code>$set()</code> methods.</li>
</ol>
<p>Answer: similar to <code>TimeZone</code>,
<code>WorkingDirectory</code> initializes <code>wd</code> to
<code>getwd()</code>.</p>
<pre class="r"><code>orig_wd &lt;- getwd()

WorkingDirectory &lt;- R6Class(&quot;WorkingDirectory&quot;, list( # nolint: object_name_linter.
  wd = getwd(),
  get = function() {
    cat(&quot;Current directory: &quot;, self$wd, &quot;\n&quot;, sep = &quot;&quot;)
    invisible(self)
  },
  set = function(dir) {
    self$wd &lt;- setwd(dir) # nolint: undesirable_function_linter.
    cat(&quot;Set directory: &quot;, self$wd, &quot;\n&quot;, sep = &quot;&quot;)
    invisible(self)
  }
))

wd &lt;- WorkingDirectory$new()
wd$get()</code></pre>
<pre><code>#&gt; Current directory: /private/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T/RtmpIlUcah/build_analysis_site</code></pre>
<pre class="r"><code>wd$set(&quot;assets&quot;)</code></pre>
<pre><code>#&gt; Set directory: /private/var/folders/vn/cw5f9gws42v9m8mdsds_zbl00000gp/T/RtmpIlUcah/build_analysis_site</code></pre>
<pre class="r"><code>list.files()</code></pre>
<pre><code>#&gt; [1] &quot;recursive-1.png&quot; &quot;recursive-2.png&quot;</code></pre>
<pre class="r"><code>setwd(orig_wd) # nolint: undesirable_function_linter.</code></pre>
<p>AR Solutions: Take a look at the following implementation, which is
quite minimalistic:</p>
<pre class="r"><code>WorkingDirectory &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;WorkingDirectory&quot;,
  public = list(
    get = function() {
      getwd()
    },
    set = function(value) {
      setwd(value) # nolint: undesirable_function_linter.
    }
  )
)</code></pre>
<p>Bug: like <code>Cards</code>, <code>WorkingDirectory</code> should
set <code>wd</code> in <code>initialize()</code>. Also, as AR Solutions
notes in a comment:</p>
<blockquote>
<p>You should never do <code>get = getwd()</code> etc because in
packages, that inlines the function definition at package build time,
creating a subtle dependency that will cause bugs that are extremely
difficult to track down</p>
</blockquote>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>Why can’t you model the time zone or current working directory with
an S3 class?</li>
</ol>
<p>Answer: per exercise 3, time zone and current working directory are
both stateful.</p>
<p>AR Solutions: Because S3 classes are not suitable for modelling a
state that changes over time. S3 methods should (almost) always return
the same result when called with the same inputs.</p>
<hr />
<ol start="7" style="list-style-type: decimal">
<li>What base type are R6 objects built on top of? What attributes do
they have?</li>
</ol>
<p>Answer: R6n objects are built on environments, and have a class
attribute with an S3 hierarchy including the base R6 class, per
14.2.5.</p>
<pre class="r"><code>typeof(tz)</code></pre>
<pre><code>#&gt; [1] &quot;environment&quot;</code></pre>
<pre class="r"><code>attributes(tz)</code></pre>
<pre><code>#&gt; $class
#&gt; [1] &quot;TimeZone&quot; &quot;R6&quot;</code></pre>
<p>AR Solutions: R6 objects are built on top of environments. They have
a <code>class</code> attribute, which is a character vector containing
the class name, the name of any super classes (if existent) and the
string <code>"R6"</code> as the last element.</p>
<hr />
</div>
<div id="exercises-7" class="section level2">
<h2>14.3.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Create a bank account class that prevents you from directly setting
the account balance, but you can still withdraw from and deposit to.
Throw an error if you attempt to go into overdraft.</li>
</ol>
<p>Answer: <code>SecureAccount</code> uses a private internal balance
exposed through an active function.</p>
<pre class="r"><code>SecureAccount &lt;- R6Class(&quot;SecureAccount&quot;, # nolint: object_name_linter.
  private = list(
    .balance = 0L
  ),
  public = list(
    deposit = function(value) {
      stopifnot(is.integer(value), length(value) == 1)
      private$.balance &lt;- private$.balance + value
      invisible(self)
    },
    withdraw = function(value) {
      stopifnot(is.integer(value), length(value) == 1, value &lt;= private$.balance)
      private$.balance &lt;- private$.balance - value
      invisible(self)
    }
  ),
  active = list(
    balance = function(value) {
      if (missing(value)) {
        private$.balance
      } else {
        stop(&quot;`$balance` is read only&quot;, call. = FALSE)
      }
    }
  )
)

sa &lt;- SecureAccount$new()
sa$deposit(10L)
sa$withdraw(5L)
try(sa$withdraw(20L))</code></pre>
<pre><code>#&gt; Error in sa$withdraw(20L) : value &lt;= private$.balance is not TRUE</code></pre>
<pre class="r"><code>try(sa$balance &lt;- 100L)</code></pre>
<pre><code>#&gt; Error : `$balance` is read only</code></pre>
<pre class="r"><code>sa$balance</code></pre>
<pre><code>#&gt; [1] 5</code></pre>
<p>AR Solutions: To fulfill this requirement, we make balance a private
field. The user has to use the <code>$deposit()</code> and
<code>$withdraw()</code> methods which have access to the balance
field.</p>
<pre class="r"><code>BankAccountStrict2 &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;BankAccountStrict2&quot;,
  public = list(
    deposit = function(dep = 0) {
      private$balance &lt;- private$balance + dep
      invisible(self)
    },
    withdraw = function(draw = 0) {
      if (private$balance - draw &lt; 0) {
        stop(
          &quot;Your `withdraw` must be smaller &quot;,
          &quot;than your `balance`.&quot;,
          call. = FALSE
        )
      }
      private$balance &lt;- private$balance - draw
      invisible(self)
    }
  ),
  private = list(
    balance = 0
  )
)</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Create a class with a write-only <code>$password</code> field. It
should have <code>$check_password(password)</code> method that returns
<code>TRUE</code> or <code>FALSE</code>, but there should be no way to
view the complete password.</li>
</ol>
<p>Answer: <code>Login</code> implements a write-only
<code>$password</code> field using an active function.
<code>check_password()</code> will error if a password hasn’t been set.
In real life, this should be implemented with a secure password hashing
function, like <code>bcrypt</code> or <code>scrypt</code>.</p>
<pre class="r"><code>Login &lt;- R6Class(&quot;Login&quot;, # nolint: object_name_linter.
  private = list(
    .password = NULL
  ),
  public = list(
    check_password = function(password) {
      stopifnot(is.character(password), length(password) == 1)
      if (is.null(private$.password)) stop(&quot;Error: password not set&quot;)
      password == private$.password
    }
  ),
  active = list(
    password = function(value) {
      if (missing(value)) {
        stop(&quot;`$password` is write only&quot;, call. = FALSE)
      } else {
        stopifnot(is.character(value), length(value) == 1)
        private$.password &lt;- value
        invisible(self)
      }
    }
  )
)

l &lt;- Login$new()
try(l$check_password(&quot;Password1&quot;))</code></pre>
<pre><code>#&gt; Error in l$check_password(&quot;Password1&quot;) : Error: password not set</code></pre>
<pre class="r"><code>l$password &lt;- &quot;Password1&quot;
l$check_password(&quot;Password1&quot;)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>l$check_password(&quot;Password2&quot;)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>try(l$password)</code></pre>
<pre><code>#&gt; Error : `$password` is write only</code></pre>
<p>AR Solutions: To protect the password from changes and direct access,
the password will be a private field. Further, our <code>Password</code>
will get its own print method which hides the password.</p>
<pre class="r"><code>Password &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;Password&quot;,
  public = list(
    print = function(...) {
      cat(&quot;&lt;Password&gt;: ********\n&quot;)
      invisible(self)
    },
    set = function(value) {
      private$password &lt;- value
    },
    check = function(password) {
      identical(password, private$password)
    }
  ),
  private = list(
    password = NULL
  )
)</code></pre>
<p>Let’s create one instance of our new class and confirm that the
password is neither accessible nor visible, but still check-able.</p>
<pre class="r"><code>my_pw &lt;- Password$new()
my_pw$set(&quot;snuffles&quot;)
my_pw$password</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>my_pw</code></pre>
<pre><code>#&gt; &lt;Password&gt;: ********</code></pre>
<pre class="r"><code>my_pw$check(&quot;snuggles&quot;)</code></pre>
<pre><code>#&gt; [1] FALSE</code></pre>
<pre class="r"><code>my_pw$check(&quot;snuffles&quot;)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<p>Note: the AR Solutions class properly masks the password when calling
<code>print()</code>, but mine does not:</p>
<pre class="r"><code>l</code></pre>
<pre><code>#&gt; &lt;Login&gt;
#&gt;   Public:
#&gt;     check_password: function (password) 
#&gt;     clone: function (deep = FALSE) 
#&gt;     password: active binding
#&gt;   Private:
#&gt;     .password: Password1</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Extend the <code>Rando</code> class with another active binding that
allows you to access the previous random value. Ensure that active
binding is the only way to access the value.</li>
</ol>
<p>Answer: the updated <code>Rando</code> class sets a private value
when <code>random</code> is run that is accessible only through
<code>previous</code>, initially set to <code>NA</code>.</p>
<pre class="r"><code>Rando &lt;- R6::R6Class(&quot;Rando&quot;, # nolint: object_name_linter.
  private = list(
    .previous = NA
  ),
  active = list(
    random = function(value) {
      if (missing(value)) {
        private$.previous &lt;- runif(1)
        private$.previous
      } else {
        stop(&quot;Can&#39;t set `$random`&quot;, call. = FALSE)
      }
    },
    previous = function(value) {
      if (missing(value)) {
        private$.previous
      } else {
        stop(&quot;Can&#39;t set `$previous`&quot;, call. = FALSE)
      }
    }
  )
)
x &lt;- Rando$new()

x$previous</code></pre>
<pre><code>#&gt; [1] NA</code></pre>
<pre class="r"><code>x$random</code></pre>
<pre><code>#&gt; [1] 0.9643438</code></pre>
<pre class="r"><code>x$previous</code></pre>
<pre><code>#&gt; [1] 0.9643438</code></pre>
<pre class="r"><code>x$random</code></pre>
<pre><code>#&gt; [1] 0.1186832</code></pre>
<pre class="r"><code>x$previous</code></pre>
<pre><code>#&gt; [1] 0.1186832</code></pre>
<p>AR Solutions: To access the previous random value from an instance,
we add a private <code>$last_random</code> field to our class, and we
modify <code>$random()</code> to write to this field, whenever it is
called. To access the <code>$last_random</code> field we provide
<code>$previous()</code>.</p>
<pre class="r"><code>Rando &lt;- R6::R6Class( # nolint: object_name_linter.
  classname = &quot;Rando&quot;,
  private = list(
    last_random = NULL
  ),
  active = list(
    random = function(value) {
      if (missing(value)) {
        private$last_random &lt;- runif(1)
        private$last_random
      } else {
        stop(&quot;Can&#39;t set `$random`.&quot;, call. = FALSE)
      }
    },
    previous = function(value) {
      if (missing(value)) {
        private$last_random
      }
    }
  )
)</code></pre>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Can subclasses access private fields/methods from their parent?
Perform an experiment to find out.</li>
</ol>
<p>Answer: <code>LoginEvil</code> shows that subclasses <em>can</em>
access private fields from their parent.</p>
<pre class="r"><code>LoginEvil &lt;- R6Class(&quot;LoginEvil&quot;, # nolint: object_name_linter.
  inherit = Login,
  public = list(
    steal_password = function() {
      cat(&quot;The password is: &quot;, private$.password, &quot;\n&quot;, sep = &quot;&quot;)
    }
  )
)

evil &lt;- LoginEvil$new()
evil$password &lt;- &quot;SuperSecretPassword&quot;
evil$steal_password()</code></pre>
<pre><code>#&gt; The password is: SuperSecretPassword</code></pre>
<p>AR Solutions: To find out if private fields/methods can be accessed
from subclasses, we first create a class <code>A</code> with a private
field <code>foo</code> and a private method <code>bar()</code>.
Afterwards, an instance of a subclass <code>B</code> is created and
calls the <code>foobar()</code> methods, which tries to access the
<code>foo</code> field and the <code>bar()</code> method from its
superclass <code>A</code>.</p>
<pre class="r"><code>A &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;A&quot;,
  private = list(
    field = &quot;foo&quot;,
    method = function() {
      &quot;bar&quot;
    }
  )
)
B &lt;- R6Class( # nolint: object_name_linter.
  classname = &quot;B&quot;,
  inherit = A,
  public = list(
    test = function() {
      cat(&quot;Field:  &quot;, super$field, &quot;\n&quot;, sep = &quot;&quot;)
      cat(&quot;Method: &quot;, super$method(), &quot;\n&quot;, sep = &quot;&quot;)
    }
  )
)
B$new()$test()</code></pre>
<pre><code>#&gt; Field:  
#&gt; Method: bar</code></pre>
<p>We conclude that subclasses can access private methods from their
superclasses, but not private fields.</p>
<p>Note: as I discovered, private fields are not accessible through
<code>super$</code>, but <em>are</em> accessible through
<code>private$</code>.</p>
<hr />
</div>
<div id="exercises-8" class="section level2">
<h2>14.4.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Create a class that allows you to write a line to a specified file.
You should open a connection to the file in <code>$initialize()</code>,
append a line using <code>cat()</code> in <code>$append_line()</code>,
and close the connection in <code>$finalize()</code>.</li>
</ol>
<p>Answer: <code>WriteFile</code> implemented below.</p>
<pre class="r"><code>WriteFile &lt;- R6Class(&quot;WriteFile&quot;, list( # nolint: object_name_linter.
  wfile = NULL,
  initialize = function(filename) {
    self$wfile &lt;- file(filename, &quot;a&quot;)
  },
  append_line = function(line) {
    cat(line, file = self$wfile)
  },
  finalize = function() {
    close(self$wfile)
  }
))

tmp &lt;- tempfile()
wf &lt;- WriteFile$new(tmp)
wf$append_line(&quot;The quick brown fox jumps over the lazy dog.\n&quot;)
readLines(tmp)</code></pre>
<pre><code>#&gt; [1] &quot;The quick brown fox jumps over the lazy dog.&quot;</code></pre>
<p>AR Solutions: Our <code>FileWriter</code> class will create a
connection to a file at initialization. Therefore, we open a connection
to a user specified file during the initialisation. Note that we need to
set <code>open = "a"</code> in <code>file()</code> to open connection
for appending text. Otherwise, <code>cat()</code> would only work when
applied to files, but not with connections as explicitly asked for in
the exercise. Further, we add the <code>append_line()</code> method and
a <code>close()</code> statement as finalizer.</p>
<pre class="r"><code>FileWriter &lt;- R6::R6Class( # nolint: object_name_linter.
  classname = &quot;FileWriter&quot;,
  public = list(
    con = NULL,
    initialize = function(filename) {
      self$con &lt;- file(filename, open = &quot;a&quot;)
    },
    finalize = function() {
      close(self$con)
    },
    append_line = function(x) {
      cat(x, &quot;\n&quot;, sep = &quot;&quot;, file = self$con)
    }
  )
)</code></pre>
<hr />
</div>
</div>
<div id="s4" class="section level1">
<h1>15 S4</h1>
<pre class="r"><code>rm(list = ls())</code></pre>
<p>S4 provides a formal approach to functional OOP. The underlying ideas
are similar to S3 (the topic of Chapter 13), but implementation is much
stricter and makes use of specialised functions for creating classes
(<code>setClass()</code>), generics (<code>setGeneric()</code>), and
methods (<code>setMethod()</code>). Additionally, S4 provides both
multiple inheritance (i.e. a class can have multiple parents) and
multiple dispatch (i.e. method dispatch can use the class of multiple
arguments).</p>
<p>An important new component of S4 is the <strong>slot</strong>, a
named component of the object that is accessed using the specialised
subsetting operator <code>@</code> (pronounced at). The set of slots,
and their classes, forms an important part of the definition of an S4
class.</p>
<div id="exercises-9" class="section level2">
<h2>15.2.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li><code>lubridate::period()</code> returns an S4 class. What slots
does it have? What class is each slot? What accessors does it
provide?</li>
</ol>
<p>Answer: the S4 class, <code>Period</code>, has 6 slots: .Data, year,
month, day, hour, and minute, all numeric. I couldn’t figure out how to
get the accessors.</p>
<pre class="r"><code>p &lt;- lubridate::period()
is(p)</code></pre>
<pre><code>#&gt; [1] &quot;Period&quot;   &quot;Timespan&quot; &quot;numeric&quot;  &quot;vector&quot;</code></pre>
<pre class="r"><code>vapply(slotNames(p), function(x) class(slot(p, x)), character(1))</code></pre>
<pre><code>#&gt;     .Data      year     month       day      hour    minute 
#&gt; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot;</code></pre>
<p>AR Solutions: Objects of the S4 <code>Period</code> class have six
slots named <code>year</code>, <code>month</code>, <code>day</code>,
<code>hour</code>, <code>minute</code>, and <code>.Data</code> (which
contains the number of seconds). All slots are of type double. Most
fields can be retrieved by an identically named accessor
(e.g. <code>lubridate::year()</code> will return the field), use
<code>second()</code> to get the <code>.Data</code> slot.</p>
<p>As a short example, we create a period of 1 second, 2 minutes, 3
hours, 4 days and 5 weeks.</p>
<pre class="r"><code>example_12345 &lt;- lubridate::period(
  c(1, 2, 3, 4, 5),
  c(&quot;second&quot;, &quot;minute&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;week&quot;)
)</code></pre>
<p>This should add up to a period of 39 days, 3 hours, 2 minutes and 1
second.</p>
<pre class="r"><code>example_12345</code></pre>
<pre><code>#&gt; [1] &quot;39d 3H 2M 1S&quot;</code></pre>
<p>When we inspect <code>example_12345</code>, we see the fields and
infer that the seconds are stored in the <code>.Data</code> field.</p>
<pre class="r"><code>str(example_12345)</code></pre>
<pre><code>#&gt; Formal class &#39;Period&#39; [package &quot;lubridate&quot;] with 6 slots
#&gt;   ..@ .Data : num 1
#&gt;   ..@ year  : num 0
#&gt;   ..@ month : num 0
#&gt;   ..@ day   : num 39
#&gt;   ..@ hour  : num 3
#&gt;   ..@ minute: num 2</code></pre>
<p>Notes: it is easier to just use <code>getClass</code> to enumerate
slots and slot classes:</p>
<pre class="r"><code>getClass(is(lubridate::period()))</code></pre>
<pre><code>#&gt; Class &quot;Period&quot; [package &quot;lubridate&quot;]
#&gt; 
#&gt; Slots:
#&gt;                                                       
#&gt; Name:    .Data    year   month     day    hour  minute
#&gt; Class: numeric numeric numeric numeric numeric numeric
#&gt; 
#&gt; Extends: 
#&gt; Class &quot;Timespan&quot;, directly
#&gt; Class &quot;numeric&quot;, from data part
#&gt; Class &quot;vector&quot;, by class &quot;numeric&quot;, distance 2</code></pre>
<p>Methods defined for a particular class can be listed using
<code>showMethods()</code>, and S4 methods can be listed using
<code>.S4methods()</code>:</p>
<pre class="r"><code>.S4methods(&quot;Period&quot;)</code></pre>
<pre><code>#&gt; no methods found</code></pre>
<p><code>Period</code> has no S4 methods, only regular functions.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What other ways can you find help for a method? Read
<code>?"?"</code> and summarise the details.</li>
</ol>
<p>Answer: there are three ways to get help for a method:</p>
<ol style="list-style-type: decimal">
<li><code>?function</code> provides the function documentation</li>
<li><code>methods?function</code> provides the overall documentation
methods for the function</li>
<li><code>methods?function(signature)</code> provides the documentation
for a specific method</li>
</ol>
<p>AR Solutions: Besides adding <code>?</code> in front of a function
call (i.e. <code>?method()</code>), we may find:</p>
<ul>
<li>general documentation for a generic via
<code>?genericName</code></li>
<li>general documentation for the methods of a generic via
<code>methods?genericName</code></li>
<li>documentation for a specific method via
<code>ClassName?methodName</code>.</li>
</ul>
<hr />
</div>
<div id="exercises-10" class="section level2">
<h2>15.3.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Extend the Person class with fields to match
<code>utils::person()</code>. Think about what slots you will need, what
class each slot should have, and what you’ll need to check in your
validity method.</li>
</ol>
<p>Answer: the <code>Person</code> class uses the fields from
<code>utils::person()</code>, excluding deprecated fields. Per the docs,
<code>family</code> must be a string (length 1), others can be vectors
(but this is not enforced).</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Person&quot;,
  slots = c(
    given = &quot;character&quot;,
    family = &quot;character&quot;,
    email = &quot;character&quot;,
    role = &quot;character&quot;,
    comment = &quot;character&quot;
  ),
  prototype = list(
    given = NA_character_,
    family = NA_character_,
    email = NA_character_,
    role = NA_character_,
    comment = NA_character_
  )
)

setValidity(&quot;Person&quot;, function(object) {
  # regex from https://www.nicebread.de/validating-email-adresses-in-r/
  regex &lt;- &quot;\\&lt;[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\&gt;&quot;

  if (length(object@family) &gt; 1) {
    &quot;@family must be a string (length 1)&quot;
  } else if (!is.na(object@email) &amp; !grepl(regex, object@email, ignore.case = TRUE)) {
    &quot;invalid @email&quot;
  } else {
    TRUE
  }
}) |&gt;
  invisible()

Person &lt;- function(given = NA_character_, family = NA_character_, # nolint: object_name_linter.
                   email = NA_character_, role = NA_character_, comment = NA_character_) {
  given &lt;- as.character(given)
  family &lt;- as.character(family)
  email &lt;- as.character(email)
  role &lt;- as.character(role)
  comment &lt;- as.character(comment)

  new(&quot;Person&quot;, given = given, family = family, email = email, role = role, comment = comment)
}

Person(&quot;John&quot;, &quot;Benninghoff&quot;, email = &quot;john@example.com&quot;, comment = 51)
try(Person(&quot;John&quot;, c(&quot;Three&quot;, &quot;Last&quot;, &quot;Names&quot;)))
try(Person(&quot;John&quot;, email = &quot;invalid@local&quot;))</code></pre>
<p>AR Solutions: The Person class from <em>Advanced R</em> contains the
slots <code>name</code> and <code>age</code>. The person class from the
<code>{utils}</code> package contains the slots <code>given</code>
(vector of given names), <code>family</code>, <code>role</code>,
<code>email</code> and <code>comment</code> (see
<code>?utils::person</code>).</p>
<p>All slots from <code>utils::person()</code> besides <code>role</code>
must be of type character and length 1. The entries in the
<code>role</code> slot must match one of the following abbreviations
“aut”, “com”, “cph”, “cre”, “ctb”, “ctr”, “dtc”, “fnd”, “rev”, “ths”,
“trl”. Therefore, <code>role</code> might be of different length than
the other slots and we’ll add a corresponding constraint within the
validator.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
# Definition of the Person class
setClass(&quot;Person&quot;,
  slots = c(
    age = &quot;numeric&quot;,
    given = &quot;character&quot;,
    family = &quot;character&quot;,
    role = &quot;character&quot;,
    email = &quot;character&quot;,
    comment = &quot;character&quot;
  ),
  prototype = list(
    age = NA_real_,
    given = NA_character_,
    family = NA_character_,
    role = NA_character_,
    email = NA_character_,
    comment = NA_character_
  )
)
# Helper to create instances of the Person class
Person &lt;- function(given, family, # nolint: object_name_linter.
                   age = NA_real_,
                   role = NA_character_,
                   email = NA_character_,
                   comment = NA_character_) {
  age &lt;- as.double(age)
  new(&quot;Person&quot;,
    age = age,
    given = given,
    family = family,
    role = role,
    email = email,
    comment = comment
  )
}
# Validator to ensure that each slot is of length one
setValidity(&quot;Person&quot;, function(object) { # nolint: cyclocomp_linter.
  invalids &lt;- character(0)
  if (length(object@age) != 1 ||
    length(object@given) != 1 ||
    length(object@family) != 1 ||
    length(object@email) != 1 ||
    length(object@comment) != 1) {
    invalids &lt;- paste0(
      &quot;@name, @age, @given, @family, @email, &quot;,
      &quot;@comment must be of length 1&quot;
    )
  }

  known_roles &lt;- c(
    NA_character_, &quot;aut&quot;, &quot;com&quot;, &quot;cph&quot;, &quot;cre&quot;, &quot;ctb&quot;,
    &quot;ctr&quot;, &quot;dtc&quot;, &quot;fnd&quot;, &quot;rev&quot;, &quot;ths&quot;, &quot;trl&quot;
  )

  if (!all(object@role %in% known_roles)) {
    paste(
      &quot;@role(s) must be one of&quot;,
      paste(known_roles, collapse = &quot;, &quot;) # nolint: paste_linter.
    )
  }

  if (length(invalids)) {
    return(invalids)
  }
  TRUE
}) |&gt;
  invisible()</code></pre>
<p>Notes: while I missed including <code>age</code>, our implementations
are similar except for validations.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What happens if you define a new S4 class that doesn’t have any
slots? (Hint: read about virtual classes in
<code>?setClass</code>.)</li>
</ol>
<p>Answer: defining a new class with no slots makes it a virtual class,
which can’t be used to create new objects, but can be used to define a
class union.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Virtual&quot;)
try(new(&quot;Virtual&quot;))
setClassUnion(&quot;Virtual&quot;, &quot;Person&quot;)
getClass(&quot;Virtual&quot;)</code></pre>
<p>AR Solutions: It depends on the other arguments. If we inherit from
another class, we get the same slots. But something interesting happens
if we don’t inherit from an existing class. We get a virtual class. A
virtual class can’t be instantiated:</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Human&quot;)
try(new(&quot;Human&quot;))</code></pre>
<p>But can be inherited from:</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Programmer&quot;, contains = &quot;Human&quot;)</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Imagine you were going to reimplement factors, dates, and data
frames in S4. Sketch out the <code>setClass()</code> calls that you
would use to define the classes. Think about appropriate
<code>slots</code> and <code>prototype</code>.</li>
</ol>
<p>Answer: sketch below. Default values would be set in
<code>initialize()</code>.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Factor&quot;,
  slots = list(
    x = &quot;character&quot;,
    levels = &quot;character&quot;,
    labels = &quot;character&quot;,
    exclude = &quot;character&quot;,
    ordered = &quot;logical&quot;,
    nmax = &quot;integer&quot;
  ),
  prototype = list(
    x = character(0),
    levels = character(0),
    labels = character(0),
    exclude = NA_character_,
    ordered = FALSE,
    nmax = NA_integer_
  )
)

setClass(&quot;S4Date&quot;,
  slots = list(
    days = &quot;integer&quot;
  ),
  prototype = list(
    days = 0L
  )
)

setClass(&quot;DataFrame&quot;,
  slots = list(
    data = &quot;matrix&quot;,
    col_names = &quot;character&quot;,
    row_names = &quot;character&quot;
  ),
  prototype = list(
    data = matrix(nrow = 0, ncol = 0),
    col_names = NULL,
    row_names = NULL
  )
)</code></pre>
<p>AR Solutions: For all these classes we need one slot for the data and
one slot per attribute. Keep in mind, that inheritance matters for
ordered factors and dates. For data frames, special checks like equal
lengths of the underlying list’s elements should be done within a
validator.</p>
<p>For simplicity we don’t introduce an explicit subclass for ordered
factors. Instead, we introduce <code>ordered</code> as a slot.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Factor&quot;,
  slots = c(
    data = &quot;integer&quot;,
    levels = &quot;character&quot;,
    ordered = &quot;logical&quot;
  ),
  prototype = list(
    data = integer(),
    levels = character(),
    ordered = FALSE
  )
)
new(&quot;Factor&quot;, data = c(1L, 2L), levels = letters[1:3])</code></pre>
<p>The <code>Date2</code> class stores its dates as integers, similarly
to base R which uses doubles. Dates don’t have any other attributes.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Date2&quot;,
  slots = list(
    data = &quot;integer&quot;
  ),
  prototype = list(
    data = integer()
  )
)

new(&quot;Date2&quot;, data = 1L)</code></pre>
<p>Our <code>DataFrame</code> class consists of a list and a slot for
<code>row.names</code>. Most of the logic (e.g. checking that all
elements of the list are a vector, and that they all have the same
length) would need to be part of a validator.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;DataFrame&quot;,
  slots = c(
    data = &quot;list&quot;,
    row.names = &quot;character&quot;
  ),
  prototype = list(
    data = list(),
    row.names = character(0)
  )
)

new(&quot;DataFrame&quot;, data = list(a = 1, b = 2))</code></pre>
<p>Notes:</p>
<ul>
<li>A key insight from AR Solutions is that the objects need one slot
for data and one for each attribute</li>
<li>My implementation of <code>Factor</code> is wrong, where the AR
Solutions answer is clearly right</li>
<li>The implementations of the new <code>Date</code> object are similar;
the prototype for AR Solutions is better</li>
<li>The AR Solutions <code>DataFrame</code> omits column names (names),
where mine does not; using a list for the data in <code>DataFrame</code>
is a better choice, but harder to implement</li>
</ul>
<pre class="r"><code>attributes(data.frame())</code></pre>
<pre><code>#&gt; $names
#&gt; character(0)
#&gt; 
#&gt; $row.names
#&gt; integer(0)
#&gt; 
#&gt; $class
#&gt; [1] &quot;data.frame&quot;</code></pre>
<hr />
</div>
<div id="exercises-11" class="section level2">
<h2>15.4.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Add <code>age()</code> accessors for the <code>Person</code>
class.</li>
</ol>
<p>Answer: the code below adds age accessors to Advanced R
<code>Person</code>.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Person&quot;,
  slots = c(
    name = &quot;character&quot;,
    age = &quot;numeric&quot;
  ),
  prototype = list(
    name = NA_character_,
    age = NA_real_
  )
)

john &lt;- new(&quot;Person&quot;, name = &quot;John Smith&quot;)

setGeneric(&quot;age&quot;, function(x) standardGeneric(&quot;age&quot;)) |&gt;
  invisible()
setMethod(&quot;age&quot;, &quot;Person&quot;, function(x) x@age)

age(john)

setGeneric(&quot;age&lt;-&quot;, function(x, value) standardGeneric(&quot;age&lt;-&quot;)) |&gt;
  invisible()
setMethod(&quot;age&lt;-&quot;, &quot;Person&quot;, function(x, value) {
  x@age &lt;- value
  validObject(x)
  x
})

age(john) &lt;- 51
age(john)</code></pre>
<p>AR Solutions: We implement the accessors via an <code>age()</code>
generic, with a method for the <code>Person</code> class and a
corresponding replacement function <code>age&lt;-</code>:</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setGeneric(&quot;age&quot;, function(x) standardGeneric(&quot;age&quot;))
setMethod(&quot;age&quot;, &quot;Person&quot;, function(x) x@age)

setGeneric(&quot;age&lt;-&quot;, function(x, value) standardGeneric(&quot;age&lt;-&quot;))
setMethod(&quot;age&lt;-&quot;, &quot;Person&quot;, function(x, value) {
  x@age &lt;- value
  validObject(x)
  x
})</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>In the definition of the generic, why is it necessary to repeat the
name of the generic twice?</li>
</ol>
<p>Answer: according to the R docs, <code>setGeneric(name)</code>
specifies an existing function. When creating a new generic, the form
<code>setGeneric(name, def)</code> is used, where <code>def</code> is
<code>standardGeneric(name)</code>.</p>
<p>AR Solutions: Within <code>setGeneric()</code> the <code>name</code>
(1st argument) is needed as the name of the generic. Then, the name also
explicitly incorporates method dispatch via
<code>standardGeneric()</code> within the generic’s body
(<code>def</code> parameter of <code>setGeneric()</code>). This
behaviour is similar to <code>UseMethod()</code> in S3.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Why does the <code>show()</code> method defined in Section 15.4.3
use <code>is(object)[[1]]</code>? (Hint: try printing the employee
subclass.)</li>
</ol>
<p>Answer: <code>is(object)</code> returns a vector for a subclass, with
the current class first.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Employee&quot;,
  contains = &quot;Person&quot;,
  slots = c(
    boss = &quot;Person&quot;
  ),
  prototype = list(
    boss = new(&quot;Person&quot;)
  )
)

setMethod(&quot;show&quot;, &quot;Person&quot;, function(object) {
  cat(is(object)[[1]], &quot;\n&quot;,
    &quot;  Name: &quot;, object@name, &quot;\n&quot;,
    &quot;  Age:  &quot;, object@age, &quot;\n&quot;,
    sep = &quot;&quot;
  )
})

john
jane &lt;- new(&quot;Employee&quot;, name = &quot;Jane Doe&quot;)
is(jane)
jane</code></pre>
<p>AR Solutions: <code>is(object)</code> returns the class of the
object. <code>is(object)</code> also contains the superclass, for
subclasses like <code>Employee</code>. In order to always return the
most specific class (the subclass), <code>show()</code> returns the
first element of <code>is(object)</code>.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What happens if you define a method with different argument names to
the generic?</li>
</ol>
<p>Answer: this should cause method dispatch to fail, but I don’t know
of a way to test.</p>
<p>AR Solutions: It depends. We first create the object
<code>hadley</code> of class <code>Person</code>:</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
.Person &lt;- setClass( # nolint: object_name_linter.
  &quot;Person&quot;,
  slots = c(name = &quot;character&quot;, age = &quot;numeric&quot;)
)
hadley &lt;- .Person(name = &quot;Hadley&quot;)
hadley</code></pre>
<p>Now let’s see which arguments can be supplied to the
<code>show()</code> generic.</p>
<pre class="r"><code>formals(&quot;show&quot;)</code></pre>
<pre><code>#&gt; $object</code></pre>
<p>Usually, we would use this argument when defining a new method.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setMethod(&quot;show&quot;, &quot;Person&quot;, function(object) {
  cat(object@name, &quot;creates hard exercises&quot;)
})

hadley</code></pre>
<p>When we supply another name as a first element of our method
(e.g. <code>x</code> instead of <code>object</code>), this element will
be matched to the correct <code>object</code> argument and we receive a
warning. Our method will work, though:</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setMethod(&quot;show&quot;, &quot;Person&quot;, function(x) {
  cat(x@name, &quot;creates hard exercises&quot;)
})

hadley</code></pre>
<p>If we add more arguments to our method than our generic can handle,
we will get an error.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
try(
  setMethod(&quot;show&quot;, &quot;Person&quot;, function(x, y) {
    cat(x@name, &quot;is&quot;, x@age, &quot;years old&quot;)
  })
)</code></pre>
<p>If we do this with arguments added to the correctly written
<code>object</code> argument, we will receive an informative error
message. It states that we could add other argument names for generics,
which can take the <code>...</code> argument.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
try(
  setMethod(&quot;show&quot;, &quot;Person&quot;, function(object, y) {
    cat(object@name, &quot;is&quot;, object@age, &quot;years old&quot;)
  })
)</code></pre>
<hr />
</div>
<div id="exercises-12" class="section level2">
<h2>15.5.5 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Draw the method graph for
<code>f(sweat_smile, kissing_cat)</code></li>
</ol>
<p>Answer: skipped.</p>
<p>AR Solutions: Look at the graph and repeat after me: “I will keep my
class structure simple and use multiple inheritance sparingly”.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Draw the method graph for
<code>f(smiley, wink, kissing_smiling_eyes)</code></li>
</ol>
<p>Answer: skipped.</p>
<p>AR Solutions: We see that the method graph below looks simpler than
the one above. Relatively speaking, multiple dispatch seems to introduce
less complexity than multiple inheritance. Use it with care, though!</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Take the last example which shows multiple dispatch over two classes
that use multiple inheritance. What happens if you define a method for
all terminal classes? Why does method dispatch not save us much work
here?</li>
</ol>
<p>Answer: since all terminal nodes are equidistant from the classes,
the method is ambiguous. This is true at the first level as well. The
only way to avoid ambiguity is to avoid method dispatch altogether and
define a method at the root node.</p>
<p>AR Solutions: We will introduce ambiguity, since one class has
distance 2 to all terminal nodes and the other four have distance 1 to
two terminal nodes each. To resolve this ambiguity we have to define
five more methods, one per class combination.</p>
<hr />
</div>
<div id="exercises-13" class="section level2">
<h2>15.6.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>What would a full <code>setOldClass()</code> definition look like
for an ordered factor (i.e. add <code>slots</code> and
<code>prototype</code> the definition above)?</li>
</ol>
<p>Answer: building on the AR Solutions example and the
<code>factor</code> example in 15.6.1, the following S4 object behaves
like the <code>ordered()</code> version:</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Ordered&quot;,
  contains = &quot;integer&quot;,
  slots = c(
    levels = &quot;character&quot;,
    ordered = &quot;logical&quot;
  ),
  prototype = structure(
    integer(),
    levels = character(),
    ordered = TRUE
  )
)
setOldClass(&quot;ordered&quot;, S4Class = &quot;Ordered&quot;)

o &lt;- new(&quot;Ordered&quot;, 1:4, levels = letters[1:4])
o
str(ordered(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)))</code></pre>
<p>AR Solutions: The purpose of <code>setOldClass()</code> lies in
registering an S3 class as a “formally defined class”, so that it can be
used within the S4 object-oriented programming system. When using it, we
may provide the argument <code>S4Class</code>, which will inherit the
slots and their default values (prototype) to the registered class.</p>
<p>Let’s build an S4 <code>OrderedFactor</code> on top of the S3 factor
in such a way.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setOldClass(&quot;factor&quot;) # use build-in definition for brevity
OrderedFactor &lt;- setClass( # nolint: object_name_linter.
  &quot;OrderedFactor&quot;,
  contains = &quot;factor&quot;, # inherit from registered S3 class
  slots = c(
    levels = &quot;character&quot;,
    ordered = &quot;logical&quot; # add logical order slot
  ),
  prototype = structure(
    integer(),
    levels = character(),
    ordered = logical() # add default value
  )
)</code></pre>
<p>We can now register the (S3) ordered-class, while providing an “S4
template”. We can also use the S4-class to create new object
directly.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setOldClass(&quot;ordered&quot;, S4Class = &quot;OrderedFactor&quot;)
x &lt;- OrderedFactor(
  c(1L, 2L, 2L),
  levels = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;),
  ordered = TRUE
)
str(x)</code></pre>
<p>Notes: while my class <code>Ordered</code> looks similar to the AR
Solutions version, it does not include the S3 class:</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
str(o)</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Define a <code>length</code> method for the <code>Person</code>
class.</li>
</ol>
<p>Answer: since <code>Person</code> is a vector class, its length is
the <code>length()</code> of any of its fields (we use Person2 here due
to prevent conflicts with the already defined Person class):</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
setClass(&quot;Person2&quot;,
  slots = c(
    name = &quot;character&quot;,
    age = &quot;numeric&quot;
  ),
  prototype = list(
    name = NA_character_,
    age = NA_real_
  )
)

setGeneric(&quot;length&quot;) |&gt;
  invisible()
setMethod(&quot;length&quot;, &quot;Person2&quot;, function(x) length(x@name))

people &lt;- new(&quot;Person2&quot;, name = c(&quot;John Smith&quot;, &quot;Jane Doe&quot;), age = c(NA_real_, NA_real_))
people
length(people)</code></pre>
<p>AR Solutions: We keep things simple and will just return
<code>"180cm"</code> when the <code>length()</code> method is called on
a <code>Person</code> object. The method can be defined either as an S3
or S4 method.</p>
<pre class="r"><code># TODO: eval = FALSE set to allow rendering using build_analysis_site()
length.Person &lt;- function(x) &quot;180cm&quot; # S3
setMethod(&quot;length&quot;, &quot;Person&quot;, function(x) &quot;180cm&quot;) # S4</code></pre>
<hr />
</div>
</div>
<div id="trade-offs" class="section level1">
<h1>16 Trade-offs</h1>
<p>You now know about the three most important OOP toolkits available in
R. Now that you understand their basic operation and the principles that
underlie them, we can start to compare and contrast the systems in order
to understand their strengths and weaknesses. This will help you pick
the system that is most likely to solve new problems.</p>
<p>Overall, when picking an OO system, I recommend that you default to
S3. S3 is simple, and widely used throughout base R and CRAN. While it’s
far from perfect, its idiosyncrasies are well understood and there are
known approaches to overcome most shortcomings. If you have an existing
background in programming you are likely to lean towards R6, because it
will feel familiar. I think you should resist this tendency for two
reasons. Firstly, if you use R6 it’s very easy to create a non-idiomatic
API that will feel very odd to native R users, and will have surprising
pain points because of the reference semantics. Secondly, if you stick
to R6, you’ll lose out on learning a new way of thinking about OOP that
gives you a new set of tools for solving problems.</p>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiBBZHZhbmNlZCBSIFdvcmtib29rIChPYmplY3Qtb3JpZW50ZWQgcHJvZ3JhbW1pbmcpCmRhdGU6ICcyMDIyLTA4LTE1JwpvdXRwdXQ6CiAgaHRtbF9kb2N1bWVudDoKICAgIHRoZW1lOgogICAgICB2ZXJzaW9uOiA1CiAgICB0b2M6IHllcwogICAgdG9jX2Zsb2F0OgogICAgICBjb2xsYXBzZWQ6IHllcwogICAgICBzbW9vdGhfc2Nyb2xsOiBubwotLS0KCldvcmtib29rIGZvciBjb21wbGV0aW5nIHF1aXp6ZXMgYW5kIGV4ZXJjaXNlcyBmcm9tIHRoZSAiT2JqZWN0LW9yaWVudGVkIHByb2dyYW1taW5nIiBjaGFwdGVycyBvZiBbQWR2YW5jZWQgUl0oaHR0cHM6Ly9hZHYtci5oYWRsZXkubnovaW5kZXguaHRtbCksIHNlY29uZCBlZGl0aW9uLCB3aXRoIGNvbXBhcmlzb25zIHRvIHNvbHV0aW9ucyBmcm9tIFtBZHZhbmNlZCBSIFNvbHV0aW9uc10oaHR0cHM6Ly9hZHZhbmNlZC1yLXNvbHV0aW9ucy5yYmluZC5pbykuCgpgYGB7ciBzZXR1cCwgbWVzc2FnZSA9IEZBTFNFLCB3YXJuaW5nID0gRkFMU0V9CmxpYnJhcnkoc2xvb3ApCmxpYnJhcnkocHVycnIpCmxpYnJhcnkoZHBseXIpCmxpYnJhcnkoUjYpCmxpYnJhcnkobWV0aG9kcykKCiMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaGFkbGV5L2Fkdi1yL2Jsb2IvbWFzdGVyL2NvbW1vbi5SCmtuaXRyOjpvcHRzX2NodW5rJHNldCgKICBjb21tZW50ID0gIiM+IiwKICBmaWcuYWxpZ24gPSAiY2VudGVyIgopCgprbml0cjo6a25pdF9ob29rcyRzZXQoCiAgc21hbGxfbWFyID0gZnVuY3Rpb24oYmVmb3JlLCBvcHRpb25zLCBlbnZpcikgewogICAgaWYgKGJlZm9yZSkgewogICAgICBwYXIobWFyID0gYyg0LjEsIDQuMSwgMC41LCAwLjUpKSAjIG5vbGludDogdW5kZXNpcmFibGVfZnVuY3Rpb25fbGludGVyLgogICAgfQogIH0KKQpgYGAKCiMgSW50cm9kdWN0aW9uCgpUaGlzIHdvcmtib29rIGluY2x1ZGVzIGFuc3dlcnMgYW5kIHNvbHV0aW9ucyB0byB0aGUgcXVpenplcyBhbmQgZXhlcmNpc2VzIGZyb20gW0FkdmFuY2VkIFJdKGh0dHBzOi8vYWR2LXIuaGFkbGV5Lm56L2luZGV4Lmh0bWwpIGFuZCBbQWR2YW5jZWQgUiBTb2x1dGlvbnNdKGh0dHBzOi8vYWR2YW5jZWQtci1zb2x1dGlvbnMucmJpbmQuaW8pLCBvcmdhbml6ZWQgYnkgY2hhcHRlci4gSXQgaW5jbHVkZXMgZXhjZXJwdHMgZnJvbSBib3RoIGJvb2tzLCBjb3BpZWQgaGVyZS4KCioqV0FSTklORywgU1BPSUxFUlMhKiogSWYgeW91IGhhdmVuJ3QgcmVhZCBBZHZhbmNlZCBSIGFuZCBpbnRlbmQgdG8gY29tcGxldGUgdGhlIHF1aXp6ZXMgYW5kIGV4ZXJjaXNlcywgZG9uJ3QgcmVhZCB0aGlzIG5vdGVib29rLiBJdCBjb250YWlucyBteSAocG90ZW50aWFsbHkgd3JvbmcpIGFuc3dlcnMgdG8gYm90aC4KCiMgMTIgQmFzZSB0eXBlcwoKVG8gdGFsayBhYm91dCBvYmplY3RzIGFuZCBPT1AgaW4gUiB3ZSBmaXJzdCBuZWVkIHRvIGNsZWFyIHVwIGEgZnVuZGFtZW50YWwgY29uZnVzaW9uIGFib3V0IHR3byB1c2VzIG9mIHRoZSB3b3JkICJvYmplY3QiLiBTbyBmYXIgaW4gdGhpcyBib29rLCB3ZSd2ZSB1c2VkIHRoZSB3b3JkIGluIHRoZSBnZW5lcmFsIHNlbnNlIGNhcHR1cmVkIGJ5IEpvaG4gQ2hhbWJlcnMnIHBpdGh5IHF1b3RlOiAiRXZlcnl0aGluZyB0aGF0IGV4aXN0cyBpbiBSIGlzIGFuIG9iamVjdCIuIEhvd2V2ZXIsIHdoaWxlIGV2ZXJ5dGhpbmcgX2lzXyBhbiBvYmplY3QsIG5vdCBldmVyeXRoaW5nIGlzIG9iamVjdC1vcmllbnRlZC4gVGhpcyBjb25mdXNpb24gYXJpc2VzIGJlY2F1c2UgdGhlIGJhc2Ugb2JqZWN0cyBjb21lIGZyb20gUywgYW5kIHdlcmUgZGV2ZWxvcGVkIGJlZm9yZSBhbnlvbmUgdGhvdWdodCB0aGF0IFMgbWlnaHQgbmVlZCBhbiBPT1Agc3lzdGVtLiBUaGUgdG9vbHMgYW5kIG5vbWVuY2xhdHVyZSBldm9sdmVkIG9yZ2FuaWNhbGx5IG92ZXIgbWFueSB5ZWFycyB3aXRob3V0IGEgc2luZ2xlIGd1aWRpbmcgcHJpbmNpcGxlLgoKTW9zdCBvZiB0aGUgdGltZSwgdGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gb2JqZWN0cyBhbmQgb2JqZWN0LW9yaWVudGVkIG9iamVjdHMgaXMgbm90IGltcG9ydGFudC4gQnV0IGhlcmUgd2UgbmVlZCB0byBnZXQgaW50byB0aGUgbml0dHkgZ3JpdHR5IGRldGFpbHMgc28gd2UnbGwgdXNlIHRoZSB0ZXJtcyBfX2Jhc2Ugb2JqZWN0c19fIGFuZCBfX09PIG9iamVjdHNfXyB0byBkaXN0aW5ndWlzaCB0aGVtLgoKIyAxMyBTMwoKUzMgaXMgUidzIGZpcnN0IGFuZCBzaW1wbGVzdCBPTyBzeXN0ZW0uIFMzIGlzIGluZm9ybWFsIGFuZCBhZCBob2MsIGJ1dCB0aGVyZSBpcyBhIGNlcnRhaW4gZWxlZ2FuY2UgaW4gaXRzIG1pbmltYWxpc206IHlvdSBjYW4ndCB0YWtlIGF3YXkgYW55IHBhcnQgb2YgaXQgYW5kIHN0aWxsIGhhdmUgYSB1c2VmdWwgT08gc3lzdGVtLiBGb3IgdGhlc2UgcmVhc29ucywgeW91IHNob3VsZCB1c2UgaXQsIHVubGVzcyB5b3UgaGF2ZSBhIGNvbXBlbGxpbmcgcmVhc29uIHRvIGRvIG90aGVyd2lzZS4gUzMgaXMgdGhlIG9ubHkgT08gc3lzdGVtIHVzZWQgaW4gdGhlIGJhc2UgYW5kIHN0YXRzIHBhY2thZ2VzLCBhbmQgaXQncyB0aGUgbW9zdCBjb21tb25seSB1c2VkIHN5c3RlbSBpbiBDUkFOIHBhY2thZ2VzLgoKUzMgaXMgdmVyeSBmbGV4aWJsZSwgd2hpY2ggbWVhbnMgaXQgYWxsb3dzIHlvdSB0byBkbyB0aGluZ3MgdGhhdCBhcmUgcXVpdGUgaWxsLWFkdmlzZWQuIElmIHlvdSdyZSBjb21pbmcgZnJvbSBhIHN0cmljdCBlbnZpcm9ubWVudCBsaWtlIEphdmEgdGhpcyB3aWxsIHNlZW0gcHJldHR5IGZyaWdodGVuaW5nLCBidXQgaXQgZ2l2ZXMgUiBwcm9ncmFtbWVycyBhIHRyZW1lbmRvdXMgYW1vdW50IG9mIGZyZWVkb20uICBJdCBtYXkgYmUgdmVyeSBkaWZmaWN1bHQgdG8gcHJldmVudCBwZW9wbGUgZnJvbSBkb2luZyBzb21ldGhpbmcgeW91IGRvbid0IHdhbnQgdGhlbSB0byBkbywgYnV0IHlvdXIgdXNlcnMgd2lsbCBuZXZlciBiZSBoZWxkIGJhY2sgYmVjYXVzZSB0aGVyZSBpcyBzb21ldGhpbmcgeW91IGhhdmVuJ3QgaW1wbGVtZW50ZWQgeWV0LiBTaW5jZSBTMyBoYXMgZmV3IGJ1aWx0LWluIGNvbnN0cmFpbnRzLCB0aGUga2V5IHRvIGl0cyBzdWNjZXNzZnVsIHVzZSBpcyBhcHBseWluZyB0aGUgY29uc3RyYWludHMgeW91cnNlbGYuIFRoaXMgY2hhcHRlciB3aWxsIHRoZXJlZm9yZSB0ZWFjaCB5b3UgdGhlIGNvbnZlbnRpb25zIHlvdSBzaG91bGQgKGFsbW9zdCkgYWx3YXlzIGZvbGxvdy4KClRoZSBnb2FsIG9mIHRoaXMgY2hhcHRlciBpcyB0byBzaG93IHlvdSBob3cgdGhlIFMzIHN5c3RlbSB3b3Jrcywgbm90IGhvdyB0byB1c2UgaXQgZWZmZWN0aXZlbHkgdG8gY3JlYXRlIG5ldyBjbGFzc2VzIGFuZCBnZW5lcmljcy4gSSdkIHJlY29tbWVuZCBjb3VwbGluZyB0aGUgdGhlb3JldGljYWwga25vd2xlZGdlIGZyb20gdGhpcyBjaGFwdGVyIHdpdGggdGhlIHByYWN0aWNhbCBrbm93bGVkZ2UgZW5jb2RlZCBpbiB0aGUgW3ZjdHJzIHBhY2thZ2VdKGh0dHBzOi8vdmN0cnMuci1saWIub3JnKS4KCiMjIDEzLjIuMSBFeGVyY2lzZXMKCjEuICBEZXNjcmliZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGB0LnRlc3QoKWAgYW5kIGB0LmRhdGEuZnJhbWUoKWAuCiAgICBXaGVuIGlzIGVhY2ggZnVuY3Rpb24gY2FsbGVkPwoKYGBge3J9CmZ0eXBlKHQudGVzdCkKZnR5cGUodC5kYXRhLmZyYW1lKQpzM19kaXNwYXRjaCh0LnRlc3QoZm9ybXVsYSgpKSkKczNfZGlzcGF0Y2godChkYXRhLmZyYW1lKCkpKQpgYGAKCkFuc3dlcjogQXMgbm90ZWQgYnkgYHNsb29wOjpmdHlwZSgpYCBhbmQgdGhlIGRvY3MsIGB0LnRlc3QoKWAgaXMgYSBTMyBnZW5lcmljLCBhbmQgYHQuZGF0YS5mcmFtZSgpYCBpcyBhbiBTMyBtZXRob2QgZm9yIGB0KClgICh0cmFuc3Bvc2UpLiBgdC5kYXRhLmZyYW1lKClgIGlzIGNhbGxlZCBhcyBhIG1ldGhvZCB3aGVuIGNhbGxpbmcgYHQoeClgIHdoZW4gYHhgIGlzIGEgYGRhdGEuZnJhbWVgLiBgdC50ZXN0KClgIGNhbGxzIGVpdGhlciBgdC50ZXN0LmRlZmF1bHRgIG9yIGB0LnRlc3QuZm9ybXVsYWAuCgpBUiBTb2x1dGlvbnM6IEJlY2F1c2Ugb2YgUzMncyBgZ2VuZXJpYy5jbGFzcygpYCBuYW1pbmcgc2NoZW1lLCBib3RoIGZ1bmN0aW9ucyBtYXkgaW5pdGlhbGx5IGxvb2sgc2ltaWxhciwgd2hpbGUgdGhleSBhcmUgaW4gZmFjdCB1bnJlbGF0ZWQuCgotIGB0LnRlc3QoKWAgaXMgYSAqZ2VuZXJpYyogZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHQtdGVzdC4gCi0gYHQuZGF0YS5mcmFtZSgpYCBpcyBhICptZXRob2QqIHRoYXQgZ2V0cyBjYWxsZWQgYnkgdGhlIGdlbmVyaWMgYHQoKWAgdG8gdHJhbnNwb3NlIGRhdGEgZnJhbWUgaW5wdXQuCgpEdWUgdG8gUidzIFMzIGRpc3BhdGNoIHJ1bGVzLCBgdC50ZXN0KClgIHdvdWxkIGFsc28gZ2V0IGNhbGxlZCB3aGVuIGB0KClgIGlzIGFwcGxpZWQgdG8gYW4gb2JqZWN0IG9mIGNsYXNzIGB0ZXN0YAoKLS0tCgoyLiAgTWFrZSBhIGxpc3Qgb2YgY29tbW9ubHkgdXNlZCBiYXNlIFIgZnVuY3Rpb25zIHRoYXQgY29udGFpbiBgLmAgaW4gdGhlaXIKICAgIG5hbWUgYnV0IGFyZSBub3QgUzMgbWV0aG9kcy4KCmBgYHtyfQpmdHlwZShhcy5jaGFyYWN0ZXIpCmZ0eXBlKGFzLmRhdGEuZnJhbWUpCmZ0eXBlKGRhdGEuZnJhbWUpCmZ0eXBlKGV2YWwucGFyZW50KQpmdHlwZShmaWxlLnBhdGgpCmZ0eXBlKGZpbGUuY29weSkKZnR5cGUoaXMubnVsbCkKZnR5cGUoaXMuZGF0YS5mcmFtZSkKZnR5cGUoU3lzLmxvY2FsZWNvbnYpCmZ0eXBlKFN5cy50aW1lKQpgYGAKCkFuc3dlcjoKCi0gQWxsIG9mIHRoZSBgYXMuYCBmdW5jdGlvbnMKLSBgZGF0YS5mcmFtZWAKLSBBbGwgb2YgdGhlIGBmaWxlLmAgZnVuY3Rpb25zCi0gQWxsIG9mIHRoZSBgaXMuYCBmdW5jdGlvbnMKLSBBbGwgb2YgdGhlIGBTeXMuYCBmdW5jdGlvbnMKCkFSIFNvbHV0aW9uczogSW4gcmVjZW50IHllYXJzICJzbmFrZV9jYXNlIi1zdHlsZSBoYXMgYmVjb21lIGluY3JlYXNpbmdseSBjb21tb24gd2hlbiBuYW1pbmcgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMgaW4gUi4gQnV0IG1hbnkgZnVuY3Rpb25zIGluIGJhc2UgUiB3aWxsIGNvbnRpbnVlIHRvIGJlICJwb2ludC5zZXBhcmF0ZWQiLCB3aGljaCBpcyB3aHkgc29tZSBpbmNvbnNpc3RlbmN5IGluIHlvdXIgUiBjb2RlIG1vc3QgbGlrZWx5IGNhbm5vdCBiZSBhdm9pZGVkLiAoYGluc3RhbGwucGFja2FnZXMoKSwgcmVhZC5jc3YoKSwgbGlzdC5maWxlcygpLCBkb3dubG9hZC5maWxlKCksIGRhdGEuZnJhbWUoKSwgYXMuY2hhcmFjdGVyKCksIFN5cy5EYXRlKCksIGFsbC5lcXVhbCgpLCBkby5jYWxsKCksIG9uLmV4aXQoKWApCgotLS0KCjMuICBXaGF0IGRvZXMgdGhlIGBhcy5kYXRhLmZyYW1lLmRhdGEuZnJhbWUoKWAgbWV0aG9kIGRvPyBXaHkgaXMKICAgIGl0IGNvbmZ1c2luZz8gSG93IGNvdWxkIHlvdSBhdm9pZCB0aGlzIGNvbmZ1c2lvbiBpbiB5b3VyIG93bgogICAgY29kZT8KCmBgYHtyfQpzM19kaXNwYXRjaChhcy5kYXRhLmZyYW1lKGRhdGEuZnJhbWUoKSkpCmBgYAoKQW5zd2VyOiBgYXMuZGF0YS5mcmFtZS5kYXRhLmZyYW1lKClgIGlzIHRoZSBtZXRob2QgdXNlZCB0byBjb2VyY2UgYSBgZGF0YS5mcmFtZWAgdG8gYSBgZGF0YS5mcmFtZWAuIFRoaXMgaXMgY29uZnVzaW5nIGJlY2F1c2UgdGhlIGNsYXNzIGNvbnRhaW5zIGEgcGVyaW9kIChhcyBkb2VzIHRoZSBmdW5jdGlvbiBjYWxsKTsgYXZvaWRpbmcgcGVyaW9kcyBpbXByb3ZlcyByZWFkYWJpbGl0eTogYGFzX2RhdGFmcmFtZS5kYXRhZnJhbWVgIG1ha2VzIHRoZSBnZW5lcmljIGFuZCBtZXRob2QgY2xlYXIuCgpBUiBTb2x1dGlvbnM6IFRoZSBmdW5jdGlvbiBgYXMuZGF0YS5mcmFtZS5kYXRhLmZyYW1lKClgIGltcGxlbWVudHMgdGhlIGBkYXRhLmZyYW1lKClgICptZXRob2QqIGZvciB0aGUgYGFzLmRhdGEuZnJhbWUoKWAgKmdlbmVyaWMqLCB3aGljaCBjb2VyY2VzIG9iamVjdHMgdG8gZGF0YSBmcmFtZXMuCgpUaGUgbmFtZSBpcyBjb25mdXNpbmcsIGJlY2F1c2UgaXQgZG9lcyBub3QgY2xlYXJseSBjb21tdW5pY2F0ZSB0aGUgdHlwZSBvZiB0aGUgZnVuY3Rpb24sIHdoaWNoIGNvdWxkIGJlIGEgcmVndWxhciBmdW5jdGlvbiwgYSBnZW5lcmljIG9yIGEgbWV0aG9kLiBFdmVuIGlmIHdlIGFzc3VtZSBhIG1ldGhvZCwgdGhlIGFtb3VudCBvZiBgLmAncyBtYWtlcyBpdCBkaWZmaWN1bHQgdG8gc2VwYXJhdGUgdGhlIGdlbmVyaWMtIGFuZCB0aGUgY2xhc3MtcGFydCBvZiB0aGUgbmFtZS4gSXMgaXQgdGhlIGBkYXRhLmZyYW1lLmRhdGEuZnJhbWUoKWAgbWV0aG9kIGZvciB0aGUgYGFzKClgIGdlbmVyaWM/IElzIGl0IHRoZSBgZnJhbWUuZGF0YS5mcmFtZSgpYCBtZXRob2QgZm9yIHRoZSBgYXMuZGF0YSgpYCBnZW5lcmljPwoKV2UgY291bGQgYXZvaWQgdGhpcyBjb25mdXNpb24gYnkgYXBwbHlpbmcgYSBkaWZmZXJlbnQgbmFtaW5nIGNvbnZlbnRpb24gKGUuZy4gInNuYWtlX2Nhc2UiKSBmb3Igb3VyIGNsYXNzIGFuZCBmdW5jdGlvbiBuYW1lcy4KCi0tLQoKNC4gIERlc2NyaWJlIHRoZSBkaWZmZXJlbmNlIGluIGJlaGF2aW91ciBpbiB0aGVzZSB0d28gY2FsbHMuCgpgYGB7cn0Kc2V0LnNlZWQoMTAxNCkKc29tZV9kYXlzIDwtIGFzLkRhdGUoIjIwMTctMDEtMzEiKSArIHNhbXBsZSgxMCwgNSkKbWVhbihzb21lX2RheXMpCm1lYW4odW5jbGFzcyhzb21lX2RheXMpKQoKczNfZGlzcGF0Y2gobWVhbihzb21lX2RheXMpKQpzM19kaXNwYXRjaChtZWFuKHVuY2xhc3Moc29tZV9kYXlzKSkpCmBgYAoKQW5zd2VyOiB0aGUgZmlyc3QgY2FsbCBjYWxjdWxhdGVzIHRoZSBtZWFuIHVzaW5nIGBtZWFuLkRhdGUoKWAsIGFuZCBzbyByZXR1cm5zIGEgZGF0ZS4gdXNpbmcgYHVuY2xhc3MoKWAgY2hhbmdlcyB0aGUgZGF0ZSB0byBpdHMgdW5kZXJseWluZyB2YWx1ZSAoZG91YmxlKSB3aGljaCBjYWxjdWxhdGVzIHRoZSBtZWFuIHVzaW5nIGBtZWFuLmRlZmF1bHQoKWAuCgpBUiBTb2x1dGlvbnM6IGBtZWFuKClgIGlzIGEgZ2VuZXJpYyBmdW5jdGlvbiwgd2hpY2ggd2lsbCBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBiYXNlZCBvbiB0aGUgY2xhc3Mgb2YgdGhlIGlucHV0LiBgc29tZV9kYXlzYCBoYXMgdGhlIGNsYXNzIGBEYXRlYCBhbmQgYG1lYW4uRGF0ZShzb21lX2RheXMpYCB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBtZWFuIGRhdGUgb2YgYHNvbWVfZGF5c2AuCgpBZnRlciBgdW5jbGFzcygpYCBoYXMgcmVtb3ZlZCB0aGUgY2xhc3MgYXR0cmlidXRlIGZyb20gYHNvbWVfZGF0ZWAsIHRoZSBkZWZhdWx0IG1ldGhvZCBpcyBjaG9zZW4uIGBtZWFuLmRlZmF1bHQodW5jbGFzcyhzb21lX2RheXMpKWAgdGhlbiBjYWxjdWxhdGVzIHRoZSBtZWFuIG9mIHRoZSB1bmRlcmx5aW5nIGRvdWJsZS4KCi0tLQoKNS4gIFdoYXQgY2xhc3Mgb2Ygb2JqZWN0IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHJldHVybj8gV2hhdCBiYXNlIHR5cGUgaXMgaXQgCiAgICBidWlsdCBvbj8gV2hhdCBhdHRyaWJ1dGVzIGRvZXMgaXQgdXNlPwoKYGBge3J9CnggPC0gZWNkZihycG9pcygxMDAsIDEwKSkKeAoKc3RyKHgpCmBgYAoKQW5zd2VyOiB0aGUgY29kZSByZXR1cm5zIGFuIG9iamVjdCBvZiBjbGFzcyBgZWNkZmAsIHdoaWNoIGlzIGJ1aWxkIG9uIHRoZSBgc3RlcGZ1bmAgb2JqZWN0LCBhbmQgdGhlIGBmdW5jdGlvbmAgYmFzZSB0eXBlLiBJdCBhZGRpdGlvbmFsbHkgaW5jbHVkZXMgdGhlIGBjYWxsYCBhdHRyaWJ1dGUuCgpBUiBTb2x1dGlvbnM6IEl0IHJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBjbGFzcyBgZWNkZmAgKGVtcGlyaWNhbCBjdW11bGF0aXZlIGRpc3RyaWJ1dGlvbiBmdW5jdGlvbikgd2l0aCB0aGUgc3VwZXJjbGFzc2VzIGBzdGVwZnVuYCBhbmQgYGZ1bmN0aW9uYC4gVGhlIGBlY2RmYCBvYmplY3QgaXMgYnVpbHQgb24gdGhlIGJhc2UgdHlwZSBgY2xvc3VyZWAgKGEgZnVuY3Rpb24pLiBUaGUgZXhwcmVzc2lvbiwgd2hpY2ggd2FzIHVzZWQgdG8gY3JlYXRlIGl0IChgcnBvaXMoMTAwLCAxMClgKSwgaXMgc3RvcmVkIGluIHRoZSBgY2FsbGAgYXR0cmlidXRlLgoKYGBge3J9CnR5cGVvZih4KQpgYGAKCi0tLQoKNi4gIFdoYXQgY2xhc3Mgb2Ygb2JqZWN0IGRvZXMgdGhlIGZvbGxvd2luZyBjb2RlIHJldHVybj8gV2hhdCBiYXNlIHR5cGUgaXMgaXQgCiAgICBidWlsdCBvbj8gV2hhdCBhdHRyaWJ1dGVzIGRvZXMgaXQgdXNlPwoKYGBge3J9CnggPC0gdGFibGUocnBvaXMoMTAwLCA1KSkKeAoKc3RyKHgpCnN0cih1bmNsYXNzKHgpKQpgYGAKCkFuc3dlcjogcGVyIHRoZSBkb2NzLCB0aGUgY29kZSByZXR1cm5zIGFuIG9iamVjdCBvZiBjbGFzcyBgdGFibGVgLCB3aGljaCBpcyBidWlsdCBvbiBgYXJyYXlgLCB3aGljaCB1c2VzIHRoZSBgZGltbmFtZXNgIGF0dHJpYnV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIGEgdmVjdG9yLgoKQVIgU29sdXRpb25zOiBUaGlzIGNvZGUgcmV0dXJucyBhIGB0YWJsZWAgb2JqZWN0LCB3aGljaCBpcyBidWlsdCB1cG9uIHRoZSBgaW50ZWdlcmAgdHlwZS4gVGhlIGF0dHJpYnV0ZSBgZGltbmFtZXNgIGlzIHVzZWQgdG8gbmFtZSB0aGUgZWxlbWVudHMgb2YgdGhlIGludGVnZXIgdmVjdG9yLgoKLS0tCgojIyAxMy4zLjQgRXhlcmNpc2VzCgoxLiAgV3JpdGUgYSBjb25zdHJ1Y3RvciBmb3IgYGRhdGEuZnJhbWVgIG9iamVjdHMuIFdoYXQgYmFzZSB0eXBlIGlzIGEgZGF0YQogICAgZnJhbWUgYnVpbHQgb24/IFdoYXQgYXR0cmlidXRlcyBkb2VzIGl0IHVzZT8gV2hhdCBhcmUgdGhlIHJlc3RyaWN0aW9ucwogICAgcGxhY2VkIG9uIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzPyBXaGF0IGFib3V0IHRoZSBuYW1lcz8KCmBgYHtyfQpkcHV0KGRhdGEuZnJhbWUoKSkKZHB1dChkYXRhLmZyYW1lKGEgPSAxOjIsIGIgPSAzOjQpKQp1bmNsYXNzKGRhdGEuZnJhbWUoYSA9IDE6MiwgYiA9IDM6NCkpCmBgYAoKQW5zd2VyOiBjb2RlIGJlbG93LiBUaGUgZGF0YSBmcmFtZSBpcyBidWlsdCBvbiB0aGUgbGlzdCBiYXNlIHR5cGUsIGFuZCBpbmNsdWRlcyB0aGUgbmFtZXMsIHJvdy5uYW1lcywgYW5kIGNsYXNzIGF0dHJpYnV0ZXMuIFRoaXMgaW1wbGVtZW50YXRpb24gcmVxdWlyZXMgdmFsdWVzIHRvIGJlIGEgbGlzdCwgbmFtZXMgdG8gYmUgYSBjaGFyYWN0ZXIsIGFuZCByb3cubmFtZXMgdG8gYmUgYW4gaW50ZWdlci4KCmBgYHtyfQpuZXdfZGF0YS5mcmFtZSA8LSBmdW5jdGlvbih2YWx1ZXMgPSBsaXN0KCksICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzID0gY2hhcmFjdGVyKGxlbmd0aCh2YWx1ZXMpKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Lm5hbWVzID0gaW50ZWdlcihsZW5ndGgodmFsdWVzKSkpIHsgIyBub2xpbnQ6IG9iamVjdF9uYW1lX2xpbnRlci4KICBzdG9waWZub3QoCiAgICBpcy5saXN0KHZhbHVlcyksCiAgICBpcy5jaGFyYWN0ZXIobmFtZXMpLAogICAgaXMuaW50ZWdlcihyb3cubmFtZXMpCiAgKQogIHN0cnVjdHVyZSh2YWx1ZXMsIG5hbWVzID0gbmFtZXMsIHJvdy5uYW1lcyA9IHJvdy5uYW1lcywgY2xhc3MgPSAiZGF0YS5mcmFtZSIpCn0KCm5ld19kYXRhLmZyYW1lKCkKbmV3X2RhdGEuZnJhbWUobGlzdCgxOjMsIDQ6NiwgNzo5KSkKbmV3X2RhdGEuZnJhbWUobGlzdCgxOjMsIDQ6NiwgNzo5KSwgbmFtZXMgPSBjKCJhIiwgImIiLCAiYyIpLCByb3cubmFtZXMgPSAxOjMpCmBgYAoKQVIgU29sdXRpb25zOiBEYXRhIGZyYW1lcyBhcmUgYnVpbHQgb24gbmFtZWQgbGlzdHMgb2YgdmVjdG9ycywgd2hpY2ggYWxsIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiBCZXNpZGVzIHRoZSBgY2xhc3NgIGFuZCB0aGUgY29sdW1uIG5hbWVzIChgbmFtZXNgKSwgdGhlIGByb3cubmFtZXNgIGFyZSB0aGVpciBvbmx5IGZ1cnRoZXIgYXR0cmlidXRlLiBUaGlzIG11c3QgYmUgYSBjaGFyYWN0ZXIgdmVjdG9yIHdpdGggdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBvdGhlciB2ZWN0b3JzLgoKV2UgbmVlZCB0byBwcm92aWRlIHRoZSBudW1iZXIgb2Ygcm93cyBhcyBhbiBpbnB1dCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIGNyZWF0ZSBkYXRhIGZyYW1lcyB3aXRoIDAgY29sdW1ucyBidXQgbXVsdGlwbGUgcm93cy4KClRoaXMgbGVhZHMgdG8gdGhlIGZvbGxvd2luZyBjb25zdHJ1Y3RvcjoKCmBgYHtyLCBlcnJvciA9IFRSVUV9Cm5ld19kYXRhLmZyYW1lIDwtIGZ1bmN0aW9uKHgsIG4sIHJvdy5uYW1lcyA9IE5VTEwpIHsgIyBub2xpbnQ6IG9iamVjdF9uYW1lX2xpbnRlci4KICAjIG5vbGludCBzdGFydDogY29uc2VjdXRpdmVfc3RvcGlmbm90X2xpbnRlci4KICAjIENoZWNrIGlmIHRoZSB1bmRlcmx5aW5nIG9iamVjdCBpcyBhIGxpc3QKICBzdG9waWZub3QoaXMubGlzdCh4KSkKCiAgIyBDaGVjayBhbGwgaW5wdXRzIGFyZSB0aGUgc2FtZSBsZW5ndGgKICAjIChUaGlzIGNoZWNrIGFsc28gYWxsb3dzIHRoYXQgeCBoYXMgbGVuZ3RoIDApCiAgc3RvcGlmbm90KGFsbChsZW5ndGhzKHgpID09IG4pKQogICMgbm9saW50IGVuZAoKICBpZiAoaXMubnVsbChyb3cubmFtZXMpKSB7CiAgICAjIFVzZSBzcGVjaWFsIHJvdyBuYW1lcyBoZWxwZXIgZnJvbSBiYXNlIFIKICAgIHJvdy5uYW1lcyA8LSAuc2V0X3Jvd19uYW1lcyhuKSAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIH0gZWxzZSB7CiAgICAjIE90aGVyd2lzZSBjaGVjayB0aGF0IHRoZXkncmUgYSBjaGFyYWN0ZXIgdmVjdG9yIHdpdGggdGhlCiAgICAjIGNvcnJlY3QgbGVuZ3RoCiAgICBzdG9waWZub3QoaXMuY2hhcmFjdGVyKHJvdy5uYW1lcyksIGxlbmd0aChyb3cubmFtZXMpID09IG4pCiAgfQoKICBzdHJ1Y3R1cmUoCiAgICB4LAogICAgY2xhc3MgPSAiZGF0YS5mcmFtZSIsCiAgICByb3cubmFtZXMgPSByb3cubmFtZXMKICApCn0KCiMgVGVzdAp4IDwtIGxpc3QoYSA9IDEsIGIgPSAyKQpuZXdfZGF0YS5mcmFtZSh4LCBuID0gMSkKbmV3X2RhdGEuZnJhbWUoeCwgbiA9IDEsIHJvdy5uYW1lcyA9ICJsMSIpCgojIENyZWF0ZSBhIGRhdGEgZnJhbWUgd2l0aCAwIGNvbHVtbnMgYW5kIDIgcm93cwpuZXdfZGF0YS5mcmFtZShsaXN0KCksIG4gPSAyKQpgYGAKCk5vdGU6IEFSIFNvbHV0aW9ucyBhcHByb2FjaCBhbHNvIHZhbGlkYXRlcyB0aGF0IGFsbCBpbnB1dHMgYXJlIHNhbWUgbGVuZ3RoLCBhbmQgc3VwcG9ydHMgY3JlYXRpb24gb2YgZGF0YWZyYW1lcyB3aXRoIDAgY29sdW1ucyBidXQgbXVsdGlwbGUgcm93cy4KCi0tLQoKMi4gIEVuaGFuY2UgbXkgYGZhY3RvcigpYCBoZWxwZXIgdG8gaGF2ZSBiZXR0ZXIgYmVoYXZpb3VyIHdoZW4gb25lIG9yCiAgICBtb3JlIGB2YWx1ZXNgIGlzIG5vdCBmb3VuZCBpbiBgbGV2ZWxzYC4gV2hhdCBkb2VzIGBiYXNlOjpmYWN0b3IoKWAgZG8KICAgIGluIHRoaXMgc2l0dWF0aW9uPwoKYGBge3J9Cm5ld19mYWN0b3IgPC0gZnVuY3Rpb24oeCA9IGludGVnZXIoKSwgbGV2ZWxzID0gY2hhcmFjdGVyKCkpIHsKICBzdG9waWZub3QoCiAgICBpcy5pbnRlZ2VyKHgpLAogICAgaXMuY2hhcmFjdGVyKGxldmVscykKICApCgogIHN0cnVjdHVyZSgKICAgIHgsCiAgICBsZXZlbHMgPSBsZXZlbHMsCiAgICBjbGFzcyA9ICJmYWN0b3IiCiAgKQp9CmBgYAoKQW5zd2VyOiB0aGUgZml4IGlzIHRvIHVwZGF0ZSBgdmFsaWRhdGVfZmFjdG9yKClgIHRvIGFsbG93IGBOQWAgdmFsdWVzLCBzaW5jZSB0aGUgaGVscGVyIGFscmVhZHkgZmlsbHMgaW4gYE5BYCB3aGVuIGB2YWx1ZXNgIGlzIG5vdCBmb3VuZCBpbiBgbGV2ZWxzYC4gVGhpcyBtYXRjaGVzIHRoZSBiZWhhdmlvciBvZiBgYmFzZTo6ZmFjdG9yKClgLiAKCmBgYHtyfQp2YWxpZGF0ZV9mYWN0b3IgPC0gZnVuY3Rpb24oeCkgewogIHZhbHVlcyA8LSB1bmNsYXNzKHgpCiAgbGV2ZWxzIDwtIGF0dHIoeCwgImxldmVscyIpCgogIGlmICghYWxsKGlzLm5hKHZhbHVlcykgfCB2YWx1ZXMgPiAwKSkgewogICAgc3RvcCgKICAgICAgIkFsbCBub24tbWlzc2luZyBgeGAgdmFsdWVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8iLAogICAgICBjYWxsLiA9IEZBTFNFCiAgICApCiAgfQoKICBpZiAobGVuZ3RoKGxldmVscykgPCBtYXgodmFsdWVzLCBuYS5ybSA9IFRSVUUpKSB7CiAgICBzdG9wKAogICAgICAiVGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBhcyBtYW55IGBsZXZlbHNgIGFzIHBvc3NpYmxlIHZhbHVlcyBpbiBgeGAiLAogICAgICBjYWxsLiA9IEZBTFNFCiAgICApCiAgfQoKICB4Cn0KCm15X2ZhY3RvciA8LSBmdW5jdGlvbih4ID0gY2hhcmFjdGVyKCksIGxldmVscyA9IHVuaXF1ZSh4KSkgewogIGluZCA8LSBtYXRjaCh4LCBsZXZlbHMpCiAgdmFsaWRhdGVfZmFjdG9yKG5ld19mYWN0b3IoaW5kLCBsZXZlbHMpKQp9CgpmYWN0b3IoYygiYSIsICJhIiwgImIiKSwgbGV2ZWxzID0gImEiKQpteV9mYWN0b3IoYygiYSIsICJhIiwgImIiKSwgbGV2ZWxzID0gImEiKQpgYGAKCkFSIFNvbHV0aW9uczogYGJhc2U6OmZhY3RvcigpYCBjb252ZXJ0cyB0aGVzZSB2YWx1ZXMgKHNpbGVudGx5KSBpbnRvIGBOQWBzLgoKVGhlIGBmYWN0b3IoKWAgaGVscGVyIGluY2x1ZGluZyB0aGUgY29uc3RydWN0b3IgKGBuZXdfZmFjdG9yKClgKSBhbmQgaXRzIHZhbGlkYXRvciAoYHZhbGlkYXRlX2ZhY3RvcigpYCkgd2VyZSBnaXZlbiBpbiAqQWR2YW5jZWQgUiouIEhvd2V2ZXIsIGFzIHRoZSBnb2FsIG9mIHRoaXMgcXVlc3Rpb24gaXMgdG8gdGhyb3cgYW4gZWFybHkgZXJyb3Igd2l0aGluIHRoZSBoZWxwZXIsIHdlIG9ubHkgcmVwZWF0IHRoZSBjb2RlIGZvciB0aGUgaGVscGVyOgoKVG8gaW1wcm92ZSB0aGUgYGZhY3RvcigpYCBoZWxwZXIgd2UgY2hvb3NlIHRvIHJldHVybiBhbiBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIGluc3RlYWQuCgpgYGB7ciwgZXJyb3IgPSBUUlVFfQpmYWN0b3IyIDwtIGZ1bmN0aW9uKHgsIGxldmVscyA9IHVuaXF1ZSh4KSkgewogIG5ld19sZXZlbHMgPC0gbWF0Y2goeCwgbGV2ZWxzKQoKICAjIEVycm9yIGlmIGxldmVscyBkb24ndCBpbmNsdWRlIGFsbCB2YWx1ZXMKICBtaXNzaW5nIDwtIHVuaXF1ZShzZXRkaWZmKHgsIGxldmVscykpCiAgaWYgKGxlbmd0aChtaXNzaW5nKSA+IDApIHsKICAgIHN0b3AoCiAgICAgICJUaGUgZm9sbG93aW5nIHZhbHVlcyBkbyBub3Qgb2NjdXIgaW4gdGhlIGxldmVscyBvZiB4OiAiLAogICAgICBwYXN0ZTAoIiciLCBtaXNzaW5nLCAiJyIsIGNvbGxhcHNlID0gIiwgIiksICIuIiwKICAgICAgY2FsbC4gPSBGQUxTRQogICAgKQogIH0KCiAgdmFsaWRhdGVfZmFjdG9yKG5ld19mYWN0b3IobmV3X2xldmVscywgbGV2ZWxzKSkKfQoKIyBUZXN0CnRyeShmYWN0b3IyKGMoImEiLCAiYiIsICJjIiksIGxldmVscyA9IGMoImEiLCAiYiIpKSkKYGBgCgotLS0KCjMuICBDYXJlZnVsbHkgcmVhZCB0aGUgc291cmNlIGNvZGUgb2YgYGZhY3RvcigpYC4gV2hhdCBkb2VzIGl0IGRvIHRoYXQKICAgIG15IGNvbnN0cnVjdG9yIGRvZXMgbm90PwoKYGBge3J9CmZhY3RvcihjKCJhIiwgImEiLCAiYiIsICJjIiksIGxhYmVscyA9IGMoImFscGhhIiwgImJldGEiLCAiYmV0YSIpKQpjbGFzcyhmYWN0b3IoMToxMCwgb3JkZXJlZCA9IFRSVUUpKQpgYGAKCkFuc3dlcjogdGhlIGJhc2UgaW1wbGVtZW50YXRpb246CgotIHNldHMgdGhlIHZhbHVlIHRvIGBjaGFyYWN0ZXIoMClgIGlmIHRoZSB2YWx1ZSBpcyBudWxsCi0gcmV0YWlucyB2YWx1ZSBuYW1lcwotIGFsbG93cyBhbiB1cHBlciBib3VuZCBvbiB0aGUgbnVtYmVyIG9mIGxldmVscywgYG5tYXhgCi0gY29lcmNlcyB0aGUgdmFsdWUgdG8gY2hhcmFjdGVyCi0gcHJvdmlkZXMgYSBtZXRob2QgZm9yIGV4Y2x1ZGluZyB2YWx1ZXMgZnJvbSBsZXZlbHMsIGBleGNsdWRlYAotIHByb3ZpZGVzIGBsYWJlbHNgIGZvciByZW1hcHBpbmcgZmFjdG9ycwotIGFkZHMgYW4gIm9yZGVyZWQiIGNsYXNzIGlmIHRoZSB2YWx1ZSBpcyBvcmRlcmVkIChgb3JkZXJlZCA9IFRSVUVgKQoKTm90ZTogbGFiZWxzIGFyZSBhbiBpbnRlcmVzdGluZyBhbmQgdW5leHBlY3RlZCBmZWF0dXJlIG9mIGBmYWN0b3IoKWAKCmBgYHtyfQpmYWN0b3IKYGBgCgpBUiBTb2x1dGlvbnM6IFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiAoYGJhc2U6OmZhY3RvcigpYCkgYWxsb3dzIG1vcmUgZmxleGlibGUgaW5wdXQgZm9yIGB4YC4gSXQgY29lcmNlcyBgeGAgdG8gY2hhcmFjdGVyIG9yIHJlcGxhY2VzIGl0IHdpdGggYGNoYXJhY3RlcigwKWAgKGluIGNhc2Ugb2YgYE5VTExgKS4gSXQgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIGBsZXZlbHNgIGFyZSB1bmlxdWUuIFRoaXMgaXMgYWNoaWV2ZWQgYnkgc2V0dGluZyB0aGVtIHZpYSBgYmFzZTo6bGV2ZWxzPC1gLCB3aGljaCBmYWlscyB3aGVuIGR1cGxpY2F0ZSB2YWx1ZXMgYXJlIHN1cHBsaWVkLgoKTm90ZTogSSBtaXNzZWQgdGhlIGZhY3QgdGhhdCBgYmFzZTo6bGV2ZWxzPC1gIGZhaWxzIHdoZW4gZHVwbGljYXRlIHZhbHVlcyBhcmUgc3VwcGxpZWQuCgotLS0KICAgIAo0LiAgRmFjdG9ycyBoYXZlIGFuIG9wdGlvbmFsICJjb250cmFzdHMiIGF0dHJpYnV0ZS4gUmVhZCB0aGUgaGVscCBmb3IgYEMoKWAsIAogICAgYW5kIGJyaWVmbHkgZGVzY3JpYmUgdGhlIHB1cnBvc2Ugb2YgdGhlIGF0dHJpYnV0ZS4gV2hhdCB0eXBlIHNob3VsZCBpdCAKICAgIGhhdmU/IFJld3JpdGUgdGhlIGBuZXdfZmFjdG9yKClgIGNvbnN0cnVjdG9yIHRvIGluY2x1ZGUgdGhpcyBhdHRyaWJ1dGUuCgpBbnN3ZXI6IHBlciB0aGUgImNvbnRyYXN0IHtzdGF0c30iIGRvY3VtZW50YXRpb24sIGNvbnRyYXN0IG1hdHJpY2VzIGFyZSB1c2VkIGluIGZpdHRpbmcgYW5hbHlzaXMgb2YgdmFyaWFuY2UgYW5kIHJlZ3Jlc3Npb24gbW9kZWxzLCBzbyB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSBhIG1hdHJpeC4KCmBgYHtyfQpuZXdfZmFjdG9yIDwtIGZ1bmN0aW9uKHggPSBpbnRlZ2VyKCksIGxldmVscyA9IGNoYXJhY3RlcigpLCBjb250ciA9IG1hdHJpeCgpKSB7CiAgc3RvcGlmbm90KGlzLmludGVnZXIoeCksIGlzLmNoYXJhY3RlcihsZXZlbHMpLCBpcy5tYXRyaXgoY29udHIpKQoKICBzdHJ1Y3R1cmUoCiAgICB4LAogICAgbGV2ZWxzID0gbGV2ZWxzLAogICAgY2xhc3MgPSAiZmFjdG9yIiwKICAgIGNvbnRyYXN0cyA9IGNvbnRyCiAgKQp9CmBgYAoKQVIgU29sdXRpb25zOiBXaGVuIGZhY3RvciB2YXJpYWJsZXMgKHJlcHJlc2VudGluZyBub21pbmFsIG9yIG9yZGluYWwgaW5mb3JtYXRpb24pIGFyZSB1c2VkIGluIHN0YXRpc3RpY2FsIG1vZGVscywgdGhleSBhcmUgdHlwaWNhbGx5IGVuY29kZWQgYXMgZHVtbXkgdmFyaWFibGVzIGFuZCBieSBkZWZhdWx0IGVhY2ggbGV2ZWwgaXMgY29tcGFyZWQgd2l0aCB0aGUgZmlyc3QgZmFjdG9yIGxldmVsLiBIb3dldmVyLCBtYW55IGRpZmZlcmVudCBlbmNvZGluZ3MgKCJjb250cmFzdHMiKSBhcmUgcG9zc2libGUsIHNlZSBbQ29udHJhc3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnRyYXN0XyhzdGF0aXN0aWNzKSkuCgpXaXRoaW4gUidzIGZvcm11bGEgaW50ZXJmYWNlIHlvdSBjYW4gd3JhcCBhIGZhY3RvciBpbiBgc3RhdHM6OkMoKWAgYW5kIHNwZWNpZnkgdGhlIGNvbnRyYXN0IG9mIHlvdXIgY2hvaWNlLiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHNldCB0aGUgYGNvbnRyYXN0c2AgYXR0cmlidXRlIG9mIHlvdXIgZmFjdG9yIHZhcmlhYmxlLCB3aGljaCBhY2NlcHRzIG1hdHJpeCBpbnB1dC4gKFNlZSBgP2NvbnRyLmhlbG1lcnRgIG9yIHNpbWlsYXIgZm9yIGRldGFpbHMuKQoKT3VyIHVwZGF0ZWQgYG5ld19mYWN0b3IoKWAgY29uc3RydWN0b3IgZ2V0cyBhIGBjb250cmFzdHNgIGFyZ3VtZW50LCB3aGljaCBhY2NlcHRzIGEgbnVtZXJpYyBtYXRyaXggb3IgYE5VTExgIChkZWZhdWx0KS4KCmBgYHtyfQojIFVwZGF0ZWQgbmV3X2ZhY3RvcigpIGNvbnN0cnVjdG9yCm5ld19mYWN0b3IgPC0gZnVuY3Rpb24oeCA9IGludGVnZXIoKSwKICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHMgPSBjaGFyYWN0ZXIoKSwKICAgICAgICAgICAgICAgICAgICAgICBjb250cmFzdHMgPSBOVUxMKSB7CiAgIyBub2xpbnQgc3RhcnQ6IGNvbnNlY3V0aXZlX3N0b3BpZm5vdF9saW50ZXIuCiAgc3RvcGlmbm90KGlzLmludGVnZXIoeCkpCiAgc3RvcGlmbm90KGlzLmNoYXJhY3RlcihsZXZlbHMpKQogICMgbm9saW50IGVuZAoKICBpZiAoIWlzLm51bGwoY29uc3RyYXN0cykpIHsgIyBub2xpbnQ6IG9iamVjdF91c2FnZV9saW50ZXIuIG5vdCBzdXJlIHdoeSBsaW50ciBmbGFncyB0aGlzLgogICAgc3RvcGlmbm90KGlzLm1hdHJpeChjb250cmFzdHMpICYmIGlzLm51bWVyaWMoY29udHJhc3RzKSkgIyBub2xpbnQ6IGNvbmp1bmN0X3Rlc3RfbGludGVyLgogIH0KCiAgc3RydWN0dXJlKAogICAgeCwKICAgIGxldmVscyA9IGxldmVscywKICAgIGNsYXNzID0gImZhY3RvciIsCiAgICBjb250cmFzdHMgPSBjb250cmFzdHMKICApCn0KYGBgCgotLS0KCjUuICBSZWFkIHRoZSBkb2N1bWVudGF0aW9uIGZvciBgdXRpbHM6OmFzLnJvbWFuKClgLiBIb3cgd291bGQgeW91IHdyaXRlIGEKICAgIGNvbnN0cnVjdG9yIGZvciB0aGlzIGNsYXNzPyBEb2VzIGl0IG5lZWQgYSB2YWxpZGF0b3I/IFdoYXQgbWlnaHQgYSBoZWxwZXIgCiAgICBkbz8KCmBgYHtyfQpkcHV0KGFzLnJvbWFuKDM4OTkpKQoKbmV3X3JvbWFuIDwtIGZ1bmN0aW9uKHggPSBpbnRlZ2VyKCkpIHsKICBzdG9waWZub3QoaXMuaW50ZWdlcih4KSkKCiAgc3RydWN0dXJlKAogICAgeCwKICAgIGNsYXNzID0gInJvbWFuIgogICkKfQoKbmV3X3JvbWFuKDIwMjJMKQpgYGAKCkFuc3dlcjogdGhlIHN0cnVjdHVyZSBvZiB0aGUgY2xhc3MgInJvbWFuIiBpcyBzaW1wbGUsIGFuIGludGVnZXIgd2l0aCBhIGRlZmluZWQgY2xhc3MuIEEgc2ltcGxlIGNvbnN0cnVjdG9yIHdvdWxkIHRha2UgYW4gaW50ZWdlciBhbmQgcmV0dXJuIGFuIG9iamVjdCBvZiBjbGFzcyAicm9tYW4iIGFzIGFib3ZlLiBBIHZhbGlkYXRvciBpcyBwcm9iYWJseSBub3QgbmVlZGVkLCBidXQgY291bGQgdmFsaWRhdGUgdGhhdCB0aGUgaW50ZWdlciBpcyB3aXRoaW4gdGhlIHN1cHBvcnRlZCByYW5nZSBvZiBpbnRlZ2VycyAoMS0zODk5KS4gQSBoZWxwZXIgbWlnaHQgY29lcmNlIHRoZSBudW1iZXIgdG8gYmUgYW4gaW50ZWdlciB1c2luZyBgYXMuaW50ZWdlcigpYC4KCkFSIFNvbHV0aW9uczogVGhpcyBmdW5jdGlvbiB0cmFuc2Zvcm1zIG51bWVyaWMgaW5wdXQgaW50byBSb21hbiBudW1iZXJzLiBJdCBpcyBidWlsdCBvbiB0aGUgaW50ZWdlciB0eXBlLCB3aGljaCByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgY29uc3RydWN0b3IuCgpgYGB7cn0KbmV3X3JvbWFuIDwtIGZ1bmN0aW9uKHggPSBpbnRlZ2VyKCkpIHsKICBzdG9waWZub3QoaXMuaW50ZWdlcih4KSkKICBzdHJ1Y3R1cmUoeCwgY2xhc3MgPSAicm9tYW4iKQp9CmBgYAoKVGhlIGRvY3VtZW50YXRpb24gdGVsbHMgdXMsIHRoYXQgb25seSB2YWx1ZXMgYmV0d2VlbiAxIGFuZCAzODk5IGFyZSB1bmlxdWVseSByZXByZXNlbnRlZCwgd2hpY2ggd2UgdGhlbiBpbmNsdWRlIGluIG91ciB2YWxpZGF0aW9uIGZ1bmN0aW9uLgoKYGBge3J9CnZhbGlkYXRlX3JvbWFuIDwtIGZ1bmN0aW9uKHgpIHsKICB2YWx1ZXMgPC0gdW5jbGFzcyh4KQoKICBpZiAoYW55KHZhbHVlcyA8IDEgfCB2YWx1ZXMgPiAzODk5KSkgewogICAgc3RvcCgKICAgICAgIlJvbWFuIG51bWJlcnMgbXVzdCBmYWxsIGJldHdlZW4gMSBhbmQgMzg5OS4iLAogICAgICBjYWxsLiA9IEZBTFNFCiAgICApCiAgfQoKICB4Cn0KYGBgCgpGb3IgY29udmVuaWVuY2UsIHdlIGFsbG93IHRoZSB1c2VyIHRvIGFsc28gcGFzcyByZWFsIHZhbHVlcyB0byBhIGhlbHBlciBmdW5jdGlvbi4KCmBgYHtyLCBlcnJvciA9IFRSVUV9CnJvbWFuIDwtIGZ1bmN0aW9uKHggPSBpbnRlZ2VyKCkpIHsKICB4IDwtIGFzLmludGVnZXIoeCkKCiAgdmFsaWRhdGVfcm9tYW4obmV3X3JvbWFuKHgpKQp9CgojIFRlc3QKcm9tYW4oYygxLCA3NTMsIDIwMTkpKQp0cnkocm9tYW4oMCkpCmBgYAoKLS0tCgojIyAxMy40LjQgRXhlcmNpc2VzCgoxLiAgUmVhZCB0aGUgc291cmNlIGNvZGUgZm9yIGB0KClgIGFuZCBgdC50ZXN0KClgIGFuZCBjb25maXJtIHRoYXQKICAgIGB0LnRlc3QoKWAgaXMgYW4gUzMgZ2VuZXJpYyBhbmQgbm90IGFuIFMzIG1ldGhvZC4gV2hhdCBoYXBwZW5zIGlmCiAgICB5b3UgY3JlYXRlIGFuIG9iamVjdCB3aXRoIGNsYXNzIGB0ZXN0YCBhbmQgY2FsbCBgdCgpYCB3aXRoIGl0PyBXaHk/CgpgYGB7cn0KeCA8LSBzdHJ1Y3R1cmUoMToxMCwgY2xhc3MgPSAidGVzdCIpCnQoeCkKYGBgCgpBbnN3ZXI6IGJvdGggYHQoKWAgYW5kIGB0LnRlc3QoKWAgc2ltcGx5IGNhbGwgYFVzZU1ldGhvZCgpYCwgYW5kIGFyZSBTMyBnZW5lcmljcy4KCmBgYHtyfQp0CnQudGVzdApgYGAKCkNyZWF0aW5nIGFuIG9iamVjdCB3aXRoIGNsYXNzIGB0ZXN0YCBhbmQgY2FsbGluZyBgdCgpYCB1c2VzIHRoZSBkZWZhdWx0IG1ldGhvZCBzaW5jZSBgdC50ZXN0KClgIGlzIG5vdCBhIHJlZ2lzdGVyZWQgbWV0aG9kIGZvciBgdCgpYCwgYXMgdGhpcyBjb2RlIHNob3dzOgoKYGBge3J9Cm1ldGhvZHMoInQiKQpzM19kaXNwYXRjaCh0KHgpKQpgYGAKCkFSIFNvbHV0aW9uczogV2UgY2FuIHNlZSB0aGF0IGB0LnRlc3QoKWAgaXMgYSBnZW5lcmljIGJlY2F1c2UgaXQgY2FsbHMgYFVzZU1ldGhvZCgpYC4KCmBgYHtyfQojIG9yIHNpbXBseSBjYWxsCmZ0eXBlKHQudGVzdCkKYGBgCgpJbnRlcmVzdGluZ2x5LCBSIGFsc28gcHJvdmlkZXMgaGVscGVycywgd2hpY2ggbGlzdCBmdW5jdGlvbnMgdGhhdCBsb29rIGxpa2UgbWV0aG9kcywgYnV0IGluIGZhY3QgYXJlIG5vdDoKCmBgYHtyfQp0b29sczo6bm9uUzNtZXRob2RzKCJzdGF0cyIpCmBgYAoKV2hlbiB3ZSBjcmVhdGUgYW4gb2JqZWN0IHdpdGggY2xhc3MgYHRlc3RgLCBgdCgpYCBkaXNwYXRjaGVzIHRvIHRoZSBgdC5kZWZhdWx0KClgIG1ldGhvZC4gVGhpcyBoYXBwZW5zLCBiZWNhdXNlIGBVc2VNZXRob2QoKWAgc2ltcGx5IHNlYXJjaGVzIGZvciBmdW5jdGlvbnMgbmFtZWQgYHBhc3RlMCgiZ2VuZXJpYyIsICIuIiwgYyhjbGFzcyh4KSwgImRlZmF1bHQiKSlgLgoKSG93ZXZlciwgaW4gb2xkZXIgdmVyc2lvbnMgb2YgUiAocHJlIFIgNC4wLjA7IHdoZW4gKkFkdmFuY2VkIFIqIHdhcyB3cml0dGVuKSB0aGlzIGJlaGF2aW91ciB3YXMgc2xpZ2h0bHkgZGlmZmVyZW50LiBJbnN0ZWFkIG9mIGRpc3BhdGNoaW5nIHRvIHRoZSBgdC5kZWZhdWx0KClgIG1ldGhvZCwgdGhlIGB0LnRlc3QoKWAgZ2VuZXJpYyB3YXMgZXJyb25lb3VzbHkgdHJlYXRlZCBhcyBhIG1ldGhvZCBvZiBgdCgpYCB3aGljaCB0aGVuIGRpc3BhdGNoZWQgdG8gYHQudGVzdC5kZWZhdWx0KClgIG9yICh3aGVuIGRlZmluZWQpIHRvIGB0LnRlc3QudGVzdCgpYC4KCi0tLQoKMi4gIFdoYXQgZ2VuZXJpY3MgZG9lcyB0aGUgYHRhYmxlYCBjbGFzcyBoYXZlIG1ldGhvZHMgZm9yPwoKQW5zd2VyOiBgczNfbWV0aG9kc19jbGFzcygpYCBhbnN3ZXJzIHRoaXMgcXVlc3Rpb246CgpgYGB7ciB3YXJuaW5nID0gRkFMU0V9CnMzX21ldGhvZHNfY2xhc3MoInRhYmxlIikKYGBgCgpBUiBTb2x1dGlvbnM6IFRoaXMgaXMgYSBzaW1wbGUgYXBwbGljYXRpb24gb2YgYHNsb29wOjpzM19tZXRob2RzX2NsYXNzKClgLgoKSW50ZXJlc3RpbmdseSwgdGhlIGB0YWJsZWAgY2xhc3MgaGFzIGEgbnVtYmVyIG9mIG1ldGhvZHMgZGVzaWduZWQgdG8gaGVscCBwbG90dGluZyB3aXRoIGJhc2UgZ3JhcGhpY3MuCgpgYGB7cn0KeCA8LSBycG9pcygxMDAsIDUpCnBsb3QodGFibGUoeCkpCmBgYAoKLS0tCgozLiAgV2hhdCBnZW5lcmljcyBkb2VzIHRoZSBgZWNkZmAgY2xhc3MgaGF2ZSBtZXRob2RzIGZvcj8KCkFuc3dlcjoKCmBgYHtyIHdhcm5pbmcgPSBGQUxTRX0KczNfbWV0aG9kc19jbGFzcygiZWNkZiIpCmBgYAoKQVIgU29sdXRpb25zOiBXZSB1c2UgdGhlIHNhbWUgYXBwcm9hY2ggYXMgYWJvdmUuCgpUaGUgbWV0aG9kcyBhcmUgcHJpbWFyaWx5IGRlc2lnbmVkIGZvciBkaXNwbGF5IChgcGxvdCgpYCwgYHByaW50KClgLCBgc3VtbWFyeSgpYCksIGJ1dCB5b3UgY2FuIGFsc28gZXh0cmFjdCBxdWFudGlsZXMgd2l0aCBgcXVhbnRpbGUoKWAuCgotLS0KCjQuICBXaGljaCBiYXNlIGdlbmVyaWMgaGFzIHRoZSBncmVhdGVzdCBudW1iZXIgb2YgZGVmaW5lZCBtZXRob2RzPwoKQW5zd2VyOiB1c2luZyBjb2RlIGZyb20gNi4yLjUsIGlkZW50aWZ5IGdlbmVyaWNzIGFuZCBjb3VudCBkZWZpbmVkIG1ldGhvZHM6CgpgYGB7ciwgd2FybmluZyA9IEZBTFNFfQojIGZyb20gNi4yLjUgZXhlcmNpc2VzLCB0aGlzIGNvZGUgbWFrZXMgYSBsaXN0IG9mIGFsbCBmdW5jdGlvbnMgaW4gdGhlIGJhc2UgcGFja2FnZQpmdW5zIDwtIEZpbHRlcihpcy5mdW5jdGlvbiwgbWdldChscygicGFja2FnZTpiYXNlIiwgYWxsLm5hbWVzID0gVFJVRSksIGluaGVyaXRzID0gVFJVRSkpCgpnZXRfbWV0aG9kX2NvdW50IDwtIGZ1bmN0aW9uKGZuYW1lKSB7CiAgZGF0YS5mcmFtZSgKICAgIG5hbWUgPSBmbmFtZSwKICAgICMgdGhpcyBjb2RlIHNob3VsZCB3b3JrIGJ1dCBkb2Vzbid0OgogICAgIyBtZXRob2RfY291bnQgPSBucm93KHMzX21ldGhvZHNfZ2VuZXJpYyhmbmFtZSkpICMgbm9saW50OiBjb21tZW50ZWRfY29kZV9saW50ZXIuCiAgICBtZXRob2RfY291bnQgPSBsZW5ndGgobWV0aG9kcyhmbmFtZSkpCiAgKQp9CgptYXBfZGZyKG5hbWVzKGZ1bnMpLCBnZXRfbWV0aG9kX2NvdW50KSB8PgogIGFycmFuZ2UoZGVzYyhtZXRob2RfY291bnQpKQpgYGAKClRoaXMgYnJ1dGUtZm9yY2UgY29kZSB1bnN1cnByaXNpbmdseSBpZGVudGlmaWVzIGBwcmludCgpYCBhcyBoYXZpbmcgdGhlIGdyZWF0ZXN0IG51bWJlciBvZiBtZXRob2RzLiBBIGJ1ZyBpbiBgczNfbWV0aG9kc19nZW5lcmljKClgIHByZXZlbnRzIGl0cyB1c2UgKGVycm9yIGJlbG93KS4KCmBgYApFcnJvciBpbiBnc3ViKHBhc3RlMCgiXiIsIGdlbmVyaWNfZXNjLCAiWy4sXSIpLCAiIiwgaW5mbyRtZXRob2QpIDogCmludmFsaWQgcmVndWxhciBleHByZXNzaW9uICdeKFsuLF0nLCByZWFzb24gJ01pc3NpbmcgJyknJwpgYGAKCkFSIFNvbHV0aW9uczogQSBsaXR0bGUgZXhwZXJpbWVudGF0aW9uIChhbmQgdGhpbmtpbmcgYWJvdXQgdGhlIG1vc3QgcG9wdWxhciBmdW5jdGlvbnMpIHN1Z2dlc3RzIHRoYXQgdGhlIGBwcmludCgpYCBnZW5lcmljIGhhcyB0aGUgbW9zdCBkZWZpbmVkIG1ldGhvZHMuCgpMZXQncyB2ZXJpZnkgdGhpcyBwcm9ncmFtbWF0aWNhbGx5IHdpdGggdGhlIHRvb2xzIHdlIGhhdmUgbGVhcm5lZCBpbiB0aGlzIGFuZCB0aGUgcHJldmlvdXMgY2hhcHRlcnMuCgpgYGB7ciwgbWVzc2FnZSA9IEZBTFNFfQpscyhhbGwubmFtZXMgPSBUUlVFLCBlbnZpciA9IGJhc2VlbnYoKSkgJT4lCiAgbWdldChlbnZpciA9IGJhc2VlbnYoKSkgJT4lCiAga2VlcChpc19mdW5jdGlvbikgJT4lCiAgbmFtZXMoKSAlPiUKICBrZWVwKGlzX3MzX2dlbmVyaWMpICU+JQogIG1hcCh+IHNldF9uYW1lcyhucm93KHMzX21ldGhvZHNfZ2VuZXJpYygueCkpLCAueCkpICU+JQogIGZsYXR0ZW5faW50KCkgJT4lCiAgc29ydChkZWNyZWFzaW5nID0gVFJVRSkgJT4lCiAgaGVhZCgpCmBgYAoKLS0tCgo1LiAgQ2FyZWZ1bGx5IHJlYWQgdGhlIGRvY3VtZW50YXRpb24gZm9yIGBVc2VNZXRob2QoKWAgYW5kIGV4cGxhaW4gd2h5IHRoZQogICAgZm9sbG93aW5nIGNvZGUgcmV0dXJucyB0aGUgcmVzdWx0cyB0aGF0IGl0IGRvZXMuIFdoYXQgdHdvIHVzdWFsIHJ1bGVzCiAgICBvZiBmdW5jdGlvbiBldmFsdWF0aW9uIGRvZXMgYFVzZU1ldGhvZCgpYCB2aW9sYXRlPwoKYGBge3J9CmcgPC0gZnVuY3Rpb24oeCkgewogIHggPC0gMTAKICB5IDwtIDEwICMgbm9saW50OiBvYmplY3RfdXNhZ2VfbGludGVyLgogIFVzZU1ldGhvZCgiZyIpCn0KZy5kZWZhdWx0IDwtIGZ1bmN0aW9uKHgpIGMoeCA9IHgsIHkgPSB5KQp4IDwtIDEKeSA8LSAxCmcoeCkKYGBgCgpBbnN3ZXI6IHRoZSBkb2N1bWVudGF0aW9uIHN0YXRlcyBpbiAqKlRlY2huaWNhbCBEZXRhaWxzKio6Cgo+IGBVc2VNZXRob2RgIGNyZWF0ZXMgYSBuZXcgZnVuY3Rpb24gY2FsbCB3aXRoIGFyZ3VtZW50cyBtYXRjaGVkIGFzIHRoZXkgY2FtZSBpbiB0byB0aGUgZ2VuZXJpYy4gQW55IGxvY2FsIHZhcmlhYmxlcyBkZWZpbmVkIGJlZm9yZSB0aGUgY2FsbCB0byBgVXNlTWV0aG9kYCBhcmUgcmV0YWluZWQgKHVubGlrZSBTKS4KClNvLCBgVXNlTWV0aG9kKClgIGNyZWF0ZXMgYSBuZXcgZnVuY3Rpb24gY2FsbCB3aGVyZSBgeGAgbWF0Y2hlcyBgeCA8LSAxYCBhbmQgdGhlIGxvY2FsIHZhcmlhYmxlIGB5IDwtIDEwYCBpcyByZXRhaW5lZC4gVGhpcyBpcyBwYXNzZWQgdG8gYGcuZGVmYXVsdCgpYC4gVGhpcyB2aW9sYXRlcyBib3RoIGxhenkgZXZhbHVhdGlvbiBhbmQgbGV4aWNhbCBzY29waW5nLgoKQVIgU29sdXRpb25zOiBMZXQncyB0YWtlIHRoaXMgc3RlcCBieSBzdGVwLiBJZiB5b3UgY2FsbCBgZy5kZWZhdWx0KHgpYCBkaXJlY3RseSB5b3UgZ2V0IGBjKDEsIDEpYCBhcyB5b3UgbWlnaHQgZXhwZWN0LiAKClRoZSB2YWx1ZSBib3VuZCB0byBgeGAgY29tZXMgZnJvbSB0aGUgYXJndW1lbnQsIHRoZSB2YWx1ZSBmcm9tIGB5YCBjb21lcyBmcm9tIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQuCgpCdXQgd2hlbiB3ZSBjYWxsIGBnKHgpYCB3ZSBnZXQgYGMoMSwgMTApYC4KClRoaXMgaXMgc2VlbWluZ2x5IGluY29uc2lzdGVudDogd2h5IGRvZXMgYHhgIGNvbWUgZnJvbSB0aGUgdmFsdWUgZGVmaW5lZCBpbnNpZGUgb2YgYGcoKWAsIGFuZCBgeWAgc3RpbGwgY29tZSBmcm9tIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQ/IEl0J3MgYmVjYXVzZSBgVXNlTWV0aG9kKClgIGNhbGxzIGBnLmRlZmF1bHQoKWAgaW4gYSBzcGVjaWFsIHdheSBzbyB0aGF0IHZhcmlhYmxlcyBkZWZpbmVkIGluc2lkZSB0aGUgZ2VuZXJpYyBhcmUgYXZhaWxhYmxlIHRvIG1ldGhvZHMuIFRoZSBleGNlcHRpb24gYXJlIGFyZ3VtZW50cyBzdXBwbGllZCB0byB0aGUgZnVuY3Rpb246IHRoZXkgYXJlIHBhc3NlZCBvbiBhcyBpcyBhbmQgY2Fubm90IGJlIGFmZmVjdGVkIGJ5IGNvZGUgaW5zaWRlIHRoZSBnZW5lcmljLgoKLS0tCgo2LiAgV2hhdCBhcmUgdGhlIGFyZ3VtZW50cyB0byBgW2A/IFdoeSBpcyB0aGlzIGEgaGFyZCBxdWVzdGlvbiB0byBhbnN3ZXI/CgpBbnN3ZXI6IHRoZSBwb3NzaWJsZSBhcmd1bWVudHMgaW5jbHVkZSB0aGUgYHhgLCB0aGUgb2JqZWN0IGJlaW5nIGV4dHJhY3RlZCAob3IgcmVwbGFjZWQpLCBpbmRpY2VzIChgaWAsIGBqYCwgYC4uLmApLCBgbmFtZWAsIGBkcm9wYCwgYGV4YWN0YCwgYW5kIGB2YWx1ZWAuCgpUaGlzIGlzIGEgaGFyZCBxdWVzdGlvbiB0byBhbnN3ZXIgc2luY2UgYFtgIGlzIGFuIGlycmVndWxhciBwcmltaXRpdmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIGluIG11bHRpcGxlIHdheXMsIG5vbmUgb2Ygd2hpY2ggc3VwcG9ydCB1c2luZyBhbGwgcG9zc2libGUgYXJndW1lbnRzLgoKQVIgU29sdXRpb25zOiBUaGUgc3Vic2V0dGluZyBvcGVyYXRvciBgW2AgaXMgYSBwcmltaXRpdmUgYW5kIGEgZ2VuZXJpYyBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNvbmZpcm1lZCB2aWEgYGZ0eXBlKClgLgoKYGBge3J9CmZ0eXBlKGBbYCkKYGBgCgpGb3IgcHJpbWl0aXZlIGZ1bmN0aW9ucyBgZm9ybWFscyhbKWAgcmV0dXJucyBgTlVMTGAgc28gd2UgbmVlZCB0byBmaW5kIGFub3RoZXIgd2F5IHRvIGRldGVybWluZSB0aGUgZnVuY3Rpb25zIGFyZ3VtZW50cy4gT25lIHBvc3NpYmxlIHdheSB0byBmaWd1cmUgb3V0IGBbYCdzIGFyZ3VtZW50cyB3b3VsZCBiZSB0byBpbnNwZWN0IHRoZSB1bmRlcmx5aW5nIEMgc291cmNlIGNvZGUsIHdoaWNoIGNhbiBiZSBzZWFyY2hlZCBmb3IgdmlhIGBwcnlyOjpzaG93X2Nfc291cmNlKC5QcmltaXRpdmUoIlsiKSlgLgpXaGVuIHdlIGluc3BlY3QgdGhlIGFyZ3VtZW50cyBvZiBzb21lIG9mIGBbYCdzIG1ldGhvZHMsIHdlIHNlZSB0aGF0IHRoZSBhcmd1bWVudHMgdmFyeSB3aXRoIHRoZSBjbGFzcyBvZiBgeGAuCgpgYGB7cn0KbmFtZXMoZm9ybWFscyhgWy5kYXRhLmZyYW1lYCkpCm5hbWVzKGZvcm1hbHMoYFsudGFibGVgKSkKbmFtZXMoZm9ybWFscyhgWy5EYXRlYCkpCm5hbWVzKGZvcm1hbHMoYFsuQXNJc2ApKQpgYGAKClRvIGZpbmFsbHkgZ2V0IGEgYmV0dGVyIG92ZXJ2aWV3LCB3ZSBoYXZlIHRvIHB1dCBpbiBhIGxpdHRsZSBtb3JlIGVmZm9ydCBhbmQgYWxzbyB1c2UgYHMzX21ldGhvZHNfZ2VuZXJpYygpYCBhZ2Fpbi4KCmBgYHtyLCBtZXNzYWdlID0gRkFMU0UsIHdhcm5pbmcgPSBGQUxTRX0KczNfbWV0aG9kc19nZW5lcmljKCJbIikgJT4lCiAgZmlsdGVyKHZpc2libGUpICU+JQogIG11dGF0ZSgKICAgIG1ldGhvZCA9IHBhc3RlMCgiWy4iLCBjbGFzcyksCiAgICBhcmduYW1lcyA9IHB1cnJyOjptYXAobWV0aG9kLCB+IG5hbWVzKGZvcm1hbHMoLngpKSksCiAgICBhcmdzID0gcHVycnI6Om1hcChtZXRob2QsIH4gZm9ybWFscygueCkpLAogICAgYXJncyA9IHB1cnJyOjptYXAyKCAjIG5vbGludDogZHVwbGljYXRlX2FyZ3VtZW50X2xpbnRlci4KICAgICAgYXJnbmFtZXMsIGFyZ3MsCiAgICAgIH4gcGFzdGUoLngsIC55LCBzZXAgPSAiID0gIikKICAgICksCiAgICBhcmdzID0gcHVycnI6OnNldF9uYW1lcyhhcmdzLCBtZXRob2QpICMgbm9saW50OiBkdXBsaWNhdGVfYXJndW1lbnRfbGludGVyLgogICkgJT4lCiAgcHVsbChhcmdzKSAlPiUKICBoZWFkKCkKYGBgCgotLS0KCiMjIDEzLjUuMSBFeGVyY2lzZXMKCjEuICBDYXRlZ29yaXNlIHRoZSBvYmplY3RzIHJldHVybmVkIGJ5IGBsbSgpYCwgYGZhY3RvcigpYCwgYHRhYmxlKClgLCAKICAgIGBhcy5EYXRlKClgLCBgYXMuUE9TSVhjdCgpYCwgYGVjZGYoKWAsIGBvcmRlcmVkKClgLCBgSSgpYCBpbnRvIHRoZQogICAgc3R5bGVzIGRlc2NyaWJlZCBhYm92ZS4KCkFuc3dlcjoKCi0gYGxtKClgLCBgZWNkZigpYDogc2NhbGFyCi0gYGZhY3RvcigpYCwgYGFzLkRhdGUoKWAsIGBhcy5QT1NJWGN0KClgLCBgb3JkZXJlZGA6IHZlY3RvcgotIGB0YWJsZSgpYDogZGF0YSBmcmFtZQotIGBJKClgOiBzYW1lIGFzIHRoZSBzb3VyY2Ugb2JqZWN0CgpBUiBTb2x1dGlvbnM6IFdlIGNhbiBjYXRlZ29yaXNlIHRoZSByZXR1cm4gdmFsdWVzIGludG8gdGhlIHZhcmlvdXMgb2JqZWN0IHN0eWxlcyBieSBvYnNlcnZpbmcgaG93IHRoZSBbbnVtYmVyIG9mIG9ic2VydmF0aW9uc10oaHR0cHM6Ly92Y3Rycy5yLWxpYi5vcmcvYXJ0aWNsZXMvdHlwZS1zaXplLmh0bWwjc2l6ZSkgaXMgY2FsY3VsYXRlZDogRm9yIHZlY3RvciBzdHlsZSBjbGFzc2VzLCBgbGVuZ3RoKHgpYCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2Ygb2JzZXJ2YXRpb25zLiBSZWNvcmQgc3R5bGUgb2JqZWN0cyB1c2UgYSBsaXN0IG9mIGVxdWFsIGxlbmd0aCBlbGVtZW50cyB0byByZXByZXNlbnQgaW5kaXZpZHVhbCBjb21wb25lbnRzLiBGb3IgZGF0YSBmcmFtZXMgYW5kIG1hdHJpY2VzLCB0aGUgb2JzZXJ2YXRpb25zIGFyZSByZXByZXNlbnRlZCBieSB0aGUgcm93cy4gU2NhbGFyIHN0eWxlIG9iamVjdHMgdXNlIGEgbGlzdCB0byByZXByZXNlbnQgYSBzaW5nbGUgdGhpbmcuCgpUaGlzIGxlYWRzIHVzIHRvOgoKLSBWZWN0b3Igb2JqZWN0LXN0eWxlOiBgZmFjdG9yKClgLCBgdGFibGUoKWAsIGBhcy5EYXRlKClgLCBgYXMuUE9TSVhjdCgpYCwgYG9yZGVyZWQoKWAKLSBSZWNvcmQgb2JqZWN0LXN0eWxlOiBub3Qgb2JzZXJ2ZWQKLSBEYXRhIGZyYW1lIG9iamVjdC1zdHlsZTogbm90IG9ic2VydmVkCi0gU2NhbGFyIG9iamVjdC1zdHlsZTogYGxtKClgLCBgZWNkZigpYCAgCgpUaGUgb2JqZWN0IHN0eWxlIG9mIGBJKClgIGRlcGVuZHMgb24gdGhlIGlucHV0IHNpbmNlIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhICJjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aCBjbGFzcyBgQXNJc2AgcHJlcGVuZGVkIHRvIHRoZSBjbGFzcyhlcykiLgoKLS0tCgoyLiAgV2hhdCB3b3VsZCBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBgbG1gIG9iamVjdHMsIGBuZXdfbG0oKWAsIGxvb2sgbGlrZT8KICAgIFVzZSBgP2xtYCBhbmQgZXhwZXJpbWVudGF0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHJlcXVpcmVkIGZpZWxkcyBhbmQgdGhlaXIKICAgIHR5cGVzLgoKQW5zd2VyOiB0aGUgb25seSByZXF1aXJlZCBmaWVsZCBpcyBgZm9ybXVsYWAsIHByb3ZpZGVkIHRoYXQgdGhlIHZhcmlhYmxlcyBsaXN0ZWQgaW4gdGhlIGZvcm11bGEgZXhpc3QgKGFuZCBhcmUgYm90aCB2ZWN0b3JzKS4gYGZvcm11bGFgIG11c3QgYmUgb2YgdHlwZSAiYGZvcm11bGFgIi4KCmBgYHtyfQptcGcgPC0gcHVsbChtdGNhcnMsIG1wZykKd3QgPC0gcHVsbChtdGNhcnMsIHd0KQpsbShtcGcgfiB3dCkKYGBgCgpBUiBTb2x1dGlvbnM6IFRoZSBjb25zdHJ1Y3RvciBuZWVkcyB0byBwb3B1bGF0ZSB0aGUgYXR0cmlidXRlcyBvZiBhbiBgbG1gIG9iamVjdCBhbmQgY2hlY2sgdGhlaXIgdHlwZXMgZm9yIGNvcnJlY3RuZXNzLiBMZXQncyBzdGFydCBieSBjcmVhdGluZyBhIHNpbXBsZSBgbG1gIG9iamVjdCBhbmQgZXhwbG9yZSBpdHMgdW5kZXJseWluZyBiYXNlIHR5cGUgYW5kIGF0dHJpYnV0ZXM6CgpgYGB7cn0KbW9kIDwtIGxtKGN5bCB+IC4sIGRhdGEgPSBtdGNhcnMpCnR5cGVvZihtb2QpCmF0dHJpYnV0ZXMobW9kKQpgYGAKCkFzIGBtb2RgIGlzIGJ1aWx0IHVwb24gYSBsaXN0LCB3ZSBjYW4gc2ltcGx5IHVzZSBgbWFwKG1vZCwgdHlwZW9mKWAgdG8gZmluZCBvdXQgdGhlIGJhc2UgdHlwZXMgb2YgaXRzIGVsZW1lbnRzLiAoQWRkaXRpb25hbGx5LCB3ZSBpbnNwZWN0IGA/bG1gLCB0byBsZWFybiBtb3JlIGFib3V0IHRoZSBpbmRpdmlkdWFsIGF0dHJpYnV0ZXMuKQoKYGBge3J9Cm1hcF9jaHIobW9kLCB0eXBlb2YpCmBgYAoKTm93IHdlIHNob3VsZCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byB3cml0ZSBhIGNvbnN0cnVjdG9yIGZvciBuZXcgYGxtYCBvYmplY3RzLgoKYGBge3J9Cm5ld19sbSA8LSBmdW5jdGlvbihjb2VmZmljaWVudHMsIHJlc2lkdWFscywgZWZmZWN0cywgcmFuaywgZml0dGVkLnZhbHVlcywgYXNzaWduLAogICAgICAgICAgICAgICAgICAgcXIsIGRmLnJlc2lkdWFsLCB4bGV2ZWxzLCBjYWxsLCB0ZXJtcywgbW9kZWwgIyBub2xpbnQ6IG9iamVjdF9uYW1lX2xpbnRlci4KKSB7CiAgc3RvcGlmbm90KAogICAgaXMuZG91YmxlKGNvZWZmaWNpZW50cyksIGlzLmRvdWJsZShyZXNpZHVhbHMpLAogICAgaXMuZG91YmxlKGVmZmVjdHMpLCBpcy5pbnRlZ2VyKHJhbmspLCBpcy5kb3VibGUoZml0dGVkLnZhbHVlcyksCiAgICBpcy5pbnRlZ2VyKGFzc2lnbiksIGlzLmxpc3QocXIpLCBpcy5pbnRlZ2VyKGRmLnJlc2lkdWFsKSwKICAgIGlzLmxpc3QoeGxldmVscyksIGlzLmxhbmd1YWdlKGNhbGwpLCBpcy5sYW5ndWFnZSh0ZXJtcyksCiAgICBpcy5saXN0KG1vZGVsKQogICkKCiAgc3RydWN0dXJlKAogICAgbGlzdCgKICAgICAgY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzLAogICAgICByZXNpZHVhbHMgPSByZXNpZHVhbHMsCiAgICAgIGVmZmVjdHMgPSBlZmZlY3RzLAogICAgICByYW5rID0gcmFuaywKICAgICAgZml0dGVkLnZhbHVlcyA9IGZpdHRlZC52YWx1ZXMsCiAgICAgIGFzc2lnbiA9IGFzc2lnbiwKICAgICAgcXIgPSBxciwKICAgICAgZGYucmVzaWR1YWwgPSBkZi5yZXNpZHVhbCwKICAgICAgeGxldmVscyA9IHhsZXZlbHMsCiAgICAgIGNhbGwgPSBjYWxsLAogICAgICB0ZXJtcyA9IHRlcm1zLAogICAgICBtb2RlbCA9IG1vZGVsCiAgICApLAogICAgY2xhc3MgPSAibG0iCiAgKQp9CmBgYAoKLS0tCgojIyAxMy42LjMgRXhlcmNpc2VzCgoxLiAgSG93IGRvZXMgYFsuRGF0ZWAgc3VwcG9ydCBzdWJjbGFzc2VzPyBIb3cgZG9lcyBpdCBmYWlsIHRvIHN1cHBvcnQgCiAgICBzdWJjbGFzc2VzPwoKYGBge3J9CmBbLkRhdGVgCmAuRGF0ZWAKYGBgCgpBbnN3ZXI6IGJ5IHBhc3NpbmcgdGhlIG9iamVjdCdzIGNsYXNzIHRvIGAuRGF0ZWAsIGBbLkRhdGVgIGF2b2lkcyB0aGUgcHJvYmxlbSBvZiBgWy5zZWNyZXRgIGFuZCBjYW4gcmV0dXJuIHN1YmNsYXNzZXMgb2YgYERhdGVgLiBIb3dldmVyLCB0aGUgYC5EYXRlYCBtZXRob2QgY2FuIHJldHVybiBvYmplY3RzIHRoYXQgZG9uJ3QgY29udGFpbiB0aGUgY2xhc3MgYERhdGVgLgoKQVIgU29sdXRpb25zOiBgWy5EYXRlYCBjYWxscyBgLkRhdGVgIHdpdGggdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBbYCBvbiB0aGUgcGFyZW50IGNsYXNzLCBhbG9uZyB3aXRoIGBvbGRDbGFzcygpYDoKCmAuRGF0ZWAgaXMga2luZCBvZiBsaWtlIGEgY29uc3RydWN0b3IgZm9yIGRhdGUgY2xhc3NlcywgYWx0aG91Z2ggaXQgZG9lc24ndCBjaGVjayB0aGUgaW5wdXQgaXMgdGhlIGNvcnJlY3QgdHlwZToKCmBvbGRDbGFzcygpYCBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYXMgYGNsYXNzKClgLCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IHJldHVybiBpbXBsaWNpdCBjbGFzc2VzLCBpLmUuIGl0J3MgYmFzaWNhbGx5IGBhdHRyKHgsICJjbGFzcyIpYCAobG9va2luZyBhdCB0aGUgQyBjb2RlIHRoYXQncyBleGFjdGx5IHdoYXQgaXQgZG9lcywgZXhjZXB0IHRoYXQgaXQgYWxzbyBoYW5kbGVzIFM0IG9iamVjdHMpLgoKQXMgYG9sZENsYXNzKClgIGlzICJiYXNpY2FsbHkiIGBjbGFzcygpYCwgd2UgY2FuIHJld3JpdGUgYFsuRGF0ZWAgdG8gbWFrZSB0aGUgaW1wbGVtZW50YXRpb24gbW9yZSBjbGVhcjoKCmBgYHtyfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIApgWy5EYXRlYCA8LSBmdW5jdGlvbih4LCAuLi4sIGRyb3AgPSBUUlVFKSB7CiAgb3V0IDwtIE5leHRNZXRob2QoIlsiKQogIGNsYXNzKG91dCkgPC0gY2xhc3MoeCkKICBvdXQKfQpgYGAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKU28sIGBbLkRhdGVgIGVuc3VyZXMgdGhhdCB0aGUgb3V0cHV0IGhhcyB0aGUgc2FtZSBjbGFzcyBhcyBpbiB0aGUgaW5wdXQuIEJ1dCB3aGF0IGFib3V0IG90aGVyIGF0dHJpYnV0ZXMgdGhhdCBhIHN1YmNsYXNzIG1pZ2h0IHBvc3Nlc3M/IFRoZXkgZ2V0IGxvc3Q6CgpgYGB7cn0KeCA8LSBzdHJ1Y3R1cmUoMTo0LCB0ZXN0ID0gInRlc3QiLCBjbGFzcyA9IGMoIm15RGF0ZSIsICJEYXRlIikpCmF0dHJpYnV0ZXMoeFsxXSkKYGBgCgpOb3RlOiB0aGlzIGlzIGEgYmV0dGVyIGV4cGxhbmF0aW9uIG9mIGhvdyBpdCBmYWlscyB0byBzdXBwb3J0IHN1YmNsYXNzZXM7IGl0IGRyb3BzIG5vbi1jbGFzcyBhdHRyaWJ1dGVzLgoKLS0tCgoyLiAgUiBoYXMgdHdvIGNsYXNzZXMgZm9yIHJlcHJlc2VudGluZyBkYXRlIHRpbWUgZGF0YSwgYFBPU0lYY3RgIGFuZAogICAgYFBPU0lYbHRgLCB3aGljaCBib3RoIGluaGVyaXQgZnJvbSBgUE9TSVh0YC4gV2hpY2ggZ2VuZXJpY3MgaGF2ZQogICAgZGlmZmVyZW50IGJlaGF2aW91cnMgZm9yIHRoZSB0d28gY2xhc3Nlcz8gV2hpY2ggZ2VuZXJpY3Mgc2hhcmUgdGhlIHNhbWUKICAgIGJlaGF2aW91cj8KCkFuc3dlcjogaWYgYSBnZW5lcmljIGlzIGRlZmluZWQgZm9yIGVpdGhlciBjbGFzcywgaXQgbXVzdCBoYXZlIGRpZmZlcmVudCBiZWhhdmlvcnMuIEdlbmVyaWNzIHRoYXQgYXJlbid0IGRlZmluZWQgZm9yIGVpdGhlciBjbGFzcyBtdXN0IGhhdmUgdGhlIHNhbWUgYmVoYXZpb3IuIFdlIGNhbiBnZXQgdGhlIGxpc3Qgb2YgZ2VuZXJpY3MgZGVmaW5lZCBmb3IgZWl0aGVyIGNsYXNzIHVzaW5nIGBzbG9vcDo6czNfbWV0aG9kc19jbGFzcygpYC4gVGhlc2UgZ2VuZXJpY3MgaGF2ZSBkaWZmZXJlbnQgYmVoYXZpb3JzIGZvciB0aGUgdHdvIGNsYXNzZXM6CgpgYGB7ciwgd2FybmluZyA9IEZBTFNFfQpjdF9nZW5lcmljcyA8LSBzM19tZXRob2RzX2NsYXNzKCJQT1NJWGN0IikkZ2VuZXJpYwpsdF9nZW5lcmljcyA8LSBzM19tZXRob2RzX2NsYXNzKCJQT1NJWGx0IikkZ2VuZXJpYwpkZWZpbmVkX2dlbmVyaWNzIDwtIHVuaW9uKGN0X2dlbmVyaWNzLCBsdF9nZW5lcmljcykKZGVmaW5lZF9nZW5lcmljcwpgYGAKCldlIGFkYXB0IHdvcmsgZnJvbSBwcmV2aW91cyBleGVyY2lzZXMgdG8gZ2V0IHRoZSBsaXN0IG9mIGFsbCBnZW5lcmljcywgYW5kIGlkZW50aWZ5IFMzIGdlbmVyaWNzIHRoYXQgYXJlbid0IGRlZmluZWQgZm9yIGVpdGhlciBjbGFzcywgd2hpY2ggbXVzdCBoYXZlIHRoZSBzYW1lIGJlaGF2aW9yOgoKYGBge3J9CnMzX2dlbmVyaWNfZnVucyA8LSBGaWx0ZXIoaXNfczNfZ2VuZXJpYywgbmFtZXMoZnVucykpCnVuaW9uKHNldGRpZmYoZGVmaW5lZF9nZW5lcmljcywgczNfZ2VuZXJpY19mdW5zKSwgc2V0ZGlmZihzM19nZW5lcmljX2Z1bnMsIGRlZmluZWRfZ2VuZXJpY3MpKQpgYGAKCk5vdGU6IHRoaXMgY29kZSBkb2Vzbid0IHF1aXRlIHdvcmssIHNpbmNlIGBTdW1tYXJ5YCBpcyBhIGdlbmVyaWMgYWNjb3JkaW5nIHRvIGBpc0dlbmVyaWNgIGFuZCBpcyBub3QgYWNjb3JkaW5nIHRvIGBpc19zM19nZW5lcmljYCwgYW5kIGB3ZWlnaHRlZC5tZWFuYCBpcyBhIG5vbi1iYXNlIFMzIGdlbmVyaWMuCgpBUiBTb2x1dGlvbnM6IFRvIGFuc3dlciB0aGlzIHF1ZXN0aW9uLCB3ZSBoYXZlIHRvIGdldCB0aGUgcmVzcGVjdGl2ZSBnZW5lcmljcwoKYGBge3IsIHdhcm5pbmcgPSBGQUxTRX0KZ2VuZXJpY3NfdCA8LSBzM19tZXRob2RzX2NsYXNzKCJQT1NJWHQiKSRnZW5lcmljCmdlbmVyaWNzX2N0IDwtIHMzX21ldGhvZHNfY2xhc3MoIlBPU0lYY3QiKSRnZW5lcmljCmdlbmVyaWNzX2x0IDwtIHMzX21ldGhvZHNfY2xhc3MoIlBPU0lYbHQiKSRnZW5lcmljCmBgYAoKVGhlIGdlbmVyaWNzIGluIGBnZW5lcmljc190YCB3aXRoIGEgbWV0aG9kIGZvciB0aGUgc3VwZXJjbGFzcyBgUE9TSVh0YCBwb3RlbnRpYWxseSBzaGFyZSB0aGUgc2FtZSBiZWhhdmlvdXIgZm9yIGJvdGggc3ViY2xhc3Nlcy4gSG93ZXZlciwgaWYgYSBnZW5lcmljIGhhcyBhIHNwZWNpZmljIG1ldGhvZCBmb3Igb25lIG9mIHRoZSBzdWJjbGFzc2VzLCBpdCBoYXMgdG8gYmUgc3VidHJhY3RlZDoKCmBgYHtyfQojIFRoZXNlIGdlbmVyaWNzIHByb3ZpZGUgc3ViY2xhc3Mtc3BlY2lmaWMgbWV0aG9kcwp1bmlvbihnZW5lcmljc19jdCwgZ2VuZXJpY3NfbHQpCgojIFRoZXNlIGdlbmVyaWNzIHNoYXJlIChpbmhlcml0ZWQpIG1ldGhvZHMgZm9yIGJvdGggc3ViY2xhc3NlcwpzZXRkaWZmKGdlbmVyaWNzX3QsIHVuaW9uKGdlbmVyaWNzX2N0LCBnZW5lcmljc19sdCkpCmBgYAoKTm90ZTogYWdhaW4sIGFkdmFuY2VkIFIgZ2l2ZXMgYSBiZXR0ZXIgYW5zd2VyIHRvIHRoaXMgcXVlc3Rpb24sIGJ5IGNvbXBhcmluZyB0byB0aGUgZ2VuZXJpY3Mgc3VwcG9ydGVkIGJ5IHRoZSBwYXJlbnQgY2xhc3MuCgotLS0KCjMuICBXaGF0IGRvIHlvdSBleHBlY3QgdGhpcyBjb2RlIHRvIHJldHVybj8gV2hhdCBkb2VzIGl0IGFjdHVhbGx5IHJldHVybj8KICAgIFdoeT8KCmBgYHtyfQpnZW5lcmljMiA8LSBmdW5jdGlvbih4KSBVc2VNZXRob2QoImdlbmVyaWMyIikKZ2VuZXJpYzIuYTEgPC0gZnVuY3Rpb24oeCkgImExIgpnZW5lcmljMi5hMiA8LSBmdW5jdGlvbih4KSAiYTIiCmdlbmVyaWMyLmIgPC0gZnVuY3Rpb24oeCkgewogIGNsYXNzKHgpIDwtICJhMSIKICBOZXh0TWV0aG9kKCkKfQpnZW5lcmljMihzdHJ1Y3R1cmUobGlzdCgpLCBjbGFzcyA9IGMoImIiLCAiYTIiKSkpCmBgYAoKQW5zd2VyOiBJJ2QgZXhwZWN0IHRoaXMgY29kZSB0byByZXR1cm4gYCJhMiJgIHdpdGggYSBjbGFzcyBvZiBgYygiYTEiLCAiYTIiKWAuIEl0IGFjdHVhbGx5IHJldHVybnMgImEyIiB3aXRoIGEgY2xhc3Mgb2YgYGNoYXJhY3RlcmAuIFRoaXMgaXMgYmVjYXVzZSB3aGVuIGBnZW5lcmljMi5iYCBjYWxscyBgTmV4dE1ldGhvZCgpYCwgYGdlbmVyaWMyLmEyYCBpcyBjYWxsZWQgd2hpY2ggcmV0dXJucyBhIGJhcmUgYCJhMiJgLCBkcm9wcGluZyB0aGUgY2xhc3MgYXNzaWduZWQgYnkgYGdlbmVyaWMyLmJgLgoKYGBge3J9CmNsYXNzKGdlbmVyaWMyKHN0cnVjdHVyZShsaXN0KCksIGNsYXNzID0gYygiYiIsICJhMiIpKSkpCmBgYAoKCkFSIFNvbHV0aW9uczogV2hlbiB3ZSBleGVjdXRlIHRoZSBjb2RlIGFib3ZlLCB0aGlzIGlzIHdoYXQgaXMgaGFwcGVuaW5nOgoKLSB3ZSBwYXNzIGFuIG9iamVjdCBvZiBjbGFzc2VzIGBiYCBhbmQgYGEyYCB0byBgZ2VuZXJpYzIoKWAsIHdoaWNoIHByb21wdHMgUiB0byBsb29rIGZvciBhIG1ldGhvZGBnZW5lcmljMi5iKClgCi0gdGhlIG1ldGhvZCBgZ2VuZXJpYzIuYigpYCB0aGVuIGNoYW5nZXMgdGhlIGNsYXNzIHRvIGBhMWAgYW5kIGNhbGxzIGBOZXh0TWV0aG9kKClgCi0gT25lIHdvdWxkIHRoaW5rIHRoYXQgdGhpcyB3aWxsIGxlYWQgUiB0byBjYWxsIGBnZW5lcmljMi5hMSgpYCwgYnV0IGluIGZhY3QsIGFzIG1lbnRpb25lZCBpbiAqQWR2YW5jZWQgUiosIGBOZXh0TWV0aG9kKClgIAogICAgPiBkb2VzbuKAmXQgYWN0dWFsbHkgd29yayB3aXRoIHRoZSBjbGFzcyBhdHRyaWJ1dGUgb2YgdGhlIG9iamVjdCwgYnV0IGluc3RlYWQgdXNlcyBhIHNwZWNpYWwgZ2xvYmFsIHZhcmlhYmxlICguQ2xhc3MpIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggbWV0aG9kIHRvIGNhbGwgbmV4dC4KICAgIAogICBUaGlzIGlzIHdoeSBgZ2VuZXJpYzIuYTIoKWAgaXMgY2FsbGVkIGluc3RlYWQuCgpgYGB7cn0KZ2VuZXJpYzIoc3RydWN0dXJlKGxpc3QoKSwgY2xhc3MgPSBjKCJiIiwgImEyIikpKQpgYGAKCkxldCdzIGp1c3QgZG91YmxlIGNoZWNrIHRoZSBzdGF0ZW1lbnQgYWJvdmUgYW5kIGV2YWx1YXRlIGAuQ2xhc3NgIGV4cGxpY2l0bHkgd2l0aGluIHRoZSBgZ2VuZXJpYzIuYigpYCBtZXRob2QuCgpgYGB7cn0KZ2VuZXJpYzIuYiA8LSBmdW5jdGlvbih4KSB7CiAgY2xhc3MoeCkgPC0gImExIgogIHByaW50KC5DbGFzcykgIyBub2xpbnQ6IG9iamVjdF91c2FnZV9saW50ZXIuCiAgTmV4dE1ldGhvZCgpCn0KCmdlbmVyaWMyKHN0cnVjdHVyZShsaXN0KCksIGNsYXNzID0gYygiYiIsICJhMiIpKSkKYGBgCgotLS0KCiMjIDEzLjcuNSBFeGVyY2lzZXMKCjEuICBFeHBsYWluIHRoZSBkaWZmZXJlbmNlcyBpbiBkaXNwYXRjaCBiZWxvdzoKCmBgYHtyfQpsZW5ndGguaW50ZWdlciA8LSBmdW5jdGlvbih4KSAxMAoKeDEgPC0gMTo1CmNsYXNzKHgxKQpzM19kaXNwYXRjaChsZW5ndGgoeDEpKQoKeDIgPC0gc3RydWN0dXJlKHgxLCBjbGFzcyA9ICJpbnRlZ2VyIikKY2xhc3MoeDIpCnMzX2Rpc3BhdGNoKGxlbmd0aCh4MikpCmBgYAoKQW5zd2VyOiBgeDFgIGRpc3BhdGNoZXMgdXNpbmcgaW1wbGljaXQgY2xhc3MsIHdoaWNoIGlzIGBjKCJpbnRlZ2VyIiwgIm51bWVyaWMiKWAuIGB4MmAgaGFzIGFuIGV4cGxpY2l0IGNsYXNzLCBzbyBpdCBpcyBkaXNwYXRjaGVkIHRvIGBsZW5ndGguaW50ZWdlcmAuCgpgYGB7cn0KczNfY2xhc3MoeDEpCnMzX2NsYXNzKHgyKQpgYGAKCkFSIFNvbHV0aW9uczogYGNsYXNzKClgIHJldHVybnMgYGludGVnZXJgIGluIGJvdGggY2FzZXMuIEhvd2V2ZXIsIHdoaWxlIHRoZSBjbGFzcyBvZiBgeDFgIGlzIGNyZWF0ZWQgaW1wbGljaXRseSBhbmQgaW5oZXJpdHMgZnJvbSB0aGUgYG51bWVyaWNgIGNsYXNzLCB0aGUgY2xhc3Mgb2YgYHgyYCBpcyBzZXQgZXhwbGljaXRseS4gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSBgbGVuZ3RoKClgIGlzIGFuIGludGVybmFsIGdlbmVyaWMgYW5kIGludGVybmFsIGdlbmVyaWNzIG9ubHkgZGlzcGF0Y2ggdG8gbWV0aG9kcyB3aGVuIHRoZSBjbGFzcyBhdHRyaWJ1dGUgaGFzIGJlZW4gc2V0LCBpLmUuIGludGVybmFsIGdlbmVyaWNzIGRvIG5vdCB1c2UgaW1wbGljaXQgY2xhc3Nlcy4KCkFuIG9iamVjdCBoYXMgbm8gZXhwbGljaXQgY2xhc3MgaWYgYGF0dHIoeCwgImNsYXNzIilgIHJldHVybnMgYE5VTExgOgoKYGBge3J9CmF0dHIoeDEsICJjbGFzcyIpCmF0dHIoeDIsICJjbGFzcyIpCmBgYAoKVG8gc2VlIHRoZSByZWxldmFudCBjbGFzc2VzIGZvciB0aGUgUzMgZGlzcGF0Y2gsIG9uZSBjYW4gdXNlIGBzbG9vcDo6czNfY2xhc3MoKWA6CgpgYGB7cn0KczNfY2xhc3MoeDEpICMgaW1wbGljaXQKCnMzX2NsYXNzKHgyKSAjIGV4cGxpY2l0CmBgYAoKRm9yIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2YgYHMzX2RpcGF0Y2goKWAncyBvdXRwdXQgd2UgcXVvdGUgZnJvbSBgP3MzX2Rpc3BhdGNoYDoKLSA9PiBtZXRob2QgZXhpc3RzIGFuZCBpcyBmb3VuZCBieSBgVXNlTWV0aG9kKClgLgotIC0+IG1ldGhvZCBleGlzdHMgYW5kIGlzIHVzZWQgYnkgYE5leHRNZXRob2QoKWAuCi0gXCogbWV0aG9kIGV4aXN0cyBidXQgaXMgbm90IHVzZWQuCi0gTm90aGluZyAoYW5kIGdyZXllZCBvdXQgaW4gY29uc29sZSk6IG1ldGhvZCBkb2VzIG5vdCBleGlzdC4KCk5vdGU6IEFSIFNvbHV0aW9ucyBpbmNsdWRlcyBhbiBhZGRpdGlvbmFsIGltcG9ydGFudCBkZXRhaWwsIHRoYXQgImludGVybmFsIGdlbmVyaWNzIG9ubHkgZGlzcGF0Y2ggdG8gbWV0aG9kcyB3aGVuIHRoZSBjbGFzcyBhdHRyaWJ1dGUgaGFzIGJlZW4gc2V0Iiwgd2hpY2ggZXhwbGFpbnMgd2h5IHRoZSBpbnRlcm5hbCBnZW5lcmljIGlzIHVzZWQgZm9yIGB4MWAuCgotLS0KCjIuICBXaGF0IGNsYXNzZXMgaGF2ZSBhIG1ldGhvZCBmb3IgdGhlIGBNYXRoYCBncm91cCBnZW5lcmljIGluIGJhc2UgUj8gUmVhZAogICAgdGhlIHNvdXJjZSBjb2RlLiBIb3cgZG8gdGhlIG1ldGhvZHMgd29yaz8KCkFuc3dlcjogZm91ciBiYXNlIGNsYXNzZXMgaGF2ZSBhIG1ldGhvZCBmb3IgYE1hdGhgOiBgZGF0YS5mcmFtZWAsIGBEYXRlYCwgYGRpZmZ0aW1lYCwgYGZhY3RvcmAsIGFuZCBgUE9TSVh0YC4KCmBgYHtyfQpzM19tZXRob2RzX2dlbmVyaWMoIk1hdGgiKSB8PgogIGZpbHRlcihzb3VyY2UgPT0gImJhc2UiKSAjIG5vbGludDogdW5kZXNpcmFibGVfZnVuY3Rpb25fbGludGVyLiBzb3VyY2UgaXMgbm90IHVzZWQgYXMgYSBmdW5jdGlvbi4KYGBgCgpgYGB7cn0KTWF0aC5kYXRhLmZyYW1lCk1hdGguRGF0ZQpNYXRoLmRpZmZ0aW1lCk1hdGguZmFjdG9yCk1hdGguUE9TSVh0CmBgYAoKLSBgTWF0aC5kYXRhLmZyYW1lYCBwZXJmb3JtcyBtYXRoIGlmIGFsbCBjb2x1bW5zICh2YXJpYWJsZXMpIGFyZSBlaXRoZXIgbnVtZXJpYywgbG9naWNhbCBvciBjb21wbGV4LAogIGFuZCBlcnJvcnMgaWYgYW55IGFyZSBub3QKLSBgTWF0aC5kaWZmdGltZWAgcGVyZm9ybXMgb25seSBjZXJ0YWluIG1hdGggZnVuY3Rpb25zOiBgYWJzYCwgYHNpZ25gLCBgZmxvb3JgLCBgY2VpbGluZ2AsIGB0cnVuY2AsCiAgYHJvdW5kYCwgYW5kIGBzaWduaWZgLCBhbmQgZXJyb3JzIGZvciBvdGhlciBmdW5jdGlvbnMKLSBgTWF0aC5EYXRlYCwgYE1hdGguZmFjdG9yYCwgYW5kIGBNYXRoLlBPU0lYdGAgYWx3YXlzIGVycm9yCgpBUiBTb2x1dGlvbnM6IDogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYmVsb25nIHRvIHRoaXMgZ3JvdXAgKHNlZSA/YE1hdGhgKToKCi0gYGFic2AsIGBzaWduYCwgYHNxcnRgLCBgZmxvb3JgLCBgY2VpbGluZ2AsIGB0cnVuY2AsIGByb3VuZGAsIGBzaWduaWZgCi0gYGV4cGAsIGBsb2dgLCBgZXhwbTFgLCBgbG9nMXBgLCBgY29zYCwgYHNpbmAsIGB0YW5gLCBgY29zcGlgLCBgc2lucGlgLCBgdGFucGlgLCBgYWNvc2AsIGBhc2luYCwKICBgYXRhbmAsIGBjb3NoYCwgYHNpbmhgLCBgdGFuaGAsIGBhY29zaGAsIGBhc2luaGAsIGBhdGFuaGAKLSBgbGdhbW1hYCwgYGdhbW1hYCwgYGRpZ2FtbWFgLCBgdHJpZ2FtbWFgCi0gYGN1bXN1bWAsIGBjdW1wcm9kYCwgYGN1bW1heGAsIGBjdW1taW5gCgpUaGUgZm9sbG93aW5nIGNsYXNzZXMgaGF2ZSBhIG1ldGhvZCBmb3IgdGhpcyBncm91cCBnZW5lcmljOgoKYGBge3J9CnMzX21ldGhvZHNfZ2VuZXJpYygiTWF0aCIpCmBgYAoKVG8gZXhwbGFpbiB0aGUgYmFzaWMgaWRlYSwgd2UganVzdCBvdmVyd3JpdGUgdGhlIGRhdGEgZnJhbWUgbWV0aG9kOgoKYGBge3J9Ck1hdGguZGF0YS5mcmFtZSA8LSBmdW5jdGlvbih4KSAiaGVsbG8iCmBgYAoKTm93IGFsbCBmdW5jdGlvbnMgZnJvbSB0aGUgbWF0aCBnZW5lcmljIGdyb3VwLCB3aWxsIHJldHVybiBgImhlbGxvImAKCmBgYHtyfQphYnMobXRjYXJzKQpleHAobXRjYXJzKQpsZ2FtbWEobXRjYXJzKQpgYGAKCk9mIGNvdXJzZSwgZGlmZmVyZW50IGZ1bmN0aW9ucyBzaG91bGQgcGVyZm9ybSBkaWZmZXJlbnQgY2FsY3VsYXRpb25zLiBIZXJlIGAuR2VuZXJpY2AgY29tZXMgaW50byBwbGF5LCB3aGljaCBwcm92aWRlcyB1cyB3aXRoIHRoZSBjYWxsaW5nIGdlbmVyaWMgYXMgYSBzdHJpbmcKCmBgYHtyfQpNYXRoLmRhdGEuZnJhbWUgPC0gZnVuY3Rpb24oeCwgLi4uKSB7CiAgLkdlbmVyaWMgIyBub2xpbnQ6IG9iamVjdF91c2FnZV9saW50ZXIuCn0KYWJzKG10Y2FycykKZXhwKG10Y2FycykKbGdhbW1hKG10Y2FycykKcm0oTWF0aC5kYXRhLmZyYW1lKQpgYGAKClRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZSBvZiBgTWF0aC5kYXRhLmZyYW1lKClgIGlzIGEgZ29vZCBleGFtcGxlIG9uIGhvdyB0byBpbnZva2UgdGhlIHN0cmluZyByZXR1cm5lZCBieSBgLkdlbmVyaWNgIGludG8gYSBzcGVjaWZpYyBtZXRob2QuIGBNYXRoLmZhY3RvcigpYCBpcyBhIGdvb2QgZXhhbXBsZSBvZiBhIG1ldGhvZCwgd2hpY2ggaXMgc2ltcGx5IGRlZmluZWQgZm9yIGJldHRlciBlcnJvciBtZXNzYWdlcy4KCk5vdGU6IEkgcHJlZmVyIG15IGFuc3dlciB0byB0aGUgQVIgU29sdXRpb25zIGFuc3dlci4KCi0tLQoKMy4gIGBNYXRoLmRpZmZ0aW1lKClgIGlzIG1vcmUgY29tcGxpY2F0ZWQgdGhhbiBJIGRlc2NyaWJlZC4gV2h5PwoKQW5zd2VyOiB0aGUgZXhwbGFuYXRpb24gaW4gdGhlIHRleHQgb21pdHMgdGhlIGZhY3QgdGhhdCBgTWF0aC5kaWZmdGltZSgpYCBmaXJzdCBjaGVja3MgdGhhdCB0aGUgbWF0aCBmdW5jdGlvbiBiZWluZyBjYWxsZWQuCgpBUiBTb2x1dGlvbnM6IGBNYXRoLmRpZmZ0aW1lKClgIGFsc28gZXhjbHVkZXMgY2FzZXMgYXBhcnQgZnJvbSBgYWJzYCwgYHNpZ25gLCBgZmxvb3JgLCBgY2VpbGluZ2AsIGB0cnVuY2AsIGByb3VuZGAgYW5kIGBzaWduaWZgIGFuZCBuZWVkcyB0byByZXR1cm4gYSBmaXR0aW5nIGVycm9yIG1lc3NhZ2UuCgotLS0KCiMgMTQgUjYKCmBgYHtyfQpybShsaXN0ID0gbHMoKSkKYGBgCgpUaGlzIGNoYXB0ZXIgZGVzY3JpYmVzIHRoZSBSNiBPT1Agc3lzdGVtLiBSNiBoYXMgdHdvIHNwZWNpYWwgcHJvcGVydGllczoKCiogSXQgdXNlcyB0aGUgZW5jYXBzdWxhdGVkIE9PUCBwYXJhZGlnbSwgd2hpY2ggbWVhbnMgdGhhdCBtZXRob2RzIGJlbG9uZyB0byAKICBvYmplY3RzLCBub3QgZ2VuZXJpY3MsIGFuZCB5b3UgY2FsbCB0aGVtIGxpa2UgYG9iamVjdCRtZXRob2QoKWAuIAogIAoqIFI2IG9iamVjdHMgYXJlIF9fbXV0YWJsZV9fLCB3aGljaCBtZWFucyB0aGF0IHRoZXkgYXJlIG1vZGlmaWVkIGluIHBsYWNlLCBhbmQgCiAgaGVuY2UgaGF2ZSByZWZlcmVuY2Ugc2VtYW50aWNzLgoKSWYgeW91J3ZlIGxlYXJuZWQgT09QIGluIGFub3RoZXIgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UsIGl0J3MgbGlrZWx5IHRoYXQgUjYgd2lsbCBmZWVsIHZlcnkgbmF0dXJhbCwgYW5kIHlvdSdsbCBiZSBpbmNsaW5lZCB0byBwcmVmZXIgaXQgb3ZlciBTMy4gUmVzaXN0IHRoZSB0ZW1wdGF0aW9uIHRvIGZvbGxvdyB0aGUgcGF0aCBvZiBsZWFzdCByZXNpc3RhbmNlOiBpbiBtb3N0IGNhc2VzIFI2IHdpbGwgbGVhZCB5b3UgdG8gbm9uLWlkaW9tYXRpYyBSIGNvZGUuIFdlJ2xsIGNvbWUgYmFjayB0byB0aGlzIHRoZW1lIGluIFNlY3Rpb24gMTYuMy4KClI2IGlzIHZlcnkgc2ltaWxhciB0byBhIGJhc2UgT09QIHN5c3RlbSBjYWxsZWQgX19yZWZlcmVuY2UgY2xhc3Nlc19fLCBvciBSQyBmb3Igc2hvcnQuIEkgZGVzY3JpYmUgd2h5IEkgdGVhY2ggUjYgYW5kIG5vdCBSQyBpbiBTZWN0aW9uIDE0LjUuCgojIyAxNC4yLjYgRXhlcmNpc2VzCgoxLiAgQ3JlYXRlIGEgYmFuayBhY2NvdW50IFI2IGNsYXNzIHRoYXQgc3RvcmVzIGEgYmFsYW5jZSBhbmQgYWxsb3dzIHlvdSB0byAKICAgIGRlcG9zaXQgYW5kIHdpdGhkcmF3IG1vbmV5LiBDcmVhdGUgYSBzdWJjbGFzcyB0aGF0IHRocm93cyBhbiBlcnJvciAKICAgIGlmIHlvdSBhdHRlbXB0IHRvIGdvIGludG8gb3ZlcmRyYWZ0LiBDcmVhdGUgYW5vdGhlciBzdWJjbGFzcyB0aGF0IGFsbG93cwogICAgeW91IHRvIGdvIGludG8gb3ZlcmRyYWZ0LCBidXQgY2hhcmdlcyB5b3UgYSBmZWUuCgpBbnN3ZXI6IGBBY2NvdW50YCBzdG9yZXMgYSBiYWxhbmNlIGFzIGFuIGludGVnZXIgdmFsdWUgb2YgY2VudHMsIGFuZCBwcmludHMgaW4gZG9sbGFycyAodG8gYXZvaWQgcHJvYmxlbXMgd2l0aCBmbG9hdGluZyBwb2ludCBtYXRoKS4KCmBgYHtyfQpBY2NvdW50IDwtIFI2Q2xhc3MoIkFjY291bnQiLCBsaXN0KCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGJhbGFuY2UgPSAwTCwKICBpbml0aWFsaXplID0gZnVuY3Rpb24oYmFsYW5jZSA9IDBMKSB7CiAgICBzdG9waWZub3QoaXMuaW50ZWdlcihiYWxhbmNlKSwgbGVuZ3RoKGJhbGFuY2UpID09IDEpCiAgICBzZWxmJGJhbGFuY2UgPC0gYmFsYW5jZQogIH0sCiAgcHJpbnQgPSBmdW5jdGlvbiguLi4pIHsKICAgIGNhdCgiQWNjb3VudDogXG4iKQogICAgY2F0KCIgIEJhbGFuY2U6ICQiLCBmb3JtYXQoc2VsZiRiYWxhbmNlIC8gMTAwLCBuc21hbGwgPSAyKSwgIlxuIiwgc2VwID0gIiIpCiAgICBpbnZpc2libGUoc2VsZikKICB9LAogIGRlcG9zaXQgPSBmdW5jdGlvbih2YWx1ZSkgewogICAgc3RvcGlmbm90KGlzLmludGVnZXIodmFsdWUpLCBsZW5ndGgodmFsdWUpID09IDEpCiAgICBzZWxmJGJhbGFuY2UgPC0gc2VsZiRiYWxhbmNlICsgdmFsdWUKICAgIGludmlzaWJsZShzZWxmKQogIH0sCiAgd2l0aGRyYXcgPSBmdW5jdGlvbih2YWx1ZSkgewogICAgc3RvcGlmbm90KGlzLmludGVnZXIodmFsdWUpLCBsZW5ndGgodmFsdWUpID09IDEpCiAgICBzZWxmJGJhbGFuY2UgPC0gc2VsZiRiYWxhbmNlIC0gdmFsdWUKICAgIGludmlzaWJsZShzZWxmKQogIH0KKSkKCkFjY291bnRPdmVyZHJhZnQgPC0gUjZDbGFzcygiQWNjb3VudE92ZXJkcmFmdCIsICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgaW5oZXJpdCA9IEFjY291bnQsCiAgcHVibGljID0gbGlzdCgKICAgIHdpdGhkcmF3ID0gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgc3RvcGlmbm90KHZhbHVlIDw9IHNlbGYkYmFsYW5jZSkKICAgICAgc3VwZXIkd2l0aGRyYXcodmFsdWUpCiAgICB9CiAgKQopCgpBY2NvdW50T3ZlcmRyYWZ0RmVlIDwtIFI2Q2xhc3MoIkFjY291bnRPdmVyZHJhZnRGZWUiLCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGluaGVyaXQgPSBBY2NvdW50LAogIHB1YmxpYyA9IGxpc3QoCiAgICB3aXRoZHJhdyA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIGlmICh2YWx1ZSA+IHNlbGYkYmFsYW5jZSkgdmFsdWUgPC0gdmFsdWUgKyA1MDBMCiAgICAgIHN1cGVyJHdpdGhkcmF3KHZhbHVlKQogICAgfQogICkKKQoKdHJ5KEFjY291bnQkbmV3KDEuNSkpCgphIDwtIEFjY291bnQkbmV3KDEwMEwpCmEkZGVwb3NpdCgxMDBMKQphJHdpdGhkcmF3KDI1MEwpCmEKCmEyIDwtIEFjY291bnRPdmVyZHJhZnQkbmV3KDIwMEwpCnRyeShhMiR3aXRoZHJhdygyNTBMKSkKYTIkd2l0aGRyYXcoMTUwTCkKYTIKCmEzIDwtIEFjY291bnRPdmVyZHJhZnRGZWUkbmV3KDIwMEwpCmEzJHdpdGhkcmF3KDI1MEwpCmEzCmBgYAoKQVIgU29sdXRpb25zOiBgQmFua0FjY291bnRgIGlzIGEgc2ltaWxhciwgc2ltcGxlciBhcHByb2FjaDoKCmBgYHtyfQpCYW5rQWNjb3VudCA8LSBSNkNsYXNzKCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGNsYXNzbmFtZSA9ICJCYW5rQWNjb3VudCIsCiAgcHVibGljID0gbGlzdCgKICAgIGJhbGFuY2UgPSAwLAogICAgZGVwb3NpdCA9IGZ1bmN0aW9uKGRlcCA9IDApIHsKICAgICAgc2VsZiRiYWxhbmNlIDwtIHNlbGYkYmFsYW5jZSArIGRlcAogICAgICBpbnZpc2libGUoc2VsZikKICAgIH0sCiAgICB3aXRoZHJhdyA9IGZ1bmN0aW9uKGRyYXcpIHsKICAgICAgc2VsZiRiYWxhbmNlIDwtIHNlbGYkYmFsYW5jZSAtIGRyYXcKICAgICAgaW52aXNpYmxlKHNlbGYpCiAgICB9CiAgKQopCgpCYW5rQWNjb3VudFN0cmljdCA8LSBSNkNsYXNzKCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGNsYXNzbmFtZSA9ICJCYW5rQWNjb3VudFN0cmljdCIsCiAgaW5oZXJpdCA9IEJhbmtBY2NvdW50LAogIHB1YmxpYyA9IGxpc3QoCiAgICB3aXRoZHJhdyA9IGZ1bmN0aW9uKGRyYXcgPSAwKSB7CiAgICAgIGlmIChzZWxmJGJhbGFuY2UgLSBkcmF3IDwgMCkgewogICAgICAgIHN0b3AoIllvdXIgYHdpdGhkcmF3YCBtdXN0IGJlIHNtYWxsZXIgIiwKICAgICAgICAgICJ0aGFuIHlvdXIgYGJhbGFuY2VgLiIsCiAgICAgICAgICBjYWxsLiA9IEZBTFNFCiAgICAgICAgKQogICAgICB9CiAgICAgIHN1cGVyJHdpdGhkcmF3KGRyYXcgPSBkcmF3KQogICAgfQogICkKKQoKQmFua0FjY291bnRDaGFyZ2luZyA8LSBSNkNsYXNzKCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGNsYXNzbmFtZSA9ICJCYW5rQWNjb3VudENoYXJnaW5nIiwKICBpbmhlcml0ID0gQmFua0FjY291bnQsCiAgcHVibGljID0gbGlzdCgKICAgIHdpdGhkcmF3ID0gZnVuY3Rpb24oZHJhdyA9IDApIHsKICAgICAgaWYgKHNlbGYkYmFsYW5jZSAtIGRyYXcgPCAwKSB7CiAgICAgICAgZHJhdyA8LSBkcmF3ICsgMQogICAgICB9CiAgICAgIHN1cGVyJHdpdGhkcmF3KGRyYXcgPSBkcmF3KQogICAgfQogICkKKQpgYGAKCk5vdGU6IG15IG9iamVjdCBuYW1lLCBgQWNjb3VudE92ZXJkcmFmdEZlZWAgaXMgbWlzbGVhZGluZywgc2luY2UgaXQgaXMgbm90IGEgc3ViY2xhc3Mgb2YgYEFjY291bnRPdmVyZHJhZnRgIC0gdGhlIFIgU29sdXRpb25zIG5hbWluZyBjb252ZW50aW9uIGlzIGNsZWFyZXIuCgotLS0KCjIuICBDcmVhdGUgYW4gUjYgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc2h1ZmZsZWQgZGVjayBvZiBjYXJkcy4gWW91IHNob3VsZCBiZQogICAgYWJsZSB0byBkcmF3IGNhcmRzIGZyb20gdGhlIGRlY2sgd2l0aCBgJGRyYXcobilgLCBhbmQgcmV0dXJuIGFsbCBjYXJkcyB0byAKICAgIHRoZSBkZWNrIGFuZCByZXNodWZmbGUgd2l0aCBgJHJlc2h1ZmZsZSgpYC4gVXNlIHRoZSBmb2xsb3dpbmcgY29kZSB0byBtYWtlIAogICAgYSB2ZWN0b3Igb2YgY2FyZHMuCgpgYGB7cn0Kc3VpdCA8LSBjKCLimaAiLCAi4pmlIiwgIuKZpiIsICLimaMiKQp2YWx1ZSA8LSBjKCJBIiwgMjoxMCwgIkoiLCAiUSIsICJLIikKY2FyZHMgPC0gcGFzdGUwKHJlcCh2YWx1ZSwgNCksIHN1aXQpCmBgYAoKQW5zd2VyOiBgQ2FyZHNgIHNodWZmbGVzIHRoZSBkZWNrIHVzaW5nIGBzYW1wbGUoKWAuIFRoZSBgZHJhdygpYCBmdW5jdGlvbiBwcmludHMgdGhlIGNhcmRzIGRyYXduIGFuZCBtb3ZlcyB0aGVtIGludG8gcGxheS4KCmBgYHtyfQpDYXJkcyA8LSBSNkNsYXNzKCJDYXJkcyIsIGxpc3QoICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgZGVjayA9IHNhbXBsZShjYXJkcywgNTIpLAogIHBsYXkgPSBOVUxMLAogIHByaW50ID0gZnVuY3Rpb24oLi4uKSB7CiAgICBjYXQoIkNhcmRzOiBcbiIpCiAgICBjYXQoIiAgRGVjazoiLCBzZWxmJGRlY2ssICJcbiIsIHNlcCA9ICIgIikKICAgIGNhdCgiICBQbGF5OiIsIHNlbGYkcGxheSwgIlxuIiwgc2VwID0gIiAiKQogICAgaW52aXNpYmxlKHNlbGYpCiAgfSwKICBkcmF3ID0gZnVuY3Rpb24obiA9IDFMKSB7CiAgICBzdG9waWZub3QoaXMuaW50ZWdlcihuKSwgbGVuZ3RoKG4pID09IDEsIG4gPiAwLCBuIDw9IGxlbmd0aChzZWxmJGRlY2spKQogICAgZCA8LSBoZWFkKHNlbGYkZGVjaywgbikKICAgIHNlbGYkcGxheSA8LSBjKHNlbGYkcGxheSwgZCkKICAgIHNlbGYkZGVjayA8LSB0YWlsKHNlbGYkZGVjaywgLW4pCiAgICBpbnZpc2libGUoc2VsZikKICB9LAogIHJlc2h1ZmZsZSA9IGZ1bmN0aW9uKCkgewogICAgc2VsZiRkZWNrIDwtIHNhbXBsZShjYXJkcywgNTIpCiAgICBzZWxmJHBsYXkgPC0gTlVMTAogICAgaW52aXNpYmxlKHNlbGYpCiAgfQopKQoKZCA8LSBDYXJkcyRuZXcoKQpkCnRyeShkJGRyYXcoMS41KSkKdHJ5KGQkZHJhdygwTCkpCnRyeShkJGRyYXcoNTNMKSkKZCRkcmF3KDEzTCkKZApkJGRyYXcoMTNMKQpkCmQkcmVzaHVmZmxlKCkKZApgYGAKCkFSIFNvbHV0aW9uczogT3VyIG5ldyBgU2h1ZmZsZWREZWNrYCBjbGFzcyB3aWxsIHVzZSBgc2FtcGxlKClgIGFuZCBwb3NpdGl2ZSBpbnRlZ2VyIHN1YnNldHRpbmcgdG8gaW1wbGVtZW50IHRoZSByZXNodWZmbGluZyBhbmQgZHJhd2luZyBmdW5jdGlvbmFsaXR5LiBXZSBhbHNvIGFkZCBhIGNoZWNrLCBzbyB5b3UgY2Fubm90IGRyYXcgbW9yZSBjYXJkcyB0aGFuIHRoZXJlIGFyZSBsZWZ0IGluIHRoZSBkZWNrLgoKYGBge3J9ClNodWZmbGVkRGVjayA8LSBSNkNsYXNzKCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGNsYXNzbmFtZSA9ICJTaHVmZmxlZERlY2siLAogIHB1YmxpYyA9IGxpc3QoCiAgICBkZWNrID0gTlVMTCwKICAgIGluaXRpYWxpemUgPSBmdW5jdGlvbihkZWNrID0gY2FyZHMpIHsKICAgICAgc2VsZiRkZWNrIDwtIHNhbXBsZShkZWNrKQogICAgfSwKICAgIHJlc2h1ZmZsZSA9IGZ1bmN0aW9uKCkgewogICAgICBzZWxmJGRlY2sgPC0gc2FtcGxlKGNhcmRzKQogICAgICBpbnZpc2libGUoc2VsZikKICAgIH0sCiAgICBuID0gZnVuY3Rpb24oKSB7CiAgICAgIGxlbmd0aChzZWxmJGRlY2spCiAgICB9LAogICAgZHJhdyA9IGZ1bmN0aW9uKG4gPSAxKSB7CiAgICAgIGlmIChuID4gc2VsZiRuKCkpIHsKICAgICAgICBzdG9wKCJPbmx5ICIsIHNlbGYkbigpLCAiIGNhcmRzIHJlbWFpbmluZy4iLCBjYWxsLiA9IEZBTFNFKQogICAgICB9CgogICAgICBvdXRwdXQgPC0gc2VsZiRkZWNrW3NlcV9sZW4obildCiAgICAgIHNlbGYkZGVjayA8LSBzZWxmJGRlY2tbLXNlcV9sZW4obildCiAgICAgIG91dHB1dAogICAgfQogICkKKQpgYGAKCk5vdGVzOiBpdCBzZWVtcyBzaW1wbGVyIHRvIHNldCBgZGVja2AgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZyBhbiBgaW5pdGlhbGl6ZWAgZnVuY3Rpb24sIGFsdGhvdWdoIGBzYW1wbGUoY2FyZHMpYCBpcyBjbGVhbmVyLiBgc2VsZiRuKClgIGlzIGEgdXNlZnVsIGZ1bmN0aW9uLCBhbmQgdGhlIGNob2ljZSBvZiByZW1vdmluZyBhbmQgcmV0dXJuaW5nIGNhcmRzIHdpdGggYGRyYXcoKWAgaXMgcHJvYmFibHkgYSBiZXR0ZXIgZGVzaWduLiBJIHByZWZlciBteSBhcHByb2FjaCB1c2luZyBgaGVhZCgpYCBhbmQgYHRhaWwoKWAgb3ZlciBSIFNvbHV0aW9ucyB1c2Ugb2YgYHNlcV9sZW4oKWAuCgpCdWc6IHBlciAxNC40LjMgc2V0dGluZyBmaWVsZHMgZGlyZWN0bHkgZml4ZXMgdGhlIG9yZGVyIHdoZW4gdGhlIGNsYXNzIGlzICpkZWZpbmVkKi4gVGhpcyByZXN1bHRzIGluIGEgYnVnOiBgQ2FyZHNgIGhhcyB0aGUgc2FtZSBzdGFydGluZyBzaHVmZmxlIGZvciBlYWNoIG5ldyBvYmplY3QsIGJ1dCBgU2h1ZmZsZWREZWNrYCBkb2VzIG5vdDoKCmBgYHtyfQpDYXJkcyRuZXcoKQpDYXJkcyRuZXcoKQpTaHVmZmxlZERlY2skbmV3KCkkZHJhdyg1MikKU2h1ZmZsZWREZWNrJG5ldygpJGRyYXcoNTIpCmBgYAoKLS0tCgozLiAgV2h5IGNhbid0IHlvdSBtb2RlbCBhIGJhbmsgYWNjb3VudCBvciBhIGRlY2sgb2YgY2FyZHMgd2l0aCBhbiBTMyBjbGFzcz8KCkFuc3dlcjogYmVjYXVzZSBTMyBjbGFzc2VzIGFyZSBjb3BpZWQtb24tbW9kaWZ5LCB0aGV5IGxhY2sgc3RhdGUuIFI2IGNsYXNzZXMgYXJlIHN0YXRlZnVsIHNpbmNlIHRoZXkgYXJlIG1vZGlmaWVkIGluLXBsYWNlLiBCb3RoIGJhbmsgYWNjb3VudHMgYW5kIGEgZGVjayBvZiBjYXJkcyBhcmUgc3RhdGVmdWwgb2JqZWN0cy4KCkFSIFNvbHV0aW9uczogQmVjYXVzZSBTMyBjbGFzc2VzIG9iZXkgUidzIHVzdWFsIHNlbWFudGljcyBvZiBjb3B5LW9uLW1vZGlmeTogZXZlcnkgdGltZSB5b3UgZGVwb3NpdCBtb25leSBpbnRvIHlvdXIgYmFuayBhY2NvdW50IG9yIGRyYXcgYSBjYXJkIGZyb20gdGhlIGRlY2ssIHlvdSdkIGdldCBhIG5ldyBjb3B5IG9mIHRoZSBvYmplY3QuCgpJdCBpcyBwb3NzaWJsZSB0byBjb21iaW5lIFMzIGNsYXNzZXMgd2l0aCBhbiBlbnZpcm9ubWVudCAod2hpY2ggaXMgaG93IFI2IHdvcmtzKSwgYnV0IGl0IGlzIGlsbC1hZHZpc2VkIHRvIGNyZWF0ZSBhbiBvYmplY3QgdGhhdCBsb29rcyBsaWtlIGEgcmVndWxhciBSIG9iamVjdCBidXQgaGFzIHJlZmVyZW5jZSBzZW1hbnRpY3MuCgotLS0KCjQuICBDcmVhdGUgYW4gUjYgY2xhc3MgdGhhdCBhbGxvd3MgeW91IHRvIGdldCBhbmQgc2V0IHRoZSBjdXJyZW50IHRpbWUgem9uZS4gCiAgICBZb3UgY2FuIGFjY2VzcyB0aGUgY3VycmVudCB0aW1lIHpvbmUgd2l0aCBgU3lzLnRpbWV6b25lKClgIGFuZCBzZXQgaXQgCiAgICB3aXRoIGBTeXMuc2V0ZW52KFRaID0gIm5ld3RpbWV6b25lIilgLiBXaGVuIHNldHRpbmcgdGhlIHRpbWUgem9uZSwgbWFrZQogICAgc3VyZSB0aGUgbmV3IHRpbWUgem9uZSBpcyBpbiB0aGUgbGlzdCBwcm92aWRlZCBieSBgT2xzb25OYW1lcygpYC4KCkFuc3dlcjogYFRpbWVab25lYCBpcyBpbml0aWFsaXplZCB3aXRoIHRoZSBjdXJyZW50IHRpbWUgem9uZSwgc3RvcmVkIGFzIGB0emAgaW4gdGhlIG9iamVjdC4KCmBgYHtyfQpvcmlnX3R6IDwtIFN5cy50aW1lem9uZSgpCgpUaW1lWm9uZSA8LSBSNkNsYXNzKCJUaW1lWm9uZSIsIGxpc3QoICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgdHogPSBTeXMudGltZXpvbmUoKSwKICBnZXQgPSBmdW5jdGlvbigpIHsKICAgIGNhdCgiQ3VycmVudCB0aW1lIHpvbmU6ICIsIHNlbGYkdHosICJcbiIsIHNlcCA9ICIiKQogICAgaW52aXNpYmxlKHNlbGYpCiAgfSwKICBzZXQgPSBmdW5jdGlvbih0eikgewogICAgc3RvcGlmbm90KHR6ICVpbiUgT2xzb25OYW1lcygpKQogICAgU3lzLnNldGVudihUWiA9IHR6KSAjIG5vbGludDogdW5kZXNpcmFibGVfZnVuY3Rpb25fbGludGVyLgogICAgc2VsZiR0eiA8LSB0egogICAgY2F0KCJTZXQgdGltZSB6b25lOiAiLCBzZWxmJHR6LCAiXG4iLCBzZXAgPSAiIikKICAgIGludmlzaWJsZShzZWxmKQogIH0KKSkKCnR6IDwtIFRpbWVab25lJG5ldygpCnR6JGdldCgpCmRhdGUoKQp0eiRzZXQoIkFtZXJpY2EvTmV3X1lvcmsiKQpkYXRlKCkKClN5cy5zZXRlbnYoVFogPSBvcmlnX3R6KSAjIG5vbGludDogdW5kZXNpcmFibGVfZnVuY3Rpb25fbGludGVyLgpgYGAKCkJ1ZzogbGlrZSBgQ2FyZHNgLCBgVGltZVpvbmVgIHNob3VsZCBzZXQgYHR6YCBpbiBgaW5pdGlhbGl6ZSgpYC4KCkFSIFNvbHV0aW9uczogVG8gY3JlYXRlIGFuIFI2IGNsYXNzIHRoYXQgYWxsb3dzIHVzIHRvIGdldCBhbmQgc2V0IHRoZSB0aW1lIHpvbmUsIHdlIHByb3ZpZGUgdGhlIHJlc3BlY3RpdmUgZnVuY3Rpb25zIGFzIHB1YmxpYyBtZXRob2RzIHRvIHRoZSBSNiBjbGFzcy4KCmBgYHtyfQpUaW1lem9uZSA8LSBSNkNsYXNzKCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGNsYXNzbmFtZSA9ICJUaW1lem9uZSIsCiAgcHVibGljID0gbGlzdCgKICAgIGdldCA9IGZ1bmN0aW9uKCkgewogICAgICBTeXMudGltZXpvbmUoKQogICAgfSwKICAgIHNldCA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIHN0b3BpZm5vdCh2YWx1ZSAlaW4lIE9sc29uTmFtZXMoKSkKICAgICAgb2xkIDwtIHNlbGYkZ2V0KCkKICAgICAgU3lzLnNldGVudihUWiA9IHZhbHVlKSAjIG5vbGludDogdW5kZXNpcmFibGVfZnVuY3Rpb25fbGludGVyLgogICAgICBpbnZpc2libGUob2xkKQogICAgfQogICkKKQpgYGAKCihXaGVuIHNldHRpbmcsIHdlIHJldHVybiB0aGUgb2xkIHZhbHVlIGludmlzaWJseSBiZWNhdXNlIHRoaXMgbWFrZXMgaXQgZWFzeSB0byByZXN0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZS4pCgotLS0KCjUuICBDcmVhdGUgYW4gUjYgY2xhc3MgdGhhdCBtYW5hZ2VzIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LgogICAgSXQgc2hvdWxkIGhhdmUgYCRnZXQoKWAgYW5kIGAkc2V0KClgIG1ldGhvZHMuCgpBbnN3ZXI6IHNpbWlsYXIgdG8gYFRpbWVab25lYCwgYFdvcmtpbmdEaXJlY3RvcnlgIGluaXRpYWxpemVzIGB3ZGAgdG8gYGdldHdkKClgLgoKYGBge3Igd2FybmluZyA9IEZBTFNFfQpvcmlnX3dkIDwtIGdldHdkKCkKCldvcmtpbmdEaXJlY3RvcnkgPC0gUjZDbGFzcygiV29ya2luZ0RpcmVjdG9yeSIsIGxpc3QoICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgd2QgPSBnZXR3ZCgpLAogIGdldCA9IGZ1bmN0aW9uKCkgewogICAgY2F0KCJDdXJyZW50IGRpcmVjdG9yeTogIiwgc2VsZiR3ZCwgIlxuIiwgc2VwID0gIiIpCiAgICBpbnZpc2libGUoc2VsZikKICB9LAogIHNldCA9IGZ1bmN0aW9uKGRpcikgewogICAgc2VsZiR3ZCA8LSBzZXR3ZChkaXIpICMgbm9saW50OiB1bmRlc2lyYWJsZV9mdW5jdGlvbl9saW50ZXIuCiAgICBjYXQoIlNldCBkaXJlY3Rvcnk6ICIsIHNlbGYkd2QsICJcbiIsIHNlcCA9ICIiKQogICAgaW52aXNpYmxlKHNlbGYpCiAgfQopKQoKd2QgPC0gV29ya2luZ0RpcmVjdG9yeSRuZXcoKQp3ZCRnZXQoKQp3ZCRzZXQoImFzc2V0cyIpCmxpc3QuZmlsZXMoKQoKc2V0d2Qob3JpZ193ZCkgIyBub2xpbnQ6IHVuZGVzaXJhYmxlX2Z1bmN0aW9uX2xpbnRlci4KYGBgCgpBUiBTb2x1dGlvbnM6IFRha2UgYSBsb29rIGF0IHRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHF1aXRlIG1pbmltYWxpc3RpYzoKCmBgYHtyfQpXb3JraW5nRGlyZWN0b3J5IDwtIFI2Q2xhc3MoICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgY2xhc3NuYW1lID0gIldvcmtpbmdEaXJlY3RvcnkiLAogIHB1YmxpYyA9IGxpc3QoCiAgICBnZXQgPSBmdW5jdGlvbigpIHsKICAgICAgZ2V0d2QoKQogICAgfSwKICAgIHNldCA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIHNldHdkKHZhbHVlKSAjIG5vbGludDogdW5kZXNpcmFibGVfZnVuY3Rpb25fbGludGVyLgogICAgfQogICkKKQpgYGAKCkJ1ZzogbGlrZSBgQ2FyZHNgLCBgV29ya2luZ0RpcmVjdG9yeWAgc2hvdWxkIHNldCBgd2RgIGluIGBpbml0aWFsaXplKClgLiBBbHNvLCBhcyBBUiBTb2x1dGlvbnMgbm90ZXMgaW4gYSBjb21tZW50OgoKPiBZb3Ugc2hvdWxkIG5ldmVyIGRvIGBnZXQgPSBnZXR3ZCgpYCBldGMgYmVjYXVzZSBpbiBwYWNrYWdlcywgdGhhdCBpbmxpbmVzIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uIGF0IHBhY2thZ2UgYnVpbGQgdGltZSwgY3JlYXRpbmcgYSBzdWJ0bGUgZGVwZW5kZW5jeSB0aGF0IHdpbGwgY2F1c2UgYnVncyB0aGF0IGFyZSBleHRyZW1lbHkgZGlmZmljdWx0IHRvIHRyYWNrIGRvd24KCi0tLQoKNi4gIFdoeSBjYW4ndCB5b3UgbW9kZWwgdGhlIHRpbWUgem9uZSBvciBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IHdpdGggYW4gUzMKICAgIGNsYXNzPwoKQW5zd2VyOiBwZXIgZXhlcmNpc2UgMywgdGltZSB6b25lIGFuZCBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IGFyZSBib3RoIHN0YXRlZnVsLgoKQVIgU29sdXRpb25zOiBCZWNhdXNlIFMzIGNsYXNzZXMgYXJlIG5vdCBzdWl0YWJsZSBmb3IgbW9kZWxsaW5nIGEgc3RhdGUgdGhhdCBjaGFuZ2VzIG92ZXIgdGltZS4gUzMgbWV0aG9kcyBzaG91bGQgKGFsbW9zdCkgYWx3YXlzIHJldHVybiB0aGUgc2FtZSByZXN1bHQgd2hlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBpbnB1dHMuCgotLS0KCjcuICBXaGF0IGJhc2UgdHlwZSBhcmUgUjYgb2JqZWN0cyBidWlsdCBvbiB0b3Agb2Y/IFdoYXQgYXR0cmlidXRlcyBkbyB0aGV5CiAgICBoYXZlPwoKQW5zd2VyOiBSNm4gb2JqZWN0cyBhcmUgYnVpbHQgb24gZW52aXJvbm1lbnRzLCBhbmQgaGF2ZSBhIGNsYXNzIGF0dHJpYnV0ZSB3aXRoIGFuIFMzIGhpZXJhcmNoeSBpbmNsdWRpbmcgdGhlIGJhc2UgUjYgY2xhc3MsIHBlciAxNC4yLjUuCgpgYGB7cn0KdHlwZW9mKHR6KQphdHRyaWJ1dGVzKHR6KQpgYGAKCkFSIFNvbHV0aW9uczogUjYgb2JqZWN0cyBhcmUgYnVpbHQgb24gdG9wIG9mIGVudmlyb25tZW50cy4gVGhleSBoYXZlIGEgYGNsYXNzYCBhdHRyaWJ1dGUsIHdoaWNoIGlzIGEgY2hhcmFjdGVyIHZlY3RvciBjb250YWluaW5nIHRoZSBjbGFzcyBuYW1lLCB0aGUgbmFtZSBvZiBhbnkgc3VwZXIgY2xhc3NlcyAoaWYgZXhpc3RlbnQpIGFuZCB0aGUgc3RyaW5nIGAiUjYiYCBhcyB0aGUgbGFzdCBlbGVtZW50LgoKLS0tCgojIyAxNC4zLjMgRXhlcmNpc2VzCgoxLiAgQ3JlYXRlIGEgYmFuayBhY2NvdW50IGNsYXNzIHRoYXQgcHJldmVudHMgeW91IGZyb20gZGlyZWN0bHkgc2V0dGluZyB0aGUgCiAgICBhY2NvdW50IGJhbGFuY2UsIGJ1dCB5b3UgY2FuIHN0aWxsIHdpdGhkcmF3IGZyb20gYW5kIGRlcG9zaXQgdG8uIFRocm93CiAgICBhbiBlcnJvciBpZiB5b3UgYXR0ZW1wdCB0byBnbyBpbnRvIG92ZXJkcmFmdC4KCkFuc3dlcjogYFNlY3VyZUFjY291bnRgIHVzZXMgYSBwcml2YXRlIGludGVybmFsIGJhbGFuY2UgZXhwb3NlZCB0aHJvdWdoIGFuIGFjdGl2ZSBmdW5jdGlvbi4KCmBgYHtyfQpTZWN1cmVBY2NvdW50IDwtIFI2Q2xhc3MoIlNlY3VyZUFjY291bnQiLCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIHByaXZhdGUgPSBsaXN0KAogICAgLmJhbGFuY2UgPSAwTAogICksCiAgcHVibGljID0gbGlzdCgKICAgIGRlcG9zaXQgPSBmdW5jdGlvbih2YWx1ZSkgewogICAgICBzdG9waWZub3QoaXMuaW50ZWdlcih2YWx1ZSksIGxlbmd0aCh2YWx1ZSkgPT0gMSkKICAgICAgcHJpdmF0ZSQuYmFsYW5jZSA8LSBwcml2YXRlJC5iYWxhbmNlICsgdmFsdWUKICAgICAgaW52aXNpYmxlKHNlbGYpCiAgICB9LAogICAgd2l0aGRyYXcgPSBmdW5jdGlvbih2YWx1ZSkgewogICAgICBzdG9waWZub3QoaXMuaW50ZWdlcih2YWx1ZSksIGxlbmd0aCh2YWx1ZSkgPT0gMSwgdmFsdWUgPD0gcHJpdmF0ZSQuYmFsYW5jZSkKICAgICAgcHJpdmF0ZSQuYmFsYW5jZSA8LSBwcml2YXRlJC5iYWxhbmNlIC0gdmFsdWUKICAgICAgaW52aXNpYmxlKHNlbGYpCiAgICB9CiAgKSwKICBhY3RpdmUgPSBsaXN0KAogICAgYmFsYW5jZSA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIGlmIChtaXNzaW5nKHZhbHVlKSkgewogICAgICAgIHByaXZhdGUkLmJhbGFuY2UKICAgICAgfSBlbHNlIHsKICAgICAgICBzdG9wKCJgJGJhbGFuY2VgIGlzIHJlYWQgb25seSIsIGNhbGwuID0gRkFMU0UpCiAgICAgIH0KICAgIH0KICApCikKCnNhIDwtIFNlY3VyZUFjY291bnQkbmV3KCkKc2EkZGVwb3NpdCgxMEwpCnNhJHdpdGhkcmF3KDVMKQp0cnkoc2Ekd2l0aGRyYXcoMjBMKSkKdHJ5KHNhJGJhbGFuY2UgPC0gMTAwTCkKc2EkYmFsYW5jZQpgYGAKCkFSIFNvbHV0aW9uczogVG8gZnVsZmlsbCB0aGlzIHJlcXVpcmVtZW50LCB3ZSBtYWtlIGJhbGFuY2UgYSBwcml2YXRlIGZpZWxkLiBUaGUgdXNlciBoYXMgdG8gdXNlIHRoZSBgJGRlcG9zaXQoKWAgYW5kIGAkd2l0aGRyYXcoKWAgbWV0aG9kcyB3aGljaCBoYXZlIGFjY2VzcyB0byB0aGUgYmFsYW5jZSBmaWVsZC4KCmBgYHtyLCBlcnJvciA9IFRSVUV9CkJhbmtBY2NvdW50U3RyaWN0MiA8LSBSNkNsYXNzKCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGNsYXNzbmFtZSA9ICJCYW5rQWNjb3VudFN0cmljdDIiLAogIHB1YmxpYyA9IGxpc3QoCiAgICBkZXBvc2l0ID0gZnVuY3Rpb24oZGVwID0gMCkgewogICAgICBwcml2YXRlJGJhbGFuY2UgPC0gcHJpdmF0ZSRiYWxhbmNlICsgZGVwCiAgICAgIGludmlzaWJsZShzZWxmKQogICAgfSwKICAgIHdpdGhkcmF3ID0gZnVuY3Rpb24oZHJhdyA9IDApIHsKICAgICAgaWYgKHByaXZhdGUkYmFsYW5jZSAtIGRyYXcgPCAwKSB7CiAgICAgICAgc3RvcCgKICAgICAgICAgICJZb3VyIGB3aXRoZHJhd2AgbXVzdCBiZSBzbWFsbGVyICIsCiAgICAgICAgICAidGhhbiB5b3VyIGBiYWxhbmNlYC4iLAogICAgICAgICAgY2FsbC4gPSBGQUxTRQogICAgICAgICkKICAgICAgfQogICAgICBwcml2YXRlJGJhbGFuY2UgPC0gcHJpdmF0ZSRiYWxhbmNlIC0gZHJhdwogICAgICBpbnZpc2libGUoc2VsZikKICAgIH0KICApLAogIHByaXZhdGUgPSBsaXN0KAogICAgYmFsYW5jZSA9IDAKICApCikKYGBgCgotLS0KCjIuICBDcmVhdGUgYSBjbGFzcyB3aXRoIGEgd3JpdGUtb25seSBgJHBhc3N3b3JkYCBmaWVsZC4gSXQgc2hvdWxkIGhhdmUgCiAgICBgJGNoZWNrX3Bhc3N3b3JkKHBhc3N3b3JkKWAgbWV0aG9kIHRoYXQgcmV0dXJucyBgVFJVRWAgb3IgYEZBTFNFYCwgYnV0IAogICAgdGhlcmUgc2hvdWxkIGJlIG5vIHdheSB0byB2aWV3IHRoZSBjb21wbGV0ZSBwYXNzd29yZC4KCkFuc3dlcjogYExvZ2luYCBpbXBsZW1lbnRzIGEgd3JpdGUtb25seSBgJHBhc3N3b3JkYCBmaWVsZCB1c2luZyBhbiBhY3RpdmUgZnVuY3Rpb24uIGBjaGVja19wYXNzd29yZCgpYCB3aWxsIGVycm9yIGlmIGEgcGFzc3dvcmQgaGFzbid0IGJlZW4gc2V0LiBJbiByZWFsIGxpZmUsIHRoaXMgc2hvdWxkIGJlIGltcGxlbWVudGVkIHdpdGggYSBzZWN1cmUgcGFzc3dvcmQgaGFzaGluZyBmdW5jdGlvbiwgbGlrZSBgYmNyeXB0YCBvciBgc2NyeXB0YC4KCmBgYHtyfQpMb2dpbiA8LSBSNkNsYXNzKCJMb2dpbiIsICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgcHJpdmF0ZSA9IGxpc3QoCiAgICAucGFzc3dvcmQgPSBOVUxMCiAgKSwKICBwdWJsaWMgPSBsaXN0KAogICAgY2hlY2tfcGFzc3dvcmQgPSBmdW5jdGlvbihwYXNzd29yZCkgewogICAgICBzdG9waWZub3QoaXMuY2hhcmFjdGVyKHBhc3N3b3JkKSwgbGVuZ3RoKHBhc3N3b3JkKSA9PSAxKQogICAgICBpZiAoaXMubnVsbChwcml2YXRlJC5wYXNzd29yZCkpIHN0b3AoIkVycm9yOiBwYXNzd29yZCBub3Qgc2V0IikKICAgICAgcGFzc3dvcmQgPT0gcHJpdmF0ZSQucGFzc3dvcmQKICAgIH0KICApLAogIGFjdGl2ZSA9IGxpc3QoCiAgICBwYXNzd29yZCA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIGlmIChtaXNzaW5nKHZhbHVlKSkgewogICAgICAgIHN0b3AoImAkcGFzc3dvcmRgIGlzIHdyaXRlIG9ubHkiLCBjYWxsLiA9IEZBTFNFKQogICAgICB9IGVsc2UgewogICAgICAgIHN0b3BpZm5vdChpcy5jaGFyYWN0ZXIodmFsdWUpLCBsZW5ndGgodmFsdWUpID09IDEpCiAgICAgICAgcHJpdmF0ZSQucGFzc3dvcmQgPC0gdmFsdWUKICAgICAgICBpbnZpc2libGUoc2VsZikKICAgICAgfQogICAgfQogICkKKQoKbCA8LSBMb2dpbiRuZXcoKQp0cnkobCRjaGVja19wYXNzd29yZCgiUGFzc3dvcmQxIikpCmwkcGFzc3dvcmQgPC0gIlBhc3N3b3JkMSIKbCRjaGVja19wYXNzd29yZCgiUGFzc3dvcmQxIikKbCRjaGVja19wYXNzd29yZCgiUGFzc3dvcmQyIikKdHJ5KGwkcGFzc3dvcmQpCmBgYAoKQVIgU29sdXRpb25zOiBUbyBwcm90ZWN0IHRoZSBwYXNzd29yZCBmcm9tIGNoYW5nZXMgYW5kIGRpcmVjdCBhY2Nlc3MsIHRoZSBwYXNzd29yZCB3aWxsIGJlIGEgcHJpdmF0ZSBmaWVsZC4gRnVydGhlciwgb3VyIGBQYXNzd29yZGAgd2lsbCBnZXQgaXRzIG93biBwcmludCBtZXRob2Qgd2hpY2ggaGlkZXMgdGhlIHBhc3N3b3JkLgoKYGBge3J9ClBhc3N3b3JkIDwtIFI2Q2xhc3MoICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgY2xhc3NuYW1lID0gIlBhc3N3b3JkIiwKICBwdWJsaWMgPSBsaXN0KAogICAgcHJpbnQgPSBmdW5jdGlvbiguLi4pIHsKICAgICAgY2F0KCI8UGFzc3dvcmQ+OiAqKioqKioqKlxuIikKICAgICAgaW52aXNpYmxlKHNlbGYpCiAgICB9LAogICAgc2V0ID0gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgcHJpdmF0ZSRwYXNzd29yZCA8LSB2YWx1ZQogICAgfSwKICAgIGNoZWNrID0gZnVuY3Rpb24ocGFzc3dvcmQpIHsKICAgICAgaWRlbnRpY2FsKHBhc3N3b3JkLCBwcml2YXRlJHBhc3N3b3JkKQogICAgfQogICksCiAgcHJpdmF0ZSA9IGxpc3QoCiAgICBwYXNzd29yZCA9IE5VTEwKICApCikKYGBgCgpMZXQncyBjcmVhdGUgb25lIGluc3RhbmNlIG9mIG91ciBuZXcgY2xhc3MgYW5kIGNvbmZpcm0gdGhhdCB0aGUgcGFzc3dvcmQgaXMgbmVpdGhlciBhY2Nlc3NpYmxlIG5vciB2aXNpYmxlLCBidXQgc3RpbGwgY2hlY2stYWJsZS4KCmBgYHtyLCBlcnJvciA9IFRSVUV9Cm15X3B3IDwtIFBhc3N3b3JkJG5ldygpCm15X3B3JHNldCgic251ZmZsZXMiKQpteV9wdyRwYXNzd29yZApteV9wdwpteV9wdyRjaGVjaygic251Z2dsZXMiKQpteV9wdyRjaGVjaygic251ZmZsZXMiKQpgYGAKCk5vdGU6IHRoZSBBUiBTb2x1dGlvbnMgY2xhc3MgcHJvcGVybHkgbWFza3MgdGhlIHBhc3N3b3JkIHdoZW4gY2FsbGluZyBgcHJpbnQoKWAsIGJ1dCBtaW5lIGRvZXMgbm90OgoKYGBge3J9CmwKYGBgCgotLS0KCjMuICBFeHRlbmQgdGhlIGBSYW5kb2AgY2xhc3Mgd2l0aCBhbm90aGVyIGFjdGl2ZSBiaW5kaW5nIHRoYXQgYWxsb3dzIHlvdSB0byAKICAgIGFjY2VzcyB0aGUgcHJldmlvdXMgcmFuZG9tIHZhbHVlLiBFbnN1cmUgdGhhdCBhY3RpdmUgYmluZGluZyBpcyB0aGUgb25seQogICAgd2F5IHRvIGFjY2VzcyB0aGUgdmFsdWUuCgpBbnN3ZXI6IHRoZSB1cGRhdGVkIGBSYW5kb2AgY2xhc3Mgc2V0cyBhIHByaXZhdGUgdmFsdWUgd2hlbiBgcmFuZG9tYCBpcyBydW4gdGhhdCBpcyBhY2Nlc3NpYmxlIG9ubHkgdGhyb3VnaCBgcHJldmlvdXNgLCBpbml0aWFsbHkgc2V0IHRvIGBOQWAuCgpgYGB7cn0KUmFuZG8gPC0gUjY6OlI2Q2xhc3MoIlJhbmRvIiwgIyBub2xpbnQ6IG9iamVjdF9uYW1lX2xpbnRlci4KICBwcml2YXRlID0gbGlzdCgKICAgIC5wcmV2aW91cyA9IE5BCiAgKSwKICBhY3RpdmUgPSBsaXN0KAogICAgcmFuZG9tID0gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgaWYgKG1pc3NpbmcodmFsdWUpKSB7CiAgICAgICAgcHJpdmF0ZSQucHJldmlvdXMgPC0gcnVuaWYoMSkKICAgICAgICBwcml2YXRlJC5wcmV2aW91cwogICAgICB9IGVsc2UgewogICAgICAgIHN0b3AoIkNhbid0IHNldCBgJHJhbmRvbWAiLCBjYWxsLiA9IEZBTFNFKQogICAgICB9CiAgICB9LAogICAgcHJldmlvdXMgPSBmdW5jdGlvbih2YWx1ZSkgewogICAgICBpZiAobWlzc2luZyh2YWx1ZSkpIHsKICAgICAgICBwcml2YXRlJC5wcmV2aW91cwogICAgICB9IGVsc2UgewogICAgICAgIHN0b3AoIkNhbid0IHNldCBgJHByZXZpb3VzYCIsIGNhbGwuID0gRkFMU0UpCiAgICAgIH0KICAgIH0KICApCikKeCA8LSBSYW5kbyRuZXcoKQoKeCRwcmV2aW91cwp4JHJhbmRvbQp4JHByZXZpb3VzCngkcmFuZG9tCngkcHJldmlvdXMKYGBgCgpBUiBTb2x1dGlvbnM6IFRvIGFjY2VzcyB0aGUgcHJldmlvdXMgcmFuZG9tIHZhbHVlIGZyb20gYW4gaW5zdGFuY2UsIHdlIGFkZCBhIHByaXZhdGUgYCRsYXN0X3JhbmRvbWAgZmllbGQgdG8gb3VyIGNsYXNzLCBhbmQgd2UgbW9kaWZ5IGAkcmFuZG9tKClgIHRvIHdyaXRlIHRvIHRoaXMgZmllbGQsIHdoZW5ldmVyIGl0IGlzIGNhbGxlZC4gVG8gYWNjZXNzIHRoZSBgJGxhc3RfcmFuZG9tYCBmaWVsZCB3ZSBwcm92aWRlIGAkcHJldmlvdXMoKWAuCgpgYGB7cn0KUmFuZG8gPC0gUjY6OlI2Q2xhc3MoICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgY2xhc3NuYW1lID0gIlJhbmRvIiwKICBwcml2YXRlID0gbGlzdCgKICAgIGxhc3RfcmFuZG9tID0gTlVMTAogICksCiAgYWN0aXZlID0gbGlzdCgKICAgIHJhbmRvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIGlmIChtaXNzaW5nKHZhbHVlKSkgewogICAgICAgIHByaXZhdGUkbGFzdF9yYW5kb20gPC0gcnVuaWYoMSkKICAgICAgICBwcml2YXRlJGxhc3RfcmFuZG9tCiAgICAgIH0gZWxzZSB7CiAgICAgICAgc3RvcCgiQ2FuJ3Qgc2V0IGAkcmFuZG9tYC4iLCBjYWxsLiA9IEZBTFNFKQogICAgICB9CiAgICB9LAogICAgcHJldmlvdXMgPSBmdW5jdGlvbih2YWx1ZSkgewogICAgICBpZiAobWlzc2luZyh2YWx1ZSkpIHsKICAgICAgICBwcml2YXRlJGxhc3RfcmFuZG9tCiAgICAgIH0KICAgIH0KICApCikKYGBgCgotLS0KCjQuICBDYW4gc3ViY2xhc3NlcyBhY2Nlc3MgcHJpdmF0ZSBmaWVsZHMvbWV0aG9kcyBmcm9tIHRoZWlyIHBhcmVudD8gUGVyZm9ybQogICAgYW4gZXhwZXJpbWVudCB0byBmaW5kIG91dC4KCkFuc3dlcjogYExvZ2luRXZpbGAgc2hvd3MgdGhhdCBzdWJjbGFzc2VzICpjYW4qIGFjY2VzcyBwcml2YXRlIGZpZWxkcyBmcm9tIHRoZWlyIHBhcmVudC4KCmBgYHtyfQpMb2dpbkV2aWwgPC0gUjZDbGFzcygiTG9naW5FdmlsIiwgIyBub2xpbnQ6IG9iamVjdF9uYW1lX2xpbnRlci4KICBpbmhlcml0ID0gTG9naW4sCiAgcHVibGljID0gbGlzdCgKICAgIHN0ZWFsX3Bhc3N3b3JkID0gZnVuY3Rpb24oKSB7CiAgICAgIGNhdCgiVGhlIHBhc3N3b3JkIGlzOiAiLCBwcml2YXRlJC5wYXNzd29yZCwgIlxuIiwgc2VwID0gIiIpCiAgICB9CiAgKQopCgpldmlsIDwtIExvZ2luRXZpbCRuZXcoKQpldmlsJHBhc3N3b3JkIDwtICJTdXBlclNlY3JldFBhc3N3b3JkIgpldmlsJHN0ZWFsX3Bhc3N3b3JkKCkKYGBgCgpBUiBTb2x1dGlvbnM6IFRvIGZpbmQgb3V0IGlmIHByaXZhdGUgZmllbGRzL21ldGhvZHMgY2FuIGJlIGFjY2Vzc2VkIGZyb20gc3ViY2xhc3Nlcywgd2UgZmlyc3QgY3JlYXRlIGEgY2xhc3MgYEFgIHdpdGggYSBwcml2YXRlIGZpZWxkIGBmb29gIGFuZCBhIHByaXZhdGUgbWV0aG9kIGBiYXIoKWAuIEFmdGVyd2FyZHMsIGFuIGluc3RhbmNlIG9mIGEgc3ViY2xhc3MgYEJgICBpcyBjcmVhdGVkIGFuZCBjYWxscyB0aGUgYGZvb2JhcigpYCBtZXRob2RzLCB3aGljaCB0cmllcyB0byBhY2Nlc3MgdGhlIGBmb29gIGZpZWxkIGFuZCB0aGUgYGJhcigpYCBtZXRob2QgZnJvbSBpdHMgc3VwZXJjbGFzcyBgQWAuCgpgYGB7cn0KQSA8LSBSNkNsYXNzKCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGNsYXNzbmFtZSA9ICJBIiwKICBwcml2YXRlID0gbGlzdCgKICAgIGZpZWxkID0gImZvbyIsCiAgICBtZXRob2QgPSBmdW5jdGlvbigpIHsKICAgICAgImJhciIKICAgIH0KICApCikKQiA8LSBSNkNsYXNzKCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIGNsYXNzbmFtZSA9ICJCIiwKICBpbmhlcml0ID0gQSwKICBwdWJsaWMgPSBsaXN0KAogICAgdGVzdCA9IGZ1bmN0aW9uKCkgewogICAgICBjYXQoIkZpZWxkOiAgIiwgc3VwZXIkZmllbGQsICJcbiIsIHNlcCA9ICIiKQogICAgICBjYXQoIk1ldGhvZDogIiwgc3VwZXIkbWV0aG9kKCksICJcbiIsIHNlcCA9ICIiKQogICAgfQogICkKKQpCJG5ldygpJHRlc3QoKQpgYGAKCldlIGNvbmNsdWRlIHRoYXQgc3ViY2xhc3NlcyBjYW4gYWNjZXNzIHByaXZhdGUgbWV0aG9kcyBmcm9tIHRoZWlyIHN1cGVyY2xhc3NlcywgYnV0IG5vdCBwcml2YXRlIGZpZWxkcy4KCk5vdGU6IGFzIEkgZGlzY292ZXJlZCwgcHJpdmF0ZSBmaWVsZHMgYXJlIG5vdCBhY2Nlc3NpYmxlIHRocm91Z2ggYHN1cGVyJGAsIGJ1dCAqYXJlKiBhY2Nlc3NpYmxlIHRocm91Z2ggYHByaXZhdGUkYC4KCi0tLQoKIyMgMTQuNC40IEV4ZXJjaXNlcwoKMS4gIENyZWF0ZSBhIGNsYXNzIHRoYXQgYWxsb3dzIHlvdSB0byB3cml0ZSBhIGxpbmUgdG8gYSBzcGVjaWZpZWQgZmlsZS4gCiAgICBZb3Ugc2hvdWxkIG9wZW4gYSBjb25uZWN0aW9uIHRvIHRoZSBmaWxlIGluIGAkaW5pdGlhbGl6ZSgpYCwgYXBwZW5kIGEKICAgIGxpbmUgdXNpbmcgYGNhdCgpYCBpbiBgJGFwcGVuZF9saW5lKClgLCBhbmQgY2xvc2UgdGhlIGNvbm5lY3Rpb24gaW4KICAgIGAkZmluYWxpemUoKWAuCgpBbnN3ZXI6IGBXcml0ZUZpbGVgIGltcGxlbWVudGVkIGJlbG93LgoKYGBge3J9CldyaXRlRmlsZSA8LSBSNkNsYXNzKCJXcml0ZUZpbGUiLCBsaXN0KCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogIHdmaWxlID0gTlVMTCwKICBpbml0aWFsaXplID0gZnVuY3Rpb24oZmlsZW5hbWUpIHsKICAgIHNlbGYkd2ZpbGUgPC0gZmlsZShmaWxlbmFtZSwgImEiKQogIH0sCiAgYXBwZW5kX2xpbmUgPSBmdW5jdGlvbihsaW5lKSB7CiAgICBjYXQobGluZSwgZmlsZSA9IHNlbGYkd2ZpbGUpCiAgfSwKICBmaW5hbGl6ZSA9IGZ1bmN0aW9uKCkgewogICAgY2xvc2Uoc2VsZiR3ZmlsZSkKICB9CikpCgp0bXAgPC0gdGVtcGZpbGUoKQp3ZiA8LSBXcml0ZUZpbGUkbmV3KHRtcCkKd2YkYXBwZW5kX2xpbmUoIlRoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuXG4iKQpyZWFkTGluZXModG1wKQpgYGAKCkFSIFNvbHV0aW9uczogT3VyIGBGaWxlV3JpdGVyYCBjbGFzcyB3aWxsIGNyZWF0ZSBhIGNvbm5lY3Rpb24gdG8gYSBmaWxlIGF0IGluaXRpYWxpemF0aW9uLiBUaGVyZWZvcmUsIHdlIG9wZW4gYSBjb25uZWN0aW9uIHRvIGEgdXNlciBzcGVjaWZpZWQgZmlsZSBkdXJpbmcgdGhlIGluaXRpYWxpc2F0aW9uLiBOb3RlIHRoYXQgd2UgbmVlZCB0byBzZXQgYG9wZW4gPSAiYSJgIGluIGBmaWxlKClgIHRvIG9wZW4gY29ubmVjdGlvbiBmb3IgYXBwZW5kaW5nIHRleHQuIE90aGVyd2lzZSwgYGNhdCgpYCB3b3VsZCBvbmx5IHdvcmsgd2hlbiBhcHBsaWVkIHRvIGZpbGVzLCBidXQgbm90IHdpdGggY29ubmVjdGlvbnMgYXMgZXhwbGljaXRseSBhc2tlZCBmb3IgaW4gdGhlIGV4ZXJjaXNlLiBGdXJ0aGVyLCB3ZSBhZGQgdGhlIGBhcHBlbmRfbGluZSgpYCBtZXRob2QgYW5kIGEgYGNsb3NlKClgIHN0YXRlbWVudCBhcyBmaW5hbGl6ZXIuCgpgYGB7ciwgZXZhbCA9IFRSVUUsIGVycm9yID0gVFJVRX0KRmlsZVdyaXRlciA8LSBSNjo6UjZDbGFzcyggIyBub2xpbnQ6IG9iamVjdF9uYW1lX2xpbnRlci4KICBjbGFzc25hbWUgPSAiRmlsZVdyaXRlciIsCiAgcHVibGljID0gbGlzdCgKICAgIGNvbiA9IE5VTEwsCiAgICBpbml0aWFsaXplID0gZnVuY3Rpb24oZmlsZW5hbWUpIHsKICAgICAgc2VsZiRjb24gPC0gZmlsZShmaWxlbmFtZSwgb3BlbiA9ICJhIikKICAgIH0sCiAgICBmaW5hbGl6ZSA9IGZ1bmN0aW9uKCkgewogICAgICBjbG9zZShzZWxmJGNvbikKICAgIH0sCiAgICBhcHBlbmRfbGluZSA9IGZ1bmN0aW9uKHgpIHsKICAgICAgY2F0KHgsICJcbiIsIHNlcCA9ICIiLCBmaWxlID0gc2VsZiRjb24pCiAgICB9CiAgKQopCmBgYAoKLS0tCgojIDE1IFM0CgpgYGB7cn0Kcm0obGlzdCA9IGxzKCkpCmBgYAoKUzQgcHJvdmlkZXMgYSBmb3JtYWwgYXBwcm9hY2ggdG8gZnVuY3Rpb25hbCBPT1AuIFRoZSB1bmRlcmx5aW5nIGlkZWFzIGFyZSBzaW1pbGFyIHRvIFMzICh0aGUgdG9waWMgb2YgQ2hhcHRlciAxMyksIGJ1dCBpbXBsZW1lbnRhdGlvbiBpcyBtdWNoIHN0cmljdGVyIGFuZCBtYWtlcyB1c2Ugb2Ygc3BlY2lhbGlzZWQgZnVuY3Rpb25zIGZvciBjcmVhdGluZyBjbGFzc2VzIChgc2V0Q2xhc3MoKWApLCBnZW5lcmljcyAoYHNldEdlbmVyaWMoKWApLCBhbmQgbWV0aG9kcyAoYHNldE1ldGhvZCgpYCkuIEFkZGl0aW9uYWxseSwgUzQgcHJvdmlkZXMgYm90aCBtdWx0aXBsZSBpbmhlcml0YW5jZSAoaS5lLiBhIGNsYXNzIGNhbiBoYXZlIG11bHRpcGxlIHBhcmVudHMpIGFuZCBtdWx0aXBsZSBkaXNwYXRjaCAoaS5lLiBtZXRob2QgZGlzcGF0Y2ggY2FuIHVzZSB0aGUgY2xhc3Mgb2YgbXVsdGlwbGUgYXJndW1lbnRzKS4KCkFuIGltcG9ydGFudCBuZXcgY29tcG9uZW50IG9mIFM0IGlzIHRoZSBfX3Nsb3RfXywgYSBuYW1lZCBjb21wb25lbnQgb2YgdGhlIG9iamVjdCB0aGF0IGlzIGFjY2Vzc2VkIHVzaW5nIHRoZSBzcGVjaWFsaXNlZCBzdWJzZXR0aW5nIG9wZXJhdG9yIGBAYCAocHJvbm91bmNlZCBhdCkuIFRoZSBzZXQgb2Ygc2xvdHMsIGFuZCB0aGVpciBjbGFzc2VzLCBmb3JtcyBhbiBpbXBvcnRhbnQgcGFydCBvZiB0aGUgZGVmaW5pdGlvbiBvZiBhbiBTNCBjbGFzcy4KCiMjIDE1LjIuMSBFeGVyY2lzZXMKCjEuICBgbHVicmlkYXRlOjpwZXJpb2QoKWAgcmV0dXJucyBhbiBTNCBjbGFzcy4gV2hhdCBzbG90cyBkb2VzIGl0IGhhdmU/CiAgICBXaGF0IGNsYXNzIGlzIGVhY2ggc2xvdD8gV2hhdCBhY2Nlc3NvcnMgZG9lcyBpdCBwcm92aWRlPwoKQW5zd2VyOiB0aGUgUzQgY2xhc3MsIGBQZXJpb2RgLCBoYXMgNiBzbG90czogLkRhdGEsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIGFuZCBtaW51dGUsIGFsbCBudW1lcmljLiBJIGNvdWxkbid0IGZpZ3VyZSBvdXQgaG93IHRvIGdldCB0aGUgYWNjZXNzb3JzLgoKYGBge3J9CnAgPC0gbHVicmlkYXRlOjpwZXJpb2QoKQppcyhwKQp2YXBwbHkoc2xvdE5hbWVzKHApLCBmdW5jdGlvbih4KSBjbGFzcyhzbG90KHAsIHgpKSwgY2hhcmFjdGVyKDEpKQpgYGAKCkFSIFNvbHV0aW9uczogT2JqZWN0cyBvZiB0aGUgUzQgYFBlcmlvZGAgY2xhc3MgaGF2ZSBzaXggc2xvdHMgbmFtZWQgYHllYXJgLCBgbW9udGhgLCBgZGF5YCwgYGhvdXJgLCBgbWludXRlYCwgYW5kIGAuRGF0YWAgKHdoaWNoIGNvbnRhaW5zIHRoZSBudW1iZXIgb2Ygc2Vjb25kcykuIEFsbCBzbG90cyBhcmUgb2YgdHlwZSBkb3VibGUuIE1vc3QgZmllbGRzIGNhbiBiZSByZXRyaWV2ZWQgYnkgYW4gaWRlbnRpY2FsbHkgbmFtZWQgYWNjZXNzb3IgKGUuZy4gYGx1YnJpZGF0ZTo6eWVhcigpYCB3aWxsIHJldHVybiB0aGUgZmllbGQpLCB1c2UgYHNlY29uZCgpYCB0byBnZXQgdGhlIGAuRGF0YWAgc2xvdC4KCkFzIGEgc2hvcnQgZXhhbXBsZSwgd2UgY3JlYXRlIGEgcGVyaW9kIG9mIDEgc2Vjb25kLCAyIG1pbnV0ZXMsIDMgaG91cnMsIDQgZGF5cyBhbmQgNSB3ZWVrcy4KCmBgYHtyfQpleGFtcGxlXzEyMzQ1IDwtIGx1YnJpZGF0ZTo6cGVyaW9kKAogIGMoMSwgMiwgMywgNCwgNSksCiAgYygic2Vjb25kIiwgIm1pbnV0ZSIsICJob3VyIiwgImRheSIsICJ3ZWVrIikKKQpgYGAKClRoaXMgc2hvdWxkIGFkZCB1cCB0byBhIHBlcmlvZCBvZiAzOSBkYXlzLCAzIGhvdXJzLCAyIG1pbnV0ZXMgYW5kIDEgc2Vjb25kLgoKYGBge3J9CmV4YW1wbGVfMTIzNDUKYGBgCgpXaGVuIHdlIGluc3BlY3QgYGV4YW1wbGVfMTIzNDVgLCB3ZSBzZWUgdGhlIGZpZWxkcyBhbmQgaW5mZXIgdGhhdCB0aGUgc2Vjb25kcyBhcmUgc3RvcmVkIGluIHRoZSBgLkRhdGFgIGZpZWxkLgoKYGBge3J9CnN0cihleGFtcGxlXzEyMzQ1KQpgYGAKCk5vdGVzOiBpdCBpcyBlYXNpZXIgdG8ganVzdCB1c2UgYGdldENsYXNzYCB0byBlbnVtZXJhdGUgc2xvdHMgYW5kIHNsb3QgY2xhc3NlczoKCmBgYHtyfQpnZXRDbGFzcyhpcyhsdWJyaWRhdGU6OnBlcmlvZCgpKSkKYGBgCgpNZXRob2RzIGRlZmluZWQgZm9yIGEgcGFydGljdWxhciBjbGFzcyBjYW4gYmUgbGlzdGVkIHVzaW5nIGBzaG93TWV0aG9kcygpYCwgYW5kIFM0IG1ldGhvZHMgY2FuIGJlIGxpc3RlZCB1c2luZyBgLlM0bWV0aG9kcygpYDoKCmBgYHtyfQouUzRtZXRob2RzKCJQZXJpb2QiKQpgYGAKCmBQZXJpb2RgIGhhcyBubyBTNCBtZXRob2RzLCBvbmx5IHJlZ3VsYXIgZnVuY3Rpb25zLgoKLS0tCgoyLiAgV2hhdCBvdGhlciB3YXlzIGNhbiB5b3UgZmluZCBoZWxwIGZvciBhIG1ldGhvZD8gUmVhZCBgPyI/ImAgYW5kCiAgICBzdW1tYXJpc2UgdGhlIGRldGFpbHMuCgpBbnN3ZXI6IHRoZXJlIGFyZSB0aHJlZSB3YXlzIHRvIGdldCBoZWxwIGZvciBhIG1ldGhvZDoKCjEuIGA/ZnVuY3Rpb25gIHByb3ZpZGVzIHRoZSBmdW5jdGlvbiBkb2N1bWVudGF0aW9uCjEuIGBtZXRob2RzP2Z1bmN0aW9uYCBwcm92aWRlcyB0aGUgb3ZlcmFsbCBkb2N1bWVudGF0aW9uIG1ldGhvZHMgZm9yIHRoZSBmdW5jdGlvbgoxLiBgbWV0aG9kcz9mdW5jdGlvbihzaWduYXR1cmUpYCBwcm92aWRlcyB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgYSBzcGVjaWZpYyBtZXRob2QKCkFSIFNvbHV0aW9uczogQmVzaWRlcyBhZGRpbmcgYD9gIGluIGZyb250IG9mIGEgZnVuY3Rpb24gY2FsbCAoaS5lLiBgP21ldGhvZCgpYCksIHdlIG1heSBmaW5kOgoKLSBnZW5lcmFsIGRvY3VtZW50YXRpb24gZm9yIGEgZ2VuZXJpYyB2aWEgYD9nZW5lcmljTmFtZWAKLSBnZW5lcmFsIGRvY3VtZW50YXRpb24gZm9yIHRoZSBtZXRob2RzIG9mIGEgZ2VuZXJpYyB2aWEgYG1ldGhvZHM/Z2VuZXJpY05hbWVgCi0gZG9jdW1lbnRhdGlvbiBmb3IgYSBzcGVjaWZpYyBtZXRob2QgdmlhIGBDbGFzc05hbWU/bWV0aG9kTmFtZWAuCgotLS0KCiMjIDE1LjMuNiBFeGVyY2lzZXMKCjEuICBFeHRlbmQgdGhlIFBlcnNvbiBjbGFzcyB3aXRoIGZpZWxkcyB0byBtYXRjaCBgdXRpbHM6OnBlcnNvbigpYC4KICAgIFRoaW5rIGFib3V0IHdoYXQgc2xvdHMgeW91IHdpbGwgbmVlZCwgd2hhdCBjbGFzcyBlYWNoIHNsb3Qgc2hvdWxkIGhhdmUsCiAgICBhbmQgd2hhdCB5b3UnbGwgbmVlZCB0byBjaGVjayBpbiB5b3VyIHZhbGlkaXR5IG1ldGhvZC4KCkFuc3dlcjogdGhlIGBQZXJzb25gIGNsYXNzIHVzZXMgdGhlIGZpZWxkcyBmcm9tIGB1dGlsczo6cGVyc29uKClgLCBleGNsdWRpbmcgZGVwcmVjYXRlZCBmaWVsZHMuIFBlciB0aGUgZG9jcywgYGZhbWlseWAgbXVzdCBiZSBhIHN0cmluZyAobGVuZ3RoIDEpLCBvdGhlcnMgY2FuIGJlIHZlY3RvcnMgKGJ1dCB0aGlzIGlzIG5vdCBlbmZvcmNlZCkuCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQojIFRPRE86IGV2YWwgPSBGQUxTRSBzZXQgdG8gYWxsb3cgcmVuZGVyaW5nIHVzaW5nIGJ1aWxkX2FuYWx5c2lzX3NpdGUoKQpzZXRDbGFzcygiUGVyc29uIiwKICBzbG90cyA9IGMoCiAgICBnaXZlbiA9ICJjaGFyYWN0ZXIiLAogICAgZmFtaWx5ID0gImNoYXJhY3RlciIsCiAgICBlbWFpbCA9ICJjaGFyYWN0ZXIiLAogICAgcm9sZSA9ICJjaGFyYWN0ZXIiLAogICAgY29tbWVudCA9ICJjaGFyYWN0ZXIiCiAgKSwKICBwcm90b3R5cGUgPSBsaXN0KAogICAgZ2l2ZW4gPSBOQV9jaGFyYWN0ZXJfLAogICAgZmFtaWx5ID0gTkFfY2hhcmFjdGVyXywKICAgIGVtYWlsID0gTkFfY2hhcmFjdGVyXywKICAgIHJvbGUgPSBOQV9jaGFyYWN0ZXJfLAogICAgY29tbWVudCA9IE5BX2NoYXJhY3Rlcl8KICApCikKCnNldFZhbGlkaXR5KCJQZXJzb24iLCBmdW5jdGlvbihvYmplY3QpIHsKICAjIHJlZ2V4IGZyb20gaHR0cHM6Ly93d3cubmljZWJyZWFkLmRlL3ZhbGlkYXRpbmctZW1haWwtYWRyZXNzZXMtaW4tci8KICByZWdleCA8LSAiXFw8W0EtWjAtOS5fJSstXStAW0EtWjAtOS4tXStcXC5bQS1aXXsyLH1cXD4iCgogIGlmIChsZW5ndGgob2JqZWN0QGZhbWlseSkgPiAxKSB7CiAgICAiQGZhbWlseSBtdXN0IGJlIGEgc3RyaW5nIChsZW5ndGggMSkiCiAgfSBlbHNlIGlmICghaXMubmEob2JqZWN0QGVtYWlsKSAmICFncmVwbChyZWdleCwgb2JqZWN0QGVtYWlsLCBpZ25vcmUuY2FzZSA9IFRSVUUpKSB7CiAgICAiaW52YWxpZCBAZW1haWwiCiAgfSBlbHNlIHsKICAgIFRSVUUKICB9Cn0pIHw+CiAgaW52aXNpYmxlKCkKClBlcnNvbiA8LSBmdW5jdGlvbihnaXZlbiA9IE5BX2NoYXJhY3Rlcl8sIGZhbWlseSA9IE5BX2NoYXJhY3Rlcl8sICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgICAgICAgICAgICAgICAgICBlbWFpbCA9IE5BX2NoYXJhY3Rlcl8sIHJvbGUgPSBOQV9jaGFyYWN0ZXJfLCBjb21tZW50ID0gTkFfY2hhcmFjdGVyXykgewogIGdpdmVuIDwtIGFzLmNoYXJhY3RlcihnaXZlbikKICBmYW1pbHkgPC0gYXMuY2hhcmFjdGVyKGZhbWlseSkKICBlbWFpbCA8LSBhcy5jaGFyYWN0ZXIoZW1haWwpCiAgcm9sZSA8LSBhcy5jaGFyYWN0ZXIocm9sZSkKICBjb21tZW50IDwtIGFzLmNoYXJhY3Rlcihjb21tZW50KQoKICBuZXcoIlBlcnNvbiIsIGdpdmVuID0gZ2l2ZW4sIGZhbWlseSA9IGZhbWlseSwgZW1haWwgPSBlbWFpbCwgcm9sZSA9IHJvbGUsIGNvbW1lbnQgPSBjb21tZW50KQp9CgpQZXJzb24oIkpvaG4iLCAiQmVubmluZ2hvZmYiLCBlbWFpbCA9ICJqb2huQGV4YW1wbGUuY29tIiwgY29tbWVudCA9IDUxKQp0cnkoUGVyc29uKCJKb2huIiwgYygiVGhyZWUiLCAiTGFzdCIsICJOYW1lcyIpKSkKdHJ5KFBlcnNvbigiSm9obiIsIGVtYWlsID0gImludmFsaWRAbG9jYWwiKSkKYGBgCgpBUiBTb2x1dGlvbnM6IFRoZSBQZXJzb24gY2xhc3MgZnJvbSAqQWR2YW5jZWQgUiogY29udGFpbnMgdGhlIHNsb3RzIGBuYW1lYCBhbmQgYGFnZWAuIFRoZSBwZXJzb24gY2xhc3MgZnJvbSB0aGUgYHt1dGlsc31gIHBhY2thZ2UgY29udGFpbnMgdGhlIHNsb3RzIGBnaXZlbmAgKHZlY3RvciBvZiBnaXZlbiBuYW1lcyksIGBmYW1pbHlgLCBgcm9sZWAsIGBlbWFpbGAgYW5kIGBjb21tZW50YCAoc2VlIGA/dXRpbHM6OnBlcnNvbmApLiAKCkFsbCBzbG90cyBmcm9tIGB1dGlsczo6cGVyc29uKClgIGJlc2lkZXMgYHJvbGVgIG11c3QgYmUgb2YgdHlwZSBjaGFyYWN0ZXIgYW5kIGxlbmd0aCAxLiBUaGUgZW50cmllcyBpbiB0aGUgYHJvbGVgIHNsb3QgbXVzdCBtYXRjaCBvbmUgb2YgdGhlIGZvbGxvd2luZyBhYmJyZXZpYXRpb25zICJhdXQiLCAiY29tIiwgImNwaCIsICJjcmUiLCAiY3RiIiwgImN0ciIsICJkdGMiLCAiZm5kIiwgInJldiIsICJ0aHMiLCAidHJsIi4gVGhlcmVmb3JlLCBgcm9sZWAgbWlnaHQgYmUgb2YgZGlmZmVyZW50IGxlbmd0aCB0aGFuIHRoZSBvdGhlciBzbG90cyBhbmQgd2UnbGwgYWRkIGEgY29ycmVzcG9uZGluZyBjb25zdHJhaW50IHdpdGhpbiB0aGUgdmFsaWRhdG9yLgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBUT0RPOiBldmFsID0gRkFMU0Ugc2V0IHRvIGFsbG93IHJlbmRlcmluZyB1c2luZyBidWlsZF9hbmFseXNpc19zaXRlKCkKIyBEZWZpbml0aW9uIG9mIHRoZSBQZXJzb24gY2xhc3MKc2V0Q2xhc3MoIlBlcnNvbiIsCiAgc2xvdHMgPSBjKAogICAgYWdlID0gIm51bWVyaWMiLAogICAgZ2l2ZW4gPSAiY2hhcmFjdGVyIiwKICAgIGZhbWlseSA9ICJjaGFyYWN0ZXIiLAogICAgcm9sZSA9ICJjaGFyYWN0ZXIiLAogICAgZW1haWwgPSAiY2hhcmFjdGVyIiwKICAgIGNvbW1lbnQgPSAiY2hhcmFjdGVyIgogICksCiAgcHJvdG90eXBlID0gbGlzdCgKICAgIGFnZSA9IE5BX3JlYWxfLAogICAgZ2l2ZW4gPSBOQV9jaGFyYWN0ZXJfLAogICAgZmFtaWx5ID0gTkFfY2hhcmFjdGVyXywKICAgIHJvbGUgPSBOQV9jaGFyYWN0ZXJfLAogICAgZW1haWwgPSBOQV9jaGFyYWN0ZXJfLAogICAgY29tbWVudCA9IE5BX2NoYXJhY3Rlcl8KICApCikKIyBIZWxwZXIgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiB0aGUgUGVyc29uIGNsYXNzClBlcnNvbiA8LSBmdW5jdGlvbihnaXZlbiwgZmFtaWx5LCAjIG5vbGludDogb2JqZWN0X25hbWVfbGludGVyLgogICAgICAgICAgICAgICAgICAgYWdlID0gTkFfcmVhbF8sCiAgICAgICAgICAgICAgICAgICByb2xlID0gTkFfY2hhcmFjdGVyXywKICAgICAgICAgICAgICAgICAgIGVtYWlsID0gTkFfY2hhcmFjdGVyXywKICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBOQV9jaGFyYWN0ZXJfKSB7CiAgYWdlIDwtIGFzLmRvdWJsZShhZ2UpCiAgbmV3KCJQZXJzb24iLAogICAgYWdlID0gYWdlLAogICAgZ2l2ZW4gPSBnaXZlbiwKICAgIGZhbWlseSA9IGZhbWlseSwKICAgIHJvbGUgPSByb2xlLAogICAgZW1haWwgPSBlbWFpbCwKICAgIGNvbW1lbnQgPSBjb21tZW50CiAgKQp9CiMgVmFsaWRhdG9yIHRvIGVuc3VyZSB0aGF0IGVhY2ggc2xvdCBpcyBvZiBsZW5ndGggb25lCnNldFZhbGlkaXR5KCJQZXJzb24iLCBmdW5jdGlvbihvYmplY3QpIHsgIyBub2xpbnQ6IGN5Y2xvY29tcF9saW50ZXIuCiAgaW52YWxpZHMgPC0gY2hhcmFjdGVyKDApCiAgaWYgKGxlbmd0aChvYmplY3RAYWdlKSAhPSAxIHx8CiAgICBsZW5ndGgob2JqZWN0QGdpdmVuKSAhPSAxIHx8CiAgICBsZW5ndGgob2JqZWN0QGZhbWlseSkgIT0gMSB8fAogICAgbGVuZ3RoKG9iamVjdEBlbWFpbCkgIT0gMSB8fAogICAgbGVuZ3RoKG9iamVjdEBjb21tZW50KSAhPSAxKSB7CiAgICBpbnZhbGlkcyA8LSBwYXN0ZTAoCiAgICAgICJAbmFtZSwgQGFnZSwgQGdpdmVuLCBAZmFtaWx5LCBAZW1haWwsICIsCiAgICAgICJAY29tbWVudCBtdXN0IGJlIG9mIGxlbmd0aCAxIgogICAgKQogIH0KCiAga25vd25fcm9sZXMgPC0gYygKICAgIE5BX2NoYXJhY3Rlcl8sICJhdXQiLCAiY29tIiwgImNwaCIsICJjcmUiLCAiY3RiIiwKICAgICJjdHIiLCAiZHRjIiwgImZuZCIsICJyZXYiLCAidGhzIiwgInRybCIKICApCgogIGlmICghYWxsKG9iamVjdEByb2xlICVpbiUga25vd25fcm9sZXMpKSB7CiAgICBwYXN0ZSgKICAgICAgIkByb2xlKHMpIG11c3QgYmUgb25lIG9mIiwKICAgICAgcGFzdGUoa25vd25fcm9sZXMsIGNvbGxhcHNlID0gIiwgIikgIyBub2xpbnQ6IHBhc3RlX2xpbnRlci4KICAgICkKICB9CgogIGlmIChsZW5ndGgoaW52YWxpZHMpKSB7CiAgICByZXR1cm4oaW52YWxpZHMpCiAgfQogIFRSVUUKfSkgfD4KICBpbnZpc2libGUoKQpgYGAKCk5vdGVzOiB3aGlsZSBJIG1pc3NlZCBpbmNsdWRpbmcgYGFnZWAsIG91ciBpbXBsZW1lbnRhdGlvbnMgYXJlIHNpbWlsYXIgZXhjZXB0IGZvciB2YWxpZGF0aW9ucy4KCi0tLQoKMi4gIFdoYXQgaGFwcGVucyBpZiB5b3UgZGVmaW5lIGEgbmV3IFM0IGNsYXNzIHRoYXQgZG9lc24ndCBoYXZlIGFueSBzbG90cz8KICAgIChIaW50OiByZWFkIGFib3V0IHZpcnR1YWwgY2xhc3NlcyBpbiBgP3NldENsYXNzYC4pCgpBbnN3ZXI6IGRlZmluaW5nIGEgbmV3IGNsYXNzIHdpdGggbm8gc2xvdHMgbWFrZXMgaXQgYSB2aXJ0dWFsIGNsYXNzLCB3aGljaCBjYW4ndCBiZSB1c2VkIHRvIGNyZWF0ZSBuZXcgb2JqZWN0cywgYnV0IGNhbiBiZSB1c2VkIHRvIGRlZmluZSBhIGNsYXNzIHVuaW9uLgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBUT0RPOiBldmFsID0gRkFMU0Ugc2V0IHRvIGFsbG93IHJlbmRlcmluZyB1c2luZyBidWlsZF9hbmFseXNpc19zaXRlKCkKc2V0Q2xhc3MoIlZpcnR1YWwiKQp0cnkobmV3KCJWaXJ0dWFsIikpCnNldENsYXNzVW5pb24oIlZpcnR1YWwiLCAiUGVyc29uIikKZ2V0Q2xhc3MoIlZpcnR1YWwiKQpgYGAKCkFSIFNvbHV0aW9uczogSXQgZGVwZW5kcyBvbiB0aGUgb3RoZXIgYXJndW1lbnRzLiBJZiB3ZSBpbmhlcml0IGZyb20gYW5vdGhlciBjbGFzcywgd2UgZ2V0IHRoZSBzYW1lIHNsb3RzLiBCdXQgc29tZXRoaW5nIGludGVyZXN0aW5nIGhhcHBlbnMgaWYgd2UgZG9uJ3QgaW5oZXJpdCBmcm9tIGFuIGV4aXN0aW5nIGNsYXNzLiBXZSBnZXQgYSB2aXJ0dWFsIGNsYXNzLiBBIHZpcnR1YWwgY2xhc3MgY2FuJ3QgYmUgaW5zdGFudGlhdGVkOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBUT0RPOiBldmFsID0gRkFMU0Ugc2V0IHRvIGFsbG93IHJlbmRlcmluZyB1c2luZyBidWlsZF9hbmFseXNpc19zaXRlKCkKc2V0Q2xhc3MoIkh1bWFuIikKdHJ5KG5ldygiSHVtYW4iKSkKYGBgCgpCdXQgY2FuIGJlIGluaGVyaXRlZCBmcm9tOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBUT0RPOiBldmFsID0gRkFMU0Ugc2V0IHRvIGFsbG93IHJlbmRlcmluZyB1c2luZyBidWlsZF9hbmFseXNpc19zaXRlKCkKc2V0Q2xhc3MoIlByb2dyYW1tZXIiLCBjb250YWlucyA9ICJIdW1hbiIpCmBgYAoKLS0tCgozLiAgSW1hZ2luZSB5b3Ugd2VyZSBnb2luZyB0byByZWltcGxlbWVudCBmYWN0b3JzLCBkYXRlcywgYW5kIGRhdGEgZnJhbWVzIGluIAogICAgUzQuIFNrZXRjaCBvdXQgdGhlIGBzZXRDbGFzcygpYCBjYWxscyB0aGF0IHlvdSB3b3VsZCB1c2UgdG8gZGVmaW5lIHRoZSAKICAgIGNsYXNzZXMuIFRoaW5rIGFib3V0IGFwcHJvcHJpYXRlIGBzbG90c2AgYW5kIGBwcm90b3R5cGVgLgoKQW5zd2VyOiBza2V0Y2ggYmVsb3cuIERlZmF1bHQgdmFsdWVzIHdvdWxkIGJlIHNldCBpbiBgaW5pdGlhbGl6ZSgpYC4KCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCnNldENsYXNzKCJGYWN0b3IiLAogIHNsb3RzID0gbGlzdCgKICAgIHggPSAiY2hhcmFjdGVyIiwKICAgIGxldmVscyA9ICJjaGFyYWN0ZXIiLAogICAgbGFiZWxzID0gImNoYXJhY3RlciIsCiAgICBleGNsdWRlID0gImNoYXJhY3RlciIsCiAgICBvcmRlcmVkID0gImxvZ2ljYWwiLAogICAgbm1heCA9ICJpbnRlZ2VyIgogICksCiAgcHJvdG90eXBlID0gbGlzdCgKICAgIHggPSBjaGFyYWN0ZXIoMCksCiAgICBsZXZlbHMgPSBjaGFyYWN0ZXIoMCksCiAgICBsYWJlbHMgPSBjaGFyYWN0ZXIoMCksCiAgICBleGNsdWRlID0gTkFfY2hhcmFjdGVyXywKICAgIG9yZGVyZWQgPSBGQUxTRSwKICAgIG5tYXggPSBOQV9pbnRlZ2VyXwogICkKKQoKc2V0Q2xhc3MoIlM0RGF0ZSIsCiAgc2xvdHMgPSBsaXN0KAogICAgZGF5cyA9ICJpbnRlZ2VyIgogICksCiAgcHJvdG90eXBlID0gbGlzdCgKICAgIGRheXMgPSAwTAogICkKKQoKc2V0Q2xhc3MoIkRhdGFGcmFtZSIsCiAgc2xvdHMgPSBsaXN0KAogICAgZGF0YSA9ICJtYXRyaXgiLAogICAgY29sX25hbWVzID0gImNoYXJhY3RlciIsCiAgICByb3dfbmFtZXMgPSAiY2hhcmFjdGVyIgogICksCiAgcHJvdG90eXBlID0gbGlzdCgKICAgIGRhdGEgPSBtYXRyaXgobnJvdyA9IDAsIG5jb2wgPSAwKSwKICAgIGNvbF9uYW1lcyA9IE5VTEwsCiAgICByb3dfbmFtZXMgPSBOVUxMCiAgKQopCmBgYAoKQVIgU29sdXRpb25zOiBGb3IgYWxsIHRoZXNlIGNsYXNzZXMgd2UgbmVlZCBvbmUgc2xvdCBmb3IgdGhlIGRhdGEgYW5kIG9uZSBzbG90IHBlciBhdHRyaWJ1dGUuIEtlZXAgaW4gbWluZCwgdGhhdCBpbmhlcml0YW5jZSBtYXR0ZXJzIGZvciBvcmRlcmVkIGZhY3RvcnMgYW5kIGRhdGVzLiBGb3IgZGF0YSBmcmFtZXMsIHNwZWNpYWwgY2hlY2tzIGxpa2UgZXF1YWwgbGVuZ3RocyBvZiB0aGUgdW5kZXJseWluZyBsaXN0J3MgZWxlbWVudHMgc2hvdWxkIGJlIGRvbmUgd2l0aGluIGEgdmFsaWRhdG9yLgoKRm9yIHNpbXBsaWNpdHkgd2UgZG9uJ3QgaW50cm9kdWNlIGFuIGV4cGxpY2l0IHN1YmNsYXNzIGZvciBvcmRlcmVkIGZhY3RvcnMuIEluc3RlYWQsIHdlIGludHJvZHVjZSBgb3JkZXJlZGAgYXMgYSBzbG90LgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBUT0RPOiBldmFsID0gRkFMU0Ugc2V0IHRvIGFsbG93IHJlbmRlcmluZyB1c2luZyBidWlsZF9hbmFseXNpc19zaXRlKCkKc2V0Q2xhc3MoIkZhY3RvciIsCiAgc2xvdHMgPSBjKAogICAgZGF0YSA9ICJpbnRlZ2VyIiwKICAgIGxldmVscyA9ICJjaGFyYWN0ZXIiLAogICAgb3JkZXJlZCA9ICJsb2dpY2FsIgogICksCiAgcHJvdG90eXBlID0gbGlzdCgKICAgIGRhdGEgPSBpbnRlZ2VyKCksCiAgICBsZXZlbHMgPSBjaGFyYWN0ZXIoKSwKICAgIG9yZGVyZWQgPSBGQUxTRQogICkKKQpuZXcoIkZhY3RvciIsIGRhdGEgPSBjKDFMLCAyTCksIGxldmVscyA9IGxldHRlcnNbMTozXSkKYGBgCgpUaGUgYERhdGUyYCBjbGFzcyBzdG9yZXMgaXRzIGRhdGVzIGFzIGludGVnZXJzLCBzaW1pbGFybHkgdG8gYmFzZSBSIHdoaWNoIHVzZXMgZG91Ymxlcy4gRGF0ZXMgZG9uJ3QgaGF2ZSBhbnkgb3RoZXIgYXR0cmlidXRlcy4KCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCnNldENsYXNzKCJEYXRlMiIsCiAgc2xvdHMgPSBsaXN0KAogICAgZGF0YSA9ICJpbnRlZ2VyIgogICksCiAgcHJvdG90eXBlID0gbGlzdCgKICAgIGRhdGEgPSBpbnRlZ2VyKCkKICApCikKCm5ldygiRGF0ZTIiLCBkYXRhID0gMUwpCmBgYAoKT3VyIGBEYXRhRnJhbWVgIGNsYXNzIGNvbnNpc3RzIG9mIGEgbGlzdCBhbmQgYSBzbG90IGZvciBgcm93Lm5hbWVzYC4gTW9zdCBvZiB0aGUgbG9naWMgKGUuZy4gY2hlY2tpbmcgdGhhdCBhbGwgZWxlbWVudHMgb2YgdGhlIGxpc3QgYXJlIGEgdmVjdG9yLCBhbmQgdGhhdCB0aGV5IGFsbCBoYXZlIHRoZSBzYW1lIGxlbmd0aCkgd291bGQgbmVlZCB0byBiZSBwYXJ0IG9mIGEgdmFsaWRhdG9yLgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBUT0RPOiBldmFsID0gRkFMU0Ugc2V0IHRvIGFsbG93IHJlbmRlcmluZyB1c2luZyBidWlsZF9hbmFseXNpc19zaXRlKCkKc2V0Q2xhc3MoIkRhdGFGcmFtZSIsCiAgc2xvdHMgPSBjKAogICAgZGF0YSA9ICJsaXN0IiwKICAgIHJvdy5uYW1lcyA9ICJjaGFyYWN0ZXIiCiAgKSwKICBwcm90b3R5cGUgPSBsaXN0KAogICAgZGF0YSA9IGxpc3QoKSwKICAgIHJvdy5uYW1lcyA9IGNoYXJhY3RlcigwKQogICkKKQoKbmV3KCJEYXRhRnJhbWUiLCBkYXRhID0gbGlzdChhID0gMSwgYiA9IDIpKQpgYGAKCk5vdGVzOgoKLSBBIGtleSBpbnNpZ2h0IGZyb20gQVIgU29sdXRpb25zIGlzIHRoYXQgdGhlIG9iamVjdHMgbmVlZCBvbmUgc2xvdCBmb3IgZGF0YSBhbmQgb25lIGZvciBlYWNoCiAgYXR0cmlidXRlCi0gTXkgaW1wbGVtZW50YXRpb24gb2YgYEZhY3RvcmAgaXMgd3JvbmcsIHdoZXJlIHRoZSBBUiBTb2x1dGlvbnMgYW5zd2VyIGlzIGNsZWFybHkgcmlnaHQKLSBUaGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBuZXcgYERhdGVgIG9iamVjdCBhcmUgc2ltaWxhcjsgdGhlIHByb3RvdHlwZSBmb3IgQVIgU29sdXRpb25zIGlzCiAgYmV0dGVyCi0gVGhlIEFSIFNvbHV0aW9ucyBgRGF0YUZyYW1lYCBvbWl0cyBjb2x1bW4gbmFtZXMgKG5hbWVzKSwgd2hlcmUgbWluZSBkb2VzIG5vdDsgdXNpbmcgYSBsaXN0IGZvciB0aGUKICBkYXRhIGluIGBEYXRhRnJhbWVgIGlzIGEgYmV0dGVyIGNob2ljZSwgYnV0IGhhcmRlciB0byBpbXBsZW1lbnQKCmBgYHtyfQphdHRyaWJ1dGVzKGRhdGEuZnJhbWUoKSkKYGBgCgotLS0KCiMjIDE1LjQuNSBFeGVyY2lzZXMKCjEuICBBZGQgYGFnZSgpYCBhY2Nlc3NvcnMgZm9yIHRoZSBgUGVyc29uYCBjbGFzcy4KCkFuc3dlcjogdGhlIGNvZGUgYmVsb3cgYWRkcyBhZ2UgYWNjZXNzb3JzIHRvIEFkdmFuY2VkIFIgYFBlcnNvbmAuCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQojIFRPRE86IGV2YWwgPSBGQUxTRSBzZXQgdG8gYWxsb3cgcmVuZGVyaW5nIHVzaW5nIGJ1aWxkX2FuYWx5c2lzX3NpdGUoKQpzZXRDbGFzcygiUGVyc29uIiwKICBzbG90cyA9IGMoCiAgICBuYW1lID0gImNoYXJhY3RlciIsCiAgICBhZ2UgPSAibnVtZXJpYyIKICApLAogIHByb3RvdHlwZSA9IGxpc3QoCiAgICBuYW1lID0gTkFfY2hhcmFjdGVyXywKICAgIGFnZSA9IE5BX3JlYWxfCiAgKQopCgpqb2huIDwtIG5ldygiUGVyc29uIiwgbmFtZSA9ICJKb2huIFNtaXRoIikKCnNldEdlbmVyaWMoImFnZSIsIGZ1bmN0aW9uKHgpIHN0YW5kYXJkR2VuZXJpYygiYWdlIikpIHw+CiAgaW52aXNpYmxlKCkKc2V0TWV0aG9kKCJhZ2UiLCAiUGVyc29uIiwgZnVuY3Rpb24oeCkgeEBhZ2UpCgphZ2Uoam9obikKCnNldEdlbmVyaWMoImFnZTwtIiwgZnVuY3Rpb24oeCwgdmFsdWUpIHN0YW5kYXJkR2VuZXJpYygiYWdlPC0iKSkgfD4KICBpbnZpc2libGUoKQpzZXRNZXRob2QoImFnZTwtIiwgIlBlcnNvbiIsIGZ1bmN0aW9uKHgsIHZhbHVlKSB7CiAgeEBhZ2UgPC0gdmFsdWUKICB2YWxpZE9iamVjdCh4KQogIHgKfSkKCmFnZShqb2huKSA8LSA1MQphZ2Uoam9obikKYGBgCgpBUiBTb2x1dGlvbnM6IFdlIGltcGxlbWVudCB0aGUgYWNjZXNzb3JzIHZpYSBhbiBgYWdlKClgIGdlbmVyaWMsIHdpdGggYSBtZXRob2QgZm9yIHRoZSBgUGVyc29uYCBjbGFzcyBhbmQgYSBjb3JyZXNwb25kaW5nIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGBhZ2U8LWA6CgpgYGB7ciwgZXZhbCA9IEZBTFNFfQojIFRPRE86IGV2YWwgPSBGQUxTRSBzZXQgdG8gYWxsb3cgcmVuZGVyaW5nIHVzaW5nIGJ1aWxkX2FuYWx5c2lzX3NpdGUoKQpzZXRHZW5lcmljKCJhZ2UiLCBmdW5jdGlvbih4KSBzdGFuZGFyZEdlbmVyaWMoImFnZSIpKQpzZXRNZXRob2QoImFnZSIsICJQZXJzb24iLCBmdW5jdGlvbih4KSB4QGFnZSkKCnNldEdlbmVyaWMoImFnZTwtIiwgZnVuY3Rpb24oeCwgdmFsdWUpIHN0YW5kYXJkR2VuZXJpYygiYWdlPC0iKSkKc2V0TWV0aG9kKCJhZ2U8LSIsICJQZXJzb24iLCBmdW5jdGlvbih4LCB2YWx1ZSkgewogIHhAYWdlIDwtIHZhbHVlCiAgdmFsaWRPYmplY3QoeCkKICB4Cn0pCmBgYAoKLS0tCgoyLiAgSW4gdGhlIGRlZmluaXRpb24gb2YgdGhlIGdlbmVyaWMsIHdoeSBpcyBpdCBuZWNlc3NhcnkgdG8gcmVwZWF0IHRoZQogICAgbmFtZSBvZiB0aGUgZ2VuZXJpYyB0d2ljZT8KCkFuc3dlcjogYWNjb3JkaW5nIHRvIHRoZSBSIGRvY3MsIGBzZXRHZW5lcmljKG5hbWUpYCBzcGVjaWZpZXMgYW4gZXhpc3RpbmcgZnVuY3Rpb24uIFdoZW4gY3JlYXRpbmcgYSBuZXcgZ2VuZXJpYywgdGhlIGZvcm0gYHNldEdlbmVyaWMobmFtZSwgZGVmKWAgaXMgdXNlZCwgd2hlcmUgYGRlZmAgaXMgYHN0YW5kYXJkR2VuZXJpYyhuYW1lKWAuCgpBUiBTb2x1dGlvbnM6IFdpdGhpbiBgc2V0R2VuZXJpYygpYCB0aGUgYG5hbWVgICgxc3QgYXJndW1lbnQpIGlzIG5lZWRlZCBhcyB0aGUgbmFtZSBvZiB0aGUgZ2VuZXJpYy4gVGhlbiwgdGhlIG5hbWUgYWxzbyBleHBsaWNpdGx5IGluY29ycG9yYXRlcyBtZXRob2QgZGlzcGF0Y2ggdmlhIGBzdGFuZGFyZEdlbmVyaWMoKWAgd2l0aGluIHRoZSBnZW5lcmljJ3MgYm9keSAoYGRlZmAgcGFyYW1ldGVyIG9mIGBzZXRHZW5lcmljKClgKS4gVGhpcyBiZWhhdmlvdXIgaXMgc2ltaWxhciB0byBgVXNlTWV0aG9kKClgIGluIFMzLgoKLS0tCgozLiAgV2h5IGRvZXMgdGhlIGBzaG93KClgIG1ldGhvZCBkZWZpbmVkIGluIFNlY3Rpb24gMTUuNC4zIHVzZQogICAgYGlzKG9iamVjdClbWzFdXWA/IChIaW50OiB0cnkgcHJpbnRpbmcgdGhlIGVtcGxveWVlIHN1YmNsYXNzLikKCkFuc3dlcjogYGlzKG9iamVjdClgIHJldHVybnMgYSB2ZWN0b3IgZm9yIGEgc3ViY2xhc3MsIHdpdGggdGhlIGN1cnJlbnQgY2xhc3MgZmlyc3QuCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQojIFRPRE86IGV2YWwgPSBGQUxTRSBzZXQgdG8gYWxsb3cgcmVuZGVyaW5nIHVzaW5nIGJ1aWxkX2FuYWx5c2lzX3NpdGUoKQpzZXRDbGFzcygiRW1wbG95ZWUiLAogIGNvbnRhaW5zID0gIlBlcnNvbiIsCiAgc2xvdHMgPSBjKAogICAgYm9zcyA9ICJQZXJzb24iCiAgKSwKICBwcm90b3R5cGUgPSBsaXN0KAogICAgYm9zcyA9IG5ldygiUGVyc29uIikKICApCikKCnNldE1ldGhvZCgic2hvdyIsICJQZXJzb24iLCBmdW5jdGlvbihvYmplY3QpIHsKICBjYXQoaXMob2JqZWN0KVtbMV1dLCAiXG4iLAogICAgIiAgTmFtZTogIiwgb2JqZWN0QG5hbWUsICJcbiIsCiAgICAiICBBZ2U6ICAiLCBvYmplY3RAYWdlLCAiXG4iLAogICAgc2VwID0gIiIKICApCn0pCgpqb2huCmphbmUgPC0gbmV3KCJFbXBsb3llZSIsIG5hbWUgPSAiSmFuZSBEb2UiKQppcyhqYW5lKQpqYW5lCmBgYAoKQVIgU29sdXRpb25zOiBgaXMob2JqZWN0KWAgcmV0dXJucyB0aGUgY2xhc3Mgb2YgdGhlIG9iamVjdC4gYGlzKG9iamVjdClgIGFsc28gY29udGFpbnMgdGhlIHN1cGVyY2xhc3MsIGZvciBzdWJjbGFzc2VzIGxpa2UgYEVtcGxveWVlYC4gSW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiB0aGUgbW9zdCBzcGVjaWZpYyBjbGFzcyAodGhlIHN1YmNsYXNzKSwgYHNob3coKWAgcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgaXMob2JqZWN0KWAuCgotLS0KCjQuICBXaGF0IGhhcHBlbnMgaWYgeW91IGRlZmluZSBhIG1ldGhvZCB3aXRoIGRpZmZlcmVudCBhcmd1bWVudCBuYW1lcyB0bwogICAgdGhlIGdlbmVyaWM/CgpBbnN3ZXI6IHRoaXMgc2hvdWxkIGNhdXNlIG1ldGhvZCBkaXNwYXRjaCB0byBmYWlsLCBidXQgSSBkb24ndCBrbm93IG9mIGEgd2F5IHRvIHRlc3QuCgpBUiBTb2x1dGlvbnM6IEl0IGRlcGVuZHMuIFdlIGZpcnN0IGNyZWF0ZSB0aGUgb2JqZWN0IGBoYWRsZXlgIG9mIGNsYXNzIGBQZXJzb25gOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBUT0RPOiBldmFsID0gRkFMU0Ugc2V0IHRvIGFsbG93IHJlbmRlcmluZyB1c2luZyBidWlsZF9hbmFseXNpc19zaXRlKCkKLlBlcnNvbiA8LSBzZXRDbGFzcyggIyBub2xpbnQ6IG9iamVjdF9uYW1lX2xpbnRlci4KICAiUGVyc29uIiwKICBzbG90cyA9IGMobmFtZSA9ICJjaGFyYWN0ZXIiLCBhZ2UgPSAibnVtZXJpYyIpCikKaGFkbGV5IDwtIC5QZXJzb24obmFtZSA9ICJIYWRsZXkiKQpoYWRsZXkKYGBgCgpOb3cgbGV0J3Mgc2VlIHdoaWNoIGFyZ3VtZW50cyBjYW4gYmUgc3VwcGxpZWQgdG8gdGhlIGBzaG93KClgIGdlbmVyaWMuCgpgYGB7cn0KZm9ybWFscygic2hvdyIpCmBgYAoKVXN1YWxseSwgd2Ugd291bGQgdXNlIHRoaXMgYXJndW1lbnQgd2hlbiBkZWZpbmluZyBhIG5ldyBtZXRob2QuCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQojIFRPRE86IGV2YWwgPSBGQUxTRSBzZXQgdG8gYWxsb3cgcmVuZGVyaW5nIHVzaW5nIGJ1aWxkX2FuYWx5c2lzX3NpdGUoKQpzZXRNZXRob2QoInNob3ciLCAiUGVyc29uIiwgZnVuY3Rpb24ob2JqZWN0KSB7CiAgY2F0KG9iamVjdEBuYW1lLCAiY3JlYXRlcyBoYXJkIGV4ZXJjaXNlcyIpCn0pCgpoYWRsZXkKYGBgCgpXaGVuIHdlIHN1cHBseSBhbm90aGVyIG5hbWUgYXMgYSBmaXJzdCBlbGVtZW50IG9mIG91ciBtZXRob2QgKGUuZy4gYHhgIGluc3RlYWQgb2YgYG9iamVjdGApLCB0aGlzIGVsZW1lbnQgd2lsbCBiZSBtYXRjaGVkIHRvIHRoZSBjb3JyZWN0IGBvYmplY3RgIGFyZ3VtZW50IGFuZCB3ZSByZWNlaXZlIGEgd2FybmluZy4gT3VyIG1ldGhvZCB3aWxsIHdvcmssIHRob3VnaDoKCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCnNldE1ldGhvZCgic2hvdyIsICJQZXJzb24iLCBmdW5jdGlvbih4KSB7CiAgY2F0KHhAbmFtZSwgImNyZWF0ZXMgaGFyZCBleGVyY2lzZXMiKQp9KQoKaGFkbGV5CmBgYAoKSWYgd2UgYWRkIG1vcmUgYXJndW1lbnRzIHRvIG91ciBtZXRob2QgdGhhbiBvdXIgZ2VuZXJpYyBjYW4gaGFuZGxlLCB3ZSB3aWxsIGdldCBhbiBlcnJvci4KCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCnRyeSgKICBzZXRNZXRob2QoInNob3ciLCAiUGVyc29uIiwgZnVuY3Rpb24oeCwgeSkgewogICAgY2F0KHhAbmFtZSwgImlzIiwgeEBhZ2UsICJ5ZWFycyBvbGQiKQogIH0pCikKYGBgCgpJZiB3ZSBkbyB0aGlzIHdpdGggYXJndW1lbnRzIGFkZGVkIHRvIHRoZSBjb3JyZWN0bHkgd3JpdHRlbiBgb2JqZWN0YCBhcmd1bWVudCwgd2Ugd2lsbCByZWNlaXZlIGFuIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UuIEl0IHN0YXRlcyB0aGF0IHdlIGNvdWxkIGFkZCBvdGhlciBhcmd1bWVudCBuYW1lcyBmb3IgZ2VuZXJpY3MsIHdoaWNoIGNhbiB0YWtlIHRoZSBgLi4uYCBhcmd1bWVudC4KCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCnRyeSgKICBzZXRNZXRob2QoInNob3ciLCAiUGVyc29uIiwgZnVuY3Rpb24ob2JqZWN0LCB5KSB7CiAgICBjYXQob2JqZWN0QG5hbWUsICJpcyIsIG9iamVjdEBhZ2UsICJ5ZWFycyBvbGQiKQogIH0pCikKYGBgCgotLS0KCiMjIDE1LjUuNSBFeGVyY2lzZXMKCjEuICBEcmF3IHRoZSBtZXRob2QgZ3JhcGggZm9yIGBmKHN3ZWF0X3NtaWxlLCBraXNzaW5nX2NhdClgCgpBbnN3ZXI6IHNraXBwZWQuCgpBUiBTb2x1dGlvbnM6IExvb2sgYXQgdGhlIGdyYXBoIGFuZCByZXBlYXQgYWZ0ZXIgbWU6ICJJIHdpbGwga2VlcCBteSBjbGFzcyBzdHJ1Y3R1cmUgc2ltcGxlIGFuZCB1c2UgbXVsdGlwbGUgaW5oZXJpdGFuY2Ugc3BhcmluZ2x5Ii4KCi0tLQoKMi4gIERyYXcgdGhlIG1ldGhvZCBncmFwaCBmb3IgYGYoc21pbGV5LCB3aW5rLCBraXNzaW5nX3NtaWxpbmdfZXllcylgCgpBbnN3ZXI6IHNraXBwZWQuCgpBUiBTb2x1dGlvbnM6IFdlIHNlZSB0aGF0IHRoZSBtZXRob2QgZ3JhcGggYmVsb3cgbG9va3Mgc2ltcGxlciB0aGFuIHRoZSBvbmUgYWJvdmUuIFJlbGF0aXZlbHkgc3BlYWtpbmcsIG11bHRpcGxlIGRpc3BhdGNoIHNlZW1zIHRvIGludHJvZHVjZSBsZXNzIGNvbXBsZXhpdHkgdGhhbiBtdWx0aXBsZSBpbmhlcml0YW5jZS4gVXNlIGl0IHdpdGggY2FyZSwgdGhvdWdoIQoKLS0tCgozLiAgVGFrZSB0aGUgbGFzdCBleGFtcGxlIHdoaWNoIHNob3dzIG11bHRpcGxlIGRpc3BhdGNoIG92ZXIgdHdvIGNsYXNzZXMgdGhhdAogICAgdXNlIG11bHRpcGxlIGluaGVyaXRhbmNlLiBXaGF0IGhhcHBlbnMgaWYgeW91IGRlZmluZSBhIG1ldGhvZCBmb3IgYWxsCiAgICB0ZXJtaW5hbCBjbGFzc2VzPyBXaHkgZG9lcyBtZXRob2QgZGlzcGF0Y2ggbm90IHNhdmUgdXMgbXVjaCB3b3JrIGhlcmU/CgpBbnN3ZXI6IHNpbmNlIGFsbCB0ZXJtaW5hbCBub2RlcyBhcmUgZXF1aWRpc3RhbnQgZnJvbSB0aGUgY2xhc3NlcywgdGhlIG1ldGhvZCBpcyBhbWJpZ3VvdXMuIFRoaXMgaXMgdHJ1ZSBhdCB0aGUgZmlyc3QgbGV2ZWwgYXMgd2VsbC4gVGhlIG9ubHkgd2F5IHRvIGF2b2lkIGFtYmlndWl0eSBpcyB0byBhdm9pZCBtZXRob2QgZGlzcGF0Y2ggYWx0b2dldGhlciBhbmQgZGVmaW5lIGEgbWV0aG9kIGF0IHRoZSByb290IG5vZGUuCgpBUiBTb2x1dGlvbnM6IFdlIHdpbGwgaW50cm9kdWNlIGFtYmlndWl0eSwgc2luY2Ugb25lIGNsYXNzIGhhcyBkaXN0YW5jZSAyIHRvIGFsbCB0ZXJtaW5hbCBub2RlcyBhbmQgdGhlIG90aGVyIGZvdXIgaGF2ZSBkaXN0YW5jZSAxIHRvIHR3byB0ZXJtaW5hbCBub2RlcyBlYWNoLiBUbyByZXNvbHZlIHRoaXMgYW1iaWd1aXR5IHdlIGhhdmUgdG8gZGVmaW5lIGZpdmUgbW9yZSBtZXRob2RzLCBvbmUgcGVyIGNsYXNzIGNvbWJpbmF0aW9uLgoKLS0tCgojIyAxNS42LjMgRXhlcmNpc2VzCgoxLiAgV2hhdCB3b3VsZCBhIGZ1bGwgYHNldE9sZENsYXNzKClgIGRlZmluaXRpb24gbG9vayBsaWtlIGZvciBhbiBvcmRlcmVkIAogICAgZmFjdG9yIChpLmUuIGFkZCBgc2xvdHNgIGFuZCBgcHJvdG90eXBlYCB0aGUgZGVmaW5pdGlvbiBhYm92ZSk/CgpBbnN3ZXI6IGJ1aWxkaW5nIG9uIHRoZSBBUiBTb2x1dGlvbnMgZXhhbXBsZSBhbmQgdGhlIGBmYWN0b3JgIGV4YW1wbGUgaW4gMTUuNi4xLCB0aGUgZm9sbG93aW5nIFM0IG9iamVjdCBiZWhhdmVzIGxpa2UgdGhlIGBvcmRlcmVkKClgIHZlcnNpb246CgpgYGB7ciwgZXZhbCA9IEZBTFNFfQojIFRPRE86IGV2YWwgPSBGQUxTRSBzZXQgdG8gYWxsb3cgcmVuZGVyaW5nIHVzaW5nIGJ1aWxkX2FuYWx5c2lzX3NpdGUoKQpzZXRDbGFzcygiT3JkZXJlZCIsCiAgY29udGFpbnMgPSAiaW50ZWdlciIsCiAgc2xvdHMgPSBjKAogICAgbGV2ZWxzID0gImNoYXJhY3RlciIsCiAgICBvcmRlcmVkID0gImxvZ2ljYWwiCiAgKSwKICBwcm90b3R5cGUgPSBzdHJ1Y3R1cmUoCiAgICBpbnRlZ2VyKCksCiAgICBsZXZlbHMgPSBjaGFyYWN0ZXIoKSwKICAgIG9yZGVyZWQgPSBUUlVFCiAgKQopCnNldE9sZENsYXNzKCJvcmRlcmVkIiwgUzRDbGFzcyA9ICJPcmRlcmVkIikKCm8gPC0gbmV3KCJPcmRlcmVkIiwgMTo0LCBsZXZlbHMgPSBsZXR0ZXJzWzE6NF0pCm8Kc3RyKG9yZGVyZWQoYygiYSIsICJiIiwgImMiLCAiZCIpKSkKYGBgCgpBUiBTb2x1dGlvbnM6IFRoZSBwdXJwb3NlIG9mIGBzZXRPbGRDbGFzcygpYCBsaWVzIGluIHJlZ2lzdGVyaW5nIGFuIFMzIGNsYXNzIGFzIGEgImZvcm1hbGx5IGRlZmluZWQgY2xhc3MiLCBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgUzQgb2JqZWN0LW9yaWVudGVkIHByb2dyYW1taW5nIHN5c3RlbS4gV2hlbiB1c2luZyBpdCwgd2UgbWF5IHByb3ZpZGUgdGhlIGFyZ3VtZW50IGBTNENsYXNzYCwgd2hpY2ggd2lsbCBpbmhlcml0IHRoZSBzbG90cyBhbmQgdGhlaXIgZGVmYXVsdCB2YWx1ZXMgKHByb3RvdHlwZSkgdG8gdGhlIHJlZ2lzdGVyZWQgY2xhc3MuCgpMZXQncyBidWlsZCBhbiBTNCBgT3JkZXJlZEZhY3RvcmAgb24gdG9wIG9mIHRoZSBTMyBmYWN0b3IgaW4gc3VjaCBhIHdheS4KCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCnNldE9sZENsYXNzKCJmYWN0b3IiKSAjIHVzZSBidWlsZC1pbiBkZWZpbml0aW9uIGZvciBicmV2aXR5Ck9yZGVyZWRGYWN0b3IgPC0gc2V0Q2xhc3MoICMgbm9saW50OiBvYmplY3RfbmFtZV9saW50ZXIuCiAgIk9yZGVyZWRGYWN0b3IiLAogIGNvbnRhaW5zID0gImZhY3RvciIsICMgaW5oZXJpdCBmcm9tIHJlZ2lzdGVyZWQgUzMgY2xhc3MKICBzbG90cyA9IGMoCiAgICBsZXZlbHMgPSAiY2hhcmFjdGVyIiwKICAgIG9yZGVyZWQgPSAibG9naWNhbCIgIyBhZGQgbG9naWNhbCBvcmRlciBzbG90CiAgKSwKICBwcm90b3R5cGUgPSBzdHJ1Y3R1cmUoCiAgICBpbnRlZ2VyKCksCiAgICBsZXZlbHMgPSBjaGFyYWN0ZXIoKSwKICAgIG9yZGVyZWQgPSBsb2dpY2FsKCkgIyBhZGQgZGVmYXVsdCB2YWx1ZQogICkKKQpgYGAKCldlIGNhbiBub3cgcmVnaXN0ZXIgdGhlIChTMykgb3JkZXJlZC1jbGFzcywgd2hpbGUgcHJvdmlkaW5nIGFuICJTNCB0ZW1wbGF0ZSIuIFdlIGNhbiBhbHNvIHVzZSB0aGUgUzQtY2xhc3MgdG8gY3JlYXRlIG5ldyBvYmplY3QgZGlyZWN0bHkuCgpgYGB7ciwgd2FybmluZyA9IEZBTFNFLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCnNldE9sZENsYXNzKCJvcmRlcmVkIiwgUzRDbGFzcyA9ICJPcmRlcmVkRmFjdG9yIikKeCA8LSBPcmRlcmVkRmFjdG9yKAogIGMoMUwsIDJMLCAyTCksCiAgbGV2ZWxzID0gYygiYSIsICJiIiwgImMiKSwKICBvcmRlcmVkID0gVFJVRQopCnN0cih4KQpgYGAKCk5vdGVzOiB3aGlsZSBteSBjbGFzcyBgT3JkZXJlZGAgbG9va3Mgc2ltaWxhciB0byB0aGUgQVIgU29sdXRpb25zIHZlcnNpb24sIGl0IGRvZXMgbm90IGluY2x1ZGUgdGhlIFMzIGNsYXNzOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KIyBUT0RPOiBldmFsID0gRkFMU0Ugc2V0IHRvIGFsbG93IHJlbmRlcmluZyB1c2luZyBidWlsZF9hbmFseXNpc19zaXRlKCkKc3RyKG8pCmBgYAoKLS0tCgoyLiAgRGVmaW5lIGEgYGxlbmd0aGAgbWV0aG9kIGZvciB0aGUgYFBlcnNvbmAgY2xhc3MuCgpBbnN3ZXI6IHNpbmNlIGBQZXJzb25gIGlzIGEgdmVjdG9yIGNsYXNzLCBpdHMgbGVuZ3RoIGlzIHRoZSBgbGVuZ3RoKClgIG9mIGFueSBvZiBpdHMgZmllbGRzICh3ZSB1c2UgUGVyc29uMiBoZXJlIGR1ZSB0byBwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIHRoZSBhbHJlYWR5IGRlZmluZWQgUGVyc29uIGNsYXNzKToKCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCnNldENsYXNzKCJQZXJzb24yIiwKICBzbG90cyA9IGMoCiAgICBuYW1lID0gImNoYXJhY3RlciIsCiAgICBhZ2UgPSAibnVtZXJpYyIKICApLAogIHByb3RvdHlwZSA9IGxpc3QoCiAgICBuYW1lID0gTkFfY2hhcmFjdGVyXywKICAgIGFnZSA9IE5BX3JlYWxfCiAgKQopCgpzZXRHZW5lcmljKCJsZW5ndGgiKSB8PgogIGludmlzaWJsZSgpCnNldE1ldGhvZCgibGVuZ3RoIiwgIlBlcnNvbjIiLCBmdW5jdGlvbih4KSBsZW5ndGgoeEBuYW1lKSkKCnBlb3BsZSA8LSBuZXcoIlBlcnNvbjIiLCBuYW1lID0gYygiSm9obiBTbWl0aCIsICJKYW5lIERvZSIpLCBhZ2UgPSBjKE5BX3JlYWxfLCBOQV9yZWFsXykpCnBlb3BsZQpsZW5ndGgocGVvcGxlKQpgYGAKCkFSIFNvbHV0aW9uczogV2Uga2VlcCB0aGluZ3Mgc2ltcGxlIGFuZCB3aWxsIGp1c3QgcmV0dXJuIGAiMTgwY20iYCB3aGVuIHRoZSBgbGVuZ3RoKClgIG1ldGhvZCBpcyBjYWxsZWQgb24gYSBgUGVyc29uYCBvYmplY3QuIFRoZSBtZXRob2QgY2FuIGJlIGRlZmluZWQgZWl0aGVyIGFzIGFuIFMzIG9yIFM0IG1ldGhvZC4KCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgVE9ETzogZXZhbCA9IEZBTFNFIHNldCB0byBhbGxvdyByZW5kZXJpbmcgdXNpbmcgYnVpbGRfYW5hbHlzaXNfc2l0ZSgpCmxlbmd0aC5QZXJzb24gPC0gZnVuY3Rpb24oeCkgIjE4MGNtIiAjIFMzCnNldE1ldGhvZCgibGVuZ3RoIiwgIlBlcnNvbiIsIGZ1bmN0aW9uKHgpICIxODBjbSIpICMgUzQKYGBgCgotLS0KCiMgMTYgVHJhZGUtb2ZmcwoKWW91IG5vdyBrbm93IGFib3V0IHRoZSB0aHJlZSBtb3N0IGltcG9ydGFudCBPT1AgdG9vbGtpdHMgYXZhaWxhYmxlIGluIFIuIE5vdyB0aGF0IHlvdSB1bmRlcnN0YW5kIHRoZWlyIGJhc2ljIG9wZXJhdGlvbiBhbmQgdGhlIHByaW5jaXBsZXMgdGhhdCB1bmRlcmxpZSB0aGVtLCB3ZSBjYW4gc3RhcnQgdG8gY29tcGFyZSBhbmQgY29udHJhc3QgdGhlIHN5c3RlbXMgaW4gb3JkZXIgdG8gdW5kZXJzdGFuZCB0aGVpciBzdHJlbmd0aHMgYW5kIHdlYWtuZXNzZXMuIFRoaXMgd2lsbCBoZWxwIHlvdSBwaWNrIHRoZSBzeXN0ZW0gdGhhdCBpcyBtb3N0IGxpa2VseSB0byBzb2x2ZSBuZXcgcHJvYmxlbXMuCgpPdmVyYWxsLCB3aGVuIHBpY2tpbmcgYW4gT08gc3lzdGVtLCBJIHJlY29tbWVuZCB0aGF0IHlvdSBkZWZhdWx0IHRvIFMzLiBTMyBpcyBzaW1wbGUsIGFuZCB3aWRlbHkgdXNlZCB0aHJvdWdob3V0IGJhc2UgUiBhbmQgQ1JBTi4gV2hpbGUgaXQncyBmYXIgZnJvbSBwZXJmZWN0LCBpdHMgaWRpb3N5bmNyYXNpZXMgYXJlIHdlbGwgdW5kZXJzdG9vZCBhbmQgdGhlcmUgYXJlIGtub3duIGFwcHJvYWNoZXMgdG8gb3ZlcmNvbWUgbW9zdCBzaG9ydGNvbWluZ3MuIElmIHlvdSBoYXZlIGFuIGV4aXN0aW5nIGJhY2tncm91bmQgaW4gcHJvZ3JhbW1pbmcgeW91IGFyZSBsaWtlbHkgdG8gbGVhbiB0b3dhcmRzIFI2LCBiZWNhdXNlIGl0IHdpbGwgZmVlbCBmYW1pbGlhci4gSSB0aGluayB5b3Ugc2hvdWxkIHJlc2lzdCB0aGlzIHRlbmRlbmN5IGZvciB0d28gcmVhc29ucy4gRmlyc3RseSwgaWYgeW91IHVzZSBSNiBpdCdzIHZlcnkgZWFzeSB0byBjcmVhdGUgYSBub24taWRpb21hdGljIEFQSSB0aGF0IHdpbGwgZmVlbCB2ZXJ5IG9kZCB0byBuYXRpdmUgUiB1c2VycywgYW5kIHdpbGwgaGF2ZSBzdXJwcmlzaW5nIHBhaW4gcG9pbnRzIGJlY2F1c2Ugb2YgdGhlIHJlZmVyZW5jZSBzZW1hbnRpY3MuIFNlY29uZGx5LCBpZiB5b3Ugc3RpY2sgdG8gUjYsIHlvdSdsbCBsb3NlIG91dCBvbiBsZWFybmluZyBhIG5ldyB3YXkgb2YgdGhpbmtpbmcgYWJvdXQgT09QIHRoYXQgZ2l2ZXMgeW91IGEgbmV3IHNldCBvZiB0b29scyBmb3Igc29sdmluZyBwcm9ibGVtcy4K</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("advanced-r-3.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
