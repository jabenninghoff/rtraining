<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2022-07-31" />

<title>Advanced R Workbook (Functional programming)</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link href="site_libs/bootstrap-5.1.3/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-5.1.3/bootstrap.bundle.min.js"></script>
<script src="site_libs/bs3compat-0.4.0/transition.js"></script>
<script src="site_libs/bs3compat-0.4.0/tabs.js"></script>
<script src="site_libs/bs3compat-0.4.0/bs3compat.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">rtraining notebooks</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="reference/index.html">Reference</a>
</li>
<li>
  <a href="news/index.html">Changelog</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="FaultTree.html">FaultTree.widget Test</a>
    </li>
    <li>
      <a href="advanced-r-1.html">Advanced R Workbook (Foundations)</a>
    </li>
    <li>
      <a href="advanced-r-2.html">Advanced R Workbook (Functional programming)</a>
    </li>
    <li>
      <a href="r-setup-log.html">R Setup Log</a>
    </li>
    <li>
      <a href="r-training-log.html">R Training Log</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/jabenninghoff/rtraining/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Advanced R Workbook (Functional
programming)</h1>
<h4 class="date">2022-07-31</h4>

</div>


<p>Workbook for completing quizzes and exercises from the “Functional
programming” chapters of <a
href="https://adv-r.hadley.nz/index.html">Advanced R</a>, second
edition, with comparisons to solutions from <a
href="https://advanced-r-solutions.rbind.io">Advanced R
Solutions</a>.</p>
<pre class="r"><code>library(purrr)
library(palmerpenguins) # nolint: unused_import_linter. Imported for `penguins` tibble.
library(ggplot2)
library(scales)
library(rlang)

# from https://github.com/hadley/adv-r/blob/master/common.R
knitr::opts_chunk$set(
  comment = &quot;#&gt;&quot;,
  fig.align = &quot;center&quot;
)

knitr::knit_hooks$set(
  small_mar = function(before, options, envir) {
    if (before) {
      par(mar = c(4.1, 4.1, 0.5, 0.5)) # nolint: undesirable_function_linter.
    }
  }
)</code></pre>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This workbook includes answers and solutions to the quizzes and
exercises from <a href="https://adv-r.hadley.nz/index.html">Advanced
R</a> and <a href="https://advanced-r-solutions.rbind.io">Advanced R
Solutions</a>, organized by chapter. It includes excerpts from both
books, copied here.</p>
<p><strong>WARNING, SPOILERS!</strong> If you haven’t read Advanced R
and intend to complete the quizzes and exercises, don’t read this
notebook. It contains my (potentially wrong) answers to both.</p>
</div>
<div id="functionals" class="section level1">
<h1>9 Functionals</h1>
<blockquote>
<p>To become significantly more reliable, code must become more
transparent. In particular, nested conditions and loops must be viewed
with great suspicion. Complicated control flows confuse programmers.
Messy code often hides bugs.</p>
<p>— Bjarne Stroustrup</p>
</blockquote>
<p>A <strong>functional</strong> is a function that takes a function as
an input and returns a vector as output. Here’s a simple functional: it
calls the function provided as input with 1000 random uniform
numbers.</p>
<pre class="r"><code>randomise &lt;- function(f) f(runif(1e3))
randomise(mean)</code></pre>
<pre><code>#&gt; [1] 0.5061972</code></pre>
<pre class="r"><code>randomise(mean)</code></pre>
<pre><code>#&gt; [1] 0.4919023</code></pre>
<pre class="r"><code>randomise(sum)</code></pre>
<pre><code>#&gt; [1] 512.254</code></pre>
<p>The chances are that you’ve already used a functional. You might have
used for-loop replacements like base R’s <code>lapply()</code>,
<code>apply()</code>, and <code>tapply()</code>; or purrr’s
<code>map()</code>; or maybe you’ve used a mathematical functional like
<code>integrate()</code> or <code>optim()</code>.</p>
<p>A common use of functionals is as an alternative to for loops. For
loops have a bad rap in R because many people believe they are slow<a
href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, but the
real downside of for loops is that they’re very flexible: a loop conveys
that you’re iterating, but not what should be done with the results.
Just as it’s better to use <code>while</code> than <code>repeat</code>,
and it’s better to use <code>for</code> than <code>while</code> (Section
5.3.2), it’s better to use a functional than <code>for</code>. Each
functional is tailored for a specific task, so when you recognise the
functional you immediately know why it’s being used.</p>
<p>If you’re an experienced for loop user, switching to functionals is
typically a pattern matching exercise. You look at the for loop and find
a functional that matches the basic form. If one doesn’t exist, don’t
try and torture an existing functional to fit the form you need.
Instead, just leave it as a for loop! (Or once you’ve repeated the same
loop two or more times, maybe think about writing your own
functional).</p>
<div id="exercises" class="section level2">
<h2>9.2.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Use <code>as_mapper()</code> to explore how purrr generates
anonymous functions for the integer, character, and list helpers. What
helper allows you to extract attributes? Read the documentation to find
out.</li>
</ol>
<pre class="r"><code>map_dbl</code></pre>
<pre><code>#&gt; function (.x, .f, ...) 
#&gt; {
#&gt;     .f &lt;- as_mapper(.f, ...)
#&gt;     .Call(map_impl, environment(), &quot;.x&quot;, &quot;.f&quot;, &quot;double&quot;)
#&gt; }
#&gt; &lt;bytecode: 0x7fec78c97e78&gt;
#&gt; &lt;environment: namespace:purrr&gt;</code></pre>
<pre class="r"><code>map_dbl(mtcars, ~ length(unique(.x)))</code></pre>
<pre><code>#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
#&gt;   25    3   27   22   22   29   30    2    2    3    6</code></pre>
<pre class="r"><code>as_mapper(~ length(unique(.x)))</code></pre>
<pre><code>#&gt; &lt;lambda&gt;
#&gt; function (..., .x = ..1, .y = ..2, . = ..1) 
#&gt; length(unique(.x))
#&gt; &lt;environment: 0x7fec5e9f6390&gt;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;rlang_lambda_function&quot; &quot;function&quot;</code></pre>
<pre class="r"><code>function(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))</code></pre>
<pre><code>#&gt; function(..., .x = ..1, .y = ..2, . = ..1) length(unique(.x))
#&gt; &lt;environment: 0x7fec5e9f6390&gt;</code></pre>
<pre class="r"><code>as_mapper(mean)</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; UseMethod(&quot;mean&quot;)
#&gt; &lt;bytecode: 0x7fec7cd17510&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<pre class="r"><code>as_mapper(function(x) mean(x, na.rm = TRUE))</code></pre>
<pre><code>#&gt; function(x) mean(x, na.rm = TRUE)
#&gt; &lt;environment: 0x7fec5e9f6390&gt;</code></pre>
<pre class="r"><code>as_mapper(~ mean(.x, na.rm = TRUE))</code></pre>
<pre><code>#&gt; &lt;lambda&gt;
#&gt; function (..., .x = ..1, .y = ..2, . = ..1) 
#&gt; mean(.x, na.rm = TRUE)
#&gt; &lt;environment: 0x7fec5e9f6390&gt;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;rlang_lambda_function&quot; &quot;function&quot;</code></pre>
<p>Answer: Exploration above. <code>attr_getter()</code> supports
extraction of attributes.</p>
<p>AR Solutions: <code>map()</code> offers multiple ways (functions,
formulas, and extractor functions) to specify its function argument
(<code>.f</code>). Initially, the various inputs have to be transformed
into a valid function, which is then applied. The creation of this valid
function is the job of <code>as_mapper()</code> and it is called every
time <code>map()</code> is used.</p>
<p>Given character, numeric or list input <code>as_mapper()</code> will
create an extractor function. Characters select by name, while numeric
input selects by positions and a list allows a mix of these two
approaches. This extractor interface can be very useful, when working
with nested data.</p>
<p>The extractor function is implemented as a call to
<code>purrr::pluck()</code>, which accepts a list of accessors
(accessors “access” some part of your data object).</p>
<pre class="r"><code>as_mapper(c(1, 2)) # equivalent to function(x) x[[1]][[2]]</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; pluck(x, 1, 2, .default = NULL)
#&gt; &lt;environment: 0x7fec897bb790&gt;</code></pre>
<pre class="r"><code>as_mapper(c(&quot;a&quot;, &quot;b&quot;)) # equivalent to function(x) x[[&quot;a&quot;]][[&quot;b]]</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; pluck(x, &quot;a&quot;, &quot;b&quot;, .default = NULL)
#&gt; &lt;environment: 0x7fec8935c8b0&gt;</code></pre>
<pre class="r"><code>as_mapper(list(1, &quot;b&quot;)) # equivalent to function(x) x[[1]][[&quot;b]]</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; pluck(x, 1, &quot;b&quot;, .default = NULL)
#&gt; &lt;environment: 0x7fec8cfef218&gt;</code></pre>
<p>Besides mixing positions and names, it is also possible to pass along
an accessor function. This is basically an anonymous function that gets
information about some aspect of the input data. You are free to define
your own accessor functions.</p>
<p>If you need to access certain attributes, the helper
<code>attr_getter(y)</code> is already predefined and will create the
appropriate accessor function for you.</p>
<pre class="r"><code># Define custom accessor function
get_class &lt;- function(x) attr(x, &quot;class&quot;)
pluck(mtcars, get_class)</code></pre>
<pre><code>#&gt; [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code># Use attr_getter() as a helper
pluck(mtcars, attr_getter(&quot;class&quot;))</code></pre>
<pre><code>#&gt; [1] &quot;data.frame&quot;</code></pre>
<p>Note: AR Solutions provides good additional insight into
<code>as_mapper()</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li><code>map(1:3, ~ runif(2))</code> is a useful pattern for generating
random numbers, but <code>map(1:3, runif(2))</code> is not. Why not? Can
you explain why it returns the result that it does?</li>
</ol>
<pre class="r"><code>map(1:3, ~ runif(2))</code></pre>
<pre><code>#&gt; [[1]]
#&gt; [1] 0.7396427 0.7399283
#&gt; 
#&gt; [[2]]
#&gt; [1] 0.6515631 0.8474986
#&gt; 
#&gt; [[3]]
#&gt; [1] 0.9539403 0.8543524</code></pre>
<pre class="r"><code>map(1:3, runif(2))</code></pre>
<pre><code>#&gt; [[1]]
#&gt; NULL
#&gt; 
#&gt; [[2]]
#&gt; NULL
#&gt; 
#&gt; [[3]]
#&gt; NULL</code></pre>
<p>Answer: <code>~ runif(2)</code> generates a mapper that returns 2
random values from the uniform distribution, where <code>runif(2)</code>
creates a <code>pluck()</code> mapper with 2 random values, which will
(nearly) always return <code>NULL</code>, as demonstrated by the code
below:</p>
<pre class="r"><code>as_mapper(~ runif(2))</code></pre>
<pre><code>#&gt; &lt;lambda&gt;
#&gt; function (..., .x = ..1, .y = ..2, . = ..1) 
#&gt; runif(2)
#&gt; &lt;environment: 0x7fec5e9f6390&gt;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;rlang_lambda_function&quot; &quot;function&quot;</code></pre>
<pre class="r"><code>as_mapper(runif(2))</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; pluck(x, 0.280366659164429, 0.380494769429788, .default = NULL)
#&gt; &lt;environment: 0x7fec883b43a8&gt;</code></pre>
<p>A more reasonable use of a pluck mapper for <code>1:3</code> is
<code>1</code>:</p>
<pre class="r"><code>map(1:3, 1)</code></pre>
<pre><code>#&gt; [[1]]
#&gt; [1] 1
#&gt; 
#&gt; [[2]]
#&gt; [1] 2
#&gt; 
#&gt; [[3]]
#&gt; [1] 3</code></pre>
<p>AR Solutions: The first pattern creates multiple random numbers,
because <code>~ runif(2)</code> successfully uses the formula interface.
Internally <code>map()</code> applies <code>as_mapper()</code> to this
formula, which converts <code>~ runif(2)</code> into an anonymous
function. Afterwards <code>runif(2)</code> is applied three times (one
time during each iteration), leading to three different pairs of random
numbers.</p>
<p>In the second pattern <code>runif(2)</code> is evaluated once, then
the results are passed to <code>map()</code>. Consequently
<code>as_mapper()</code> creates an extractor function based on the
return values from <code>runif(2)</code> (via <code>pluck()</code>).
This leads to three <code>NULL</code>s (<code>pluck()</code>’s
<code>.default</code> return), because no values corresponding to the
index can be found.</p>
<p>Note: AR Solutions provides additional detail, but is otherwise the
same.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li><p>Use the appropriate <code>map()</code> function to:</p>
<ol style="list-style-type: lower-alpha">
<li><p>Compute the standard deviation of every column in a numeric data
frame.</p></li>
<li><p>Compute the standard deviation of every numeric column in a mixed
data frame. (Hint: you’ll need to do it in two steps.)</p></li>
<li><p>Compute the number of levels for every factor in a data
frame.</p></li>
</ol></li>
</ol>
<pre class="r"><code># a
map_dbl(mtcars, sd)</code></pre>
<pre><code>#&gt;         mpg         cyl        disp          hp        drat          wt        qsec          vs 
#&gt;   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574   1.7869432   0.5040161 
#&gt;          am        gear        carb 
#&gt;   0.4989909   0.7378041   1.6152000</code></pre>
<pre class="r"><code># b
map_dbl(iris[map_lgl(iris, is.numeric)], sd)</code></pre>
<pre><code>#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
#&gt;    0.8280661    0.4358663    1.7652982    0.7622377</code></pre>
<pre class="r"><code># c
map_int(warpbreaks, nlevels)</code></pre>
<pre><code>#&gt;  breaks    wool tension 
#&gt;       0       2       3</code></pre>
<pre class="r"><code># c, excluding non-factor columns
map_int(warpbreaks[map_lgl(warpbreaks, is.factor)], nlevels)</code></pre>
<pre><code>#&gt;    wool tension 
#&gt;       2       3</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: To solve this exercise we take advantage of calling the
type stable variants of <code>map()</code>, which give us more concise
output, and use <code>map_lgl()</code> to select the columns of the data
frame (later you’ll learn about <code>keep()</code>, which simplifies
this pattern a little).</p>
<pre class="r"><code>map_dbl(mtcars, sd)</code></pre>
<pre><code>#&gt;         mpg         cyl        disp          hp        drat          wt        qsec          vs 
#&gt;   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574   1.7869432   0.5040161 
#&gt;          am        gear        carb 
#&gt;   0.4989909   0.7378041   1.6152000</code></pre>
<pre class="r"><code>penguins_numeric &lt;- map_lgl(penguins, is.numeric)
map_dbl(penguins[penguins_numeric], sd, na.rm = TRUE)</code></pre>
<pre><code>#&gt;    bill_length_mm     bill_depth_mm flipper_length_mm       body_mass_g              year 
#&gt;         5.4595837         1.9747932        14.0617137       801.9545357         0.8183559</code></pre>
<pre class="r"><code>penguins_factor &lt;- map_lgl(penguins, is.factor)
map_int(penguins[penguins_factor], ~ length(levels(.x)))</code></pre>
<pre><code>#&gt; species  island     sex 
#&gt;       3       3       2</code></pre>
<p>Note: my code is more concise, both with selections and use of
<code>nlevels()</code>, although using <code>keep()</code> is
preferable.</p>
<pre class="r"><code>map_int(keep(warpbreaks, is.factor), nlevels)</code></pre>
<pre><code>#&gt;    wool tension 
#&gt;       2       3</code></pre>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>The following code simulates the performance of a t-test for
non-normal data. Extract the p-value from each test, then
visualise.</li>
</ol>
<pre class="r"><code>trials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))
hist(map_dbl(trials, &quot;p.value&quot;), breaks = 10)</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-11-1.png" width="768" style="display: block; margin: auto;" /></p>
<p>Answer: code above.</p>
<p>AR Solutions: There are many ways to visualise this data. However,
since there are only 100 data points, we choose a dot plot to visualise
the distribution. (Unfortunately, <code>{ggplot2}</code>s
<code>geom_dotplot()</code> doesn’t compute proper counts as it was
created to visualise distribution densities instead of frequencies, so a
histogram would be a suitable alternative).</p>
<pre class="r"><code># Advanced R Solutions uses different code for trials
trials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))

library(ggplot2)

df_trials &lt;- tibble::tibble(p_value = map_dbl(trials, &quot;p.value&quot;))

df_trials %&gt;%
  ggplot(aes(x = p_value, fill = p_value &lt; 0.05)) +
  geom_dotplot(binwidth = 0.01) + # geom_histogram() as alternative
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = &quot;top&quot;
  )</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-12-1.png" width="768" style="display: block; margin: auto;" /></p>
<p>Notes: the code AR Solutions uses for trials,
<code>trials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))</code>,
appears to be correct compared to Advanced R.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>The following code uses a map nested inside another map to apply a
function to every element of a nested list. Why does it fail, and what
do you need to do to make it work?</li>
</ol>
<pre class="r"><code>x &lt;- list(
  list(1, c(3, 9)),
  list(c(3, 6), 7, c(4, 7, 6))
)

triple &lt;- function(x) x * 3
try(map(x, map, .f = triple))</code></pre>
<pre><code>#&gt; Error in .f(.x[[i]], ...) : unused argument (function (.x, .f, ...) 
#&gt; {
#&gt;     .f &lt;- as_mapper(.f, ...)
#&gt;     .Call(map_impl, environment(), &quot;.x&quot;, &quot;.f&quot;, &quot;list&quot;)
#&gt; })</code></pre>
<p>Answer: the call fails since the <code>.f = triple</code> specifies
the function for the outer <code>map()</code>, and the <code>map</code>
is passed as an additional argument to <code>triple()</code>, which
generates the error since <code>triple()</code> only takes a single
argument. The solution is to pass triple as an additional argument to
the outer <code>map()</code>:</p>
<pre class="r"><code>map(x, map, triple)</code></pre>
<pre><code>#&gt; [[1]]
#&gt; [[1]][[1]]
#&gt; [1] 3
#&gt; 
#&gt; [[1]][[2]]
#&gt; [1]  9 27
#&gt; 
#&gt; 
#&gt; [[2]]
#&gt; [[2]][[1]]
#&gt; [1]  9 18
#&gt; 
#&gt; [[2]][[2]]
#&gt; [1] 21
#&gt; 
#&gt; [[2]][[3]]
#&gt; [1] 12 21 18</code></pre>
<p>AR Solutions: This function call fails, because <code>triple()</code>
is specified as the <code>.f</code> argument and consequently belongs to
the outer <code>map()</code>. The unnamed argument <code>map</code> is
treated as an argument of <code>triple()</code>, which causes the
error.</p>
<p>There are a number of ways we could resolve the problem. However,
there is not much to choose between them for this simple example,
although it is good to know your options for more complicated cases.</p>
<pre class="r"><code># Don&#39;t name the argument
map(x, map, triple)

# Use magrittr-style anonymous function
map(x, . %&gt;% map(triple))

# Use purrr-style anonymous function
map(x, ~ map(.x, triple))</code></pre>
<p>Note: I don’t like the magrittr-style anonymous function option. The
others are good.</p>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>Use <code>map()</code> to fit linear models to the
<code>mtcars</code> dataset using the formulas stored in this list:</li>
</ol>
<pre class="r"><code>formulas &lt;- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)</code></pre>
<p>Answer: the following code works, but doesn’t display the text of the
formula in the <code>Call:</code></p>
<pre class="r"><code>map(formulas, lm, mtcars)</code></pre>
<pre><code>#&gt; [[1]]
#&gt; 
#&gt; Call:
#&gt; .f(formula = .x[[i]], data = ..1)
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept)         disp  
#&gt;    29.59985     -0.04122  
#&gt; 
#&gt; 
#&gt; [[2]]
#&gt; 
#&gt; Call:
#&gt; .f(formula = .x[[i]], data = ..1)
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept)    I(1/disp)  
#&gt;       10.75      1557.67  
#&gt; 
#&gt; 
#&gt; [[3]]
#&gt; 
#&gt; Call:
#&gt; .f(formula = .x[[i]], data = ..1)
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept)         disp           wt  
#&gt;    34.96055     -0.01772     -3.35083  
#&gt; 
#&gt; 
#&gt; [[4]]
#&gt; 
#&gt; Call:
#&gt; .f(formula = .x[[i]], data = ..1)
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept)    I(1/disp)           wt  
#&gt;      19.024     1142.560       -1.798</code></pre>
<p>AR Solutions: The data (<code>mtcars</code>) is constant for all
these models and so we iterate over the <code>formulas</code> provided.
As the formula is the first argument of <code>lm()</code>, we don’t need
to specify it explicitly.</p>
<pre class="r"><code>models &lt;- map(formulas, lm, data = mtcars)</code></pre>
<p>Note: AR Solutions specifies <code>data = mtcars</code> but is
otherwise the same.</p>
<hr />
<ol start="7" style="list-style-type: decimal">
<li>Fit the model <code>mpg ~ disp</code> to each of the bootstrap
replicates of <code>mtcars</code> in the list below, then extract the
<span class="math inline">\(R^2\)</span> of the model fit (Hint: you can
compute the <span class="math inline">\(R^2\)</span> with
<code>summary()</code>.)</li>
</ol>
<pre class="r"><code>bootstrap &lt;- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps &lt;- map(1:10, ~ bootstrap(mtcars))

map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)</code></pre>
<pre><code>#&gt;  [1] 0.7898250 0.9028571 0.7440835 0.8193964 0.7277909 0.6212389 0.7260793 0.6770312 0.7653197
#&gt; [10] 0.7804232</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: To accomplish this task, we take advantage of the “list
in, list out”-functionality of <code>map()</code>. This allows us to
chain multiple transformations together. We start by fitting the models.
We then calculate the summaries and extract the <span
class="math inline">\(R^2\)</span> values. For the last call we use
<code>map_dbl()</code>, which provides convenient output.</p>
<pre class="r"><code>bootstraps %&gt;%
  map(~ lm(mpg ~ disp, data = .x)) %&gt;%
  map(summary) %&gt;%
  map_dbl(&quot;r.squared&quot;)</code></pre>
<pre><code>#&gt;  [1] 0.7898250 0.9028571 0.7440835 0.8193964 0.7277909 0.6212389 0.7260793 0.6770312 0.7653197
#&gt; [10] 0.7804232</code></pre>
<p>Note: while AR Solutions is arguably <em>slightly</em> more readable,
my code should be faster:</p>
<pre class="r"><code>bench::mark({
  map_dbl(bootstraps, ~ summary(lm(mpg ~ disp, .x))$r.squared)
})</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                                         min median itr/s…¹ mem_a…² gc/se…³
#&gt;   &lt;bch:expr&gt;                                                      &lt;bch:&gt; &lt;bch:&gt;   &lt;dbl&gt; &lt;bch:b&gt;   &lt;dbl&gt;
#&gt; 1 { map_dbl(bootstraps, ~summary(lm(mpg ~ disp, .x))$r.squared) } 6.02ms 6.39ms    149.  63.7KB    4.25
#&gt; # … with abbreviated variable names ¹​`itr/sec`, ²​mem_alloc, ³​`gc/sec`</code></pre>
<pre class="r"><code>bench::mark({
  bootstraps %&gt;%
    map(~ lm(mpg ~ disp, data = .x)) %&gt;%
    map(summary) %&gt;%
    map_dbl(&quot;r.squared&quot;)
})</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                                                                        min
#&gt;   &lt;bch:expr&gt;                                                                                   &lt;bch:tm&gt;
#&gt; 1 { bootstraps %&gt;% map(~lm(mpg ~ disp, data = .x)) %&gt;% map(summary) %&gt;% map_dbl(&quot;r.squared&quot;) }   5.67ms
#&gt; # … with 4 more variables: median &lt;bch:tm&gt;, `itr/sec` &lt;dbl&gt;, mem_alloc &lt;bch:byt&gt;, `gc/sec` &lt;dbl&gt;
#&gt; # ℹ Use `colnames()` to see all variable names</code></pre>
<p>It is actually slightly slower! AR Solutions wins!</p>
<hr />
</div>
<div id="exercises-1" class="section level2">
<h2>9.4.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Explain the results of <code>modify(mtcars, 1)</code>.</li>
</ol>
<pre class="r"><code>modify(mtcars, 1)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4 Wag"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Datsun 710"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Hornet 4 Drive"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Hornet Sportabout"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Valiant"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Duster 360"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Merc 240D"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Merc 230"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Merc 280"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Merc 450SE"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Merc 450SL"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Merc 450SLC"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Cadillac Fleetwood"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Lincoln Continental"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Chrysler Imperial"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Fiat 128"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Honda Civic"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Toyota Corolla"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Toyota Corona"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Dodge Challenger"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"AMC Javelin"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Camaro Z28"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Pontiac Firebird"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Fiat X1-9"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Porsche 914-2"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Lotus Europa"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Ford Pantera L"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Ferrari Dino"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Maserati Bora"},{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>as_mapper(1)</code></pre>
<pre><code>#&gt; function (x, ...) 
#&gt; pluck(x, 1, .default = NULL)
#&gt; &lt;environment: 0x7fec8ae72d80&gt;</code></pre>
<pre class="r"><code>head(mtcars, 1)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"21","2":"6","3":"160","4":"110","5":"3.9","6":"2.62","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Answer: <code>modify(mtcars, 1)</code> creates a mapper that plucks
the first element of each column of <code>mtcars</code> and writes that
value to every row.</p>
<p>AR Solutions: <code>modify()</code> is based on <code>map()</code>,
and in this case, the extractor interface will be used. It extracts the
first element of each column in <code>mtcars</code>.
<code>modify()</code> always returns the same structure as its input: in
this case it forces the first row to be recycled 32 times. (Internally
<code>modify()</code> uses <code>.x[] &lt;- map(.x, .f, ...)</code> for
assignment.)</p>
<p>Notes: this code makes the recycling clear:</p>
<pre class="r"><code>unlist(map(mtcars, 1))</code></pre>
<pre><code>#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb 
#&gt;  21.00   6.00 160.00 110.00   3.90   2.62  16.46   0.00   1.00   4.00   4.00</code></pre>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Rewrite the following code to use <code>iwalk()</code> instead of
<code>walk2()</code>. What are the advantages and disadvantages?</li>
</ol>
<pre class="r"><code>cyls &lt;- split(mtcars, mtcars$cyl)
paths &lt;- file.path(temp, paste0(&quot;cyl-&quot;, names(cyls), &quot;.csv&quot;))
walk2(cyls, paths, write.csv)</code></pre>
<p>Answer: code below.</p>
<pre class="r"><code>temp &lt;- tempfile()
dir.create(temp)

cyls &lt;- split(mtcars, mtcars$cyl)
iwalk(cyls, ~ write.csv(.x, file.path(temp, paste0(&quot;cyl-&quot;, .y, &quot;.csv&quot;))))
dir(temp)</code></pre>
<pre><code>#&gt; [1] &quot;cyl-4.csv&quot; &quot;cyl-6.csv&quot; &quot;cyl-8.csv&quot;</code></pre>
<p>The main advantage of using <code>iwalk()</code> is that it will use
<code>seq_along()</code> if <code>x</code> does not have names. In this
case, x has names, and the resulting code is a bit harder to understand,
and requires a formula (or function).</p>
<p>AR Solutions: <code>iwalk()</code> allows us to use a single
variable, storing the output path in the names.</p>
<pre class="r"><code>temp &lt;- tempfile()
dir.create(temp)
cyls &lt;- split(mtcars, mtcars$cyl)
names(cyls) &lt;- file.path(temp, paste0(&quot;cyl-&quot;, names(cyls), &quot;.csv&quot;))
iwalk(cyls, ~ write.csv(.x, .y))</code></pre>
<p>We could do this in a single pipe by taking advantage of
<code>set_names()</code>:</p>
<pre class="r"><code>mtcars %&gt;%
  split(mtcars$cyl) %&gt;%
  set_names(~ file.path(temp, paste0(&quot;cyl-&quot;, .x, &quot;.csv&quot;))) %&gt;%
  iwalk(~ write.csv(.x, .y))</code></pre>
<p>Notes: the AR Solutions use of names and the pipe is clever.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Explain how the following code transforms a data frame using
functions stored in a list.</li>
</ol>
<pre class="r"><code>if (exists(&quot;mtcars&quot;)) rm(mtcars)</code></pre>
<pre><code>#&gt; Warning in rm(mtcars): object &#39;mtcars&#39; not found</code></pre>
<pre class="r"><code>mtcars</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.620","7":"16.46","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4"},{"1":"21.0","2":"6","3":"160.0","4":"110","5":"3.90","6":"2.875","7":"17.02","8":"0","9":"1","10":"4","11":"4","_rn_":"Mazda RX4 Wag"},{"1":"22.8","2":"4","3":"108.0","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"1","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"21.4","2":"6","3":"258.0","4":"110","5":"3.08","6":"3.215","7":"19.44","8":"1","9":"0","10":"3","11":"1","_rn_":"Hornet 4 Drive"},{"1":"18.7","2":"8","3":"360.0","4":"175","5":"3.15","6":"3.440","7":"17.02","8":"0","9":"0","10":"3","11":"2","_rn_":"Hornet Sportabout"},{"1":"18.1","2":"6","3":"225.0","4":"105","5":"2.76","6":"3.460","7":"20.22","8":"1","9":"0","10":"3","11":"1","_rn_":"Valiant"},{"1":"14.3","2":"8","3":"360.0","4":"245","5":"3.21","6":"3.570","7":"15.84","8":"0","9":"0","10":"3","11":"4","_rn_":"Duster 360"},{"1":"24.4","2":"4","3":"146.7","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"140.8","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"0","10":"4","11":"2","_rn_":"Merc 230"},{"1":"19.2","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.30","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280"},{"1":"17.8","2":"6","3":"167.6","4":"123","5":"3.92","6":"3.440","7":"18.90","8":"1","9":"0","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"16.4","2":"8","3":"275.8","4":"180","5":"3.07","6":"4.070","7":"17.40","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SE"},{"1":"17.3","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.730","7":"17.60","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SL"},{"1":"15.2","2":"8","3":"275.8","4":"180","5":"3.07","6":"3.780","7":"18.00","8":"0","9":"0","10":"3","11":"3","_rn_":"Merc 450SLC"},{"1":"10.4","2":"8","3":"472.0","4":"205","5":"2.93","6":"5.250","7":"17.98","8":"0","9":"0","10":"3","11":"4","_rn_":"Cadillac Fleetwood"},{"1":"10.4","2":"8","3":"460.0","4":"215","5":"3.00","6":"5.424","7":"17.82","8":"0","9":"0","10":"3","11":"4","_rn_":"Lincoln Continental"},{"1":"14.7","2":"8","3":"440.0","4":"230","5":"3.23","6":"5.345","7":"17.42","8":"0","9":"0","10":"3","11":"4","_rn_":"Chrysler Imperial"},{"1":"32.4","2":"4","3":"78.7","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"75.7","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"1","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"71.1","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"120.1","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"0","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"15.5","2":"8","3":"318.0","4":"150","5":"2.76","6":"3.520","7":"16.87","8":"0","9":"0","10":"3","11":"2","_rn_":"Dodge Challenger"},{"1":"15.2","2":"8","3":"304.0","4":"150","5":"3.15","6":"3.435","7":"17.30","8":"0","9":"0","10":"3","11":"2","_rn_":"AMC Javelin"},{"1":"13.3","2":"8","3":"350.0","4":"245","5":"3.73","6":"3.840","7":"15.41","8":"0","9":"0","10":"3","11":"4","_rn_":"Camaro Z28"},{"1":"19.2","2":"8","3":"400.0","4":"175","5":"3.08","6":"3.845","7":"17.05","8":"0","9":"0","10":"3","11":"2","_rn_":"Pontiac Firebird"},{"1":"27.3","2":"4","3":"79.0","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"1","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"120.3","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"1","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"95.1","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"1","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"15.8","2":"8","3":"351.0","4":"264","5":"4.22","6":"3.170","7":"14.50","8":"0","9":"1","10":"5","11":"4","_rn_":"Ford Pantera L"},{"1":"19.7","2":"6","3":"145.0","4":"175","5":"3.62","6":"2.770","7":"15.50","8":"0","9":"1","10":"5","11":"6","_rn_":"Ferrari Dino"},{"1":"15.0","2":"8","3":"301.0","4":"335","5":"3.54","6":"3.570","7":"14.60","8":"0","9":"1","10":"5","11":"8","_rn_":"Maserati Bora"},{"1":"21.4","2":"4","3":"121.0","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"1","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>trans &lt;- list(
  disp = function(x) x * 0.0163871,
  am = function(x) factor(x, labels = c(&quot;auto&quot;, &quot;manual&quot;))
)

nm &lt;- names(trans)
mtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))

mtcars</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["fct"],"align":["left"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"21.0","2":"6","3":"2.621936","4":"110","5":"3.90","6":"2.620","7":"16.46","8":"0","9":"manual","10":"4","11":"4","_rn_":"Mazda RX4"},{"1":"21.0","2":"6","3":"2.621936","4":"110","5":"3.90","6":"2.875","7":"17.02","8":"0","9":"manual","10":"4","11":"4","_rn_":"Mazda RX4 Wag"},{"1":"22.8","2":"4","3":"1.769807","4":"93","5":"3.85","6":"2.320","7":"18.61","8":"1","9":"manual","10":"4","11":"1","_rn_":"Datsun 710"},{"1":"21.4","2":"6","3":"4.227872","4":"110","5":"3.08","6":"3.215","7":"19.44","8":"1","9":"auto","10":"3","11":"1","_rn_":"Hornet 4 Drive"},{"1":"18.7","2":"8","3":"5.899356","4":"175","5":"3.15","6":"3.440","7":"17.02","8":"0","9":"auto","10":"3","11":"2","_rn_":"Hornet Sportabout"},{"1":"18.1","2":"6","3":"3.687098","4":"105","5":"2.76","6":"3.460","7":"20.22","8":"1","9":"auto","10":"3","11":"1","_rn_":"Valiant"},{"1":"14.3","2":"8","3":"5.899356","4":"245","5":"3.21","6":"3.570","7":"15.84","8":"0","9":"auto","10":"3","11":"4","_rn_":"Duster 360"},{"1":"24.4","2":"4","3":"2.403988","4":"62","5":"3.69","6":"3.190","7":"20.00","8":"1","9":"auto","10":"4","11":"2","_rn_":"Merc 240D"},{"1":"22.8","2":"4","3":"2.307304","4":"95","5":"3.92","6":"3.150","7":"22.90","8":"1","9":"auto","10":"4","11":"2","_rn_":"Merc 230"},{"1":"19.2","2":"6","3":"2.746478","4":"123","5":"3.92","6":"3.440","7":"18.30","8":"1","9":"auto","10":"4","11":"4","_rn_":"Merc 280"},{"1":"17.8","2":"6","3":"2.746478","4":"123","5":"3.92","6":"3.440","7":"18.90","8":"1","9":"auto","10":"4","11":"4","_rn_":"Merc 280C"},{"1":"16.4","2":"8","3":"4.519562","4":"180","5":"3.07","6":"4.070","7":"17.40","8":"0","9":"auto","10":"3","11":"3","_rn_":"Merc 450SE"},{"1":"17.3","2":"8","3":"4.519562","4":"180","5":"3.07","6":"3.730","7":"17.60","8":"0","9":"auto","10":"3","11":"3","_rn_":"Merc 450SL"},{"1":"15.2","2":"8","3":"4.519562","4":"180","5":"3.07","6":"3.780","7":"18.00","8":"0","9":"auto","10":"3","11":"3","_rn_":"Merc 450SLC"},{"1":"10.4","2":"8","3":"7.734711","4":"205","5":"2.93","6":"5.250","7":"17.98","8":"0","9":"auto","10":"3","11":"4","_rn_":"Cadillac Fleetwood"},{"1":"10.4","2":"8","3":"7.538066","4":"215","5":"3.00","6":"5.424","7":"17.82","8":"0","9":"auto","10":"3","11":"4","_rn_":"Lincoln Continental"},{"1":"14.7","2":"8","3":"7.210324","4":"230","5":"3.23","6":"5.345","7":"17.42","8":"0","9":"auto","10":"3","11":"4","_rn_":"Chrysler Imperial"},{"1":"32.4","2":"4","3":"1.289665","4":"66","5":"4.08","6":"2.200","7":"19.47","8":"1","9":"manual","10":"4","11":"1","_rn_":"Fiat 128"},{"1":"30.4","2":"4","3":"1.240503","4":"52","5":"4.93","6":"1.615","7":"18.52","8":"1","9":"manual","10":"4","11":"2","_rn_":"Honda Civic"},{"1":"33.9","2":"4","3":"1.165123","4":"65","5":"4.22","6":"1.835","7":"19.90","8":"1","9":"manual","10":"4","11":"1","_rn_":"Toyota Corolla"},{"1":"21.5","2":"4","3":"1.968091","4":"97","5":"3.70","6":"2.465","7":"20.01","8":"1","9":"auto","10":"3","11":"1","_rn_":"Toyota Corona"},{"1":"15.5","2":"8","3":"5.211098","4":"150","5":"2.76","6":"3.520","7":"16.87","8":"0","9":"auto","10":"3","11":"2","_rn_":"Dodge Challenger"},{"1":"15.2","2":"8","3":"4.981678","4":"150","5":"3.15","6":"3.435","7":"17.30","8":"0","9":"auto","10":"3","11":"2","_rn_":"AMC Javelin"},{"1":"13.3","2":"8","3":"5.735485","4":"245","5":"3.73","6":"3.840","7":"15.41","8":"0","9":"auto","10":"3","11":"4","_rn_":"Camaro Z28"},{"1":"19.2","2":"8","3":"6.554840","4":"175","5":"3.08","6":"3.845","7":"17.05","8":"0","9":"auto","10":"3","11":"2","_rn_":"Pontiac Firebird"},{"1":"27.3","2":"4","3":"1.294581","4":"66","5":"4.08","6":"1.935","7":"18.90","8":"1","9":"manual","10":"4","11":"1","_rn_":"Fiat X1-9"},{"1":"26.0","2":"4","3":"1.971368","4":"91","5":"4.43","6":"2.140","7":"16.70","8":"0","9":"manual","10":"5","11":"2","_rn_":"Porsche 914-2"},{"1":"30.4","2":"4","3":"1.558413","4":"113","5":"3.77","6":"1.513","7":"16.90","8":"1","9":"manual","10":"5","11":"2","_rn_":"Lotus Europa"},{"1":"15.8","2":"8","3":"5.751872","4":"264","5":"4.22","6":"3.170","7":"14.50","8":"0","9":"manual","10":"5","11":"4","_rn_":"Ford Pantera L"},{"1":"19.7","2":"6","3":"2.376130","4":"175","5":"3.62","6":"2.770","7":"15.50","8":"0","9":"manual","10":"5","11":"6","_rn_":"Ferrari Dino"},{"1":"15.0","2":"8","3":"4.932517","4":"335","5":"3.54","6":"3.570","7":"14.60","8":"0","9":"manual","10":"5","11":"8","_rn_":"Maserati Bora"},{"1":"21.4","2":"4","3":"1.982839","4":"109","5":"4.11","6":"2.780","7":"18.60","8":"1","9":"manual","10":"4","11":"2","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>rm(mtcars)</code></pre>
<p>Compare and contrast the <code>map2()</code> approach to this
<code>map()</code> approach:</p>
<pre class="r"><code>mtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))</code></pre>
<p>Answer: the <code>map2()</code> code applies the anonymous functions
to the corresponding column in <code>mtcars</code> based on their name
in the list:</p>
<ul>
<li><code>mtcars[nm]</code> is equivalent to
<code>mtcars[c("disp", "am")]</code>, so the code is modifying those two
columns</li>
<li>the mapping function, <code>function(f, var) f(var)</code> is run as
<code>f(mtcars[["disp"]])</code> and <code>f(mtcars[["am"]])</code>,
with the corresponding function in <code>trans</code> as <code>f</code>,
since <code>trans</code> and <code>mtcars[nm]</code> are passed as
parameters to the function</li>
</ul>
<p>The equivalent <code>map()</code> approach isn’t as clean: it’s
harder to understand what <code>map()</code> is doing.</p>
<p>AR Solutions: In the first approach</p>
<pre class="r"><code>mtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))</code></pre>
<p>the list of the 2 functions (<code>trans</code>) and the 2
appropriately selected data frame columns (<code>mtcars[nm]</code>) are
supplied to <code>map2()</code>. <code>map2()</code> creates an
anonymous function (<code>f(var)</code>) which applies the functions to
the variables when <code>map2()</code> iterates over their (similar)
indices. On the left-hand side, the respective 2 elements of
<code>mtcars</code> are being replaced by their new transformations.</p>
<p>The <code>map()</code> variant</p>
<pre class="r"><code>mtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))</code></pre>
<p>does basically the same. However, it directly iterates over the names
(<code>nm</code>) of the transformations. Therefore, the data frame
columns are selected during the iteration.</p>
<p>Besides the iteration pattern, the approaches differ in the
possibilities for appropriate argument naming in the <code>.f</code>
argument. In the <code>map2()</code> approach we iterate over the
elements of <code>x</code> and <code>y</code>. Therefore, it is possible
to choose appropriate placeholders like <code>f</code> and
<code>var</code>. This makes the anonymous function more expressive at
the cost of making it longer. We think using the formula interface in
this way is preferable compared to the rather cryptic
<code>mtcars[nm] &lt;- map2(trans, mtcars[nm], ~ .x(.y))</code>.</p>
<p>In the <code>map()</code> approach we map over the variable names. It
is therefore not possible to introduce placeholders for the function and
variable names. The formula syntax together with the <code>.x</code>
pronoun is pretty compact. The object names and the brackets clearly
indicate the application of transformations to specific columns of
<code>mtcars</code>. In this case the iteration over the variable names
comes in handy, as it highlights the importance of matching between
<code>trans</code> and <code>mtcars</code> element names. Together with
the replacement form on the left-hand side, this line is relatively easy
to inspect.</p>
<p>To summarise, in situations where <code>map()</code> and
<code>map2()</code> provide solutions for an iteration problem, several
points may be considered before deciding for one or the other
approach.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>What does <code>write.csv()</code> return, i.e. what happens if you
use it with <code>map2()</code> instead of <code>walk2()</code>?</li>
</ol>
<pre class="r"><code>paths &lt;- file.path(temp, paste0(&quot;cyl-&quot;, names(cyls), &quot;.csv&quot;))
map2(cyls, paths, write.csv)</code></pre>
<pre><code>#&gt; $`4`
#&gt; NULL
#&gt; 
#&gt; $`6`
#&gt; NULL
#&gt; 
#&gt; $`8`
#&gt; NULL</code></pre>
<p>Answer: <code>write.csv()</code> is designed to return
<code>NULL</code>, invisibly. While <code>walk2()</code> hides the
<code>NULL</code> return values, <code>map2()</code> does not.</p>
<p>AR Solutions: <code>write.csv()</code> returns <code>NULL</code>. As
we call the function for its side effect (creating a CSV file),
<code>walk2()</code> would be appropriate here. Otherwise, we receive a
rather uninformative list of <code>NULL</code>s.</p>
<hr />
</div>
<div id="exercises-2" class="section level2">
<h2>9.6.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Why isn’t <code>is.na()</code> a predicate function? What base R
function is closest to being a predicate version of
<code>is.na()</code>?</li>
</ol>
<p>Answer: <code>is.na(x)</code> returns <code>logical(0)</code> when
<code>x</code> is <code>NULL</code>, which violates the rule that
predicate functions only return <code>TRUE</code> or <code>FALSE</code>.
<code>anyNA(x, recursive = FALSE)</code> appears to be a predicate
version of <code>is.na()</code>.</p>
<p>AR Solutions: <code>is.na()</code> is not a predicate function,
because it returns a logical <em>vector</em> the same length as the
input, not a single <code>TRUE</code> or <code>FALSE</code>.</p>
<p><code>anyNA()</code> is the closest equivalent because it always
returns a single <code>TRUE</code> or <code>FALSE</code> if there are
any missing values present. You could also imagine an
<code>allNA()</code> which would return <code>TRUE</code> if all values
were missing, but that’s considerably less useful so base R does not
provide it.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li><code>simple_reduce()</code> has a problem when <code>x</code> is
length 0 or length 1. Describe the source of the problem and how you
might go about fixing it.</li>
</ol>
<pre class="r"><code>simple_reduce &lt;- function(x, f) {
  out &lt;- x[[1]]
  for (i in seq(2, length(x))) {
    out &lt;- f(out, x[[i]])
  }
  out
}</code></pre>
<p>Answer: using <code>seq()</code> results in a backwards count when
<code>x</code> is length 0 or 1.</p>
<pre class="r"><code>seq(2, 0)</code></pre>
<pre><code>#&gt; [1] 2 1 0</code></pre>
<pre class="r"><code>seq(2, 1)</code></pre>
<pre><code>#&gt; [1] 2 1</code></pre>
<p>The fix is to check the length of <code>x</code> and return itself
when length is 0 and throw an error when length is 1, as
<code>reduce()</code> does.</p>
<p>AR Solutions: The loop inside <code>simple_reduce()</code> always
starts with the index 2, and <code>seq()</code> can count both up
<em>and</em> down:</p>
<p>Therefore, subsetting length-0 and length-1 vectors via
<code>[[</code> will lead to a <em>subscript out of bounds</em> error.
To avoid this, we allow <code>simple_reduce()</code> to return before
the for loop is started and include a default argument for 0-length
vectors.</p>
<pre class="r"><code>simple_reduce &lt;- function(x, f, default) {
  if (length(x) == 0L) {
    return(default)
  }
  if (length(x) == 1L) {
    return(x[[1L]])
  }

  out &lt;- x[[1]]
  for (i in seq(2, length(x))) {
    out &lt;- f(out, x[[i]])
  }

  out
}</code></pre>
<p>Our new <code>simple_reduce()</code> now works as intended:</p>
<pre class="r"><code>try(simple_reduce(integer(0), `+`))</code></pre>
<pre><code>#&gt; Error in simple_reduce(integer(0), `+`) : 
#&gt;   argument &quot;default&quot; is missing, with no default</code></pre>
<pre class="r"><code>simple_reduce(integer(0), `+`, default = 0L)</code></pre>
<pre><code>#&gt; [1] 0</code></pre>
<pre class="r"><code>simple_reduce(1, `+`)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>simple_reduce(1:3, `+`)</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Implement the <code>span()</code> function from Haskell: given a
list <code>x</code> and a predicate function <code>f</code>,
<code>span(x, f)</code> returns the location of the longest sequential
run of elements where the predicate is true. (Hint: you might find
<code>rle()</code> helpful.)</li>
</ol>
<pre class="r"><code>test &lt;- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:39))
test2 &lt;- c(as.list(letters[1:21]), as.list(1:20), as.list(letters[22:26]), as.list(20:40))

span &lt;- function(x, f) {
  runs &lt;- rle(map_lgl(x, f))
  max_true &lt;- max_index &lt;- 0
  index &lt;- 1
  for (i in seq_along(runs$values)) {
    if (runs$values[i] &amp;&amp; runs$lengths[i] &gt; max_true) {
      max_true &lt;- runs$lengths[i]
      max_index &lt;- index
    }
    index &lt;- index + runs$lengths[i]
  }
  max_index
}

span(test, is.numeric)</code></pre>
<pre><code>#&gt; [1] 22</code></pre>
<pre class="r"><code>span(test2, is.numeric)</code></pre>
<pre><code>#&gt; [1] 47</code></pre>
<pre class="r"><code>span(1, is.numeric)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>span(&quot;a&quot;, is.numeric)</code></pre>
<pre><code>#&gt; [1] 0</code></pre>
<pre class="r"><code>span(list(&quot;a&quot;, 1:10, 1:20), is.numeric)</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: Our <code>span_r()</code> function returns the indices
of the (first occurring) longest sequential run of elements where the
predicate is true. If the predicate is never true, the longest run has
length 0, in which case we return <code>integer(0)</code>.</p>
<pre class="r"><code>span_r &lt;- function(x, f) {
  idx &lt;- unname(map_lgl(x, ~ f(.x)))
  rle &lt;- rle(idx)

  # Check if the predicate is never true
  if (!any(rle$values)) {
    return(integer(0))
  }

  # Find the length of the longest sequence of true values
  longest &lt;- max(rle$lengths[rle$values])
  # Find the position of the (first) longest run in rle
  longest_idx &lt;- which(rle$values &amp; rle$lengths == longest)[1]

  # Add up all lengths in rle before the longest run
  ind_before_longest &lt;- sum(rle$lengths[seq_len(longest_idx - 1)])

  out_start &lt;- ind_before_longest + 1L
  out_end &lt;- ind_before_longest + longest
  out_start:out_end
}

# Check that it works
span_r(c(0, 0, 0, 0, 0), is.na)</code></pre>
<pre><code>#&gt; integer(0)</code></pre>
<pre class="r"><code>span_r(c(NA, 0, 0, 0, 0), is.na)</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>span_r(c(NA, 0, NA, NA, NA), is.na)</code></pre>
<pre><code>#&gt; [1] 3 4 5</code></pre>
<p>Notes: AR Solutions shows how to find the index of the longest
sequence using <code>which()</code>, which is new to me, and returns
more information by returning indexes of the entire span. The AR
Solutions approach is also significantly faster (which I did not
expect).</p>
<pre class="r"><code>bench::mark(span_r(test2, is.numeric))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                     min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 span_r(test2, is.numeric)   96.9µs    107µs     8712.    4.01KB     8.81</code></pre>
<pre class="r"><code>bench::mark(span(test2, is.numeric))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                   min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;              &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 span(test2, is.numeric)    144µs    163µs     5874.    4.01KB     6.31</code></pre>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Implement <code>arg_max()</code>. It should take a function and a
vector of inputs, and return the elements of the input where the
function returns the highest value. For example,
<code>arg_max(-10:5, function(x) x ^ 2)</code> should return -10.
<code>arg_max(-5:5, function(x) x ^ 2)</code> should return
<code>c(-5, 5)</code>. Also implement the matching
<code>arg_min()</code> function.</li>
</ol>
<p>Answer: code below.</p>
<pre class="r"><code>arg_max &lt;- function(x, f) {
  val &lt;- map_dbl(x, f)
  val_max &lt;- max(val)
  x[which(val == val_max)]
}

arg_max(-10:5, function(x) x^2)</code></pre>
<pre><code>#&gt; [1] -10</code></pre>
<pre class="r"><code>arg_max(-5:5, function(x) x^2)</code></pre>
<pre><code>#&gt; [1] -5  5</code></pre>
<pre class="r"><code>arg_min &lt;- function(x, f) {
  val &lt;- map_dbl(x, f)
  val_min &lt;- min(val)
  x[which(val == val_min)]
}

arg_min(-10:5, function(x) x^2)</code></pre>
<pre><code>#&gt; [1] 0</code></pre>
<pre class="r"><code>arg_min(c(-5:-1, 1:5), function(x) x^2)</code></pre>
<pre><code>#&gt; [1] -1  1</code></pre>
<p>AR Solutions: Both functions take a vector of inputs and a function
as an argument. The function output is then used to subset the input
accordingly.</p>
<pre class="r"><code>arg_max &lt;- function(x, f) {
  y &lt;- map_dbl(x, f)
  x[y == max(y)]
}

arg_min &lt;- function(x, f) {
  y &lt;- map_dbl(x, f)
  x[y == min(y)]
}

arg_max(-10:5, function(x) x^2)</code></pre>
<pre><code>#&gt; [1] -10</code></pre>
<pre class="r"><code>arg_min(-10:5, function(x) x^2)</code></pre>
<pre><code>#&gt; [1] 0</code></pre>
<p>Notes: using <code>which()</code> is unnecessary, AR Solutions is a
better approach.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>The function below scales a vector so it falls in the range [0, 1].
How would you apply it to every column of a data frame? How would you
apply it to every numeric column in a data frame?</li>
</ol>
<pre class="r"><code>scale01 &lt;- function(x) {
  rng &lt;- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}</code></pre>
<p>Answer: code below.</p>
<pre class="r"><code># every column
modify(mtcars, scale01)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["mpg"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["cyl"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["disp"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["hp"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["drat"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["wt"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["qsec"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["vs"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["am"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["gear"],"name":[10],"type":["dbl"],"align":["right"]},{"label":["carb"],"name":[11],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.4510638","2":"0.5","3":"0.22175106","4":"0.20494700","5":"0.52534562","6":"0.28304781","7":"0.23333333","8":"0","9":"1","10":"0.5","11":"0.4285714","_rn_":"Mazda RX4"},{"1":"0.4510638","2":"0.5","3":"0.22175106","4":"0.20494700","5":"0.52534562","6":"0.34824853","7":"0.30000000","8":"0","9":"1","10":"0.5","11":"0.4285714","_rn_":"Mazda RX4 Wag"},{"1":"0.5276596","2":"0.0","3":"0.09204290","4":"0.14487633","5":"0.50230415","6":"0.20634109","7":"0.48928571","8":"1","9":"1","10":"0.5","11":"0.0000000","_rn_":"Datsun 710"},{"1":"0.4680851","2":"0.5","3":"0.46620105","4":"0.20494700","5":"0.14746544","6":"0.43518282","7":"0.58809524","8":"1","9":"0","10":"0.0","11":"0.0000000","_rn_":"Hornet 4 Drive"},{"1":"0.3531915","2":"1.0","3":"0.72062859","4":"0.43462898","5":"0.17972350","6":"0.49271286","7":"0.30000000","8":"0","9":"0","10":"0.0","11":"0.1428571","_rn_":"Hornet Sportabout"},{"1":"0.3276596","2":"0.5","3":"0.38388626","4":"0.18727915","5":"0.00000000","6":"0.49782664","7":"0.68095238","8":"1","9":"0","10":"0.0","11":"0.0000000","_rn_":"Valiant"},{"1":"0.1659574","2":"1.0","3":"0.72062859","4":"0.68197880","5":"0.20737327","6":"0.52595244","7":"0.15952381","8":"0","9":"0","10":"0.0","11":"0.4285714","_rn_":"Duster 360"},{"1":"0.5957447","2":"0.0","3":"0.18857570","4":"0.03533569","5":"0.42857143","6":"0.42879059","7":"0.65476190","8":"1","9":"0","10":"0.5","11":"0.1428571","_rn_":"Merc 240D"},{"1":"0.5276596","2":"0.0","3":"0.17385882","4":"0.15194346","5":"0.53456221","6":"0.41856303","7":"1.00000000","8":"1","9":"0","10":"0.5","11":"0.1428571","_rn_":"Merc 230"},{"1":"0.3744681","2":"0.5","3":"0.24070841","4":"0.25088339","5":"0.53456221","6":"0.49271286","7":"0.45238095","8":"1","9":"0","10":"0.5","11":"0.4285714","_rn_":"Merc 280"},{"1":"0.3148936","2":"0.5","3":"0.24070841","4":"0.25088339","5":"0.53456221","6":"0.49271286","7":"0.52380952","8":"1","9":"0","10":"0.5","11":"0.4285714","_rn_":"Merc 280C"},{"1":"0.2553191","2":"1.0","3":"0.51060115","4":"0.45229682","5":"0.14285714","6":"0.65379698","7":"0.34523810","8":"0","9":"0","10":"0.0","11":"0.2857143","_rn_":"Merc 450SE"},{"1":"0.2936170","2":"1.0","3":"0.51060115","4":"0.45229682","5":"0.14285714","6":"0.56686269","7":"0.36904762","8":"0","9":"0","10":"0.0","11":"0.2857143","_rn_":"Merc 450SL"},{"1":"0.2042553","2":"1.0","3":"0.51060115","4":"0.45229682","5":"0.14285714","6":"0.57964715","7":"0.41666667","8":"0","9":"0","10":"0.0","11":"0.2857143","_rn_":"Merc 450SLC"},{"1":"0.0000000","2":"1.0","3":"1.00000000","4":"0.54063604","5":"0.07834101","6":"0.95551010","7":"0.41428571","8":"0","9":"0","10":"0.0","11":"0.4285714","_rn_":"Cadillac Fleetwood"},{"1":"0.0000000","2":"1.0","3":"0.97006735","4":"0.57597173","5":"0.11059908","6":"1.00000000","7":"0.39523810","8":"0","9":"0","10":"0.0","11":"0.4285714","_rn_":"Lincoln Continental"},{"1":"0.1829787","2":"1.0","3":"0.92017960","4":"0.62897527","5":"0.21658986","6":"0.97980056","7":"0.34761905","8":"0","9":"0","10":"0.0","11":"0.4285714","_rn_":"Chrysler Imperial"},{"1":"0.9361702","2":"0.0","3":"0.01895735","4":"0.04946996","5":"0.60829493","6":"0.17565840","7":"0.59166667","8":"1","9":"1","10":"0.5","11":"0.0000000","_rn_":"Fiat 128"},{"1":"0.8510638","2":"0.0","3":"0.01147418","4":"0.00000000","5":"1.00000000","6":"0.02608029","7":"0.47857143","8":"1","9":"1","10":"0.5","11":"0.1428571","_rn_":"Honda Civic"},{"1":"1.0000000","2":"0.0","3":"0.00000000","4":"0.04593640","5":"0.67281106","6":"0.08233188","7":"0.64285714","8":"1","9":"1","10":"0.5","11":"0.0000000","_rn_":"Toyota Corolla"},{"1":"0.4723404","2":"0.0","3":"0.12222499","4":"0.15901060","5":"0.43317972","6":"0.24341601","7":"0.65595238","8":"1","9":"0","10":"0.0","11":"0.0000000","_rn_":"Toyota Corona"},{"1":"0.2170213","2":"1.0","3":"0.61586431","4":"0.34628975","5":"0.00000000","6":"0.51316799","7":"0.28214286","8":"0","9":"0","10":"0.0","11":"0.1428571","_rn_":"Dodge Challenger"},{"1":"0.2042553","2":"1.0","3":"0.58094288","4":"0.34628975","5":"0.17972350","6":"0.49143442","7":"0.33333333","8":"0","9":"0","10":"0.0","11":"0.1428571","_rn_":"AMC Javelin"},{"1":"0.1234043","2":"1.0","3":"0.69568471","4":"0.68197880","5":"0.44700461","6":"0.59498849","7":"0.10833333","8":"0","9":"0","10":"0.0","11":"0.4285714","_rn_":"Camaro Z28"},{"1":"0.3744681","2":"1.0","3":"0.82040409","4":"0.43462898","5":"0.14746544","6":"0.59626694","7":"0.30357143","8":"0","9":"0","10":"0.0","11":"0.1428571","_rn_":"Pontiac Firebird"},{"1":"0.7191489","2":"0.0","3":"0.01970566","4":"0.04946996","5":"0.60829493","6":"0.10790079","7":"0.52380952","8":"1","9":"1","10":"0.5","11":"0.0000000","_rn_":"Fiat X1-9"},{"1":"0.6638298","2":"0.0","3":"0.12272387","4":"0.13780919","5":"0.76958525","6":"0.16031705","7":"0.26190476","8":"0","9":"1","10":"1.0","11":"0.1428571","_rn_":"Porsche 914-2"},{"1":"0.8510638","2":"0.0","3":"0.05986530","4":"0.21554770","5":"0.46543779","6":"0.00000000","7":"0.28571429","8":"1","9":"1","10":"1.0","11":"0.1428571","_rn_":"Lotus Europa"},{"1":"0.2297872","2":"1.0","3":"0.69817910","4":"0.74911661","5":"0.67281106","6":"0.42367681","7":"0.00000000","8":"0","9":"1","10":"1.0","11":"0.4285714","_rn_":"Ford Pantera L"},{"1":"0.3957447","2":"0.5","3":"0.18433525","4":"0.43462898","5":"0.39631336","6":"0.32140118","7":"0.11904762","8":"0","9":"1","10":"1.0","11":"0.7142857","_rn_":"Ferrari Dino"},{"1":"0.1957447","2":"1.0","3":"0.57345972","4":"1.00000000","5":"0.35944700","6":"0.52595244","7":"0.01190476","8":"0","9":"1","10":"1.0","11":"1.0000000","_rn_":"Maserati Bora"},{"1":"0.4680851","2":"0.0","3":"0.12446994","4":"0.20141343","5":"0.62211982","6":"0.32395807","7":"0.48809524","8":"1","9":"1","10":"0.5","11":"0.1428571","_rn_":"Volvo 142E"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code># every numeric column
modify_if(iris, is.numeric, scale01)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["Sepal.Length"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Sepal.Width"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Petal.Length"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Petal.Width"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Species"],"name":[5],"type":["fct"],"align":["left"]}],"data":[{"1":"0.22222222","2":"0.62500000","3":"0.06779661","4":"0.04166667","5":"setosa"},{"1":"0.16666667","2":"0.41666667","3":"0.06779661","4":"0.04166667","5":"setosa"},{"1":"0.11111111","2":"0.50000000","3":"0.05084746","4":"0.04166667","5":"setosa"},{"1":"0.08333333","2":"0.45833333","3":"0.08474576","4":"0.04166667","5":"setosa"},{"1":"0.19444444","2":"0.66666667","3":"0.06779661","4":"0.04166667","5":"setosa"},{"1":"0.30555556","2":"0.79166667","3":"0.11864407","4":"0.12500000","5":"setosa"},{"1":"0.08333333","2":"0.58333333","3":"0.06779661","4":"0.08333333","5":"setosa"},{"1":"0.19444444","2":"0.58333333","3":"0.08474576","4":"0.04166667","5":"setosa"},{"1":"0.02777778","2":"0.37500000","3":"0.06779661","4":"0.04166667","5":"setosa"},{"1":"0.16666667","2":"0.45833333","3":"0.08474576","4":"0.00000000","5":"setosa"},{"1":"0.30555556","2":"0.70833333","3":"0.08474576","4":"0.04166667","5":"setosa"},{"1":"0.13888889","2":"0.58333333","3":"0.10169492","4":"0.04166667","5":"setosa"},{"1":"0.13888889","2":"0.41666667","3":"0.06779661","4":"0.00000000","5":"setosa"},{"1":"0.00000000","2":"0.41666667","3":"0.01694915","4":"0.00000000","5":"setosa"},{"1":"0.41666667","2":"0.83333333","3":"0.03389831","4":"0.04166667","5":"setosa"},{"1":"0.38888889","2":"1.00000000","3":"0.08474576","4":"0.12500000","5":"setosa"},{"1":"0.30555556","2":"0.79166667","3":"0.05084746","4":"0.12500000","5":"setosa"},{"1":"0.22222222","2":"0.62500000","3":"0.06779661","4":"0.08333333","5":"setosa"},{"1":"0.38888889","2":"0.75000000","3":"0.11864407","4":"0.08333333","5":"setosa"},{"1":"0.22222222","2":"0.75000000","3":"0.08474576","4":"0.08333333","5":"setosa"},{"1":"0.30555556","2":"0.58333333","3":"0.11864407","4":"0.04166667","5":"setosa"},{"1":"0.22222222","2":"0.70833333","3":"0.08474576","4":"0.12500000","5":"setosa"},{"1":"0.08333333","2":"0.66666667","3":"0.00000000","4":"0.04166667","5":"setosa"},{"1":"0.22222222","2":"0.54166667","3":"0.11864407","4":"0.16666667","5":"setosa"},{"1":"0.13888889","2":"0.58333333","3":"0.15254237","4":"0.04166667","5":"setosa"},{"1":"0.19444444","2":"0.41666667","3":"0.10169492","4":"0.04166667","5":"setosa"},{"1":"0.19444444","2":"0.58333333","3":"0.10169492","4":"0.12500000","5":"setosa"},{"1":"0.25000000","2":"0.62500000","3":"0.08474576","4":"0.04166667","5":"setosa"},{"1":"0.25000000","2":"0.58333333","3":"0.06779661","4":"0.04166667","5":"setosa"},{"1":"0.11111111","2":"0.50000000","3":"0.10169492","4":"0.04166667","5":"setosa"},{"1":"0.13888889","2":"0.45833333","3":"0.10169492","4":"0.04166667","5":"setosa"},{"1":"0.30555556","2":"0.58333333","3":"0.08474576","4":"0.12500000","5":"setosa"},{"1":"0.25000000","2":"0.87500000","3":"0.08474576","4":"0.00000000","5":"setosa"},{"1":"0.33333333","2":"0.91666667","3":"0.06779661","4":"0.04166667","5":"setosa"},{"1":"0.16666667","2":"0.45833333","3":"0.08474576","4":"0.04166667","5":"setosa"},{"1":"0.19444444","2":"0.50000000","3":"0.03389831","4":"0.04166667","5":"setosa"},{"1":"0.33333333","2":"0.62500000","3":"0.05084746","4":"0.04166667","5":"setosa"},{"1":"0.16666667","2":"0.66666667","3":"0.06779661","4":"0.00000000","5":"setosa"},{"1":"0.02777778","2":"0.41666667","3":"0.05084746","4":"0.04166667","5":"setosa"},{"1":"0.22222222","2":"0.58333333","3":"0.08474576","4":"0.04166667","5":"setosa"},{"1":"0.19444444","2":"0.62500000","3":"0.05084746","4":"0.08333333","5":"setosa"},{"1":"0.05555556","2":"0.12500000","3":"0.05084746","4":"0.08333333","5":"setosa"},{"1":"0.02777778","2":"0.50000000","3":"0.05084746","4":"0.04166667","5":"setosa"},{"1":"0.19444444","2":"0.62500000","3":"0.10169492","4":"0.20833333","5":"setosa"},{"1":"0.22222222","2":"0.75000000","3":"0.15254237","4":"0.12500000","5":"setosa"},{"1":"0.13888889","2":"0.41666667","3":"0.06779661","4":"0.08333333","5":"setosa"},{"1":"0.22222222","2":"0.75000000","3":"0.10169492","4":"0.04166667","5":"setosa"},{"1":"0.08333333","2":"0.50000000","3":"0.06779661","4":"0.04166667","5":"setosa"},{"1":"0.27777778","2":"0.70833333","3":"0.08474576","4":"0.04166667","5":"setosa"},{"1":"0.19444444","2":"0.54166667","3":"0.06779661","4":"0.04166667","5":"setosa"},{"1":"0.75000000","2":"0.50000000","3":"0.62711864","4":"0.54166667","5":"versicolor"},{"1":"0.58333333","2":"0.50000000","3":"0.59322034","4":"0.58333333","5":"versicolor"},{"1":"0.72222222","2":"0.45833333","3":"0.66101695","4":"0.58333333","5":"versicolor"},{"1":"0.33333333","2":"0.12500000","3":"0.50847458","4":"0.50000000","5":"versicolor"},{"1":"0.61111111","2":"0.33333333","3":"0.61016949","4":"0.58333333","5":"versicolor"},{"1":"0.38888889","2":"0.33333333","3":"0.59322034","4":"0.50000000","5":"versicolor"},{"1":"0.55555556","2":"0.54166667","3":"0.62711864","4":"0.62500000","5":"versicolor"},{"1":"0.16666667","2":"0.16666667","3":"0.38983051","4":"0.37500000","5":"versicolor"},{"1":"0.63888889","2":"0.37500000","3":"0.61016949","4":"0.50000000","5":"versicolor"},{"1":"0.25000000","2":"0.29166667","3":"0.49152542","4":"0.54166667","5":"versicolor"},{"1":"0.19444444","2":"0.00000000","3":"0.42372881","4":"0.37500000","5":"versicolor"},{"1":"0.44444444","2":"0.41666667","3":"0.54237288","4":"0.58333333","5":"versicolor"},{"1":"0.47222222","2":"0.08333333","3":"0.50847458","4":"0.37500000","5":"versicolor"},{"1":"0.50000000","2":"0.37500000","3":"0.62711864","4":"0.54166667","5":"versicolor"},{"1":"0.36111111","2":"0.37500000","3":"0.44067797","4":"0.50000000","5":"versicolor"},{"1":"0.66666667","2":"0.45833333","3":"0.57627119","4":"0.54166667","5":"versicolor"},{"1":"0.36111111","2":"0.41666667","3":"0.59322034","4":"0.58333333","5":"versicolor"},{"1":"0.41666667","2":"0.29166667","3":"0.52542373","4":"0.37500000","5":"versicolor"},{"1":"0.52777778","2":"0.08333333","3":"0.59322034","4":"0.58333333","5":"versicolor"},{"1":"0.36111111","2":"0.20833333","3":"0.49152542","4":"0.41666667","5":"versicolor"},{"1":"0.44444444","2":"0.50000000","3":"0.64406780","4":"0.70833333","5":"versicolor"},{"1":"0.50000000","2":"0.33333333","3":"0.50847458","4":"0.50000000","5":"versicolor"},{"1":"0.55555556","2":"0.20833333","3":"0.66101695","4":"0.58333333","5":"versicolor"},{"1":"0.50000000","2":"0.33333333","3":"0.62711864","4":"0.45833333","5":"versicolor"},{"1":"0.58333333","2":"0.37500000","3":"0.55932203","4":"0.50000000","5":"versicolor"},{"1":"0.63888889","2":"0.41666667","3":"0.57627119","4":"0.54166667","5":"versicolor"},{"1":"0.69444444","2":"0.33333333","3":"0.64406780","4":"0.54166667","5":"versicolor"},{"1":"0.66666667","2":"0.41666667","3":"0.67796610","4":"0.66666667","5":"versicolor"},{"1":"0.47222222","2":"0.37500000","3":"0.59322034","4":"0.58333333","5":"versicolor"},{"1":"0.38888889","2":"0.25000000","3":"0.42372881","4":"0.37500000","5":"versicolor"},{"1":"0.33333333","2":"0.16666667","3":"0.47457627","4":"0.41666667","5":"versicolor"},{"1":"0.33333333","2":"0.16666667","3":"0.45762712","4":"0.37500000","5":"versicolor"},{"1":"0.41666667","2":"0.29166667","3":"0.49152542","4":"0.45833333","5":"versicolor"},{"1":"0.47222222","2":"0.29166667","3":"0.69491525","4":"0.62500000","5":"versicolor"},{"1":"0.30555556","2":"0.41666667","3":"0.59322034","4":"0.58333333","5":"versicolor"},{"1":"0.47222222","2":"0.58333333","3":"0.59322034","4":"0.62500000","5":"versicolor"},{"1":"0.66666667","2":"0.45833333","3":"0.62711864","4":"0.58333333","5":"versicolor"},{"1":"0.55555556","2":"0.12500000","3":"0.57627119","4":"0.50000000","5":"versicolor"},{"1":"0.36111111","2":"0.41666667","3":"0.52542373","4":"0.50000000","5":"versicolor"},{"1":"0.33333333","2":"0.20833333","3":"0.50847458","4":"0.50000000","5":"versicolor"},{"1":"0.33333333","2":"0.25000000","3":"0.57627119","4":"0.45833333","5":"versicolor"},{"1":"0.50000000","2":"0.41666667","3":"0.61016949","4":"0.54166667","5":"versicolor"},{"1":"0.41666667","2":"0.25000000","3":"0.50847458","4":"0.45833333","5":"versicolor"},{"1":"0.19444444","2":"0.12500000","3":"0.38983051","4":"0.37500000","5":"versicolor"},{"1":"0.36111111","2":"0.29166667","3":"0.54237288","4":"0.50000000","5":"versicolor"},{"1":"0.38888889","2":"0.41666667","3":"0.54237288","4":"0.45833333","5":"versicolor"},{"1":"0.38888889","2":"0.37500000","3":"0.54237288","4":"0.50000000","5":"versicolor"},{"1":"0.52777778","2":"0.37500000","3":"0.55932203","4":"0.50000000","5":"versicolor"},{"1":"0.22222222","2":"0.20833333","3":"0.33898305","4":"0.41666667","5":"versicolor"},{"1":"0.38888889","2":"0.33333333","3":"0.52542373","4":"0.50000000","5":"versicolor"},{"1":"0.55555556","2":"0.54166667","3":"0.84745763","4":"1.00000000","5":"virginica"},{"1":"0.41666667","2":"0.29166667","3":"0.69491525","4":"0.75000000","5":"virginica"},{"1":"0.77777778","2":"0.41666667","3":"0.83050847","4":"0.83333333","5":"virginica"},{"1":"0.55555556","2":"0.37500000","3":"0.77966102","4":"0.70833333","5":"virginica"},{"1":"0.61111111","2":"0.41666667","3":"0.81355932","4":"0.87500000","5":"virginica"},{"1":"0.91666667","2":"0.41666667","3":"0.94915254","4":"0.83333333","5":"virginica"},{"1":"0.16666667","2":"0.20833333","3":"0.59322034","4":"0.66666667","5":"virginica"},{"1":"0.83333333","2":"0.37500000","3":"0.89830508","4":"0.70833333","5":"virginica"},{"1":"0.66666667","2":"0.20833333","3":"0.81355932","4":"0.70833333","5":"virginica"},{"1":"0.80555556","2":"0.66666667","3":"0.86440678","4":"1.00000000","5":"virginica"},{"1":"0.61111111","2":"0.50000000","3":"0.69491525","4":"0.79166667","5":"virginica"},{"1":"0.58333333","2":"0.29166667","3":"0.72881356","4":"0.75000000","5":"virginica"},{"1":"0.69444444","2":"0.41666667","3":"0.76271186","4":"0.83333333","5":"virginica"},{"1":"0.38888889","2":"0.20833333","3":"0.67796610","4":"0.79166667","5":"virginica"},{"1":"0.41666667","2":"0.33333333","3":"0.69491525","4":"0.95833333","5":"virginica"},{"1":"0.58333333","2":"0.50000000","3":"0.72881356","4":"0.91666667","5":"virginica"},{"1":"0.61111111","2":"0.41666667","3":"0.76271186","4":"0.70833333","5":"virginica"},{"1":"0.94444444","2":"0.75000000","3":"0.96610169","4":"0.87500000","5":"virginica"},{"1":"0.94444444","2":"0.25000000","3":"1.00000000","4":"0.91666667","5":"virginica"},{"1":"0.47222222","2":"0.08333333","3":"0.67796610","4":"0.58333333","5":"virginica"},{"1":"0.72222222","2":"0.50000000","3":"0.79661017","4":"0.91666667","5":"virginica"},{"1":"0.36111111","2":"0.33333333","3":"0.66101695","4":"0.79166667","5":"virginica"},{"1":"0.94444444","2":"0.33333333","3":"0.96610169","4":"0.79166667","5":"virginica"},{"1":"0.55555556","2":"0.29166667","3":"0.66101695","4":"0.70833333","5":"virginica"},{"1":"0.66666667","2":"0.54166667","3":"0.79661017","4":"0.83333333","5":"virginica"},{"1":"0.80555556","2":"0.50000000","3":"0.84745763","4":"0.70833333","5":"virginica"},{"1":"0.52777778","2":"0.33333333","3":"0.64406780","4":"0.70833333","5":"virginica"},{"1":"0.50000000","2":"0.41666667","3":"0.66101695","4":"0.70833333","5":"virginica"},{"1":"0.58333333","2":"0.33333333","3":"0.77966102","4":"0.83333333","5":"virginica"},{"1":"0.80555556","2":"0.41666667","3":"0.81355932","4":"0.62500000","5":"virginica"},{"1":"0.86111111","2":"0.33333333","3":"0.86440678","4":"0.75000000","5":"virginica"},{"1":"1.00000000","2":"0.75000000","3":"0.91525424","4":"0.79166667","5":"virginica"},{"1":"0.58333333","2":"0.33333333","3":"0.77966102","4":"0.87500000","5":"virginica"},{"1":"0.55555556","2":"0.33333333","3":"0.69491525","4":"0.58333333","5":"virginica"},{"1":"0.50000000","2":"0.25000000","3":"0.77966102","4":"0.54166667","5":"virginica"},{"1":"0.94444444","2":"0.41666667","3":"0.86440678","4":"0.91666667","5":"virginica"},{"1":"0.55555556","2":"0.58333333","3":"0.77966102","4":"0.95833333","5":"virginica"},{"1":"0.58333333","2":"0.45833333","3":"0.76271186","4":"0.70833333","5":"virginica"},{"1":"0.47222222","2":"0.41666667","3":"0.64406780","4":"0.70833333","5":"virginica"},{"1":"0.72222222","2":"0.45833333","3":"0.74576271","4":"0.83333333","5":"virginica"},{"1":"0.66666667","2":"0.45833333","3":"0.77966102","4":"0.95833333","5":"virginica"},{"1":"0.72222222","2":"0.45833333","3":"0.69491525","4":"0.91666667","5":"virginica"},{"1":"0.41666667","2":"0.29166667","3":"0.69491525","4":"0.75000000","5":"virginica"},{"1":"0.69444444","2":"0.50000000","3":"0.83050847","4":"0.91666667","5":"virginica"},{"1":"0.66666667","2":"0.54166667","3":"0.79661017","4":"1.00000000","5":"virginica"},{"1":"0.66666667","2":"0.41666667","3":"0.71186441","4":"0.91666667","5":"virginica"},{"1":"0.55555556","2":"0.20833333","3":"0.67796610","4":"0.75000000","5":"virginica"},{"1":"0.61111111","2":"0.41666667","3":"0.71186441","4":"0.79166667","5":"virginica"},{"1":"0.52777778","2":"0.58333333","3":"0.74576271","4":"0.91666667","5":"virginica"},{"1":"0.44444444","2":"0.41666667","3":"0.69491525","4":"0.70833333","5":"virginica"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>AR Solutions: To apply a function to every column of a data frame, we
can use <code>purrr::modify()</code> (or <code>purrr::map_dfr()</code>),
which also conveniently returns a data frame. To limit the application
to numeric columns, the scoped version <code>modify_if()</code> can be
used.</p>
<pre class="r"><code>modify_if(mtcars, is.numeric, scale01)</code></pre>
<hr />
</div>
<div id="exercises-3" class="section level2">
<h2>9.7.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>How does <code>apply()</code> arrange the output? Read the
documentation and perform some experiments.</li>
</ol>
<pre class="r"><code># experiments
m1 &lt;- matrix(1:4, nrow = 1)
apply(m1, 1, sum)
apply(m1, 2, sum)
apply(m1, c(1, 2), `*`, 2)
apply(m1, 1, `*`, 2)
apply(m1, 1, `*`, 2, simplify = FALSE)
apply(m1, 2, `*`, 2)
apply(m1, 1, sum, simplify = FALSE)

m1a &lt;- matrix(1:4, ncol = 1)
apply(m1a, 1, `*`, 2)

m2 &lt;- matrix(1:20, ncol = 4)
apply(m2, 1, sum)

m3 &lt;- array(1:24, dim = c(2, 3, 4))
apply(m3, 1, sum)
apply(m3, 2, sum)
apply(m3, 3, sum)
apply(m3, 1, `*`, 2)
apply(m3, 2, `*`, 2)
apply(m3, 3, `*`, 2)
apply(m3, c(1, 2, 3), `*`, 2)</code></pre>
<p>Answer: the documentation states:</p>
<blockquote>
<p>If each call to <code>FUN</code> returns a vector of length
<code>n</code>, and simplify is <code>TRUE</code>, then apply returns an
array of dimension <code>c(n, dim(X)[MARGIN])</code> if
<code>n &gt; 1</code>. If <code>n</code> equals 1, <code>apply</code>
returns a vector if <code>MARGIN</code> has length 1 and an array of
<code>dimension dim(X)[MARGIN]</code> otherwise. If <code>n</code> is 0,
the result has length 0 but not necessarily the ‘correct’ dimension.</p>
<p>If the calls to <code>FUN</code> return vectors of different lengths,
or if simplify is <code>FALSE</code>, apply returns a list of
<code>length prod(dim(X)[MARGIN])</code> with <code>dim</code> set to
<code>MARGIN</code> if this has length greater than one.</p>
</blockquote>
<p>With exploration, under normal circumstances:</p>
<ul>
<li>If <code>MARGIN</code> includes all dimensions of an array or matrix
(<code>c(1, 2)</code> or <code>c(1, 2, 3)</code>), the output is
arranged in the same shape as the input</li>
<li>Otherwise, the return value drops a dimension if modifying a vector
in place (as with <code>*</code>), or returns a vector when summarizing
(as with <code>sum</code>)</li>
<li>Matrices of a single row are simplified to a vector</li>
<li>Matrices of a single column are returned as a matrix</li>
<li>When <code>simplify = FALSE</code> is set, a list is returned</li>
</ul>
<p>However, even with all this, the “rules” aren’t clear to me.</p>
<p>AR Solutions: Basically <code>apply()</code> applies a function over
the margins of an array. In the two-dimensional case, the margins are
just the rows and columns of a matrix. Let’s make this concrete.</p>
<pre class="r"><code>arr2 &lt;- array(1:12, dim = c(3, 4))
rownames(arr2) &lt;- paste0(&quot;row&quot;, 1:3)
colnames(arr2) &lt;- paste0(&quot;col&quot;, 1:4)
arr2</code></pre>
<pre><code>#&gt;      col1 col2 col3 col4
#&gt; row1    1    4    7   10
#&gt; row2    2    5    8   11
#&gt; row3    3    6    9   12</code></pre>
<p>When we apply the <code>head()</code> function over the first margin
of <code>arr2()</code> (i.e. the rows), the results are contained in the
columns of the output, transposing the array compared to the original
input.</p>
<pre class="r"><code>apply(arr2, 1, function(x) x[1:2])</code></pre>
<pre><code>#&gt;      row1 row2 row3
#&gt; col1    1    2    3
#&gt; col2    4    5    6</code></pre>
<p>And vice versa if we apply over the second margin (the columns):</p>
<pre class="r"><code>apply(arr2, 2, function(x) x[1:2])</code></pre>
<pre><code>#&gt;      col1 col2 col3 col4
#&gt; row1    1    4    7   10
#&gt; row2    2    5    8   11</code></pre>
<p>The output of <code>apply()</code> is organised first by the margins
being operated over, then the results of the function. This can become
quite confusing for higher dimensional arrays.</p>
<p>Notes: AR Solutions’ explanation is better, but the output is still
confusing.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>What do <code>eapply()</code> and <code>rapply()</code> do? Does
purrr have equivalents?</li>
</ol>
<p>Answer: <code>eapply()</code> applies a function to named values in
an environment. <code>rapply()</code> is a recursive
<code>lapply()</code>. There are no equivalents in purrr.</p>
<p>AR Solutions: <code>eapply()</code> is a variant of
<code>lapply()</code>, which iterates over the (named) elements of an
environment. In <code>purrr</code> there is no equivalent for
<code>eapply()</code> as <code>purrr</code> mainly provides functions
that operate on vectors and functions, but not on environments.</p>
<p><code>rapply()</code> applies a function to all elements of a list
recursively. This function makes it possible to limit the application of
the function to specified classes (default <code>classes = ANY</code>).
One may also specify how elements of other classes should remain: as
their identity (<code>how = replace</code>) or another value
(<code>default = NULL</code>). The closest equivalent in
<code>purrr</code> is <code>modify_depth()</code>, which allows you to
modify elements at a specified depth in a nested list.</p>
<p>Notes: I wasn’t aware of <code>purrr::modify_depth()</code>.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Challenge: read about the <a
href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html#%25_idx_1096">fixed
point algorithm</a>. Complete the exercises using R.</li>
</ol>
<p>Answer: the fixed point algorithm is defined below, with an example
solution:</p>
<pre><code>(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point cos 1.0)
0.7390822985224023

(fixed-point (lambda (y) (+ (sin y) (cos y)))
             1.0)
1.2587315962971173

(define (sqrt x)
  (fixed-point (lambda (y) (/ x y))
               1.0))</code></pre>
<p>Implementation in R:</p>
<pre class="r"><code>fixed_point &lt;- function(f, x) {
  tolerance &lt;- 0.00001
  close_enough &lt;- function(v1, v2) {
    abs(v1 - v2) &lt; tolerance
  }

  if (close_enough(f(x), x)) {
    f(x)
  } else {
    fixed_point(f, f(x))
  }
}

fixed_point(cos, 1.0)</code></pre>
<pre><code>#&gt; [1] 0.7390823</code></pre>
<pre class="r"><code>fixed_point(function(y) sin(y) + cos(y), 1.0)</code></pre>
<pre><code>#&gt; [1] 1.258732</code></pre>
<p>AR Solutions: A number <span class="math inline">\(x\)</span> is
called a fixed point of a function <span
class="math inline">\(f\)</span> if it satisfies the equation <span
class="math inline">\(f(x) = x\)</span>. For some functions we may find
a fixed point by beginning with a starting value and applying <span
class="math inline">\(f\)</span> repeatedly. Here
<code>fixed_point()</code> acts as a functional because it takes a
function as an argument.</p>
<pre class="r"><code>fixed_point_ar &lt;- function(f, x_init, n_max = 10000, tol = 0.0001) {
  n &lt;- 0
  x &lt;- x_init
  y &lt;- f(x)

  is_fixed_point &lt;- function(x, y) {
    abs(x - y) &lt; tol
  }

  while (!is_fixed_point(x, y)) {
    x &lt;- y
    y &lt;- f(y)

    # Make sure we eventually stop
    n &lt;- n + 1
    if (n &gt; n_max) {
      stop(&quot;Failed to converge.&quot;, call. = FALSE)
    }
  }

  x
}

# Functions with fixed points
fixed_point_ar(sin, x_init = 1)</code></pre>
<pre><code>#&gt; [1] 0.08430922</code></pre>
<pre class="r"><code>fixed_point_ar(cos, x_init = 1)</code></pre>
<pre><code>#&gt; [1] 0.7391302</code></pre>
<pre class="r"><code># Functions without fixed points
add_one &lt;- function(x) x + 1
try(fixed_point_ar(add_one, x_init = 1))</code></pre>
<pre><code>#&gt; Error : Failed to converge.</code></pre>
<p>Notes: AR Solutions offers a different approach using a
<code>while()</code> loop that is guaranteed to stop. My approach using
recursive calls does stop eventually with a stack limit error (however,
this stops <code>build_analysis_site()</code>):</p>
<pre class="r"><code>fixed_point(add_one, 1)</code></pre>
<p>Comparing benchmarks:</p>
<pre class="r"><code>bench::mark(fixed_point_ar(cos, x_init = 1, tol = 0.00001))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                        min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                                   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 fixed_point_ar(cos, x_init = 1, tol = 1e-05)   19.6µs     23µs    40486.        0B     8.10</code></pre>
<pre class="r"><code>bench::mark(fixed_point(cos, 1))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression               min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;          &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 fixed_point(cos, 1)   50.2µs   61.5µs    15554.        0B     8.69</code></pre>
<p>As usual, AR Solutions is faster. :-(</p>
<hr />
</div>
</div>
<div id="function-factories" class="section level1">
<h1>10 Function factories</h1>
<pre class="r"><code>rm(list = ls())</code></pre>
<p>A <strong>function factory</strong> is a function that makes
functions. Here’s a very simple example: we use a function factory
(<code>power1()</code>) to make two child functions
(<code>square()</code> and <code>cube()</code>):</p>
<pre class="r"><code>power1 &lt;- function(exp) {
  function(x) {
    x^exp
  }
}
square &lt;- power1(2)
cube &lt;- power1(3)</code></pre>
<p>Don’t worry if this doesn’t make sense yet, it should by the end of
the chapter!</p>
<p>I’ll call <code>square()</code> and <code>cube()</code>
<strong>manufactured functions</strong>, but this is just a term to ease
communication with other humans: from R’s perspective they are no
different to functions created any other way.</p>
<pre class="r"><code>square(3)</code></pre>
<pre><code>#&gt; [1] 9</code></pre>
<pre class="r"><code>cube(3)</code></pre>
<pre><code>#&gt; [1] 27</code></pre>
<p>You have already learned about the individual components that make
function factories possible:</p>
<ul>
<li><p>In Section 6.2.3, you learned about R’s first-class functions. In
R, you bind a function to a name in the same way as you bind any object
to a name: with <code>&lt;-</code>.</p></li>
<li><p>In Section 7.4.2, you learned that a function captures (encloses)
the environment in which it is created.</p></li>
<li><p>In Section 7.4.4, you learned that a function creates a new
execution environment every time it is run. This environment is usually
ephemeral, but here it becomes the enclosing environment of the
manufactured function.</p></li>
</ul>
<p>In this chapter, you’ll learn how the non-obvious combination of
these three features leads to the function factory. You’ll also see
examples of their usage in visualisation and statistics.</p>
<p>Of the three main functional programming tools (functionals, function
factories, and function operators), function factories are the least
used. Generally, they don’t tend to reduce overall code complexity but
instead partition complexity into more easily digested chunks. Function
factories are also an important building block for the very useful
function operators, which you’ll learn about in Chapter 11.</p>
<div id="exercises-4" class="section level2">
<h2>10.2.6 Exercises</h2>
<ol style="list-style-type: decimal">
<li>The definition of <code>force()</code> is simple:</li>
</ol>
<pre class="r"><code>force</code></pre>
<pre><code>#&gt; function (x) 
#&gt; x
#&gt; &lt;bytecode: 0x7fecac868b08&gt;
#&gt; &lt;environment: namespace:base&gt;</code></pre>
<p>Why is it better to <code>force(x)</code> instead of just
<code>x</code>?</p>
<p>Answer: as the R Documentation states, ‘This is semantic sugar’: in
other words, <code>force(x)</code> makes the intent of the call
explicit, to force evaluation, whereas <code>x</code> does not.</p>
<p>AR Solutions: As you can see <code>force(x)</code> is similar to
<code>x</code>. As mentioned in <em>Advanced R</em>, we prefer this
explicit form, because</p>
<blockquote>
<p>using this function clearly indicates that you’re forcing evaluation,
not that you’ve accidentally typed <code>x</code>.”</p>
</blockquote>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Base R contains two function factories, <code>approxfun()</code> and
<code>ecdf()</code>. Read their documentation and experiment to figure
out what the functions do and what they return.</li>
</ol>
<pre class="r"><code>x &lt;- c(1, 3, 6, 10, 19)
y &lt;- x * 2
plot(x, y, xlim = c(0, 20), ylim = c(0, 40))</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-57-1.png" width="768" style="display: block; margin: auto;" /></p>
<pre class="r"><code>af &lt;- approxfun(x, y)
plot(0:20, af(0:20), xlim = c(0, 20), ylim = c(0, 40))</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-57-2.png" width="768" style="display: block; margin: auto;" /></p>
<p>Answer: <code>approxfun()</code> returns “a function performing the
linear (or constant) interpolation.” As the example above shows,
<code>approxfun()</code> provides linear interpolation that by default
does not return values outside the minimum and maximum.</p>
<pre class="r"><code>plot(ecdf(rlnorm(1000)))</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-58-1.png" width="768" style="display: block; margin: auto;" /></p>
<pre class="r"><code>plot(ecdf(rnorm(1000)))</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-58-2.png" width="768" style="display: block; margin: auto;" /></p>
<pre class="r"><code>plot(ecdf(runif(1000)))</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-58-3.png" width="768" style="display: block; margin: auto;" /></p>
<p><code>ecdf()</code> “Compute[s] an empirical cumulative distribution
function”, the Empirical Cumulative Distribution Function, which is a
standard statistical plot. It plots the actual observations connected by
a line, which is easier to see with fewer observations:</p>
<pre class="r"><code>plot(ecdf(runif(50)))</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-59-1.png" width="768" style="display: block; margin: auto;" /></p>
<p>AR Solutions: (Note: full solution <a
href="https://advanced-r-solutions.rbind.io/function-factories.html#factory-fundamentals">here</a>)</p>
<p>Let’s begin with <code>approxfun()</code> as it is used within
<code>ecdf()</code> as well:</p>
<p><code>approxfun()</code> takes a combination of data points (x and y
values) as input and returns a stepwise linear (or constant)
interpolation function. To find out what this means exactly, we first
create a few random data points.</p>
<p>Next, we use <code>approxfun()</code> to construct the linear and
constant interpolation functions for our <code>x</code> and
<code>y</code> values.</p>
<p>When we apply these functions to new x values, these are mapped to
the lines connecting the initial y values (linear case) or to the same y
value as for the next smallest initial x value (constant case).</p>
<p>However, both functions are only defined within
<code>range(x)</code>.</p>
<p>To change this behaviour, one can set <code>rule = 2</code>. This
leads to the result that for values outside of <code>range(x)</code> the
boundary values of the function are returned.</p>
<p>Another option is to customise the return values as individual
constants for each side via <code>yleft</code> and/or
<code>yright</code>.</p>
<p>Further, <code>approxfun()</code> provides the option to shift the y
values for <code>method = "constant"</code> between their left and right
values. According to the documentation this indicates a compromise
between left- and right-continuous steps.</p>
<p>Finally, the <code>ties</code> argument allows to aggregate y values
if multiple ones were provided for the same x value. For example, in the
following line we use <code>mean()</code> to aggregate these y values
before they are used for the interpolation
<code>approxfun(x = c(1,1,2), y = 1:3, ties = mean)</code>.</p>
<p>Next, we focus on <code>ecdf()</code>. “ecdf” is an acronym for
empirical cumulative distribution function. For a numeric vector of
density values, <code>ecdf()</code> initially creates the (x, y) pairs
for the nodes of the density function and then passes these pairs to
<code>approxfun()</code>, which gets called with specifically adapted
settings
(<code>approxfun(vals, cumsum(tabulate(match(x, vals)))/n, method = "constant", yleft = 0, yright = 1, f = 0, ties = "ordered")</code>).</p>
<p>New values are then mapped on the y value of the next smallest x
value from within the initial input.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Create a function <code>pick()</code> that takes an index,
<code>i</code>, as an argument and returns a function with an argument
<code>x</code> that subsets <code>x</code> with <code>i</code>.</li>
</ol>
<pre class="r"><code>pick &lt;- function(i) {
  function(x) x[[i]]
}

x &lt;- 2:8
pick(1)(x)</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<pre class="r"><code># should be equivalent to
x[[1]]</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<pre class="r"><code>unlist(lapply(mtcars, pick(5)))</code></pre>
<pre><code>#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb 
#&gt;  18.70   8.00 360.00 175.00   3.15   3.44  17.02   0.00   0.00   3.00   2.00</code></pre>
<pre class="r"><code># should be equivalent to
unlist(lapply(mtcars, function(x) x[[5]]))</code></pre>
<pre><code>#&gt;    mpg    cyl   disp     hp   drat     wt   qsec     vs     am   gear   carb 
#&gt;  18.70   8.00 360.00 175.00   3.15   3.44  17.02   0.00   0.00   3.00   2.00</code></pre>
<p>Answer: code above. Modified to use <code>unlist()</code> to shorten
output.</p>
<p>AR Solutions: In this exercise <code>pick(i)</code> acts as a
function factory, which returns the required subsetting function.</p>
<pre class="r"><code>pick &lt;- function(i) {
  force(i)
  function(x) x[[i]]
}</code></pre>
<p>Note: the AR Solutions version appropriately uses
<code>force()</code>.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Create a function that creates functions that compute the
i<sup>th</sup> <a
href="https://en.wikipedia.org/wiki/Central_moment">central moment</a>
of a numeric vector. You can test it by running the following code:</li>
</ol>
<pre class="r"><code>moment &lt;- function(i) {
  function(x) mean((x - mean(x))^i)
}

m1 &lt;- moment(1)
m2 &lt;- moment(2)
x &lt;- runif(100)
stopifnot(
  all.equal(m1(x), 0),
  all.equal(m2(x), var(x) * 99 / 100)
)
bench::mark(m2(x))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 m2(x)        7.26µs   8.19µs   106083.      848B     10.6</code></pre>
<p>Answer: code above, following the formula <span
class="math inline">\(E[(X - E[X])^i]\)</span>, where <span
class="math inline">\(E\)</span> is the <a
href="https://en.wikipedia.org/wiki/Expected_value">expected value</a>,
ie the <em>mean</em>.</p>
<p>AR Solutions: The first moment is closely related to the mean and
describes the average deviation from the mean, which is 0 (within
numerical margin of error). The second moment describes the variance of
the input data. If we want to compare it to <code>var()</code>, we need
to undo <a
href="https://en.wikipedia.org/wiki/Bessel%27s_correction">Bessel’s
correction</a> by multiplying with <span
class="math inline">\(\frac{N-1}{N}\)</span>.</p>
<pre class="r"><code>moment &lt;- function(i) {
  force(i)

  function(x) sum((x - mean(x))^i) / length(x)
}
m1 &lt;- moment(1)
m2 &lt;- moment(2)
x &lt;- runif(100)
all.equal(m1(x), 0) # removed stopifnot() for clarity</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>all.equal(m2(x), var(x) * 99 / 100)</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>bench::mark(m2(x))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 m2(x)         4.9µs   5.34µs   172963.      848B        0</code></pre>
<p>Note: isn’t <code>sum() / length()</code> just <code>mean()</code>?
For fun, compare <code>bench::mark()</code> (above). Curses, foiled
again!</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>What happens if you don’t use a closure? Make predictions, then
verify with the code below.</li>
</ol>
<pre class="r"><code>i &lt;- 0
new_counter2 &lt;- function() {
  i &lt;&lt;- i + 1 # nolint: undesirable_operator_linter. use of `&lt;&lt;-` is intended here.
  i
}</code></pre>
<p>Answer: <code>i</code> should increment by 1 every time
<code>new_counter2()</code> is run, but can be altered by changing the
global variable <code>i</code>. [Correct!]</p>
<pre class="r"><code>new_counter2()</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>new_counter2()</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<pre class="r"><code>new_counter2()</code></pre>
<pre><code>#&gt; [1] 3</code></pre>
<pre class="r"><code>i &lt;- 5
new_counter2()</code></pre>
<pre><code>#&gt; [1] 6</code></pre>
<pre class="r"><code>i &lt;- 0</code></pre>
<p>AR Solutions: Without the captured and encapsulated environment of a
closure the counts will be stored in the global environment. Here they
can be overwritten or deleted as well as interfere with other
counters.</p>
<pre class="r"><code>new_counter2()</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>i</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>new_counter2()</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<pre class="r"><code>i</code></pre>
<pre><code>#&gt; [1] 2</code></pre>
<pre class="r"><code>i &lt;- 0
new_counter2()</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>i</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>i &lt;- 0</code></pre>
<hr />
<ol start="6" style="list-style-type: decimal">
<li>What happens if you use <code>&lt;-</code> instead of
<code>&lt;&lt;-</code>? Make predictions, then verify with the code
below.</li>
</ol>
<pre class="r"><code>new_counter3 &lt;- function() {
  i &lt;- 0 # nolint: object_usage_linter.
  function() {
    i &lt;- i + 1
    i
  }
}</code></pre>
<p>Answer: functions created by <code>new_counter3()</code> starts with
a new value of <code>i &lt;- 0</code> each time, and will always return
1. [Correct!]</p>
<pre class="r"><code>nc3 &lt;- new_counter3()

nc3()</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<pre class="r"><code>nc3()</code></pre>
<pre><code>#&gt; [1] 1</code></pre>
<p>AR Solutions: Without the super assignment <code>&lt;&lt;-</code>,
the counter will always return 1. The counter always starts in a new
execution environment within the same enclosing environment, which
contains an unchanged value for <code>i</code> (in this case it remains
0).</p>
<hr />
</div>
<div id="exercises-5" class="section level2">
<h2>10.3.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Compare and contrast <code>ggplot2::label_bquote()</code> with
<code>scales::number_format()</code></li>
</ol>
<p>Answer: <code>ggplot2::label_bquote()</code> “offers a flexible way
of labelling facet rows or columns with plotmath expressions. Backquoted
variables will be replaced with their value in the facet.”</p>
<p>The example shows a scatterplot of weight and miles per gallon
faceted by engine type (v-shaped).</p>
<pre class="r"><code>ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  facet_grid(vs ~ ., labeller = label_bquote(vs == .(vs)))</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-69-1.png" width="768" style="display: block; margin: auto;" /></p>
<p><code>scales::number_format()</code> has been superseded by
<code>scales::label_number()</code>:</p>
<p>“Use <code>label_number()</code> force decimal display of numbers
(i.e. don’t use scientific notation). <code>label_comma()</code> is a
special case that inserts a comma every three digits.”</p>
<pre class="r"><code>demo_continuous(c(-1e6, 1e6), labels = label_number())</code></pre>
<pre><code>#&gt; scale_x_continuous(labels = label_number())</code></pre>
<p><img src="advanced-r-2_files/figure-html/unnamed-chunk-70-1.png" width="768" style="display: block; margin: auto;" /></p>
<p><code>ggplot2::label_bquote()</code> is a special-purpose function
for facets, while <code>scales::number_format()</code> can be applied
more generally. Both are function factories that can be applied to
changing labels.</p>
<p>AR Solutions: Both functions will help you in styling your output,
e.g. in your plots and they do this by returning the desired formatting
function to you.</p>
<p><code>ggplot2::label_bquote()</code> takes relatively straightforward
<a
href="https://stat.ethz.ch/R-manual/R-patched/library/grDevices/html/plotmath.html">plotmath</a>
expressions and uses them for faceting labels in <code>{ggplot2}</code>.
Because this function is used in <code>{ggplot2}</code> it needs to
return a function of <code>class = "labeller"</code>.</p>
<p><code>scales::number_format()</code> initially <code>force()</code>s
the computation of all parameters. It’s essentially a parametrised
wrapper around <code>scales::number()</code> and will help you format
numbers appropriately. It will return a simple function.</p>
<hr />
</div>
<div id="exercises-6" class="section level2">
<h2>10.4.4 Exercises</h2>
<ol style="list-style-type: decimal">
<li>In <code>boot_model()</code>, why don’t I need to force the
evaluation of <code>df</code> or <code>model</code>?</li>
</ol>
<p>Answer: assuming <code>model</code> actually refers to
<code>formula</code>, both are evaluated when
<code>mod &lt;- lm(formula, data = df)</code> is run.</p>
<p>AR Solutions: <code>boot_model()</code> ultimately returns a
function, and whenever you return a function you need to make sure all
the inputs are explicitly evaluated. Here that happens automatically
because we use <code>df</code> and <code>formula</code> in
<code>lm()</code> before returning the function.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Why might you formulate the Box-Cox transformation like this?</li>
</ol>
<pre class="r"><code>boxcox3 &lt;- function(x) {
  function(lambda) {
    if (lambda == 0) {
      log(x)
    } else {
      (x^lambda - 1) / lambda
    }
  }
}</code></pre>
<p>Answer: <code>boxcox3</code> returns a function where <code>x</code>
is fixed and <code>lambda</code> can vary, which allows for easy
exploration of different values of lambda, for example using
<code>lapply()</code> or <code>optimize()</code>.</p>
<p>AR Solutions: <code>boxcox3()</code> returns a function where
<code>x</code> is fixed (though it is not forced, so it may be
manipulated later). This allows us to apply and test different
transformations for different inputs and give them a descriptive
name.</p>
<p>Note: I missed the fact that <code>x</code> is not forced.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Why don’t you need to worry that <code>boot_permute()</code> stores
a copy of the data inside the function that it generates?</li>
</ol>
<p>Answer: as R is copy-on-write, and <code>boot_permute()</code> stores
an unmodified copy of the data, the function contains only a reference
to the original data.</p>
<p>AR Solutions: We don’t need to worry that it stores a copy of the
data, because it actually doesn’t store one; it’s just a name that
points to the same underlying object in memory.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>How much time does <code>ll_poisson2()</code> save compared to
<code>ll_poisson1()</code>? Use <code>bench::mark()</code> to see how
much faster the optimisation occurs. How does changing the length of
<code>x</code> change the results?</li>
</ol>
<pre class="r"><code>ll_poisson1 &lt;- function(x) {
  n &lt;- length(x)

  function(lambda) {
    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))
  }
}

ll_poisson2 &lt;- function(x) {
  n &lt;- length(x)
  sum_x &lt;- sum(x)
  c &lt;- sum(lfactorial(x))

  function(lambda) {
    log(lambda) * sum_x - n * lambda - c
  }
}

x1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)

bench::mark(optimize(ll_poisson1(x1), c(0, 100), maximum = TRUE))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                                min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                                           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 optimize(ll_poisson1(x1), c(0, 100), maximum = TRUE)   29.7µs     36µs    26193.        0B     7.86</code></pre>
<pre class="r"><code>bench::mark(optimize(ll_poisson2(x1), c(0, 100), maximum = TRUE))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                                min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                                           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 optimize(ll_poisson2(x1), c(0, 100), maximum = TRUE)   18.7µs   21.7µs    43671.        0B     8.74</code></pre>
<pre class="r"><code>x &lt;- rpois(1e3, 100L)
bench::mark(optimize(ll_poisson1(x), c(0, 100), maximum = TRUE))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                               min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                                          &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 optimize(ll_poisson1(x), c(0, 100), maximum = TRUE)    319µs    366µs     2684.     110KB     4.23</code></pre>
<pre class="r"><code>bench::mark(optimize(ll_poisson2(x), c(0, 100), maximum = TRUE))</code></pre>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   expression                                               min   median `itr/sec` mem_alloc `gc/sec`
#&gt;   &lt;bch:expr&gt;                                          &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;
#&gt; 1 optimize(ll_poisson2(x), c(0, 100), maximum = TRUE)   41.3µs   46.1µs    20468.    7.86KB     4.19</code></pre>
<p>Answer: <code>ll_poisson2()</code> is nearly twice as fast with
<code>x1</code> and nearly 10 times as fast when the length of
<code>x</code> is 100.</p>
<p>Notes: consulting AR Solutions was needed to understand how to
benchmark the two functions.</p>
<p>AR Solutions:</p>
<p>A benchmark on <code>x1</code> reveals a performance improvement of
factor 2 for <code>ll_poisson2()</code> over
<code>ll_poisson1()</code></p>
<p>As the redundant calculations within <code>ll_poisson1()</code>
become more expensive with growing length of <code>x1</code>, we expect
even further relative performance improvements for
<code>ll_poisson2()</code>. The following benchmark reveals a relative
performance improvement of factor 20 for <code>ll_poisson2()</code> when
<code>x1</code> is of length 100,000.</p>
<hr />
</div>
<div id="exercises-7" class="section level2">
<h2>10.5.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li><p>Which of the following commands is equivalent to
<code>with(x, f(z))</code>?</p>
<ol style="list-style-type: lower-alpha">
<li><code>x$f(x$z)</code>.</li>
<li><code>f(x$z)</code>.</li>
<li><code>x$f(z)</code>.</li>
<li><code>f(z)</code>.</li>
<li>It depends.</li>
</ol></li>
</ol>
<p>Answer: (e). depending on the value of <code>x</code>, it could be
any of (a) through (d).</p>
<p>AR Solutions: (e) “It depends” is the correct answer. Usually
<code>with()</code> is used with a data frame, so you’d usually expect
(b), but if <code>x</code> is a list, it could be any of the
options.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Compare and contrast the effects of <code>env_bind()</code>
vs. <code>attach()</code> for the following code.</li>
</ol>
<pre class="r"><code>funs &lt;- list(
  mean = function(x) mean(x, na.rm = TRUE),
  sum = function(x) sum(x, na.rm = TRUE)
)

# nolint start: undesirable_function_linter.
attach(funs)</code></pre>
<pre><code>#&gt; The following objects are masked from package:base:
#&gt; 
#&gt;     mean, sum</code></pre>
<pre class="r"><code>mean &lt;- function(x) stop(&quot;Hi!&quot;)
detach(funs)
# nolint end

env_bind(globalenv(), !!!funs)
mean &lt;- function(x) stop(&quot;Hi!&quot;)
env_unbind(globalenv(), names(funs))</code></pre>
<p>Answer: <code>attach()</code> places the function names in the search
path, and the <code>env_bind()</code> code places the function names in
the global environment. Both have the effect of masking
<code>mean()</code> and <code>sum()</code>, but as the chapter points
out, when unbinding, “there’s no guarantee that they haven’t been
rebound in the meantime, and you might be deleting an object that
someone else created.”</p>
<p>AR Solutions: <code>attach()</code> adds <code>funs</code> to the
search path. Therefore, the provided functions are found before their
respective versions from the <code>{base}</code> package. Further, they
cannot get accidentally overwritten by similar named functions in the
global environment. One annoying downside of using <code>attach()</code>
is the possibility to attach the same object multiple times, making it
necessary to call <code>detach()</code> equally often.</p>
<p>In contrast <code>rlang::env_bind()</code> just adds the functions in
<code>fun</code> to the global environment. No further side effects are
introduced, and the functions are overwritten when similarly named
functions are defined.</p>
<p>Notes: AR Solutions provides a more complete answer.</p>
<hr />
</div>
</div>
<div id="function-operators" class="section level1">
<h1>11 Function operators</h1>
<pre class="r"><code>rm(list = ls())</code></pre>
<p>In this chapter, you’ll learn about function operators. A
<strong>function operator</strong> is a function that takes one (or
more) functions as input and returns a function as output. The following
code shows a simple function operator, <code>chatty()</code>. It wraps a
function, making a new function that prints out its first argument. You
might create a function like this because it gives you a window to see
how functionals, like <code>map_int()</code>, work.</p>
<pre class="r"><code>chatty &lt;- function(f) {
  force(f)

  function(x, ...) {
    res &lt;- f(x, ...)
    cat(&quot;Processing &quot;, x, &quot;\n&quot;, sep = &quot;&quot;)
    res
  }
}
f &lt;- function(x) x^2
s &lt;- c(3, 2, 1)
purrr::map_dbl(s, chatty(f))</code></pre>
<pre><code>#&gt; Processing 3
#&gt; Processing 2
#&gt; Processing 1</code></pre>
<pre><code>#&gt; [1] 9 4 1</code></pre>
<p>Function operators are closely related to function factories; indeed
they’re just a function factory that takes a function as input. Like
factories, there’s nothing you can’t do without them, but they often
allow you to factor out complexity in order to make your code more
readable and reusable.</p>
<p>Function operators are typically paired with functionals. If you’re
using a for-loop, there’s rarely a reason to use a function operator, as
it will make your code more complex for little gain.</p>
<p>If you’re familiar with Python, decorators is just another name for
function operators.</p>
<div id="exercises-8" class="section level2">
<h2>11.2.3 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Base R provides a function operator in the form of
<code>Vectorize()</code>. What does it do? When might you use it?</li>
</ol>
<p>Answer: according to the R documentation, “<code>Vectorize</code>
creates a function wrapper that vectorizes the action of its argument
<code>FUN</code>.” “The arguments named in the
<code>vectorize.args</code> argument to <code>Vectorize</code> are the
arguments passed in the <code>...</code> list to <code>mapply</code>.
Only those that are actually passed will be vectorized; default values
will not.” and returns “A function with the same arguments as
<code>FUN</code>, wrapping a call to <code>mapply</code>.”</p>
<p>In other words, it is a function operator that uses
<code>mapply()</code> to iterate across the arguments. This is
potentially simpler to understand than use of <code>mapply()</code>.</p>
<p>In the R documentation example, the vectorized <code>rep.int</code>
is called for each pair of values:</p>
<pre class="r"><code>vrep &lt;- Vectorize(rep.int)
vrep(1:4, 4:1)</code></pre>
<pre><code>#&gt; [[1]]
#&gt; [1] 1 1 1 1
#&gt; 
#&gt; [[2]]
#&gt; [1] 2 2 2
#&gt; 
#&gt; [[3]]
#&gt; [1] 3 3
#&gt; 
#&gt; [[4]]
#&gt; [1] 4</code></pre>
<p>AR Solutions: In R a lot of functions are “vectorised”. Vectorised
has two meanings. First, it means (broadly) that a function inputs a
vector or vectors and does something to each element. Secondly, it
usually implies that these operations are implemented in a compiled
language such as C or Fortran, so that the implementation is very
fast.</p>
<p>However, despite what the function’s name implies,
<code>Vectorize()</code> is not able to speed up the provided function.
It rather changes the input format of the supplied arguments
(<code>vectorize.args</code>), so that they can be iterated over.</p>
<p><code>Vectorize()</code> provides a convenient and concise notation
to iterate over multiple arguments but has some major drawbacks that
mean you generally shouldn’t use it. See <a
href="https://www.jimhester.com/post/2018-04-12-vectorize/">this
post</a> for more details.</p>
<p>Notes: Jim Hester’s article points out that most R functions are
already vectorized, including <code>paste()</code>!</p>
<pre class="r"><code>color &lt;- c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;)
object &lt;- c(&quot;ball&quot;, &quot;hat&quot;, &quot;coat&quot;)
name &lt;- c(&quot;Sally&quot;, &quot;Hank&quot;, &quot;Darla&quot;)

paste(&quot;A&quot;, color, object, &quot;for&quot;, name)</code></pre>
<pre><code>#&gt; [1] &quot;A blue ball for Sally&quot;  &quot;A red hat for Hank&quot;     &quot;A green coat for Darla&quot;</code></pre>
<p>It also argues against use of <code>Vectorize()</code> because a) the
functions it generates are not type stable, b) obfuscates the function
code, c) can degrade performance, and d) can’t improve performance.</p>
<p>He recommends using existing vectorized functions and either
<code>vapply()</code> or <code>map()</code>.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Read the source code for <code>possibly()</code>. How does it
work?</li>
</ol>
<pre class="r"><code>possibly</code></pre>
<pre><code>#&gt; function (.f, otherwise, quiet = TRUE) 
#&gt; {
#&gt;     .f &lt;- as_mapper(.f)
#&gt;     force(otherwise)
#&gt;     function(...) {
#&gt;         tryCatch(.f(...), error = function(e) {
#&gt;             if (!quiet) 
#&gt;                 message(&quot;Error: &quot;, e$message)
#&gt;             otherwise
#&gt;         }, interrupt = function(e) {
#&gt;             stop(&quot;Terminated by user&quot;, call. = FALSE)
#&gt;         })
#&gt;     }
#&gt; }
#&gt; &lt;bytecode: 0x7fec8c975958&gt;
#&gt; &lt;environment: namespace:purrr&gt;</code></pre>
<p>Answer: <code>possibly()</code> returns a function that uses
<code>tryCatch()</code> to return <code>otherwise</code> if the mapper
<code>.f</code> errors, unless interrupted, forcing evaluation of
<code>otherwise</code> before the mapper is called.</p>
<p>AR Solutions: <code>possibly()</code> modifies functions to return a
specified default value (<code>otherwise</code>) in case of an error and
to suppress any error messages (<code>quiet = TRUE</code>).</p>
<p>While reading the source code, we notice that <code>possibly()</code>
internally uses <code>purrr::as_mapper()</code>. This enables users to
supply not only functions, but also formulas or atomics via the same
syntax as known from other functions in the <code>{purrr}</code>
package. Besides this, the new default value (<code>otherwise</code>)
gets evaluated once to make it (almost) immutable.</p>
<p>The main functionality of <code>possibly()</code> is provided by
<code>base::tryCatch()</code>. In this part the supplied function
(<code>.f</code>) gets wrapped and the error and interrupt handling are
specified.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Read the source code for <code>safely()</code>. How does it
work?</li>
</ol>
<pre class="r"><code>safely</code></pre>
<pre><code>#&gt; function (.f, otherwise = NULL, quiet = TRUE) 
#&gt; {
#&gt;     .f &lt;- as_mapper(.f)
#&gt;     function(...) capture_error(.f(...), otherwise, quiet)
#&gt; }
#&gt; &lt;bytecode: 0x7fecba617cc8&gt;
#&gt; &lt;environment: namespace:purrr&gt;</code></pre>
<pre class="r"><code>purrr:::capture_error # nolint: undesirable_operator_linter.</code></pre>
<pre><code>#&gt; function (code, otherwise = NULL, quiet = TRUE) 
#&gt; {
#&gt;     tryCatch(list(result = code, error = NULL), error = function(e) {
#&gt;         if (!quiet) 
#&gt;             message(&quot;Error: &quot;, e$message)
#&gt;         list(result = otherwise, error = e)
#&gt;     }, interrupt = function(e) {
#&gt;         stop(&quot;Terminated by user&quot;, call. = FALSE)
#&gt;     })
#&gt; }
#&gt; &lt;bytecode: 0x7fecba7333d0&gt;
#&gt; &lt;environment: namespace:purrr&gt;</code></pre>
<p>Answer: <code>safely()</code> returns a function that uses the
internal <code>capture_error()</code> function to store the evaluation
of the mapper <code>.f</code> in <code>result</code>, and any error in
<code>error</code>.</p>
<p>AR Solutions: <code>safely()</code> modifies functions to return a
list, containing the elements <code>result</code> and
<code>error</code>. It works in a similar fashion as
<code>possibly()</code> and besides using <code>as_mapper()</code>,
<code>safely()</code> also provides the <code>otherwise</code> and
<code>quiet</code> arguments. However, in order to provide the result
and the error in a consistent way, the <code>tryCatch()</code> part of
the implementation returns a list with similar structure for both cases.
In the case of successful evaluation <code>error</code> equals
<code>NULL</code> and in case of an error <code>result</code> equals
<code>otherwise</code>, which is <code>NULL</code> by default.</p>
<p>As the <code>tryCatch()</code> part is hidden in the internal
<code>purrr:::capture_output()</code> function, we provide it here in
addition to <code>safely()</code>.</p>
<p>Take a look at <em>Advanced R</em> or the documentation of
<code>safely()</code> to see how you can take advantage of this
behaviour, e.g. when fitting many models.</p>
<hr />
</div>
<div id="exercises-9" class="section level2">
<h2>11.3.1 Exercises</h2>
<ol style="list-style-type: decimal">
<li>Weigh the pros and cons of
<code>download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1)</code>
versus
<code>download.file %&gt;% delay_by(0.1) %&gt;% dot_every(10)</code>.</li>
</ol>
<p>Answer: in the first version,
<code>download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1)</code>,
<code>delay_by</code> is the outer function, so a delay is added after
the dot is written. In the second version, a dot is added after the
delay. The first version seems better since the feedback dots aren’t
delayed.</p>
<p>AR Solutions: Both commands will print a dot every 10 downloads and
will take the same amount of time to run, so the differences may seem
quite subtle.</p>
<p>In the first case, first the dot functionality is added to
<code>download.file()</code>. Then the delay is added to this already
tweaked function. This implies, that the printing of the dot will also
be delayed, and the first dot will be printed as soon as the download
for the 10th URL starts.</p>
<p>In the latter case the delay is added first and the dot-functionality
is wrapped around it. This order will print the first dot immediately
after the 9th download is finished, then the short delay occurs before
the 10th download actually starts.</p>
<p>Note: the first case seems like the better option.</p>
<hr />
<ol start="2" style="list-style-type: decimal">
<li>Should you memoise <code>file.download()</code>? Why or why
not?</li>
</ol>
<p>Answer: <code>download.file()</code> should not be memoised! As
mentioned in the chapter, the function is not pure (the output doesn’t
depend only on the input), and has side effects (saving a file to
disk).</p>
<p>AR Solutions: Memoising <code>file.download()</code> will only work
if the files are immutable, i.e. if the file at a given URL is always
the same. There’s no point memoising unless this is true. Even if this
is true, however, memoise has to store the results in memory, and large
files will potentially take up a lot of memory.</p>
<p>This implies that it’s probably not beneficial to memoise
<code>file.download()</code> in most cases. The only exception is if you
are downloading small files many times, and the file at a given URL is
guaranteed not to change.</p>
<p>Note: AR Solutions offers a reasonable exception case when memoising
makes sense.</p>
<hr />
<ol start="3" style="list-style-type: decimal">
<li>Create a function operator that reports whenever a file is created
or deleted in the working directory, using <code>dir()</code> and
<code>setdiff()</code>. What other global function effects might you
want to track?</li>
</ol>
<pre class="r"><code>wd_changes &lt;- function(f) {
  function(...) {
    before &lt;- dir()
    ret &lt;- withVisible(f(...))
    after &lt;- dir()
    removed &lt;- setdiff(before, after)
    added &lt;- setdiff(after, before)
    if (length(removed) != 0) cat(&quot;removed files: &quot;, removed, &quot;\n&quot;)
    if (length(added) != 0) cat(&quot;added files: &quot;, added, &quot;\n&quot;)
    if (ret$visible) {
      ret$value
    } else {
      invisible(ret$value)
    }
  }
}</code></pre>
<p>Answer: code above. Other effects you might want to track include
changes to the global environment, output, and conditions.</p>
<p>AR Solutions: We start with a function that reports the difference
between two vectors containing file names:</p>
<pre class="r"><code>dir_compare &lt;- function(old, new) {
  if (setequal(old, new)) {
    return()
  }

  added &lt;- setdiff(new, old)
  removed &lt;- setdiff(old, new)

  changes &lt;- c(
    if (length(added) &gt; 0) paste0(&quot; * &#39;&quot;, added, &quot;&#39; was added&quot;),
    if (length(removed) &gt; 0) paste0(&quot; * &#39;&quot;, removed, &quot;&#39; was removed&quot;)
  )
  message(paste(changes, collapse = &quot;\n&quot;))
}
dir_compare(c(&quot;x&quot;, &quot;y&quot;), c(&quot;x&quot;, &quot;y&quot;))</code></pre>
<pre><code>#&gt; NULL</code></pre>
<pre class="r"><code>dir_compare(c(&quot;x&quot;, &quot;y&quot;), c(&quot;x&quot;, &quot;a&quot;))</code></pre>
<pre><code>#&gt;  * &#39;a&#39; was added
#&gt;  * &#39;y&#39; was removed</code></pre>
<p>Then we wrap it up in a function operator</p>
<pre class="r"><code>track_dir &lt;- function(f) {
  force(f)
  function(...) {
    dir_old &lt;- dir()
    on.exit(dir_compare(dir_old, dir()), add = TRUE)

    f(...)
  }
}</code></pre>
<p>And try it out by creating wrappers around <code>file.create()</code>
and <code>file.remove()</code>:</p>
<pre class="r"><code>file_create &lt;- track_dir(file.create)
file_remove &lt;- track_dir(file.remove)
file_create(&quot;delete_me&quot;)</code></pre>
<pre><code>#&gt;  * &#39;delete_me&#39; was added</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<pre class="r"><code>file_remove(&quot;delete_me&quot;)</code></pre>
<pre><code>#&gt;  * &#39;delete_me&#39; was removed</code></pre>
<pre><code>#&gt; [1] TRUE</code></pre>
<p>To create a more serious version of <code>track_dir()</code> one
might provide optionality to set the <code>full.names</code> and
<code>recursive</code> arguments of <code>dir()</code> to
<code>TRUE</code>. This would enable to also track the creation/deletion
of hidden files and files in folders contained in the working
directory.</p>
<p>Other global effects that might be worth tracking include changes
regarding:</p>
<ul>
<li>the search path and possibly introduced
<code>conflicts()</code></li>
<li><code>options()</code> and <code>par()</code> which modify global
settings</li>
<li>the path of the working directory</li>
<li>environment variables</li>
</ul>
<p>Notes: AR Solutions use of multiple functions, messages and
<code>on.exit</code> is preferable.</p>
<hr />
<ol start="4" style="list-style-type: decimal">
<li>Write a function operator that logs a timestamp and message to a
file every time a function is run.</li>
</ol>
<pre class="r"><code>log_call &lt;- function(f, logfile = &quot;log_call.log&quot;) {
  name &lt;- deparse(enexpr(f))
  force(f)
  force(logfile)

  function(...) {
    m &lt;- paste0(Sys.time(), &quot; log_call: &quot;, name)
    write(m, file = logfile, append = TRUE)
    f(...)
  }
}</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions: Our <code>logger()</code> function operator takes a
function and a file path as input. One timestamp is written to the file
under <code>log_path</code> when we call <code>logger()</code> and
another timestamp is written to the same file each time the new function
gets called.</p>
<pre class="r"><code>append_line &lt;- function(path, ...) {
  cat(..., &quot;\n&quot;, sep = &quot;&quot;, file = path, append = TRUE)
}

logger &lt;- function(f, log_path) {
  force(f)
  force(log_path)

  append_line(log_path, &quot;created at: &quot;, as.character(Sys.time()))
  function(...) {
    append_line(log_path, &quot;called at: &quot;, as.character(Sys.time()))
    f(...)
  }
}</code></pre>
<p>Note: AR Solutions creates a function <code>append_line()</code>
instead of using <code>write()</code>, and adds a “created at:” time,
but is otherwise functionally the same. My solution also logs the name
of the function called.</p>
<hr />
<ol start="5" style="list-style-type: decimal">
<li>Modify <code>delay_by()</code> so that instead of delaying by a
fixed amount of time, it ensures that a certain amount of time has
elapsed since the function was last called. That is, if you called
<code>g &lt;- delay_by(1, f); g(); Sys.sleep(2); g()</code> there
shouldn’t be an extra delay.</li>
</ol>
<pre class="r"><code>sleep_if &lt;- function(start, end, delay) {
  sleep_time &lt;- delay - as.numeric(end - start)
  if (sleep_time &gt; 0) Sys.sleep(sleep_time)
}

delay_by &lt;- function(f, delay) {
  force(f)
  force(delay)

  last_called &lt;- NULL
  function(...) {
    if (!is.null(last_called)) {
      sleep_if(last_called, Sys.time(), delay)
    }
    on.exit(last_called &lt;&lt;- Sys.time(), add = TRUE) # nolint: undesirable_operator_linter.

    f(...)
  }
}

f &lt;- function() {
  0
}
g &lt;- delay_by(f, 1)
h &lt;- delay_by(f, 1)

system.time({
  h()
  h()
})</code></pre>
<pre><code>#&gt;    user  system elapsed 
#&gt;   0.006   0.006   1.000</code></pre>
<pre class="r"><code>system.time({
  g()
  Sys.sleep(2)
  g()
})</code></pre>
<pre><code>#&gt;    user  system elapsed 
#&gt;   0.015   0.014   2.002</code></pre>
<p>Answer: code above.</p>
<p>AR Solutions:</p>
<p>To ensure that the function created by <code>delay_by()</code> waits
that a certain amount of time has passed since its last execution, we
incorporate three little changes into our new
<code>delay_atleast()</code> as indicated in the corresponding comments
below.</p>
<pre class="r"><code>delay_atleast &lt;- function(amount, f) {
  force(f)
  force(amount)

  # Store the last time the function was run
  last_time &lt;- NULL

  # Return modified &quot;delay-aware&quot; function
  function(...) {
    if (!is.null(last_time)) {
      wait &lt;- (last_time - Sys.time()) + amount
      if (wait &gt; 0) {
        Sys.sleep(wait)
      }
    }

    # Update the time after the function has finished
    on.exit(last_time &lt;&lt;- Sys.time()) # nolint: undesirable_operator_linter.

    f(...)
  }
}</code></pre>
<p>Notes: this was tricky; I had to consult AR Solutions for an
answer.</p>
<hr />
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>Typically it’s not the for loop itself that’s slow, but
what you’re doing inside of it. A common culprit of slow loops is
modifying a data structure, where each modification generates a copy.
See Sections 2.5.1 and 24.6 for more details.<a href="#fnref1"
class="footnote-back">↩︎</a></p></li>
</ol>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiBBZHZhbmNlZCBSIFdvcmtib29rIChGdW5jdGlvbmFsIHByb2dyYW1taW5nKQpkYXRlOiAnMjAyMi0wNy0zMScKb3V0cHV0OgogIGh0bWxfZG9jdW1lbnQ6CiAgICB0aGVtZToKICAgICAgdmVyc2lvbjogNQogICAgdG9jOiB5ZXMKICAgIHRvY19mbG9hdDoKICAgICAgY29sbGFwc2VkOiB5ZXMKICAgICAgc21vb3RoX3Njcm9sbDogbm8KLS0tCgpXb3JrYm9vayBmb3IgY29tcGxldGluZyBxdWl6emVzIGFuZCBleGVyY2lzZXMgZnJvbSB0aGUgIkZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmciIGNoYXB0ZXJzIG9mIFtBZHZhbmNlZCBSXShodHRwczovL2Fkdi1yLmhhZGxleS5uei9pbmRleC5odG1sKSwgc2Vjb25kIGVkaXRpb24sIHdpdGggY29tcGFyaXNvbnMgdG8gc29sdXRpb25zIGZyb20gW0FkdmFuY2VkIFIgU29sdXRpb25zXShodHRwczovL2FkdmFuY2VkLXItc29sdXRpb25zLnJiaW5kLmlvKS4KCmBgYHtyIHNldHVwLCBtZXNzYWdlID0gRkFMU0UsIHdhcm5pbmcgPSBGQUxTRX0KbGlicmFyeShwdXJycikKbGlicmFyeShwYWxtZXJwZW5ndWlucykgIyBub2xpbnQ6IHVudXNlZF9pbXBvcnRfbGludGVyLiBJbXBvcnRlZCBmb3IgYHBlbmd1aW5zYCB0aWJibGUuCmxpYnJhcnkoZ2dwbG90MikKbGlicmFyeShzY2FsZXMpCmxpYnJhcnkocmxhbmcpCgojIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2hhZGxleS9hZHYtci9ibG9iL21hc3Rlci9jb21tb24uUgprbml0cjo6b3B0c19jaHVuayRzZXQoCiAgY29tbWVudCA9ICIjPiIsCiAgZmlnLmFsaWduID0gImNlbnRlciIKKQoKa25pdHI6OmtuaXRfaG9va3Mkc2V0KAogIHNtYWxsX21hciA9IGZ1bmN0aW9uKGJlZm9yZSwgb3B0aW9ucywgZW52aXIpIHsKICAgIGlmIChiZWZvcmUpIHsKICAgICAgcGFyKG1hciA9IGMoNC4xLCA0LjEsIDAuNSwgMC41KSkgIyBub2xpbnQ6IHVuZGVzaXJhYmxlX2Z1bmN0aW9uX2xpbnRlci4KICAgIH0KICB9CikKYGBgCgojIEludHJvZHVjdGlvbgoKVGhpcyB3b3JrYm9vayBpbmNsdWRlcyBhbnN3ZXJzIGFuZCBzb2x1dGlvbnMgdG8gdGhlIHF1aXp6ZXMgYW5kIGV4ZXJjaXNlcyBmcm9tIFtBZHZhbmNlZCBSXShodHRwczovL2Fkdi1yLmhhZGxleS5uei9pbmRleC5odG1sKSBhbmQgW0FkdmFuY2VkIFIgU29sdXRpb25zXShodHRwczovL2FkdmFuY2VkLXItc29sdXRpb25zLnJiaW5kLmlvKSwgb3JnYW5pemVkIGJ5IGNoYXB0ZXIuIEl0IGluY2x1ZGVzIGV4Y2VycHRzIGZyb20gYm90aCBib29rcywgY29waWVkIGhlcmUuCgoqKldBUk5JTkcsIFNQT0lMRVJTISoqIElmIHlvdSBoYXZlbid0IHJlYWQgQWR2YW5jZWQgUiBhbmQgaW50ZW5kIHRvIGNvbXBsZXRlIHRoZSBxdWl6emVzIGFuZCBleGVyY2lzZXMsIGRvbid0IHJlYWQgdGhpcyBub3RlYm9vay4gSXQgY29udGFpbnMgbXkgKHBvdGVudGlhbGx5IHdyb25nKSBhbnN3ZXJzIHRvIGJvdGguCgojIDkgRnVuY3Rpb25hbHMKCj4gVG8gYmVjb21lIHNpZ25pZmljYW50bHkgbW9yZSByZWxpYWJsZSwgY29kZSBtdXN0IGJlY29tZSBtb3JlIHRyYW5zcGFyZW50Lgo+IEluIHBhcnRpY3VsYXIsIG5lc3RlZCBjb25kaXRpb25zIGFuZCBsb29wcyBtdXN0IGJlIHZpZXdlZCB3aXRoIGdyZWF0Cj4gc3VzcGljaW9uLiBDb21wbGljYXRlZCBjb250cm9sIGZsb3dzIGNvbmZ1c2UgcHJvZ3JhbW1lcnMuIE1lc3N5IGNvZGUgb2Z0ZW4KPiBoaWRlcyBidWdzLgo+Cj4gLS0tIEJqYXJuZSBTdHJvdXN0cnVwCgpBIF9fZnVuY3Rpb25hbF9fIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGZ1bmN0aW9uIGFzIGFuIGlucHV0IGFuZCByZXR1cm5zIGEgdmVjdG9yIGFzIG91dHB1dC4gSGVyZSdzIGEgc2ltcGxlIGZ1bmN0aW9uYWw6IGl0IGNhbGxzIHRoZSBmdW5jdGlvbiBwcm92aWRlZCBhcyBpbnB1dCB3aXRoIDEwMDAgcmFuZG9tIHVuaWZvcm0gbnVtYmVycy4gCgpgYGB7cn0KcmFuZG9taXNlIDwtIGZ1bmN0aW9uKGYpIGYocnVuaWYoMWUzKSkKcmFuZG9taXNlKG1lYW4pCnJhbmRvbWlzZShtZWFuKQpyYW5kb21pc2Uoc3VtKQpgYGAKClRoZSBjaGFuY2VzIGFyZSB0aGF0IHlvdSd2ZSBhbHJlYWR5IHVzZWQgYSBmdW5jdGlvbmFsLiBZb3UgbWlnaHQgaGF2ZSB1c2VkIGZvci1sb29wIHJlcGxhY2VtZW50cyBsaWtlIGJhc2UgUidzIGBsYXBwbHkoKWAsIGBhcHBseSgpYCwgYW5kIGB0YXBwbHkoKWA7IG9yIHB1cnJyJ3MgYG1hcCgpYDsgb3IgbWF5YmUgeW91J3ZlIHVzZWQgYSBtYXRoZW1hdGljYWwgZnVuY3Rpb25hbCBsaWtlIGBpbnRlZ3JhdGUoKWAgb3IgYG9wdGltKClgLiAKCkEgY29tbW9uIHVzZSBvZiBmdW5jdGlvbmFscyBpcyBhcyBhbiBhbHRlcm5hdGl2ZSB0byBmb3IgbG9vcHMuIEZvciBsb29wcyBoYXZlIGEgYmFkIHJhcCBpbiBSIGJlY2F1c2UgbWFueSBwZW9wbGUgYmVsaWV2ZSB0aGV5IGFyZSBzbG93W15ub3Qtc2xvd10sIGJ1dCB0aGUgcmVhbCBkb3duc2lkZSBvZiBmb3IgbG9vcHMgaXMgdGhhdCB0aGV5J3JlIHZlcnkgZmxleGlibGU6IGEgbG9vcCBjb252ZXlzIHRoYXQgeW91J3JlIGl0ZXJhdGluZywgYnV0IG5vdCB3aGF0IHNob3VsZCBiZSBkb25lIHdpdGggdGhlIHJlc3VsdHMuIEp1c3QgYXMgaXQncyBiZXR0ZXIgdG8gdXNlIGB3aGlsZWAgdGhhbiBgcmVwZWF0YCwgYW5kIGl0J3MgYmV0dGVyIHRvIHVzZSBgZm9yYCB0aGFuIGB3aGlsZWAgKFNlY3Rpb24gNS4zLjIpLCBpdCdzIGJldHRlciB0byB1c2UgYSBmdW5jdGlvbmFsIHRoYW4gYGZvcmAuIEVhY2ggZnVuY3Rpb25hbCBpcyB0YWlsb3JlZCBmb3IgYSBzcGVjaWZpYyB0YXNrLCBzbyB3aGVuIHlvdSByZWNvZ25pc2UgdGhlIGZ1bmN0aW9uYWwgeW91IGltbWVkaWF0ZWx5IGtub3cgd2h5IGl0J3MgYmVpbmcgdXNlZC4KCltebm90LXNsb3ddOiBUeXBpY2FsbHkgaXQncyBub3QgdGhlIGZvciBsb29wIGl0c2VsZiB0aGF0J3Mgc2xvdywgYnV0IHdoYXQgeW91J3JlIGRvaW5nIGluc2lkZSBvZiBpdC4gQSBjb21tb24gY3VscHJpdCBvZiBzbG93IGxvb3BzIGlzIG1vZGlmeWluZyBhIGRhdGEgc3RydWN0dXJlLCB3aGVyZSBlYWNoIG1vZGlmaWNhdGlvbiBnZW5lcmF0ZXMgYSBjb3B5LiBTZWUgU2VjdGlvbnMgMi41LjEgYW5kIDI0LjYgZm9yIG1vcmUgZGV0YWlscy4KCklmIHlvdSdyZSBhbiBleHBlcmllbmNlZCBmb3IgbG9vcCB1c2VyLCBzd2l0Y2hpbmcgdG8gZnVuY3Rpb25hbHMgaXMgdHlwaWNhbGx5IGEgcGF0dGVybiBtYXRjaGluZyBleGVyY2lzZS4gWW91IGxvb2sgYXQgdGhlIGZvciBsb29wIGFuZCBmaW5kIGEgZnVuY3Rpb25hbCB0aGF0IG1hdGNoZXMgdGhlIGJhc2ljIGZvcm0uIElmIG9uZSBkb2Vzbid0IGV4aXN0LCBkb24ndCB0cnkgYW5kIHRvcnR1cmUgYW4gZXhpc3RpbmcgZnVuY3Rpb25hbCB0byBmaXQgdGhlIGZvcm0geW91IG5lZWQuIEluc3RlYWQsIGp1c3QgbGVhdmUgaXQgYXMgYSBmb3IgbG9vcCEgKE9yIG9uY2UgeW91J3ZlIHJlcGVhdGVkIHRoZSBzYW1lIGxvb3AgdHdvIG9yIG1vcmUgdGltZXMsIG1heWJlIHRoaW5rIGFib3V0IHdyaXRpbmcgeW91ciBvd24gZnVuY3Rpb25hbCkuCgojIyA5LjIuNiBFeGVyY2lzZXMKCjEuICBVc2UgYGFzX21hcHBlcigpYCB0byBleHBsb3JlIGhvdyBwdXJyciBnZW5lcmF0ZXMgYW5vbnltb3VzIGZ1bmN0aW9ucyBmb3IKICAgIHRoZSBpbnRlZ2VyLCBjaGFyYWN0ZXIsIGFuZCBsaXN0IGhlbHBlcnMuIFdoYXQgaGVscGVyIGFsbG93cyB5b3UgdG8gCiAgICBleHRyYWN0IGF0dHJpYnV0ZXM/IFJlYWQgdGhlIGRvY3VtZW50YXRpb24gdG8gZmluZCBvdXQuCgpgYGB7cn0KbWFwX2RibAptYXBfZGJsKG10Y2FycywgfiBsZW5ndGgodW5pcXVlKC54KSkpCmFzX21hcHBlcih+IGxlbmd0aCh1bmlxdWUoLngpKSkKZnVuY3Rpb24oLi4uLCAueCA9IC4uMSwgLnkgPSAuLjIsIC4gPSAuLjEpIGxlbmd0aCh1bmlxdWUoLngpKQphc19tYXBwZXIobWVhbikKYXNfbWFwcGVyKGZ1bmN0aW9uKHgpIG1lYW4oeCwgbmEucm0gPSBUUlVFKSkKYXNfbWFwcGVyKH4gbWVhbigueCwgbmEucm0gPSBUUlVFKSkKYGBgCgpBbnN3ZXI6IEV4cGxvcmF0aW9uIGFib3ZlLiBgYXR0cl9nZXR0ZXIoKWAgc3VwcG9ydHMgZXh0cmFjdGlvbiBvZiBhdHRyaWJ1dGVzLgoKQVIgU29sdXRpb25zOiBgbWFwKClgIG9mZmVycyBtdWx0aXBsZSB3YXlzIChmdW5jdGlvbnMsIGZvcm11bGFzLCBhbmQgZXh0cmFjdG9yIGZ1bmN0aW9ucykgdG8gc3BlY2lmeSBpdHMgZnVuY3Rpb24gYXJndW1lbnQgKGAuZmApLiBJbml0aWFsbHksIHRoZSB2YXJpb3VzIGlucHV0cyBoYXZlIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gYSB2YWxpZCBmdW5jdGlvbiwgd2hpY2ggaXMgdGhlbiBhcHBsaWVkLiBUaGUgY3JlYXRpb24gb2YgdGhpcyB2YWxpZCBmdW5jdGlvbiBpcyB0aGUgam9iIG9mIGBhc19tYXBwZXIoKWAgYW5kIGl0IGlzIGNhbGxlZCBldmVyeSB0aW1lIGBtYXAoKWAgaXMgdXNlZC4KCkdpdmVuIGNoYXJhY3RlciwgbnVtZXJpYyBvciBsaXN0IGlucHV0IGBhc19tYXBwZXIoKWAgd2lsbCBjcmVhdGUgYW4gZXh0cmFjdG9yIGZ1bmN0aW9uLiBDaGFyYWN0ZXJzIHNlbGVjdCBieSBuYW1lLCB3aGlsZSBudW1lcmljIGlucHV0IHNlbGVjdHMgYnkgcG9zaXRpb25zIGFuZCBhIGxpc3QgYWxsb3dzIGEgbWl4IG9mIHRoZXNlIHR3byBhcHByb2FjaGVzLiBUaGlzIGV4dHJhY3RvciBpbnRlcmZhY2UgY2FuIGJlIHZlcnkgdXNlZnVsLCB3aGVuIHdvcmtpbmcgd2l0aCBuZXN0ZWQgZGF0YS4KClRoZSBleHRyYWN0b3IgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQgYXMgYSBjYWxsIHRvIGBwdXJycjo6cGx1Y2soKWAsIHdoaWNoIGFjY2VwdHMgYSBsaXN0IG9mIGFjY2Vzc29ycyAoYWNjZXNzb3JzICJhY2Nlc3MiIHNvbWUgcGFydCBvZiB5b3VyIGRhdGEgb2JqZWN0KS4KCmBgYHtyfQphc19tYXBwZXIoYygxLCAyKSkgIyBlcXVpdmFsZW50IHRvIGZ1bmN0aW9uKHgpIHhbWzFdXVtbMl1dCmFzX21hcHBlcihjKCJhIiwgImIiKSkgIyBlcXVpdmFsZW50IHRvIGZ1bmN0aW9uKHgpIHhbWyJhIl1dW1siYl1dCmFzX21hcHBlcihsaXN0KDEsICJiIikpICMgZXF1aXZhbGVudCB0byBmdW5jdGlvbih4KSB4W1sxXV1bWyJiXV0KYGBgCgpCZXNpZGVzIG1peGluZyBwb3NpdGlvbnMgYW5kIG5hbWVzLCBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBhc3MgYWxvbmcgYW4gYWNjZXNzb3IgZnVuY3Rpb24uIFRoaXMgaXMgYmFzaWNhbGx5IGFuIGFub255bW91cyBmdW5jdGlvbiB0aGF0IGdldHMgaW5mb3JtYXRpb24gYWJvdXQgc29tZSBhc3BlY3Qgb2YgdGhlIGlucHV0IGRhdGEuIFlvdSBhcmUgZnJlZSB0byBkZWZpbmUgeW91ciBvd24gYWNjZXNzb3IgZnVuY3Rpb25zLiAKCklmIHlvdSBuZWVkIHRvIGFjY2VzcyBjZXJ0YWluIGF0dHJpYnV0ZXMsIHRoZSBoZWxwZXIgYGF0dHJfZ2V0dGVyKHkpYCBpcyBhbHJlYWR5IHByZWRlZmluZWQgYW5kIHdpbGwgY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSBhY2Nlc3NvciBmdW5jdGlvbiBmb3IgeW91LgoKYGBge3J9CiMgRGVmaW5lIGN1c3RvbSBhY2Nlc3NvciBmdW5jdGlvbgpnZXRfY2xhc3MgPC0gZnVuY3Rpb24oeCkgYXR0cih4LCAiY2xhc3MiKQpwbHVjayhtdGNhcnMsIGdldF9jbGFzcykKCiMgVXNlIGF0dHJfZ2V0dGVyKCkgYXMgYSBoZWxwZXIKcGx1Y2sobXRjYXJzLCBhdHRyX2dldHRlcigiY2xhc3MiKSkKYGBgCgpOb3RlOiBBUiBTb2x1dGlvbnMgcHJvdmlkZXMgZ29vZCBhZGRpdGlvbmFsIGluc2lnaHQgaW50byBgYXNfbWFwcGVyKClgLgoKLS0tCgoyLiAgYG1hcCgxOjMsIH4gcnVuaWYoMikpYCBpcyBhIHVzZWZ1bCBwYXR0ZXJuIGZvciBnZW5lcmF0aW5nIHJhbmRvbQogICAgbnVtYmVycywgYnV0IGBtYXAoMTozLCBydW5pZigyKSlgIGlzIG5vdC4gV2h5IG5vdD8gQ2FuIHlvdSBleHBsYWluIHdoeSAKICAgIGl0IHJldHVybnMgdGhlIHJlc3VsdCB0aGF0IGl0IGRvZXM/CgpgYGB7cn0KbWFwKDE6MywgfiBydW5pZigyKSkKbWFwKDE6MywgcnVuaWYoMikpCmBgYAoKQW5zd2VyOiBgfiBydW5pZigyKWAgZ2VuZXJhdGVzIGEgbWFwcGVyIHRoYXQgcmV0dXJucyAyIHJhbmRvbSB2YWx1ZXMgZnJvbSB0aGUgdW5pZm9ybSBkaXN0cmlidXRpb24sIHdoZXJlIGBydW5pZigyKWAgY3JlYXRlcyBhIGBwbHVjaygpYCBtYXBwZXIgd2l0aCAyIHJhbmRvbSB2YWx1ZXMsIHdoaWNoIHdpbGwgKG5lYXJseSkgYWx3YXlzIHJldHVybiBgTlVMTGAsIGFzIGRlbW9uc3RyYXRlZCBieSB0aGUgY29kZSBiZWxvdzogCgpgYGB7cn0KYXNfbWFwcGVyKH4gcnVuaWYoMikpCmFzX21hcHBlcihydW5pZigyKSkKYGBgCgpBIG1vcmUgcmVhc29uYWJsZSB1c2Ugb2YgYSBwbHVjayBtYXBwZXIgZm9yIGAxOjNgIGlzIGAxYDoKCmBgYHtyfQptYXAoMTozLCAxKQpgYGAKCkFSIFNvbHV0aW9uczogVGhlIGZpcnN0IHBhdHRlcm4gY3JlYXRlcyBtdWx0aXBsZSByYW5kb20gbnVtYmVycywgYmVjYXVzZSBgfiBydW5pZigyKWAgc3VjY2Vzc2Z1bGx5IHVzZXMgdGhlIGZvcm11bGEgaW50ZXJmYWNlLiBJbnRlcm5hbGx5IGBtYXAoKWAgYXBwbGllcyBgYXNfbWFwcGVyKClgIHRvIHRoaXMgZm9ybXVsYSwgd2hpY2ggY29udmVydHMgYH4gcnVuaWYoMilgIGludG8gYW4gYW5vbnltb3VzIGZ1bmN0aW9uLiBBZnRlcndhcmRzIGBydW5pZigyKWAgaXMgYXBwbGllZCB0aHJlZSB0aW1lcyAob25lIHRpbWUgZHVyaW5nIGVhY2ggaXRlcmF0aW9uKSwgbGVhZGluZyB0byB0aHJlZSBkaWZmZXJlbnQgcGFpcnMgb2YgcmFuZG9tIG51bWJlcnMuCgpJbiB0aGUgc2Vjb25kIHBhdHRlcm4gYHJ1bmlmKDIpYCBpcyBldmFsdWF0ZWQgb25jZSwgdGhlbiB0aGUgcmVzdWx0cyBhcmUgcGFzc2VkIHRvIGBtYXAoKWAuIENvbnNlcXVlbnRseSBgYXNfbWFwcGVyKClgIGNyZWF0ZXMgYW4gZXh0cmFjdG9yIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSByZXR1cm4gdmFsdWVzIGZyb20gYHJ1bmlmKDIpYCAodmlhIGBwbHVjaygpYCkuIFRoaXMgbGVhZHMgdG8gdGhyZWUgYE5VTExgcyAoYHBsdWNrKClgJ3MgYC5kZWZhdWx0YCByZXR1cm4pLCBiZWNhdXNlIG5vIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbmRleCBjYW4gYmUgZm91bmQuCgpOb3RlOiBBUiBTb2x1dGlvbnMgcHJvdmlkZXMgYWRkaXRpb25hbCBkZXRhaWwsIGJ1dCBpcyBvdGhlcndpc2UgdGhlIHNhbWUuCgotLS0KCjMuICBVc2UgdGhlIGFwcHJvcHJpYXRlIGBtYXAoKWAgZnVuY3Rpb24gdG86CiAgICAKICAgIGEpIENvbXB1dGUgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBldmVyeSBjb2x1bW4gaW4gYSBudW1lcmljIGRhdGEgZnJhbWUuCiAgICAKICAgIGEpIENvbXB1dGUgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBldmVyeSBudW1lcmljIGNvbHVtbiBpbiBhIG1peGVkIGRhdGEKICAgICAgIGZyYW1lLiAoSGludDogeW91J2xsIG5lZWQgdG8gZG8gaXQgaW4gdHdvIHN0ZXBzLikKICAgICAgIAogICAgYSkgQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGxldmVscyBmb3IgZXZlcnkgZmFjdG9yIGluIGEgZGF0YSBmcmFtZS4KCmBgYHtyfQojIGEKbWFwX2RibChtdGNhcnMsIHNkKQojIGIKbWFwX2RibChpcmlzW21hcF9sZ2woaXJpcywgaXMubnVtZXJpYyldLCBzZCkKIyBjCm1hcF9pbnQod2FycGJyZWFrcywgbmxldmVscykKIyBjLCBleGNsdWRpbmcgbm9uLWZhY3RvciBjb2x1bW5zCm1hcF9pbnQod2FycGJyZWFrc1ttYXBfbGdsKHdhcnBicmVha3MsIGlzLmZhY3RvcildLCBubGV2ZWxzKQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogVG8gc29sdmUgdGhpcyBleGVyY2lzZSB3ZSB0YWtlIGFkdmFudGFnZSBvZiBjYWxsaW5nIHRoZSB0eXBlIHN0YWJsZSB2YXJpYW50cyBvZiBgbWFwKClgLCB3aGljaCBnaXZlIHVzIG1vcmUgY29uY2lzZSBvdXRwdXQsIGFuZCB1c2UgYG1hcF9sZ2woKWAgdG8gc2VsZWN0IHRoZSBjb2x1bW5zIG9mIHRoZSBkYXRhIGZyYW1lIChsYXRlciB5b3UnbGwgbGVhcm4gYWJvdXQgYGtlZXAoKWAsIHdoaWNoIHNpbXBsaWZpZXMgdGhpcyBwYXR0ZXJuIGEgbGl0dGxlKS4KCmBgYHtyfQptYXBfZGJsKG10Y2Fycywgc2QpCnBlbmd1aW5zX251bWVyaWMgPC0gbWFwX2xnbChwZW5ndWlucywgaXMubnVtZXJpYykKbWFwX2RibChwZW5ndWluc1twZW5ndWluc19udW1lcmljXSwgc2QsIG5hLnJtID0gVFJVRSkKcGVuZ3VpbnNfZmFjdG9yIDwtIG1hcF9sZ2wocGVuZ3VpbnMsIGlzLmZhY3RvcikKbWFwX2ludChwZW5ndWluc1twZW5ndWluc19mYWN0b3JdLCB+IGxlbmd0aChsZXZlbHMoLngpKSkKYGBgCgpOb3RlOiBteSBjb2RlIGlzIG1vcmUgY29uY2lzZSwgYm90aCB3aXRoIHNlbGVjdGlvbnMgYW5kIHVzZSBvZiBgbmxldmVscygpYCwgYWx0aG91Z2ggdXNpbmcgYGtlZXAoKWAgaXMgcHJlZmVyYWJsZS4KCmBgYHtyfQptYXBfaW50KGtlZXAod2FycGJyZWFrcywgaXMuZmFjdG9yKSwgbmxldmVscykKYGBgCgotLS0KCjQuICBUaGUgZm9sbG93aW5nIGNvZGUgc2ltdWxhdGVzIHRoZSBwZXJmb3JtYW5jZSBvZiBhIHQtdGVzdCBmb3Igbm9uLW5vcm1hbCAKICAgIGRhdGEuIEV4dHJhY3QgdGhlIHAtdmFsdWUgZnJvbSBlYWNoIHRlc3QsIHRoZW4gdmlzdWFsaXNlLgoKYGBge3J9CnRyaWFscyA8LSBtYXAoMToxMDAsIH4gdC50ZXN0KHJwb2lzKDEwLCAxMCksIHJwb2lzKDcsIDEwKSkpCmhpc3QobWFwX2RibCh0cmlhbHMsICJwLnZhbHVlIiksIGJyZWFrcyA9IDEwKQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4KCkFSIFNvbHV0aW9uczogVGhlcmUgYXJlIG1hbnkgd2F5cyB0byB2aXN1YWxpc2UgdGhpcyBkYXRhLiBIb3dldmVyLCBzaW5jZSB0aGVyZSBhcmUgb25seSAxMDAgZGF0YSBwb2ludHMsIHdlIGNob29zZSBhIGRvdCBwbG90IHRvIHZpc3VhbGlzZSB0aGUgZGlzdHJpYnV0aW9uLiAoVW5mb3J0dW5hdGVseSwgYHtnZ3Bsb3QyfWBzIGBnZW9tX2RvdHBsb3QoKWAgZG9lc24ndCBjb21wdXRlIHByb3BlciBjb3VudHMgYXMgaXQgd2FzIGNyZWF0ZWQgdG8gdmlzdWFsaXNlIGRpc3RyaWJ1dGlvbiBkZW5zaXRpZXMgaW5zdGVhZCBvZiBmcmVxdWVuY2llcywgc28gYSBoaXN0b2dyYW0gd291bGQgYmUgYSBzdWl0YWJsZSBhbHRlcm5hdGl2ZSkuCgpgYGB7cn0KIyBBZHZhbmNlZCBSIFNvbHV0aW9ucyB1c2VzIGRpZmZlcmVudCBjb2RlIGZvciB0cmlhbHMKdHJpYWxzIDwtIG1hcCgxOjEwMCwgfiB0LnRlc3QocnBvaXMoMTAsIDEwKSwgcnBvaXMoMTAsIDcpKSkKCmxpYnJhcnkoZ2dwbG90MikKCmRmX3RyaWFscyA8LSB0aWJibGU6OnRpYmJsZShwX3ZhbHVlID0gbWFwX2RibCh0cmlhbHMsICJwLnZhbHVlIikpCgpkZl90cmlhbHMgJT4lCiAgZ2dwbG90KGFlcyh4ID0gcF92YWx1ZSwgZmlsbCA9IHBfdmFsdWUgPCAwLjA1KSkgKwogIGdlb21fZG90cGxvdChiaW53aWR0aCA9IDAuMDEpICsgIyBnZW9tX2hpc3RvZ3JhbSgpIGFzIGFsdGVybmF0aXZlCiAgdGhlbWUoCiAgICBheGlzLnRleHQueSA9IGVsZW1lbnRfYmxhbmsoKSwKICAgIGF4aXMudGlja3MueSA9IGVsZW1lbnRfYmxhbmsoKSwKICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJ0b3AiCiAgKQpgYGAKCk5vdGVzOiB0aGUgY29kZSBBUiBTb2x1dGlvbnMgdXNlcyBmb3IgdHJpYWxzLCBgdHJpYWxzIDwtIG1hcCgxOjEwMCwgfiB0LnRlc3QocnBvaXMoMTAsIDEwKSwgcnBvaXMoMTAsIDcpKSlgLCBhcHBlYXJzIHRvIGJlIGNvcnJlY3QgY29tcGFyZWQgdG8gQWR2YW5jZWQgUi4KCi0tLQoKNS4gIFRoZSBmb2xsb3dpbmcgY29kZSB1c2VzIGEgbWFwIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBtYXAgdG8gYXBwbHkgYQogICAgZnVuY3Rpb24gdG8gZXZlcnkgZWxlbWVudCBvZiBhIG5lc3RlZCBsaXN0LiBXaHkgZG9lcyBpdCBmYWlsLCBhbmQgCiAgICB3aGF0IGRvIHlvdSBuZWVkIHRvIGRvIHRvIG1ha2UgaXQgd29yaz8KCmBgYHtyLCBlcnJvciA9IFRSVUV9CnggPC0gbGlzdCgKICBsaXN0KDEsIGMoMywgOSkpLAogIGxpc3QoYygzLCA2KSwgNywgYyg0LCA3LCA2KSkKKQoKdHJpcGxlIDwtIGZ1bmN0aW9uKHgpIHggKiAzCnRyeShtYXAoeCwgbWFwLCAuZiA9IHRyaXBsZSkpCmBgYAoKQW5zd2VyOiB0aGUgY2FsbCBmYWlscyBzaW5jZSB0aGUgYC5mID0gdHJpcGxlYCBzcGVjaWZpZXMgdGhlIGZ1bmN0aW9uIGZvciB0aGUgb3V0ZXIgYG1hcCgpYCwgYW5kIHRoZSBgbWFwYCBpcyBwYXNzZWQgYXMgYW4gYWRkaXRpb25hbCBhcmd1bWVudCB0byBgdHJpcGxlKClgLCB3aGljaCBnZW5lcmF0ZXMgdGhlIGVycm9yIHNpbmNlIGB0cmlwbGUoKWAgb25seSB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudC4gVGhlIHNvbHV0aW9uIGlzIHRvIHBhc3MgdHJpcGxlIGFzIGFuIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gdGhlIG91dGVyIGBtYXAoKWA6IAoKYGBge3J9Cm1hcCh4LCBtYXAsIHRyaXBsZSkKYGBgCgpBUiBTb2x1dGlvbnM6IFRoaXMgZnVuY3Rpb24gY2FsbCBmYWlscywgYmVjYXVzZSBgdHJpcGxlKClgIGlzIHNwZWNpZmllZCBhcyB0aGUgYC5mYCBhcmd1bWVudCBhbmQgY29uc2VxdWVudGx5IGJlbG9uZ3MgdG8gdGhlIG91dGVyIGBtYXAoKWAuIFRoZSB1bm5hbWVkIGFyZ3VtZW50IGBtYXBgIGlzIHRyZWF0ZWQgYXMgYW4gYXJndW1lbnQgb2YgYHRyaXBsZSgpYCwgd2hpY2ggY2F1c2VzIHRoZSBlcnJvci4KClRoZXJlIGFyZSBhIG51bWJlciBvZiB3YXlzIHdlIGNvdWxkIHJlc29sdmUgdGhlIHByb2JsZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIG5vdCBtdWNoIHRvIGNob29zZSBiZXR3ZWVuIHRoZW0gZm9yIHRoaXMgc2ltcGxlIGV4YW1wbGUsIGFsdGhvdWdoIGl0IGlzIGdvb2QgdG8ga25vdyB5b3VyIG9wdGlvbnMgZm9yIG1vcmUgY29tcGxpY2F0ZWQgY2FzZXMuCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQojIERvbid0IG5hbWUgdGhlIGFyZ3VtZW50Cm1hcCh4LCBtYXAsIHRyaXBsZSkKCiMgVXNlIG1hZ3JpdHRyLXN0eWxlIGFub255bW91cyBmdW5jdGlvbgptYXAoeCwgLiAlPiUgbWFwKHRyaXBsZSkpCgojIFVzZSBwdXJyci1zdHlsZSBhbm9ueW1vdXMgZnVuY3Rpb24KbWFwKHgsIH4gbWFwKC54LCB0cmlwbGUpKQpgYGAKCk5vdGU6IEkgZG9uJ3QgbGlrZSB0aGUgbWFncml0dHItc3R5bGUgYW5vbnltb3VzIGZ1bmN0aW9uIG9wdGlvbi4gVGhlIG90aGVycyBhcmUgZ29vZC4KCi0tLQoKNi4gIFVzZSBgbWFwKClgIHRvIGZpdCBsaW5lYXIgbW9kZWxzIHRvIHRoZSBgbXRjYXJzYCBkYXRhc2V0IHVzaW5nIHRoZSBmb3JtdWxhcwogICAgc3RvcmVkIGluIHRoaXMgbGlzdDoKCmBgYHtyfQpmb3JtdWxhcyA8LSBsaXN0KAogIG1wZyB+IGRpc3AsCiAgbXBnIH4gSSgxIC8gZGlzcCksCiAgbXBnIH4gZGlzcCArIHd0LAogIG1wZyB+IEkoMSAvIGRpc3ApICsgd3QKKQpgYGAKCkFuc3dlcjogdGhlIGZvbGxvd2luZyBjb2RlIHdvcmtzLCBidXQgZG9lc24ndCBkaXNwbGF5IHRoZSB0ZXh0IG9mIHRoZSBmb3JtdWxhIGluIHRoZSBgQ2FsbDpgCgpgYGB7cn0KbWFwKGZvcm11bGFzLCBsbSwgbXRjYXJzKQpgYGAKCkFSIFNvbHV0aW9uczogVGhlIGRhdGEgKGBtdGNhcnNgKSBpcyBjb25zdGFudCBmb3IgYWxsIHRoZXNlIG1vZGVscyBhbmQgc28gd2UgaXRlcmF0ZSBvdmVyIHRoZSBgZm9ybXVsYXNgIHByb3ZpZGVkLiBBcyB0aGUgZm9ybXVsYSBpcyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgYGxtKClgLCB3ZSBkb24ndCBuZWVkIHRvIHNwZWNpZnkgaXQgZXhwbGljaXRseS4KCmBgYHtyfQptb2RlbHMgPC0gbWFwKGZvcm11bGFzLCBsbSwgZGF0YSA9IG10Y2FycykKYGBgCgpOb3RlOiBBUiBTb2x1dGlvbnMgc3BlY2lmaWVzIGBkYXRhID0gbXRjYXJzYCBidXQgaXMgb3RoZXJ3aXNlIHRoZSBzYW1lLgoKLS0tCgo3LiAgRml0IHRoZSBtb2RlbCBgbXBnIH4gZGlzcGAgdG8gZWFjaCBvZiB0aGUgYm9vdHN0cmFwIHJlcGxpY2F0ZXMgb2YgYG10Y2Fyc2AgCiAgICBpbiB0aGUgbGlzdCBiZWxvdywgdGhlbiBleHRyYWN0IHRoZSAkUl4yJCBvZiB0aGUgbW9kZWwgZml0IChIaW50OiB5b3UgY2FuCiAgICBjb21wdXRlIHRoZSAkUl4yJCB3aXRoIGBzdW1tYXJ5KClgLikKCmBgYHtyfQpib290c3RyYXAgPC0gZnVuY3Rpb24oZGYpIHsKICBkZltzYW1wbGUobnJvdyhkZiksIHJlcGxhY2UgPSBUUlVFKSwgLCBkcm9wID0gRkFMU0VdCn0KCmJvb3RzdHJhcHMgPC0gbWFwKDE6MTAsIH4gYm9vdHN0cmFwKG10Y2FycykpCgptYXBfZGJsKGJvb3RzdHJhcHMsIH4gc3VtbWFyeShsbShtcGcgfiBkaXNwLCAueCkpJHIuc3F1YXJlZCkKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IFRvIGFjY29tcGxpc2ggdGhpcyB0YXNrLCB3ZSB0YWtlIGFkdmFudGFnZSBvZiB0aGUgImxpc3QgaW4sIGxpc3Qgb3V0Ii1mdW5jdGlvbmFsaXR5IG9mIGBtYXAoKWAuIFRoaXMgYWxsb3dzIHVzIHRvIGNoYWluIG11bHRpcGxlIHRyYW5zZm9ybWF0aW9ucyB0b2dldGhlci4gV2Ugc3RhcnQgYnkgZml0dGluZyB0aGUgbW9kZWxzLiBXZSB0aGVuIGNhbGN1bGF0ZSB0aGUgc3VtbWFyaWVzIGFuZCBleHRyYWN0IHRoZSAkUl4yJCB2YWx1ZXMuIEZvciB0aGUgbGFzdCBjYWxsIHdlIHVzZSBgbWFwX2RibCgpYCwgd2hpY2ggcHJvdmlkZXMgY29udmVuaWVudCBvdXRwdXQuCgpgYGB7cn0KYm9vdHN0cmFwcyAlPiUKICBtYXAofiBsbShtcGcgfiBkaXNwLCBkYXRhID0gLngpKSAlPiUKICBtYXAoc3VtbWFyeSkgJT4lCiAgbWFwX2RibCgici5zcXVhcmVkIikKYGBgCgpOb3RlOiB3aGlsZSBBUiBTb2x1dGlvbnMgaXMgYXJndWFibHkgKnNsaWdodGx5KiBtb3JlIHJlYWRhYmxlLCBteSBjb2RlIHNob3VsZCBiZSBmYXN0ZXI6CgpgYGB7cn0KYmVuY2g6Om1hcmsoewogIG1hcF9kYmwoYm9vdHN0cmFwcywgfiBzdW1tYXJ5KGxtKG1wZyB+IGRpc3AsIC54KSkkci5zcXVhcmVkKQp9KQoKYmVuY2g6Om1hcmsoewogIGJvb3RzdHJhcHMgJT4lCiAgICBtYXAofiBsbShtcGcgfiBkaXNwLCBkYXRhID0gLngpKSAlPiUKICAgIG1hcChzdW1tYXJ5KSAlPiUKICAgIG1hcF9kYmwoInIuc3F1YXJlZCIpCn0pCmBgYAoKSXQgaXMgYWN0dWFsbHkgc2xpZ2h0bHkgc2xvd2VyISBBUiBTb2x1dGlvbnMgd2lucyEKCi0tLQoKIyMgOS40LjYgRXhlcmNpc2VzCgoxLiAgRXhwbGFpbiB0aGUgcmVzdWx0cyBvZiBgbW9kaWZ5KG10Y2FycywgMSlgLgoKYGBge3J9Cm1vZGlmeShtdGNhcnMsIDEpCmFzX21hcHBlcigxKQpoZWFkKG10Y2FycywgMSkKYGBgCgpBbnN3ZXI6IGBtb2RpZnkobXRjYXJzLCAxKWAgY3JlYXRlcyBhIG1hcHBlciB0aGF0IHBsdWNrcyB0aGUgZmlyc3QgZWxlbWVudCBvZiBlYWNoIGNvbHVtbiBvZiBgbXRjYXJzYCBhbmQgd3JpdGVzIHRoYXQgdmFsdWUgdG8gZXZlcnkgcm93LgoKQVIgU29sdXRpb25zOiBgbW9kaWZ5KClgIGlzIGJhc2VkIG9uIGBtYXAoKWAsIGFuZCBpbiB0aGlzIGNhc2UsIHRoZSBleHRyYWN0b3IgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZC4gSXQgZXh0cmFjdHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgZWFjaCBjb2x1bW4gaW4gYG10Y2Fyc2AuIGBtb2RpZnkoKWAgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgc3RydWN0dXJlIGFzIGl0cyBpbnB1dDogaW4gdGhpcyBjYXNlIGl0IGZvcmNlcyB0aGUgZmlyc3Qgcm93IHRvIGJlIHJlY3ljbGVkIDMyIHRpbWVzLiAoSW50ZXJuYWxseSBgbW9kaWZ5KClgIHVzZXMgYC54W10gPC0gbWFwKC54LCAuZiwgLi4uKWAgZm9yIGFzc2lnbm1lbnQuKQoKTm90ZXM6IHRoaXMgY29kZSBtYWtlcyB0aGUgcmVjeWNsaW5nIGNsZWFyOgoKYGBge3J9CnVubGlzdChtYXAobXRjYXJzLCAxKSkKYGBgCgotLS0KCjIuICBSZXdyaXRlIHRoZSBmb2xsb3dpbmcgY29kZSB0byB1c2UgYGl3YWxrKClgIGluc3RlYWQgb2YgYHdhbGsyKClgLiBXaGF0CiAgICBhcmUgdGhlIGFkdmFudGFnZXMgYW5kIGRpc2FkdmFudGFnZXM/CgpgYGB7ciwgZXZhbCA9IEZBTFNFfQpjeWxzIDwtIHNwbGl0KG10Y2FycywgbXRjYXJzJGN5bCkKcGF0aHMgPC0gZmlsZS5wYXRoKHRlbXAsIHBhc3RlMCgiY3lsLSIsIG5hbWVzKGN5bHMpLCAiLmNzdiIpKQp3YWxrMihjeWxzLCBwYXRocywgd3JpdGUuY3N2KQpgYGAKCkFuc3dlcjogY29kZSBiZWxvdy4KCmBgYHtyfQp0ZW1wIDwtIHRlbXBmaWxlKCkKZGlyLmNyZWF0ZSh0ZW1wKQoKY3lscyA8LSBzcGxpdChtdGNhcnMsIG10Y2FycyRjeWwpCml3YWxrKGN5bHMsIH4gd3JpdGUuY3N2KC54LCBmaWxlLnBhdGgodGVtcCwgcGFzdGUwKCJjeWwtIiwgLnksICIuY3N2IikpKSkKZGlyKHRlbXApCmBgYAoKVGhlIG1haW4gYWR2YW50YWdlIG9mIHVzaW5nIGBpd2FsaygpYCBpcyB0aGF0IGl0IHdpbGwgdXNlIGBzZXFfYWxvbmcoKWAgaWYgYHhgIGRvZXMgbm90IGhhdmUgbmFtZXMuIEluIHRoaXMgY2FzZSwgeCBoYXMgbmFtZXMsIGFuZCB0aGUgcmVzdWx0aW5nIGNvZGUgaXMgYSBiaXQgaGFyZGVyIHRvIHVuZGVyc3RhbmQsIGFuZCByZXF1aXJlcyBhIGZvcm11bGEgKG9yIGZ1bmN0aW9uKS4KCkFSIFNvbHV0aW9uczogYGl3YWxrKClgIGFsbG93cyB1cyB0byB1c2UgYSBzaW5nbGUgdmFyaWFibGUsIHN0b3JpbmcgdGhlIG91dHB1dCBwYXRoIGluIHRoZSBuYW1lcy4KCmBgYHtyLCBldmFsID0gRkFMU0V9CnRlbXAgPC0gdGVtcGZpbGUoKQpkaXIuY3JlYXRlKHRlbXApCmN5bHMgPC0gc3BsaXQobXRjYXJzLCBtdGNhcnMkY3lsKQpuYW1lcyhjeWxzKSA8LSBmaWxlLnBhdGgodGVtcCwgcGFzdGUwKCJjeWwtIiwgbmFtZXMoY3lscyksICIuY3N2IikpCml3YWxrKGN5bHMsIH4gd3JpdGUuY3N2KC54LCAueSkpCmBgYAoKV2UgY291bGQgZG8gdGhpcyBpbiBhIHNpbmdsZSBwaXBlIGJ5IHRha2luZyBhZHZhbnRhZ2Ugb2YgYHNldF9uYW1lcygpYDoKCmBgYHtyLCBldmFsID0gRkFMU0V9Cm10Y2FycyAlPiUKICBzcGxpdChtdGNhcnMkY3lsKSAlPiUKICBzZXRfbmFtZXMofiBmaWxlLnBhdGgodGVtcCwgcGFzdGUwKCJjeWwtIiwgLngsICIuY3N2IikpKSAlPiUKICBpd2Fsayh+IHdyaXRlLmNzdigueCwgLnkpKQpgYGAKCk5vdGVzOiB0aGUgQVIgU29sdXRpb25zIHVzZSBvZiBuYW1lcyBhbmQgdGhlIHBpcGUgaXMgY2xldmVyLgoKLS0tCgozLiAgRXhwbGFpbiBob3cgdGhlIGZvbGxvd2luZyBjb2RlIHRyYW5zZm9ybXMgYSBkYXRhIGZyYW1lIHVzaW5nIGZ1bmN0aW9ucwogICAgc3RvcmVkIGluIGEgbGlzdC4KCmBgYHtyfQppZiAoZXhpc3RzKCJtdGNhcnMiKSkgcm0obXRjYXJzKQptdGNhcnMKCnRyYW5zIDwtIGxpc3QoCiAgZGlzcCA9IGZ1bmN0aW9uKHgpIHggKiAwLjAxNjM4NzEsCiAgYW0gPSBmdW5jdGlvbih4KSBmYWN0b3IoeCwgbGFiZWxzID0gYygiYXV0byIsICJtYW51YWwiKSkKKQoKbm0gPC0gbmFtZXModHJhbnMpCm10Y2Fyc1tubV0gPC0gbWFwMih0cmFucywgbXRjYXJzW25tXSwgZnVuY3Rpb24oZiwgdmFyKSBmKHZhcikpCgptdGNhcnMKcm0obXRjYXJzKQpgYGAKCkNvbXBhcmUgYW5kIGNvbnRyYXN0IHRoZSBgbWFwMigpYCBhcHByb2FjaCB0byB0aGlzIGBtYXAoKWAgYXBwcm9hY2g6CgpgYGB7ciwgZXZhbCA9IEZBTFNFfQptdGNhcnNbbm1dIDwtIG1hcChubSwgfiB0cmFuc1tbLnhdXShtdGNhcnNbWy54XV0pKQpgYGAKCkFuc3dlcjogdGhlIGBtYXAyKClgIGNvZGUgYXBwbGllcyB0aGUgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byB0aGUgY29ycmVzcG9uZGluZyBjb2x1bW4gaW4gYG10Y2Fyc2AgYmFzZWQgb24gdGhlaXIgbmFtZSBpbiB0aGUgbGlzdDoKCi0gYG10Y2Fyc1tubV1gIGlzIGVxdWl2YWxlbnQgdG8gYG10Y2Fyc1tjKCJkaXNwIiwgImFtIildYCwgc28gdGhlIGNvZGUgaXMgbW9kaWZ5aW5nIHRob3NlIHR3bwogIGNvbHVtbnMKLSB0aGUgbWFwcGluZyBmdW5jdGlvbiwgYGZ1bmN0aW9uKGYsIHZhcikgZih2YXIpYCBpcyBydW4gYXMgYGYobXRjYXJzW1siZGlzcCJdXSlgIGFuZAogIGBmKG10Y2Fyc1tbImFtIl1dKWAsIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb24gaW4gYHRyYW5zYCBhcyBgZmAsIHNpbmNlIGB0cmFuc2AgYW5kCiAgYG10Y2Fyc1tubV1gIGFyZSBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byB0aGUgZnVuY3Rpb24KClRoZSBlcXVpdmFsZW50IGBtYXAoKWAgYXBwcm9hY2ggaXNuJ3QgYXMgY2xlYW46IGl0J3MgaGFyZGVyIHRvIHVuZGVyc3RhbmQgd2hhdCBgbWFwKClgIGlzIGRvaW5nLgoKQVIgU29sdXRpb25zOiBJbiB0aGUgZmlyc3QgYXBwcm9hY2gKCmBgYHtyLCBldmFsID0gRkFMU0V9Cm10Y2Fyc1tubV0gPC0gbWFwMih0cmFucywgbXRjYXJzW25tXSwgZnVuY3Rpb24oZiwgdmFyKSBmKHZhcikpCmBgYAoKdGhlIGxpc3Qgb2YgdGhlIDIgZnVuY3Rpb25zIChgdHJhbnNgKSBhbmQgdGhlIDIgYXBwcm9wcmlhdGVseSBzZWxlY3RlZCBkYXRhIGZyYW1lIGNvbHVtbnMgKGBtdGNhcnNbbm1dYCkgYXJlIHN1cHBsaWVkIHRvIGBtYXAyKClgLiBgbWFwMigpYCBjcmVhdGVzIGFuIGFub255bW91cyBmdW5jdGlvbiAoYGYodmFyKWApIHdoaWNoIGFwcGxpZXMgdGhlIGZ1bmN0aW9ucyB0byB0aGUgdmFyaWFibGVzIHdoZW4gYG1hcDIoKWAgaXRlcmF0ZXMgb3ZlciB0aGVpciAoc2ltaWxhcikgaW5kaWNlcy4gT24gdGhlIGxlZnQtaGFuZCBzaWRlLCB0aGUgcmVzcGVjdGl2ZSAyIGVsZW1lbnRzIG9mIGBtdGNhcnNgIGFyZSBiZWluZyByZXBsYWNlZCBieSB0aGVpciBuZXcgdHJhbnNmb3JtYXRpb25zLgoKVGhlIGBtYXAoKWAgdmFyaWFudAoKYGBge3IsIGV2YWwgPSBGQUxTRX0KbXRjYXJzW25tXSA8LSBtYXAobm0sIH4gdHJhbnNbWy54XV0obXRjYXJzW1sueF1dKSkKYGBgCgpkb2VzIGJhc2ljYWxseSB0aGUgc2FtZS4gSG93ZXZlciwgaXQgZGlyZWN0bHkgaXRlcmF0ZXMgb3ZlciB0aGUgbmFtZXMgKGBubWApIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbnMuIFRoZXJlZm9yZSwgdGhlIGRhdGEgZnJhbWUgY29sdW1ucyBhcmUgc2VsZWN0ZWQgZHVyaW5nIHRoZSBpdGVyYXRpb24uCgpCZXNpZGVzIHRoZSBpdGVyYXRpb24gcGF0dGVybiwgdGhlIGFwcHJvYWNoZXMgZGlmZmVyIGluIHRoZSBwb3NzaWJpbGl0aWVzIGZvciBhcHByb3ByaWF0ZSBhcmd1bWVudCBuYW1pbmcgaW4gdGhlIGAuZmAgYXJndW1lbnQuIEluIHRoZSBgbWFwMigpYCBhcHByb2FjaCB3ZSBpdGVyYXRlIG92ZXIgdGhlIGVsZW1lbnRzIG9mIGB4YCBhbmQgYHlgLiBUaGVyZWZvcmUsIGl0IGlzIHBvc3NpYmxlIHRvIGNob29zZSBhcHByb3ByaWF0ZSBwbGFjZWhvbGRlcnMgbGlrZSBgZmAgYW5kIGB2YXJgLiBUaGlzIG1ha2VzIHRoZSBhbm9ueW1vdXMgZnVuY3Rpb24gbW9yZSBleHByZXNzaXZlIGF0IHRoZSBjb3N0IG9mIG1ha2luZyBpdCBsb25nZXIuIFdlIHRoaW5rIHVzaW5nIHRoZSBmb3JtdWxhIGludGVyZmFjZSBpbiB0aGlzIHdheSBpcyBwcmVmZXJhYmxlIGNvbXBhcmVkIHRvIHRoZSByYXRoZXIgY3J5cHRpYyBgbXRjYXJzW25tXSA8LSBtYXAyKHRyYW5zLCBtdGNhcnNbbm1dLCB+IC54KC55KSlgLgoKSW4gdGhlIGBtYXAoKWAgYXBwcm9hY2ggd2UgbWFwIG92ZXIgdGhlIHZhcmlhYmxlIG5hbWVzLiBJdCBpcyB0aGVyZWZvcmUgbm90IHBvc3NpYmxlIHRvIGludHJvZHVjZSBwbGFjZWhvbGRlcnMgZm9yIHRoZSBmdW5jdGlvbiBhbmQgdmFyaWFibGUgbmFtZXMuIFRoZSBmb3JtdWxhIHN5bnRheCB0b2dldGhlciB3aXRoIHRoZSBgLnhgIHByb25vdW4gaXMgcHJldHR5IGNvbXBhY3QuIFRoZSBvYmplY3QgbmFtZXMgYW5kIHRoZSBicmFja2V0cyBjbGVhcmx5IGluZGljYXRlIHRoZSBhcHBsaWNhdGlvbiBvZiB0cmFuc2Zvcm1hdGlvbnMgdG8gc3BlY2lmaWMgY29sdW1ucyBvZiBgbXRjYXJzYC4gSW4gdGhpcyBjYXNlIHRoZSBpdGVyYXRpb24gb3ZlciB0aGUgdmFyaWFibGUgbmFtZXMgY29tZXMgaW4gaGFuZHksIGFzIGl0IGhpZ2hsaWdodHMgdGhlIGltcG9ydGFuY2Ugb2YgbWF0Y2hpbmcgYmV0d2VlbiBgdHJhbnNgIGFuZCBgbXRjYXJzYCBlbGVtZW50IG5hbWVzLiBUb2dldGhlciB3aXRoIHRoZSByZXBsYWNlbWVudCBmb3JtIG9uIHRoZSBsZWZ0LWhhbmQgc2lkZSwgdGhpcyBsaW5lIGlzIHJlbGF0aXZlbHkgZWFzeSB0byBpbnNwZWN0LgoKVG8gc3VtbWFyaXNlLCBpbiBzaXR1YXRpb25zIHdoZXJlIGBtYXAoKWAgYW5kIGBtYXAyKClgIHByb3ZpZGUgc29sdXRpb25zIGZvciBhbiBpdGVyYXRpb24gcHJvYmxlbSwgc2V2ZXJhbCBwb2ludHMgbWF5IGJlIGNvbnNpZGVyZWQgYmVmb3JlIGRlY2lkaW5nIGZvciBvbmUgb3IgdGhlIG90aGVyIGFwcHJvYWNoLgoKLS0tCgo0LiAgV2hhdCBkb2VzIGB3cml0ZS5jc3YoKWAgcmV0dXJuLCBpLmUuIHdoYXQgaGFwcGVucyBpZiB5b3UgdXNlIGl0IHdpdGggCiAgICBgbWFwMigpYCBpbnN0ZWFkIG9mIGB3YWxrMigpYD8KCmBgYHtyfQpwYXRocyA8LSBmaWxlLnBhdGgodGVtcCwgcGFzdGUwKCJjeWwtIiwgbmFtZXMoY3lscyksICIuY3N2IikpCm1hcDIoY3lscywgcGF0aHMsIHdyaXRlLmNzdikKYGBgCgpBbnN3ZXI6IGB3cml0ZS5jc3YoKWAgaXMgZGVzaWduZWQgdG8gcmV0dXJuIGBOVUxMYCwgaW52aXNpYmx5LiBXaGlsZSBgd2FsazIoKWAgaGlkZXMgdGhlIGBOVUxMYCByZXR1cm4gdmFsdWVzLCBgbWFwMigpYCBkb2VzIG5vdC4KCkFSIFNvbHV0aW9uczogYHdyaXRlLmNzdigpYCByZXR1cm5zIGBOVUxMYC4gQXMgd2UgY2FsbCB0aGUgZnVuY3Rpb24gZm9yIGl0cyBzaWRlIGVmZmVjdCAoY3JlYXRpbmcgYSBDU1YgZmlsZSksIGB3YWxrMigpYCB3b3VsZCBiZSBhcHByb3ByaWF0ZSBoZXJlLiBPdGhlcndpc2UsIHdlIHJlY2VpdmUgYSByYXRoZXIgdW5pbmZvcm1hdGl2ZSBsaXN0IG9mIGBOVUxMYHMuCgotLS0KCiMjIDkuNi4zIEV4ZXJjaXNlcwoKMS4gIFdoeSBpc24ndCBgaXMubmEoKWAgYSBwcmVkaWNhdGUgZnVuY3Rpb24/IFdoYXQgYmFzZSBSIGZ1bmN0aW9uIGlzIGNsb3Nlc3QKICAgIHRvIGJlaW5nIGEgcHJlZGljYXRlIHZlcnNpb24gb2YgYGlzLm5hKClgPwoKQW5zd2VyOiBgaXMubmEoeClgIHJldHVybnMgYGxvZ2ljYWwoMClgIHdoZW4gYHhgIGlzIGBOVUxMYCwgd2hpY2ggdmlvbGF0ZXMgdGhlIHJ1bGUgdGhhdCBwcmVkaWNhdGUgZnVuY3Rpb25zIG9ubHkgcmV0dXJuIGBUUlVFYCBvciBgRkFMU0VgLiBgYW55TkEoeCwgcmVjdXJzaXZlID0gRkFMU0UpYCBhcHBlYXJzIHRvIGJlIGEgcHJlZGljYXRlIHZlcnNpb24gb2YgYGlzLm5hKClgLgoKQVIgU29sdXRpb25zOiBgaXMubmEoKWAgaXMgbm90IGEgcHJlZGljYXRlIGZ1bmN0aW9uLCBiZWNhdXNlIGl0IHJldHVybnMgYSBsb2dpY2FsIF92ZWN0b3JfIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgaW5wdXQsIG5vdCBhIHNpbmdsZSBgVFJVRWAgb3IgYEZBTFNFYC4KCmBhbnlOQSgpYCBpcyB0aGUgY2xvc2VzdCBlcXVpdmFsZW50IGJlY2F1c2UgaXQgYWx3YXlzIHJldHVybnMgYSBzaW5nbGUgYFRSVUVgIG9yIGBGQUxTRWAgaWYgdGhlcmUgYXJlIGFueSBtaXNzaW5nIHZhbHVlcyBwcmVzZW50LiBZb3UgY291bGQgYWxzbyBpbWFnaW5lIGFuIGBhbGxOQSgpYCB3aGljaCB3b3VsZCByZXR1cm4gYFRSVUVgIGlmIGFsbCB2YWx1ZXMgd2VyZSBtaXNzaW5nLCBidXQgdGhhdCdzIGNvbnNpZGVyYWJseSBsZXNzIHVzZWZ1bCBzbyBiYXNlIFIgZG9lcyBub3QgcHJvdmlkZSBpdC4KCi0tLQoKMi4gIGBzaW1wbGVfcmVkdWNlKClgIGhhcyBhIHByb2JsZW0gd2hlbiBgeGAgaXMgbGVuZ3RoIDAgb3IgbGVuZ3RoIDEuIERlc2NyaWJlCiAgICB0aGUgc291cmNlIG9mIHRoZSBwcm9ibGVtIGFuZCBob3cgeW91IG1pZ2h0IGdvIGFib3V0IGZpeGluZyBpdC4KCmBgYHtyfQpzaW1wbGVfcmVkdWNlIDwtIGZ1bmN0aW9uKHgsIGYpIHsKICBvdXQgPC0geFtbMV1dCiAgZm9yIChpIGluIHNlcSgyLCBsZW5ndGgoeCkpKSB7CiAgICBvdXQgPC0gZihvdXQsIHhbW2ldXSkKICB9CiAgb3V0Cn0KYGBgCgpBbnN3ZXI6IHVzaW5nIGBzZXEoKWAgcmVzdWx0cyBpbiBhIGJhY2t3YXJkcyBjb3VudCB3aGVuIGB4YCBpcyBsZW5ndGggMCBvciAxLgoKYGBge3J9CnNlcSgyLCAwKQpzZXEoMiwgMSkKYGBgCgpUaGUgZml4IGlzIHRvIGNoZWNrIHRoZSBsZW5ndGggb2YgYHhgIGFuZCByZXR1cm4gaXRzZWxmIHdoZW4gbGVuZ3RoIGlzIDAgYW5kIHRocm93IGFuIGVycm9yIHdoZW4gbGVuZ3RoIGlzIDEsIGFzIGByZWR1Y2UoKWAgZG9lcy4KCkFSIFNvbHV0aW9uczogVGhlIGxvb3AgaW5zaWRlIGBzaW1wbGVfcmVkdWNlKClgIGFsd2F5cyBzdGFydHMgd2l0aCB0aGUgaW5kZXggMiwgYW5kIGBzZXEoKWAgY2FuIGNvdW50IGJvdGggdXAgX2FuZF8gZG93bjoKClRoZXJlZm9yZSwgc3Vic2V0dGluZyBsZW5ndGgtMCBhbmQgbGVuZ3RoLTEgdmVjdG9ycyB2aWEgYFtbYCB3aWxsIGxlYWQgdG8gYSAqc3Vic2NyaXB0IG91dCBvZiBib3VuZHMqIGVycm9yLiBUbyBhdm9pZCB0aGlzLCB3ZSBhbGxvdyBgc2ltcGxlX3JlZHVjZSgpYCB0byByZXR1cm4gYmVmb3JlIHRoZSBmb3IgbG9vcCBpcyBzdGFydGVkIGFuZCBpbmNsdWRlIGEgZGVmYXVsdCBhcmd1bWVudCBmb3IgMC1sZW5ndGggdmVjdG9ycy4KCmBgYHtyfQpzaW1wbGVfcmVkdWNlIDwtIGZ1bmN0aW9uKHgsIGYsIGRlZmF1bHQpIHsKICBpZiAobGVuZ3RoKHgpID09IDBMKSB7CiAgICByZXR1cm4oZGVmYXVsdCkKICB9CiAgaWYgKGxlbmd0aCh4KSA9PSAxTCkgewogICAgcmV0dXJuKHhbWzFMXV0pCiAgfQoKICBvdXQgPC0geFtbMV1dCiAgZm9yIChpIGluIHNlcSgyLCBsZW5ndGgoeCkpKSB7CiAgICBvdXQgPC0gZihvdXQsIHhbW2ldXSkKICB9CgogIG91dAp9CmBgYAoKT3VyIG5ldyBgc2ltcGxlX3JlZHVjZSgpYCBub3cgd29ya3MgYXMgaW50ZW5kZWQ6CgpgYGB7ciwgZXJyb3IgPSBUUlVFfQp0cnkoc2ltcGxlX3JlZHVjZShpbnRlZ2VyKDApLCBgK2ApKQpzaW1wbGVfcmVkdWNlKGludGVnZXIoMCksIGArYCwgZGVmYXVsdCA9IDBMKQpzaW1wbGVfcmVkdWNlKDEsIGArYCkKc2ltcGxlX3JlZHVjZSgxOjMsIGArYCkKYGBgCgotLS0KCjMuICBJbXBsZW1lbnQgdGhlIGBzcGFuKClgIGZ1bmN0aW9uIGZyb20gSGFza2VsbDogZ2l2ZW4gYSBsaXN0IGB4YCBhbmQgYSAKICAgIHByZWRpY2F0ZSBmdW5jdGlvbiBgZmAsIGBzcGFuKHgsIGYpYCByZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgbG9uZ2VzdCAKICAgIHNlcXVlbnRpYWwgcnVuIG9mIGVsZW1lbnRzIHdoZXJlIHRoZSBwcmVkaWNhdGUgaXMgdHJ1ZS4gKEhpbnQ6IHlvdSAKICAgIG1pZ2h0IGZpbmQgYHJsZSgpYCBoZWxwZnVsLikKCmBgYHtyfQp0ZXN0IDwtIGMoYXMubGlzdChsZXR0ZXJzWzE6MjFdKSwgYXMubGlzdCgxOjIwKSwgYXMubGlzdChsZXR0ZXJzWzIyOjI2XSksIGFzLmxpc3QoMjA6MzkpKQp0ZXN0MiA8LSBjKGFzLmxpc3QobGV0dGVyc1sxOjIxXSksIGFzLmxpc3QoMToyMCksIGFzLmxpc3QobGV0dGVyc1syMjoyNl0pLCBhcy5saXN0KDIwOjQwKSkKCnNwYW4gPC0gZnVuY3Rpb24oeCwgZikgewogIHJ1bnMgPC0gcmxlKG1hcF9sZ2woeCwgZikpCiAgbWF4X3RydWUgPC0gbWF4X2luZGV4IDwtIDAKICBpbmRleCA8LSAxCiAgZm9yIChpIGluIHNlcV9hbG9uZyhydW5zJHZhbHVlcykpIHsKICAgIGlmIChydW5zJHZhbHVlc1tpXSAmJiBydW5zJGxlbmd0aHNbaV0gPiBtYXhfdHJ1ZSkgewogICAgICBtYXhfdHJ1ZSA8LSBydW5zJGxlbmd0aHNbaV0KICAgICAgbWF4X2luZGV4IDwtIGluZGV4CiAgICB9CiAgICBpbmRleCA8LSBpbmRleCArIHJ1bnMkbGVuZ3Roc1tpXQogIH0KICBtYXhfaW5kZXgKfQoKc3Bhbih0ZXN0LCBpcy5udW1lcmljKQpzcGFuKHRlc3QyLCBpcy5udW1lcmljKQpzcGFuKDEsIGlzLm51bWVyaWMpCnNwYW4oImEiLCBpcy5udW1lcmljKQpzcGFuKGxpc3QoImEiLCAxOjEwLCAxOjIwKSwgaXMubnVtZXJpYykKYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IE91ciBgc3Bhbl9yKClgIGZ1bmN0aW9uIHJldHVybnMgdGhlIGluZGljZXMgb2YgdGhlIChmaXJzdCBvY2N1cnJpbmcpIGxvbmdlc3Qgc2VxdWVudGlhbCBydW4gb2YgZWxlbWVudHMgd2hlcmUgdGhlIHByZWRpY2F0ZSBpcyB0cnVlLiBJZiB0aGUgcHJlZGljYXRlIGlzIG5ldmVyIHRydWUsIHRoZSBsb25nZXN0IHJ1biBoYXMgbGVuZ3RoIDAsIGluIHdoaWNoIGNhc2Ugd2UgcmV0dXJuIGBpbnRlZ2VyKDApYC4KCmBgYHtyfQpzcGFuX3IgPC0gZnVuY3Rpb24oeCwgZikgewogIGlkeCA8LSB1bm5hbWUobWFwX2xnbCh4LCB+IGYoLngpKSkKICBybGUgPC0gcmxlKGlkeCkKCiAgIyBDaGVjayBpZiB0aGUgcHJlZGljYXRlIGlzIG5ldmVyIHRydWUKICBpZiAoIWFueShybGUkdmFsdWVzKSkgewogICAgcmV0dXJuKGludGVnZXIoMCkpCiAgfQoKICAjIEZpbmQgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBzZXF1ZW5jZSBvZiB0cnVlIHZhbHVlcwogIGxvbmdlc3QgPC0gbWF4KHJsZSRsZW5ndGhzW3JsZSR2YWx1ZXNdKQogICMgRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIChmaXJzdCkgbG9uZ2VzdCBydW4gaW4gcmxlCiAgbG9uZ2VzdF9pZHggPC0gd2hpY2gocmxlJHZhbHVlcyAmIHJsZSRsZW5ndGhzID09IGxvbmdlc3QpWzFdCgogICMgQWRkIHVwIGFsbCBsZW5ndGhzIGluIHJsZSBiZWZvcmUgdGhlIGxvbmdlc3QgcnVuCiAgaW5kX2JlZm9yZV9sb25nZXN0IDwtIHN1bShybGUkbGVuZ3Roc1tzZXFfbGVuKGxvbmdlc3RfaWR4IC0gMSldKQoKICBvdXRfc3RhcnQgPC0gaW5kX2JlZm9yZV9sb25nZXN0ICsgMUwKICBvdXRfZW5kIDwtIGluZF9iZWZvcmVfbG9uZ2VzdCArIGxvbmdlc3QKICBvdXRfc3RhcnQ6b3V0X2VuZAp9CgojIENoZWNrIHRoYXQgaXQgd29ya3MKc3Bhbl9yKGMoMCwgMCwgMCwgMCwgMCksIGlzLm5hKQpzcGFuX3IoYyhOQSwgMCwgMCwgMCwgMCksIGlzLm5hKQpzcGFuX3IoYyhOQSwgMCwgTkEsIE5BLCBOQSksIGlzLm5hKQpgYGAKCk5vdGVzOiBBUiBTb2x1dGlvbnMgc2hvd3MgaG93IHRvIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBsb25nZXN0IHNlcXVlbmNlIHVzaW5nIGB3aGljaCgpYCwgd2hpY2ggaXMgbmV3IHRvIG1lLCBhbmQgcmV0dXJucyBtb3JlIGluZm9ybWF0aW9uIGJ5IHJldHVybmluZyBpbmRleGVzIG9mIHRoZSBlbnRpcmUgc3Bhbi4gVGhlIEFSIFNvbHV0aW9ucyBhcHByb2FjaCBpcyBhbHNvIHNpZ25pZmljYW50bHkgZmFzdGVyICh3aGljaCBJIGRpZCBub3QgZXhwZWN0KS4KCmBgYHtyfQpiZW5jaDo6bWFyayhzcGFuX3IodGVzdDIsIGlzLm51bWVyaWMpKQpiZW5jaDo6bWFyayhzcGFuKHRlc3QyLCBpcy5udW1lcmljKSkKYGBgCgotLS0KCjQuICBJbXBsZW1lbnQgYGFyZ19tYXgoKWAuIEl0IHNob3VsZCB0YWtlIGEgZnVuY3Rpb24gYW5kIGEgdmVjdG9yIG9mIGlucHV0cywgCiAgICBhbmQgcmV0dXJuIHRoZSBlbGVtZW50cyBvZiB0aGUgaW5wdXQgd2hlcmUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIGhpZ2hlc3QgCiAgICB2YWx1ZS4gRm9yIGV4YW1wbGUsIGBhcmdfbWF4KC0xMDo1LCBmdW5jdGlvbih4KSB4IF4gMilgIHNob3VsZCByZXR1cm4gLTEwLgogICAgYGFyZ19tYXgoLTU6NSwgZnVuY3Rpb24oeCkgeCBeIDIpYCBzaG91bGQgcmV0dXJuIGBjKC01LCA1KWAuCiAgICBBbHNvIGltcGxlbWVudCB0aGUgbWF0Y2hpbmcgYGFyZ19taW4oKWAgZnVuY3Rpb24uCgpBbnN3ZXI6IGNvZGUgYmVsb3cuCgpgYGB7cn0KYXJnX21heCA8LSBmdW5jdGlvbih4LCBmKSB7CiAgdmFsIDwtIG1hcF9kYmwoeCwgZikKICB2YWxfbWF4IDwtIG1heCh2YWwpCiAgeFt3aGljaCh2YWwgPT0gdmFsX21heCldCn0KCmFyZ19tYXgoLTEwOjUsIGZ1bmN0aW9uKHgpIHheMikKYXJnX21heCgtNTo1LCBmdW5jdGlvbih4KSB4XjIpCgphcmdfbWluIDwtIGZ1bmN0aW9uKHgsIGYpIHsKICB2YWwgPC0gbWFwX2RibCh4LCBmKQogIHZhbF9taW4gPC0gbWluKHZhbCkKICB4W3doaWNoKHZhbCA9PSB2YWxfbWluKV0KfQoKYXJnX21pbigtMTA6NSwgZnVuY3Rpb24oeCkgeF4yKQphcmdfbWluKGMoLTU6LTEsIDE6NSksIGZ1bmN0aW9uKHgpIHheMikKYGBgCgpBUiBTb2x1dGlvbnM6IEJvdGggZnVuY3Rpb25zIHRha2UgYSB2ZWN0b3Igb2YgaW5wdXRzIGFuZCBhIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50LiBUaGUgZnVuY3Rpb24gb3V0cHV0IGlzIHRoZW4gdXNlZCB0byBzdWJzZXQgdGhlIGlucHV0IGFjY29yZGluZ2x5LgoKYGBge3J9CmFyZ19tYXggPC0gZnVuY3Rpb24oeCwgZikgewogIHkgPC0gbWFwX2RibCh4LCBmKQogIHhbeSA9PSBtYXgoeSldCn0KCmFyZ19taW4gPC0gZnVuY3Rpb24oeCwgZikgewogIHkgPC0gbWFwX2RibCh4LCBmKQogIHhbeSA9PSBtaW4oeSldCn0KCmFyZ19tYXgoLTEwOjUsIGZ1bmN0aW9uKHgpIHheMikKYXJnX21pbigtMTA6NSwgZnVuY3Rpb24oeCkgeF4yKQpgYGAKCk5vdGVzOiB1c2luZyBgd2hpY2goKWAgaXMgdW5uZWNlc3NhcnksIEFSIFNvbHV0aW9ucyBpcyBhIGJldHRlciBhcHByb2FjaC4KCi0tLQoKNS4gIFRoZSBmdW5jdGlvbiBiZWxvdyBzY2FsZXMgYSB2ZWN0b3Igc28gaXQgZmFsbHMgaW4gdGhlIHJhbmdlIFswLCAxXS4gSG93CiAgICB3b3VsZCB5b3UgYXBwbHkgaXQgdG8gZXZlcnkgY29sdW1uIG9mIGEgZGF0YSBmcmFtZT8gSG93IHdvdWxkIHlvdSBhcHBseSBpdCAKICAgIHRvIGV2ZXJ5IG51bWVyaWMgY29sdW1uIGluIGEgZGF0YSBmcmFtZT8KCmBgYHtyfQpzY2FsZTAxIDwtIGZ1bmN0aW9uKHgpIHsKICBybmcgPC0gcmFuZ2UoeCwgbmEucm0gPSBUUlVFKQogICh4IC0gcm5nWzFdKSAvIChybmdbMl0gLSBybmdbMV0pCn0KYGBgCgpBbnN3ZXI6IGNvZGUgYmVsb3cuCgpgYGB7cn0KIyBldmVyeSBjb2x1bW4KbW9kaWZ5KG10Y2Fycywgc2NhbGUwMSkKCiMgZXZlcnkgbnVtZXJpYyBjb2x1bW4KbW9kaWZ5X2lmKGlyaXMsIGlzLm51bWVyaWMsIHNjYWxlMDEpCmBgYAoKQVIgU29sdXRpb25zOiBUbyBhcHBseSBhIGZ1bmN0aW9uIHRvIGV2ZXJ5IGNvbHVtbiBvZiBhIGRhdGEgZnJhbWUsIHdlIGNhbiB1c2UgYHB1cnJyOjptb2RpZnkoKWAgKG9yIGBwdXJycjo6bWFwX2RmcigpYCksIHdoaWNoIGFsc28gY29udmVuaWVudGx5IHJldHVybnMgYSBkYXRhIGZyYW1lLiBUbyBsaW1pdCB0aGUgYXBwbGljYXRpb24gdG8gbnVtZXJpYyBjb2x1bW5zLCB0aGUgc2NvcGVkIHZlcnNpb24gYG1vZGlmeV9pZigpYCBjYW4gYmUgdXNlZC4KCmBgYHtyLCBldmFsID0gRkFMU0V9Cm1vZGlmeV9pZihtdGNhcnMsIGlzLm51bWVyaWMsIHNjYWxlMDEpCmBgYAoKLS0tCgojIyA5LjcuMyBFeGVyY2lzZXMKCjEuICBIb3cgZG9lcyBgYXBwbHkoKWAgYXJyYW5nZSB0aGUgb3V0cHV0PyBSZWFkIHRoZSBkb2N1bWVudGF0aW9uIGFuZCBwZXJmb3JtIAogICAgc29tZSBleHBlcmltZW50cy4KCmBgYHtyLCBldmFsID0gRkFMU0V9CiMgZXhwZXJpbWVudHMKbTEgPC0gbWF0cml4KDE6NCwgbnJvdyA9IDEpCmFwcGx5KG0xLCAxLCBzdW0pCmFwcGx5KG0xLCAyLCBzdW0pCmFwcGx5KG0xLCBjKDEsIDIpLCBgKmAsIDIpCmFwcGx5KG0xLCAxLCBgKmAsIDIpCmFwcGx5KG0xLCAxLCBgKmAsIDIsIHNpbXBsaWZ5ID0gRkFMU0UpCmFwcGx5KG0xLCAyLCBgKmAsIDIpCmFwcGx5KG0xLCAxLCBzdW0sIHNpbXBsaWZ5ID0gRkFMU0UpCgptMWEgPC0gbWF0cml4KDE6NCwgbmNvbCA9IDEpCmFwcGx5KG0xYSwgMSwgYCpgLCAyKQoKbTIgPC0gbWF0cml4KDE6MjAsIG5jb2wgPSA0KQphcHBseShtMiwgMSwgc3VtKQoKbTMgPC0gYXJyYXkoMToyNCwgZGltID0gYygyLCAzLCA0KSkKYXBwbHkobTMsIDEsIHN1bSkKYXBwbHkobTMsIDIsIHN1bSkKYXBwbHkobTMsIDMsIHN1bSkKYXBwbHkobTMsIDEsIGAqYCwgMikKYXBwbHkobTMsIDIsIGAqYCwgMikKYXBwbHkobTMsIDMsIGAqYCwgMikKYXBwbHkobTMsIGMoMSwgMiwgMyksIGAqYCwgMikKYGBgCgpBbnN3ZXI6IHRoZSBkb2N1bWVudGF0aW9uIHN0YXRlczoKCj4gSWYgZWFjaCBjYWxsIHRvIGBGVU5gIHJldHVybnMgYSB2ZWN0b3Igb2YgbGVuZ3RoIGBuYCwgYW5kIHNpbXBsaWZ5IGlzIGBUUlVFYCwgdGhlbiBhcHBseSByZXR1cm5zIGFuIGFycmF5IG9mIGRpbWVuc2lvbiBgYyhuLCBkaW0oWClbTUFSR0lOXSlgIGlmIGBuID4gMWAuIElmIGBuYCBlcXVhbHMgMSwgYGFwcGx5YCByZXR1cm5zIGEgdmVjdG9yIGlmIGBNQVJHSU5gIGhhcyBsZW5ndGggMSBhbmQgYW4gYXJyYXkgb2YgYGRpbWVuc2lvbiBkaW0oWClbTUFSR0lOXWAgb3RoZXJ3aXNlLiBJZiBgbmAgaXMgMCwgdGhlIHJlc3VsdCBoYXMgbGVuZ3RoIDAgYnV0IG5vdCBuZWNlc3NhcmlseSB0aGUgJ2NvcnJlY3QnIGRpbWVuc2lvbi4KPiAKPiBJZiB0aGUgY2FsbHMgdG8gYEZVTmAgcmV0dXJuIHZlY3RvcnMgb2YgZGlmZmVyZW50IGxlbmd0aHMsIG9yIGlmIHNpbXBsaWZ5IGlzIGBGQUxTRWAsIGFwcGx5IHJldHVybnMgYSBsaXN0IG9mIGBsZW5ndGggcHJvZChkaW0oWClbTUFSR0lOXSlgIHdpdGggYGRpbWAgc2V0IHRvIGBNQVJHSU5gIGlmIHRoaXMgaGFzIGxlbmd0aCBncmVhdGVyIHRoYW4gb25lLgoKV2l0aCBleHBsb3JhdGlvbiwgdW5kZXIgbm9ybWFsIGNpcmN1bXN0YW5jZXM6CgotIElmIGBNQVJHSU5gIGluY2x1ZGVzIGFsbCBkaW1lbnNpb25zIG9mIGFuIGFycmF5IG9yIG1hdHJpeCAoYGMoMSwgMilgIG9yIGBjKDEsIDIsIDMpYCksIHRoZSBvdXRwdXQKICBpcyBhcnJhbmdlZCBpbiB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgaW5wdXQKLSBPdGhlcndpc2UsIHRoZSByZXR1cm4gdmFsdWUgZHJvcHMgYSBkaW1lbnNpb24gaWYgbW9kaWZ5aW5nIGEgdmVjdG9yIGluIHBsYWNlIChhcyB3aXRoIGAqYCksIG9yCiAgcmV0dXJucyBhIHZlY3RvciB3aGVuIHN1bW1hcml6aW5nIChhcyB3aXRoIGBzdW1gKQotIE1hdHJpY2VzIG9mIGEgc2luZ2xlIHJvdyBhcmUgc2ltcGxpZmllZCB0byBhIHZlY3RvcgotIE1hdHJpY2VzIG9mIGEgc2luZ2xlIGNvbHVtbiBhcmUgcmV0dXJuZWQgYXMgYSBtYXRyaXgKLSBXaGVuIGBzaW1wbGlmeSA9IEZBTFNFYCBpcyBzZXQsIGEgbGlzdCBpcyByZXR1cm5lZAoKSG93ZXZlciwgZXZlbiB3aXRoIGFsbCB0aGlzLCB0aGUgInJ1bGVzIiBhcmVuJ3QgY2xlYXIgdG8gbWUuCgpBUiBTb2x1dGlvbnM6IEJhc2ljYWxseSBgYXBwbHkoKWAgYXBwbGllcyBhIGZ1bmN0aW9uIG92ZXIgdGhlIG1hcmdpbnMgb2YgYW4gYXJyYXkuIEluIHRoZSB0d28tZGltZW5zaW9uYWwgY2FzZSwgdGhlIG1hcmdpbnMgYXJlIGp1c3QgdGhlIHJvd3MgYW5kIGNvbHVtbnMgb2YgYSBtYXRyaXguIExldCdzIG1ha2UgdGhpcyBjb25jcmV0ZS4KCmBgYHtyfQphcnIyIDwtIGFycmF5KDE6MTIsIGRpbSA9IGMoMywgNCkpCnJvd25hbWVzKGFycjIpIDwtIHBhc3RlMCgicm93IiwgMTozKQpjb2xuYW1lcyhhcnIyKSA8LSBwYXN0ZTAoImNvbCIsIDE6NCkKYXJyMgpgYGAKCldoZW4gd2UgYXBwbHkgdGhlIGBoZWFkKClgIGZ1bmN0aW9uIG92ZXIgdGhlIGZpcnN0IG1hcmdpbiBvZiBgYXJyMigpYCAoaS5lLiB0aGUgcm93cyksIHRoZSByZXN1bHRzIGFyZSBjb250YWluZWQgaW4gdGhlIGNvbHVtbnMgb2YgdGhlIG91dHB1dCwgdHJhbnNwb3NpbmcgdGhlIGFycmF5IGNvbXBhcmVkIHRvIHRoZSBvcmlnaW5hbCBpbnB1dC4KCmBgYHtyfQphcHBseShhcnIyLCAxLCBmdW5jdGlvbih4KSB4WzE6Ml0pCmBgYAoKQW5kIHZpY2UgdmVyc2EgaWYgd2UgYXBwbHkgb3ZlciB0aGUgc2Vjb25kIG1hcmdpbiAodGhlIGNvbHVtbnMpOgoKYGBge3J9CmFwcGx5KGFycjIsIDIsIGZ1bmN0aW9uKHgpIHhbMToyXSkKYGBgCgpUaGUgb3V0cHV0IG9mIGBhcHBseSgpYCBpcyBvcmdhbmlzZWQgZmlyc3QgYnkgdGhlIG1hcmdpbnMgYmVpbmcgb3BlcmF0ZWQgb3ZlciwgdGhlbiB0aGUgcmVzdWx0cyBvZiB0aGUgZnVuY3Rpb24uIFRoaXMgY2FuIGJlY29tZSBxdWl0ZSBjb25mdXNpbmcgZm9yIGhpZ2hlciBkaW1lbnNpb25hbCBhcnJheXMuCgpOb3RlczogQVIgU29sdXRpb25zJyBleHBsYW5hdGlvbiBpcyBiZXR0ZXIsIGJ1dCB0aGUgb3V0cHV0IGlzIHN0aWxsIGNvbmZ1c2luZy4KCi0tLQoKMi4gIFdoYXQgZG8gYGVhcHBseSgpYCBhbmQgYHJhcHBseSgpYCBkbz8gRG9lcyBwdXJyciBoYXZlIGVxdWl2YWxlbnRzPwoKQW5zd2VyOiBgZWFwcGx5KClgIGFwcGxpZXMgYSBmdW5jdGlvbiB0byBuYW1lZCB2YWx1ZXMgaW4gYW4gZW52aXJvbm1lbnQuIGByYXBwbHkoKWAgaXMgYSByZWN1cnNpdmUgYGxhcHBseSgpYC4gVGhlcmUgYXJlIG5vIGVxdWl2YWxlbnRzIGluIHB1cnJyLgoKQVIgU29sdXRpb25zOiBgZWFwcGx5KClgIGlzIGEgdmFyaWFudCBvZiBgbGFwcGx5KClgLCB3aGljaCBpdGVyYXRlcyBvdmVyIHRoZSAobmFtZWQpIGVsZW1lbnRzIG9mIGFuIGVudmlyb25tZW50LiBJbiBgcHVycnJgIHRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgZm9yIGBlYXBwbHkoKWAgYXMgYHB1cnJyYCBtYWlubHkgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgb3BlcmF0ZSBvbiB2ZWN0b3JzIGFuZCBmdW5jdGlvbnMsIGJ1dCBub3Qgb24gZW52aXJvbm1lbnRzLgoKYHJhcHBseSgpYCBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gYWxsIGVsZW1lbnRzIG9mIGEgbGlzdCByZWN1cnNpdmVseS4gVGhpcyBmdW5jdGlvbiBtYWtlcyBpdCBwb3NzaWJsZSB0byBsaW1pdCB0aGUgYXBwbGljYXRpb24gb2YgdGhlIGZ1bmN0aW9uIHRvIHNwZWNpZmllZCBjbGFzc2VzIChkZWZhdWx0IGBjbGFzc2VzID0gQU5ZYCkuIE9uZSBtYXkgYWxzbyBzcGVjaWZ5IGhvdyBlbGVtZW50cyBvZiBvdGhlciBjbGFzc2VzIHNob3VsZCByZW1haW46IGFzIHRoZWlyIGlkZW50aXR5IChgaG93ID0gcmVwbGFjZWApIG9yIGFub3RoZXIgdmFsdWUgKGBkZWZhdWx0ID0gTlVMTGApLiBUaGUgY2xvc2VzdCBlcXVpdmFsZW50IGluIGBwdXJycmAgaXMgYG1vZGlmeV9kZXB0aCgpYCwgd2hpY2ggYWxsb3dzIHlvdSB0byBtb2RpZnkgZWxlbWVudHMgYXQgYSBzcGVjaWZpZWQgZGVwdGggaW4gYSBuZXN0ZWQgbGlzdC4KCk5vdGVzOiBJIHdhc24ndCBhd2FyZSBvZiBgcHVycnI6Om1vZGlmeV9kZXB0aCgpYC4KCi0tLQoKMy4gIENoYWxsZW5nZTogcmVhZCBhYm91dCB0aGUgCiAgICBbZml4ZWQgcG9pbnQgYWxnb3JpdGhtXShodHRwczovL21pdHByZXNzLm1pdC5lZHUvc2l0ZXMvZGVmYXVsdC9maWxlcy9zaWNwL2Z1bGwtdGV4dC9ib29rL2Jvb2stWi1ILTEyLmh0bWwjJTI1X2lkeF8xMDk2KS4KICAgIENvbXBsZXRlIHRoZSBleGVyY2lzZXMgdXNpbmcgUi4KCkFuc3dlcjogdGhlIGZpeGVkIHBvaW50IGFsZ29yaXRobSBpcyBkZWZpbmVkIGJlbG93LCB3aXRoIGFuIGV4YW1wbGUgc29sdXRpb246CgpgYGAKKGRlZmluZSB0b2xlcmFuY2UgMC4wMDAwMSkKKGRlZmluZSAoZml4ZWQtcG9pbnQgZiBmaXJzdC1ndWVzcykKICAoZGVmaW5lIChjbG9zZS1lbm91Z2g/IHYxIHYyKQogICAgKDwgKGFicyAoLSB2MSB2MikpIHRvbGVyYW5jZSkpCiAgKGRlZmluZSAodHJ5IGd1ZXNzKQogICAgKGxldCAoKG5leHQgKGYgZ3Vlc3MpKSkKICAgICAgKGlmIChjbG9zZS1lbm91Z2g/IGd1ZXNzIG5leHQpCiAgICAgICAgICBuZXh0CiAgICAgICAgICAodHJ5IG5leHQpKSkpCiAgKHRyeSBmaXJzdC1ndWVzcykpCgooZml4ZWQtcG9pbnQgY29zIDEuMCkKMC43MzkwODIyOTg1MjI0MDIzCgooZml4ZWQtcG9pbnQgKGxhbWJkYSAoeSkgKCsgKHNpbiB5KSAoY29zIHkpKSkKICAgICAgICAgICAgIDEuMCkKMS4yNTg3MzE1OTYyOTcxMTczCgooZGVmaW5lIChzcXJ0IHgpCiAgKGZpeGVkLXBvaW50IChsYW1iZGEgKHkpICgvIHggeSkpCiAgICAgICAgICAgICAgIDEuMCkpCmBgYAoKSW1wbGVtZW50YXRpb24gaW4gUjoKCmBgYHtyfQpmaXhlZF9wb2ludCA8LSBmdW5jdGlvbihmLCB4KSB7CiAgdG9sZXJhbmNlIDwtIDAuMDAwMDEKICBjbG9zZV9lbm91Z2ggPC0gZnVuY3Rpb24odjEsIHYyKSB7CiAgICBhYnModjEgLSB2MikgPCB0b2xlcmFuY2UKICB9CgogIGlmIChjbG9zZV9lbm91Z2goZih4KSwgeCkpIHsKICAgIGYoeCkKICB9IGVsc2UgewogICAgZml4ZWRfcG9pbnQoZiwgZih4KSkKICB9Cn0KCmZpeGVkX3BvaW50KGNvcywgMS4wKQpmaXhlZF9wb2ludChmdW5jdGlvbih5KSBzaW4oeSkgKyBjb3MoeSksIDEuMCkKYGBgCgpBUiBTb2x1dGlvbnM6IEEgbnVtYmVyICR4JCBpcyBjYWxsZWQgYSBmaXhlZCBwb2ludCBvZiBhIGZ1bmN0aW9uICRmJCBpZiBpdCBzYXRpc2ZpZXMgdGhlIGVxdWF0aW9uICRmKHgpID0geCQuIEZvciBzb21lIGZ1bmN0aW9ucyB3ZSBtYXkgZmluZCBhIGZpeGVkIHBvaW50IGJ5IGJlZ2lubmluZyB3aXRoIGEgc3RhcnRpbmcgdmFsdWUgYW5kIGFwcGx5aW5nICRmJCByZXBlYXRlZGx5LiBIZXJlIGBmaXhlZF9wb2ludCgpYCBhY3RzIGFzIGEgZnVuY3Rpb25hbCBiZWNhdXNlIGl0IHRha2VzIGEgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnQuCgpgYGB7ciwgZXJyb3IgPSBUUlVFfQpmaXhlZF9wb2ludF9hciA8LSBmdW5jdGlvbihmLCB4X2luaXQsIG5fbWF4ID0gMTAwMDAsIHRvbCA9IDAuMDAwMSkgewogIG4gPC0gMAogIHggPC0geF9pbml0CiAgeSA8LSBmKHgpCgogIGlzX2ZpeGVkX3BvaW50IDwtIGZ1bmN0aW9uKHgsIHkpIHsKICAgIGFicyh4IC0geSkgPCB0b2wKICB9CgogIHdoaWxlICghaXNfZml4ZWRfcG9pbnQoeCwgeSkpIHsKICAgIHggPC0geQogICAgeSA8LSBmKHkpCgogICAgIyBNYWtlIHN1cmUgd2UgZXZlbnR1YWxseSBzdG9wCiAgICBuIDwtIG4gKyAxCiAgICBpZiAobiA+IG5fbWF4KSB7CiAgICAgIHN0b3AoIkZhaWxlZCB0byBjb252ZXJnZS4iLCBjYWxsLiA9IEZBTFNFKQogICAgfQogIH0KCiAgeAp9CgojIEZ1bmN0aW9ucyB3aXRoIGZpeGVkIHBvaW50cwpmaXhlZF9wb2ludF9hcihzaW4sIHhfaW5pdCA9IDEpCmZpeGVkX3BvaW50X2FyKGNvcywgeF9pbml0ID0gMSkKCiMgRnVuY3Rpb25zIHdpdGhvdXQgZml4ZWQgcG9pbnRzCmFkZF9vbmUgPC0gZnVuY3Rpb24oeCkgeCArIDEKdHJ5KGZpeGVkX3BvaW50X2FyKGFkZF9vbmUsIHhfaW5pdCA9IDEpKQpgYGAKCk5vdGVzOiBBUiBTb2x1dGlvbnMgb2ZmZXJzIGEgZGlmZmVyZW50IGFwcHJvYWNoIHVzaW5nIGEgYHdoaWxlKClgIGxvb3AgdGhhdCBpcyBndWFyYW50ZWVkIHRvIHN0b3AuIE15IGFwcHJvYWNoIHVzaW5nIHJlY3Vyc2l2ZSBjYWxscyBkb2VzIHN0b3AgZXZlbnR1YWxseSB3aXRoIGEgc3RhY2sgbGltaXQgZXJyb3IgKGhvd2V2ZXIsIHRoaXMgc3RvcHMgYGJ1aWxkX2FuYWx5c2lzX3NpdGUoKWApOgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KZml4ZWRfcG9pbnQoYWRkX29uZSwgMSkKYGBgCgpDb21wYXJpbmcgYmVuY2htYXJrczoKCmBgYHtyfQpiZW5jaDo6bWFyayhmaXhlZF9wb2ludF9hcihjb3MsIHhfaW5pdCA9IDEsIHRvbCA9IDAuMDAwMDEpKQpiZW5jaDo6bWFyayhmaXhlZF9wb2ludChjb3MsIDEpKQpgYGAKCkFzIHVzdWFsLCBBUiBTb2x1dGlvbnMgaXMgZmFzdGVyLiA6LSgKCi0tLQoKIyAxMCBGdW5jdGlvbiBmYWN0b3JpZXMKCmBgYHtyfQpybShsaXN0ID0gbHMoKSkKYGBgCgpBIF9fZnVuY3Rpb24gZmFjdG9yeV9fIGlzIGEgZnVuY3Rpb24gdGhhdCBtYWtlcyBmdW5jdGlvbnMuIEhlcmUncyBhIHZlcnkgc2ltcGxlIGV4YW1wbGU6IHdlIHVzZSBhIGZ1bmN0aW9uIGZhY3RvcnkgKGBwb3dlcjEoKWApIHRvIG1ha2UgdHdvIGNoaWxkIGZ1bmN0aW9ucyAoYHNxdWFyZSgpYCBhbmQgYGN1YmUoKWApOgoKYGBge3J9CnBvd2VyMSA8LSBmdW5jdGlvbihleHApIHsKICBmdW5jdGlvbih4KSB7CiAgICB4XmV4cAogIH0KfQpzcXVhcmUgPC0gcG93ZXIxKDIpCmN1YmUgPC0gcG93ZXIxKDMpCmBgYAoKRG9uJ3Qgd29ycnkgaWYgdGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UgeWV0LCBpdCBzaG91bGQgYnkgdGhlIGVuZCBvZiB0aGUgY2hhcHRlciEKCkknbGwgY2FsbCBgc3F1YXJlKClgIGFuZCBgY3ViZSgpYCBfX21hbnVmYWN0dXJlZCBmdW5jdGlvbnNfXywgYnV0IHRoaXMgaXMganVzdCBhIHRlcm0gdG8gZWFzZSBjb21tdW5pY2F0aW9uIHdpdGggb3RoZXIgaHVtYW5zOiBmcm9tIFIncyBwZXJzcGVjdGl2ZSB0aGV5IGFyZSBubyBkaWZmZXJlbnQgdG8gZnVuY3Rpb25zIGNyZWF0ZWQgYW55IG90aGVyIHdheS4gCgpgYGB7cn0Kc3F1YXJlKDMpCmN1YmUoMykKYGBgCgpZb3UgaGF2ZSBhbHJlYWR5IGxlYXJuZWQgYWJvdXQgdGhlIGluZGl2aWR1YWwgY29tcG9uZW50cyB0aGF0IG1ha2UgZnVuY3Rpb24gZmFjdG9yaWVzIHBvc3NpYmxlOgoKKiBJbiBTZWN0aW9uIDYuMi4zLCB5b3UgbGVhcm5lZCBhYm91dCBSJ3MgZmlyc3QtY2xhc3MgCiAgZnVuY3Rpb25zLiBJbiBSLCB5b3UgYmluZCBhIGZ1bmN0aW9uIHRvIGEgbmFtZSBpbiB0aGUgc2FtZSB3YXkgYXMgeW91IGJpbmQKICBhbnkgb2JqZWN0IHRvIGEgbmFtZTogd2l0aCBgPC1gLgoKKiBJbiBTZWN0aW9uIDcuNC4yLCB5b3UgbGVhcm5lZCB0aGF0IGEgZnVuY3Rpb24KICBjYXB0dXJlcyAoZW5jbG9zZXMpIHRoZSBlbnZpcm9ubWVudCBpbiB3aGljaCBpdCBpcyBjcmVhdGVkLgoKKiBJbiBTZWN0aW9uIDcuNC40LCB5b3UgbGVhcm5lZCB0aGF0IGEgZnVuY3Rpb24gCiAgY3JlYXRlcyBhIG5ldyBleGVjdXRpb24gZW52aXJvbm1lbnQgZXZlcnkgdGltZSBpdCBpcyBydW4uIFRoaXMgZW52aXJvbm1lbnQKICBpcyB1c3VhbGx5IGVwaGVtZXJhbCwgYnV0IGhlcmUgaXQgYmVjb21lcyB0aGUgZW5jbG9zaW5nIGVudmlyb25tZW50IG9mIAogIHRoZSBtYW51ZmFjdHVyZWQgZnVuY3Rpb24uCgpJbiB0aGlzIGNoYXB0ZXIsIHlvdSdsbCBsZWFybiBob3cgdGhlIG5vbi1vYnZpb3VzIGNvbWJpbmF0aW9uIG9mIHRoZXNlIHRocmVlIGZlYXR1cmVzIGxlYWRzIHRvIHRoZSBmdW5jdGlvbiBmYWN0b3J5LiBZb3UnbGwgYWxzbyBzZWUgZXhhbXBsZXMgb2YgdGhlaXIgdXNhZ2UgaW4gdmlzdWFsaXNhdGlvbiBhbmQgc3RhdGlzdGljcy4KCk9mIHRoZSB0aHJlZSBtYWluIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgdG9vbHMgKGZ1bmN0aW9uYWxzLCBmdW5jdGlvbiBmYWN0b3JpZXMsIGFuZCBmdW5jdGlvbiBvcGVyYXRvcnMpLCBmdW5jdGlvbiBmYWN0b3JpZXMgYXJlIHRoZSBsZWFzdCB1c2VkLiBHZW5lcmFsbHksIHRoZXkgZG9uJ3QgdGVuZCB0byByZWR1Y2Ugb3ZlcmFsbCBjb2RlIGNvbXBsZXhpdHkgYnV0IGluc3RlYWQgcGFydGl0aW9uIGNvbXBsZXhpdHkgaW50byBtb3JlIGVhc2lseSBkaWdlc3RlZCBjaHVua3MuIEZ1bmN0aW9uIGZhY3RvcmllcyBhcmUgYWxzbyBhbiBpbXBvcnRhbnQgYnVpbGRpbmcgYmxvY2sgZm9yIHRoZSB2ZXJ5IHVzZWZ1bCBmdW5jdGlvbiBvcGVyYXRvcnMsIHdoaWNoIHlvdSdsbCBsZWFybiBhYm91dCBpbiBDaGFwdGVyIDExLgoKIyMgMTAuMi42IEV4ZXJjaXNlcwoKMS4gIFRoZSBkZWZpbml0aW9uIG9mIGBmb3JjZSgpYCBpcyBzaW1wbGU6CgpgYGB7cn0KZm9yY2UKYGBgCgpXaHkgaXMgaXQgYmV0dGVyIHRvIGBmb3JjZSh4KWAgaW5zdGVhZCBvZiBqdXN0IGB4YD8KCkFuc3dlcjogYXMgdGhlIFIgRG9jdW1lbnRhdGlvbiBzdGF0ZXMsICdUaGlzIGlzIHNlbWFudGljIHN1Z2FyJzogaW4gb3RoZXIgd29yZHMsIGBmb3JjZSh4KWAgbWFrZXMgdGhlIGludGVudCBvZiB0aGUgY2FsbCBleHBsaWNpdCwgdG8gZm9yY2UgZXZhbHVhdGlvbiwgd2hlcmVhcyBgeGAgZG9lcyBub3QuCgpBUiBTb2x1dGlvbnM6IEFzIHlvdSBjYW4gc2VlIGBmb3JjZSh4KWAgaXMgc2ltaWxhciB0byBgeGAuIEFzIG1lbnRpb25lZCBpbiAqQWR2YW5jZWQgUiosIHdlIHByZWZlciB0aGlzIGV4cGxpY2l0IGZvcm0sIGJlY2F1c2UKCj4gdXNpbmcgdGhpcyBmdW5jdGlvbiBjbGVhcmx5IGluZGljYXRlcyB0aGF0IHlvdeKAmXJlIGZvcmNpbmcgZXZhbHVhdGlvbiwgbm90IHRoYXQgeW914oCZdmUgYWNjaWRlbnRhbGx5IHR5cGVkIGB4YC4iCgotLS0KCjIuICBCYXNlIFIgY29udGFpbnMgdHdvIGZ1bmN0aW9uIGZhY3RvcmllcywgYGFwcHJveGZ1bigpYCBhbmQgYGVjZGYoKWAuIAogICAgUmVhZCB0aGVpciBkb2N1bWVudGF0aW9uIGFuZCBleHBlcmltZW50IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGUgZnVuY3Rpb25zIAogICAgZG8gYW5kIHdoYXQgdGhleSByZXR1cm4uCgpgYGB7cn0KeCA8LSBjKDEsIDMsIDYsIDEwLCAxOSkKeSA8LSB4ICogMgpwbG90KHgsIHksIHhsaW0gPSBjKDAsIDIwKSwgeWxpbSA9IGMoMCwgNDApKQoKYWYgPC0gYXBwcm94ZnVuKHgsIHkpCnBsb3QoMDoyMCwgYWYoMDoyMCksIHhsaW0gPSBjKDAsIDIwKSwgeWxpbSA9IGMoMCwgNDApKQpgYGAKCkFuc3dlcjogYGFwcHJveGZ1bigpYCByZXR1cm5zICJhIGZ1bmN0aW9uIHBlcmZvcm1pbmcgdGhlIGxpbmVhciAob3IgY29uc3RhbnQpIGludGVycG9sYXRpb24uIiBBcyB0aGUgZXhhbXBsZSBhYm92ZSBzaG93cywgYGFwcHJveGZ1bigpYCBwcm92aWRlcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiB0aGF0IGJ5IGRlZmF1bHQgZG9lcyBub3QgcmV0dXJuIHZhbHVlcyBvdXRzaWRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtLgoKYGBge3J9CnBsb3QoZWNkZihybG5vcm0oMTAwMCkpKQpwbG90KGVjZGYocm5vcm0oMTAwMCkpKQpwbG90KGVjZGYocnVuaWYoMTAwMCkpKQpgYGAKCmBlY2RmKClgICJDb21wdXRlW3NdIGFuIGVtcGlyaWNhbCBjdW11bGF0aXZlIGRpc3RyaWJ1dGlvbiBmdW5jdGlvbiIsIHRoZSBFbXBpcmljYWwgQ3VtdWxhdGl2ZSBEaXN0cmlidXRpb24gRnVuY3Rpb24sIHdoaWNoIGlzIGEgc3RhbmRhcmQgc3RhdGlzdGljYWwgcGxvdC4gSXQgcGxvdHMgdGhlIGFjdHVhbCBvYnNlcnZhdGlvbnMgY29ubmVjdGVkIGJ5IGEgbGluZSwgd2hpY2ggaXMgZWFzaWVyIHRvIHNlZSB3aXRoIGZld2VyIG9ic2VydmF0aW9uczoKCmBgYHtyfQpwbG90KGVjZGYocnVuaWYoNTApKSkKYGBgCgpBUiBTb2x1dGlvbnM6IChOb3RlOiBmdWxsIHNvbHV0aW9uIFtoZXJlXShodHRwczovL2FkdmFuY2VkLXItc29sdXRpb25zLnJiaW5kLmlvL2Z1bmN0aW9uLWZhY3Rvcmllcy5odG1sI2ZhY3RvcnktZnVuZGFtZW50YWxzKSkKCkxldCdzIGJlZ2luIHdpdGggYGFwcHJveGZ1bigpYCBhcyBpdCBpcyB1c2VkIHdpdGhpbiBgZWNkZigpYCBhcyB3ZWxsOgoKYGFwcHJveGZ1bigpYCB0YWtlcyBhIGNvbWJpbmF0aW9uIG9mIGRhdGEgcG9pbnRzICh4IGFuZCB5IHZhbHVlcykgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBzdGVwd2lzZSBsaW5lYXIgKG9yIGNvbnN0YW50KSBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uLiBUbyBmaW5kIG91dCB3aGF0IHRoaXMgbWVhbnMgZXhhY3RseSwgd2UgZmlyc3QgY3JlYXRlIGEgZmV3IHJhbmRvbSBkYXRhIHBvaW50cy4KCk5leHQsIHdlIHVzZSBgYXBwcm94ZnVuKClgIHRvIGNvbnN0cnVjdCB0aGUgbGluZWFyIGFuZCBjb25zdGFudCBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9ucyBmb3Igb3VyIGB4YCBhbmQgYHlgIHZhbHVlcy4KCldoZW4gd2UgYXBwbHkgdGhlc2UgZnVuY3Rpb25zIHRvIG5ldyB4IHZhbHVlcywgdGhlc2UgYXJlIG1hcHBlZCB0byB0aGUgbGluZXMgY29ubmVjdGluZyB0aGUgaW5pdGlhbCB5IHZhbHVlcyAobGluZWFyIGNhc2UpIG9yIHRvIHRoZSBzYW1lIHkgdmFsdWUgYXMgZm9yIHRoZSBuZXh0IHNtYWxsZXN0IGluaXRpYWwgeCB2YWx1ZSAoY29uc3RhbnQgY2FzZSkuCgpIb3dldmVyLCBib3RoIGZ1bmN0aW9ucyBhcmUgb25seSBkZWZpbmVkIHdpdGhpbiBgcmFuZ2UoeClgLgoKVG8gY2hhbmdlIHRoaXMgYmVoYXZpb3VyLCBvbmUgY2FuIHNldCBgcnVsZSA9IDJgLiBUaGlzIGxlYWRzIHRvIHRoZSByZXN1bHQgdGhhdCBmb3IgdmFsdWVzIG91dHNpZGUgb2YgYHJhbmdlKHgpYCB0aGUgYm91bmRhcnkgdmFsdWVzIG9mIHRoZSBmdW5jdGlvbiBhcmUgcmV0dXJuZWQuCgpBbm90aGVyIG9wdGlvbiBpcyB0byBjdXN0b21pc2UgdGhlIHJldHVybiB2YWx1ZXMgYXMgaW5kaXZpZHVhbCBjb25zdGFudHMgZm9yIGVhY2ggc2lkZSB2aWEgYHlsZWZ0YCBhbmQvb3IgYHlyaWdodGAuCgpGdXJ0aGVyLCBgYXBwcm94ZnVuKClgIHByb3ZpZGVzIHRoZSBvcHRpb24gdG8gc2hpZnQgdGhlIHkgdmFsdWVzIGZvciBgbWV0aG9kID0gImNvbnN0YW50ImAgYmV0d2VlbiB0aGVpciBsZWZ0IGFuZCByaWdodCB2YWx1ZXMuIEFjY29yZGluZyB0byB0aGUgZG9jdW1lbnRhdGlvbiB0aGlzIGluZGljYXRlcyBhIGNvbXByb21pc2UgYmV0d2VlbiBsZWZ0LSBhbmQgcmlnaHQtY29udGludW91cyBzdGVwcy4KCkZpbmFsbHksIHRoZSBgdGllc2AgYXJndW1lbnQgYWxsb3dzIHRvIGFnZ3JlZ2F0ZSB5IHZhbHVlcyBpZiBtdWx0aXBsZSBvbmVzIHdlcmUgcHJvdmlkZWQgZm9yIHRoZSBzYW1lIHggdmFsdWUuIEZvciBleGFtcGxlLCBpbiB0aGUgZm9sbG93aW5nIGxpbmUgd2UgdXNlIGBtZWFuKClgIHRvIGFnZ3JlZ2F0ZSB0aGVzZSB5IHZhbHVlcyBiZWZvcmUgdGhleSBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24gYGFwcHJveGZ1bih4ID0gYygxLDEsMiksIHkgPSAxOjMsIHRpZXMgPSBtZWFuKWAuCgpOZXh0LCB3ZSBmb2N1cyBvbiBgZWNkZigpYC4gImVjZGYiIGlzIGFuIGFjcm9ueW0gZm9yIGVtcGlyaWNhbCBjdW11bGF0aXZlIGRpc3RyaWJ1dGlvbiBmdW5jdGlvbi4gRm9yIGEgbnVtZXJpYyB2ZWN0b3Igb2YgZGVuc2l0eSB2YWx1ZXMsIGBlY2RmKClgIGluaXRpYWxseSBjcmVhdGVzIHRoZSAoeCwgeSkgcGFpcnMgZm9yIHRoZSBub2RlcyBvZiB0aGUgZGVuc2l0eSBmdW5jdGlvbiBhbmQgdGhlbiBwYXNzZXMgdGhlc2UgcGFpcnMgdG8gYGFwcHJveGZ1bigpYCwgd2hpY2ggZ2V0cyBjYWxsZWQgd2l0aCBzcGVjaWZpY2FsbHkgYWRhcHRlZCBzZXR0aW5ncyAoYGFwcHJveGZ1bih2YWxzLCBjdW1zdW0odGFidWxhdGUobWF0Y2goeCwgdmFscykpKS9uLCBtZXRob2QgPSAiY29uc3RhbnQiLCB5bGVmdCA9IDAsIHlyaWdodCA9IDEsIGYgPSAwLCB0aWVzID0gIm9yZGVyZWQiKWApLiAKCk5ldyB2YWx1ZXMgYXJlIHRoZW4gbWFwcGVkIG9uIHRoZSB5IHZhbHVlIG9mIHRoZSBuZXh0IHNtYWxsZXN0IHggdmFsdWUgZnJvbSB3aXRoaW4gdGhlIGluaXRpYWwgaW5wdXQuCgotLS0KCjMuICBDcmVhdGUgYSBmdW5jdGlvbiBgcGljaygpYCB0aGF0IHRha2VzIGFuIGluZGV4LCBgaWAsIGFzIGFuIGFyZ3VtZW50IGFuZCAKICAgIHJldHVybnMgYSBmdW5jdGlvbiB3aXRoIGFuIGFyZ3VtZW50IGB4YCB0aGF0IHN1YnNldHMgYHhgIHdpdGggYGlgLgoKYGBge3J9CnBpY2sgPC0gZnVuY3Rpb24oaSkgewogIGZ1bmN0aW9uKHgpIHhbW2ldXQp9Cgp4IDwtIDI6OApwaWNrKDEpKHgpCiMgc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8KeFtbMV1dCgp1bmxpc3QobGFwcGx5KG10Y2FycywgcGljayg1KSkpCiMgc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8KdW5saXN0KGxhcHBseShtdGNhcnMsIGZ1bmN0aW9uKHgpIHhbWzVdXSkpCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLiBNb2RpZmllZCB0byB1c2UgYHVubGlzdCgpYCB0byBzaG9ydGVuIG91dHB1dC4KCkFSIFNvbHV0aW9uczogSW4gdGhpcyBleGVyY2lzZSBgcGljayhpKWAgYWN0cyBhcyBhIGZ1bmN0aW9uIGZhY3RvcnksIHdoaWNoIHJldHVybnMgdGhlIHJlcXVpcmVkIHN1YnNldHRpbmcgZnVuY3Rpb24uCgpgYGB7cn0KcGljayA8LSBmdW5jdGlvbihpKSB7CiAgZm9yY2UoaSkKICBmdW5jdGlvbih4KSB4W1tpXV0KfQpgYGAKCk5vdGU6IHRoZSBBUiBTb2x1dGlvbnMgdmVyc2lvbiBhcHByb3ByaWF0ZWx5IHVzZXMgYGZvcmNlKClgLgoKLS0tCgo0LiAgQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGZ1bmN0aW9ucyB0aGF0IGNvbXB1dGUgdGhlIGledGheCiAgICBbY2VudHJhbCBtb21lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfbW9tZW50KSBvZiBhIG51bWVyaWMgCiAgICB2ZWN0b3IuIFlvdSBjYW4gdGVzdCBpdCBieSBydW5uaW5nIHRoZSBmb2xsb3dpbmcgY29kZToKCmBgYHtyfQptb21lbnQgPC0gZnVuY3Rpb24oaSkgewogIGZ1bmN0aW9uKHgpIG1lYW4oKHggLSBtZWFuKHgpKV5pKQp9CgptMSA8LSBtb21lbnQoMSkKbTIgPC0gbW9tZW50KDIpCnggPC0gcnVuaWYoMTAwKQpzdG9waWZub3QoCiAgYWxsLmVxdWFsKG0xKHgpLCAwKSwKICBhbGwuZXF1YWwobTIoeCksIHZhcih4KSAqIDk5IC8gMTAwKQopCmJlbmNoOjptYXJrKG0yKHgpKQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZSwgZm9sbG93aW5nIHRoZSBmb3JtdWxhICRFWyhYIC0gRVtYXSleaV0kLCB3aGVyZSAkRSQgaXMgdGhlIFtleHBlY3RlZCB2YWx1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwZWN0ZWRfdmFsdWUpLCBpZSB0aGUgKm1lYW4qLgoKQVIgU29sdXRpb25zOiBUaGUgZmlyc3QgbW9tZW50IGlzIGNsb3NlbHkgcmVsYXRlZCB0byB0aGUgbWVhbiBhbmQgZGVzY3JpYmVzIHRoZSBhdmVyYWdlIGRldmlhdGlvbiBmcm9tIHRoZSBtZWFuLCB3aGljaCBpcyAwICh3aXRoaW4gbnVtZXJpY2FsIG1hcmdpbiBvZiBlcnJvcikuIFRoZSBzZWNvbmQgbW9tZW50IGRlc2NyaWJlcyB0aGUgdmFyaWFuY2Ugb2YgdGhlIGlucHV0IGRhdGEuIElmIHdlIHdhbnQgdG8gY29tcGFyZSBpdCB0byBgdmFyKClgLCB3ZSBuZWVkIHRvIHVuZG8gW0Jlc3NlbCdzIGNvcnJlY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jlc3NlbCUyN3NfY29ycmVjdGlvbikgYnkgbXVsdGlwbHlpbmcgd2l0aCAkXGZyYWN7Ti0xfXtOfSQuCgpgYGB7cn0KbW9tZW50IDwtIGZ1bmN0aW9uKGkpIHsKICBmb3JjZShpKQoKICBmdW5jdGlvbih4KSBzdW0oKHggLSBtZWFuKHgpKV5pKSAvIGxlbmd0aCh4KQp9Cm0xIDwtIG1vbWVudCgxKQptMiA8LSBtb21lbnQoMikKeCA8LSBydW5pZigxMDApCmFsbC5lcXVhbChtMSh4KSwgMCkgIyByZW1vdmVkIHN0b3BpZm5vdCgpIGZvciBjbGFyaXR5CmFsbC5lcXVhbChtMih4KSwgdmFyKHgpICogOTkgLyAxMDApCmJlbmNoOjptYXJrKG0yKHgpKQpgYGAKCk5vdGU6IGlzbid0IGBzdW0oKSAvIGxlbmd0aCgpYCBqdXN0IGBtZWFuKClgPyBGb3IgZnVuLCBjb21wYXJlIGBiZW5jaDo6bWFyaygpYCAoYWJvdmUpLiBDdXJzZXMsIGZvaWxlZCBhZ2FpbiEKCi0tLQoKNS4gIFdoYXQgaGFwcGVucyBpZiB5b3UgZG9uJ3QgdXNlIGEgY2xvc3VyZT8gTWFrZSBwcmVkaWN0aW9ucywgdGhlbiB2ZXJpZnkgd2l0aCAKICAgIHRoZSBjb2RlIGJlbG93LgoKYGBge3J9CmkgPC0gMApuZXdfY291bnRlcjIgPC0gZnVuY3Rpb24oKSB7CiAgaSA8PC0gaSArIDEgIyBub2xpbnQ6IHVuZGVzaXJhYmxlX29wZXJhdG9yX2xpbnRlci4gdXNlIG9mIGA8PC1gIGlzIGludGVuZGVkIGhlcmUuCiAgaQp9CmBgYAoKQW5zd2VyOiBgaWAgc2hvdWxkIGluY3JlbWVudCBieSAxIGV2ZXJ5IHRpbWUgYG5ld19jb3VudGVyMigpYCBpcyBydW4sIGJ1dCBjYW4gYmUgYWx0ZXJlZCBieSBjaGFuZ2luZyB0aGUgZ2xvYmFsIHZhcmlhYmxlIGBpYC4gW0NvcnJlY3QhXQoKYGBge3J9Cm5ld19jb3VudGVyMigpCm5ld19jb3VudGVyMigpCm5ld19jb3VudGVyMigpCmkgPC0gNQpuZXdfY291bnRlcjIoKQppIDwtIDAKYGBgCgpBUiBTb2x1dGlvbnM6IFdpdGhvdXQgdGhlIGNhcHR1cmVkIGFuZCBlbmNhcHN1bGF0ZWQgZW52aXJvbm1lbnQgb2YgYSBjbG9zdXJlIHRoZSBjb3VudHMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIGdsb2JhbCBlbnZpcm9ubWVudC4gSGVyZSB0aGV5IGNhbiBiZSBvdmVyd3JpdHRlbiBvciBkZWxldGVkIGFzIHdlbGwgYXMgaW50ZXJmZXJlIHdpdGggb3RoZXIgY291bnRlcnMuCgpgYGB7ciwgZXJyb3IgPSBUUlVFfQpuZXdfY291bnRlcjIoKQppCm5ld19jb3VudGVyMigpCmkKaSA8LSAwCm5ld19jb3VudGVyMigpCmkKaSA8LSAwCmBgYAoKLS0tCgo2LiAgV2hhdCBoYXBwZW5zIGlmIHlvdSB1c2UgYDwtYCBpbnN0ZWFkIG9mIGA8PC1gPyBNYWtlIHByZWRpY3Rpb25zLCB0aGVuIHZlcmlmeSAKICAgIHdpdGggdGhlIGNvZGUgYmVsb3cuCgpgYGB7cn0KbmV3X2NvdW50ZXIzIDwtIGZ1bmN0aW9uKCkgewogIGkgPC0gMCAjIG5vbGludDogb2JqZWN0X3VzYWdlX2xpbnRlci4KICBmdW5jdGlvbigpIHsKICAgIGkgPC0gaSArIDEKICAgIGkKICB9Cn0KYGBgCgpBbnN3ZXI6IGZ1bmN0aW9ucyBjcmVhdGVkIGJ5IGBuZXdfY291bnRlcjMoKWAgc3RhcnRzIHdpdGggYSBuZXcgdmFsdWUgb2YgYGkgPC0gMGAgZWFjaCB0aW1lLCBhbmQgd2lsbCBhbHdheXMgcmV0dXJuIDEuIFtDb3JyZWN0IV0KCmBgYHtyfQpuYzMgPC0gbmV3X2NvdW50ZXIzKCkKCm5jMygpCm5jMygpCmBgYAoKQVIgU29sdXRpb25zOiBXaXRob3V0IHRoZSBzdXBlciBhc3NpZ25tZW50IGA8PC1gLCB0aGUgY291bnRlciB3aWxsIGFsd2F5cyByZXR1cm4gMS4gVGhlIGNvdW50ZXIgYWx3YXlzIHN0YXJ0cyBpbiBhIG5ldyBleGVjdXRpb24gZW52aXJvbm1lbnQgd2l0aGluIHRoZSBzYW1lIGVuY2xvc2luZyBlbnZpcm9ubWVudCwgd2hpY2ggY29udGFpbnMgYW4gdW5jaGFuZ2VkIHZhbHVlIGZvciBgaWAgKGluIHRoaXMgY2FzZSBpdCByZW1haW5zIDApLgoKLS0tCgojIyAxMC4zLjQgRXhlcmNpc2VzCgoxLiAgQ29tcGFyZSBhbmQgY29udHJhc3QgYGdncGxvdDI6OmxhYmVsX2JxdW90ZSgpYCB3aXRoIAogICAgYHNjYWxlczo6bnVtYmVyX2Zvcm1hdCgpYAoKQW5zd2VyOiBgZ2dwbG90Mjo6bGFiZWxfYnF1b3RlKClgICJvZmZlcnMgYSBmbGV4aWJsZSB3YXkgb2YgbGFiZWxsaW5nIGZhY2V0IHJvd3Mgb3IgY29sdW1ucyB3aXRoIHBsb3RtYXRoIGV4cHJlc3Npb25zLiBCYWNrcXVvdGVkIHZhcmlhYmxlcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlaXIgdmFsdWUgaW4gdGhlIGZhY2V0LiIKClRoZSBleGFtcGxlIHNob3dzIGEgc2NhdHRlcnBsb3Qgb2Ygd2VpZ2h0IGFuZCBtaWxlcyBwZXIgZ2FsbG9uIGZhY2V0ZWQgYnkgZW5naW5lIHR5cGUgKHYtc2hhcGVkKS4KCmBgYHtyfQpnZ3Bsb3QobXRjYXJzLCBhZXMod3QsIG1wZykpICsKICBnZW9tX3BvaW50KCkgKwogIGZhY2V0X2dyaWQodnMgfiAuLCBsYWJlbGxlciA9IGxhYmVsX2JxdW90ZSh2cyA9PSAuKHZzKSkpCmBgYAoKYHNjYWxlczo6bnVtYmVyX2Zvcm1hdCgpYCBoYXMgYmVlbiBzdXBlcnNlZGVkIGJ5IGBzY2FsZXM6OmxhYmVsX251bWJlcigpYDoKCiJVc2UgYGxhYmVsX251bWJlcigpYCBmb3JjZSBkZWNpbWFsIGRpc3BsYXkgb2YgbnVtYmVycyAoaS5lLiBkb24ndCB1c2Ugc2NpZW50aWZpYyBub3RhdGlvbikuIGBsYWJlbF9jb21tYSgpYCBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IGluc2VydHMgYSBjb21tYSBldmVyeSB0aHJlZSBkaWdpdHMuIgoKYGBge3J9CmRlbW9fY29udGludW91cyhjKC0xZTYsIDFlNiksIGxhYmVscyA9IGxhYmVsX251bWJlcigpKQpgYGAKCmBnZ3Bsb3QyOjpsYWJlbF9icXVvdGUoKWAgaXMgYSBzcGVjaWFsLXB1cnBvc2UgZnVuY3Rpb24gZm9yIGZhY2V0cywgd2hpbGUgYHNjYWxlczo6bnVtYmVyX2Zvcm1hdCgpYCBjYW4gYmUgYXBwbGllZCBtb3JlIGdlbmVyYWxseS4gQm90aCBhcmUgZnVuY3Rpb24gZmFjdG9yaWVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gY2hhbmdpbmcgbGFiZWxzLgoKQVIgU29sdXRpb25zOiBCb3RoIGZ1bmN0aW9ucyB3aWxsIGhlbHAgeW91IGluIHN0eWxpbmcgeW91ciBvdXRwdXQsIGUuZy4gaW4geW91ciBwbG90cyBhbmQgdGhleSBkbyB0aGlzIGJ5IHJldHVybmluZyB0aGUgZGVzaXJlZCBmb3JtYXR0aW5nIGZ1bmN0aW9uIHRvIHlvdS4KCmBnZ3Bsb3QyOjpsYWJlbF9icXVvdGUoKWAgdGFrZXMgcmVsYXRpdmVseSBzdHJhaWdodGZvcndhcmQgW3Bsb3RtYXRoXShodHRwczovL3N0YXQuZXRoei5jaC9SLW1hbnVhbC9SLXBhdGNoZWQvbGlicmFyeS9nckRldmljZXMvaHRtbC9wbG90bWF0aC5odG1sKSBleHByZXNzaW9ucyBhbmQgdXNlcyB0aGVtIGZvciBmYWNldGluZyBsYWJlbHMgaW4gYHtnZ3Bsb3QyfWAuIEJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIGB7Z2dwbG90Mn1gIGl0IG5lZWRzIHRvIHJldHVybiBhIGZ1bmN0aW9uIG9mIGBjbGFzcyA9ICJsYWJlbGxlciJgLgoKYHNjYWxlczo6bnVtYmVyX2Zvcm1hdCgpYCBpbml0aWFsbHkgYGZvcmNlKClgcyB0aGUgY29tcHV0YXRpb24gb2YgYWxsIHBhcmFtZXRlcnMuIEl0J3MgZXNzZW50aWFsbHkgYSBwYXJhbWV0cmlzZWQgd3JhcHBlciBhcm91bmQgYHNjYWxlczo6bnVtYmVyKClgIGFuZCB3aWxsIGhlbHAgeW91IGZvcm1hdCBudW1iZXJzIGFwcHJvcHJpYXRlbHkuIEl0IHdpbGwgcmV0dXJuIGEgc2ltcGxlIGZ1bmN0aW9uLgoKLS0tCgojIyAxMC40LjQgRXhlcmNpc2VzCgoxLiAgSW4gYGJvb3RfbW9kZWwoKWAsIHdoeSBkb24ndCBJIG5lZWQgdG8gZm9yY2UgdGhlIGV2YWx1YXRpb24gb2YgYGRmYCAKICAgIG9yIGBtb2RlbGA/CgpBbnN3ZXI6IGFzc3VtaW5nIGBtb2RlbGAgYWN0dWFsbHkgcmVmZXJzIHRvIGBmb3JtdWxhYCwgYm90aCBhcmUgZXZhbHVhdGVkIHdoZW4gYG1vZCA8LSBsbShmb3JtdWxhLCBkYXRhID0gZGYpYCBpcyBydW4uCgpBUiBTb2x1dGlvbnM6IGBib290X21vZGVsKClgIHVsdGltYXRlbHkgcmV0dXJucyBhIGZ1bmN0aW9uLCBhbmQgd2hlbmV2ZXIgeW91IHJldHVybiBhIGZ1bmN0aW9uIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgdGhlIGlucHV0cyBhcmUgZXhwbGljaXRseSBldmFsdWF0ZWQuIEhlcmUgdGhhdCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgYmVjYXVzZSB3ZSB1c2UgYGRmYCBhbmQgYGZvcm11bGFgIGluIGBsbSgpYCBiZWZvcmUgcmV0dXJuaW5nIHRoZSBmdW5jdGlvbi4KCi0tLQoKMi4gIFdoeSBtaWdodCB5b3UgZm9ybXVsYXRlIHRoZSBCb3gtQ294IHRyYW5zZm9ybWF0aW9uIGxpa2UgdGhpcz8KCmBgYHtyfQpib3hjb3gzIDwtIGZ1bmN0aW9uKHgpIHsKICBmdW5jdGlvbihsYW1iZGEpIHsKICAgIGlmIChsYW1iZGEgPT0gMCkgewogICAgICBsb2coeCkKICAgIH0gZWxzZSB7CiAgICAgICh4XmxhbWJkYSAtIDEpIC8gbGFtYmRhCiAgICB9CiAgfQp9CmBgYAoKQW5zd2VyOiBgYm94Y294M2AgcmV0dXJucyBhIGZ1bmN0aW9uIHdoZXJlIGB4YCBpcyBmaXhlZCBhbmQgYGxhbWJkYWAgY2FuIHZhcnksIHdoaWNoIGFsbG93cyBmb3IgZWFzeSBleHBsb3JhdGlvbiBvZiBkaWZmZXJlbnQgdmFsdWVzIG9mIGxhbWJkYSwgZm9yIGV4YW1wbGUgdXNpbmcgYGxhcHBseSgpYCBvciBgb3B0aW1pemUoKWAuCgpBUiBTb2x1dGlvbnM6IGBib3hjb3gzKClgIHJldHVybnMgYSBmdW5jdGlvbiB3aGVyZSBgeGAgaXMgZml4ZWQgKHRob3VnaCBpdCBpcyBub3QgZm9yY2VkLCBzbyBpdCBtYXkgYmUgbWFuaXB1bGF0ZWQgbGF0ZXIpLiBUaGlzIGFsbG93cyB1cyB0byBhcHBseSBhbmQgdGVzdCBkaWZmZXJlbnQgdHJhbnNmb3JtYXRpb25zIGZvciBkaWZmZXJlbnQgaW5wdXRzIGFuZCBnaXZlIHRoZW0gYSBkZXNjcmlwdGl2ZSBuYW1lLgoKTm90ZTogSSBtaXNzZWQgdGhlIGZhY3QgdGhhdCBgeGAgaXMgbm90IGZvcmNlZC4KCi0tLQoKMy4gIFdoeSBkb24ndCB5b3UgbmVlZCB0byB3b3JyeSB0aGF0IGBib290X3Blcm11dGUoKWAgc3RvcmVzIGEgY29weSBvZiB0aGUgCiAgICBkYXRhIGluc2lkZSB0aGUgZnVuY3Rpb24gdGhhdCBpdCBnZW5lcmF0ZXM/CgpBbnN3ZXI6IGFzIFIgaXMgY29weS1vbi13cml0ZSwgYW5kIGBib290X3Blcm11dGUoKWAgc3RvcmVzIGFuIHVubW9kaWZpZWQgY29weSBvZiB0aGUgZGF0YSwgdGhlIGZ1bmN0aW9uIGNvbnRhaW5zIG9ubHkgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGRhdGEuCgpBUiBTb2x1dGlvbnM6IFdlIGRvbid0IG5lZWQgdG8gd29ycnkgdGhhdCBpdCBzdG9yZXMgYSBjb3B5IG9mIHRoZSBkYXRhLCBiZWNhdXNlIGl0IGFjdHVhbGx5IGRvZXNuJ3Qgc3RvcmUgb25lOyBpdCdzIGp1c3QgYSBuYW1lIHRoYXQgcG9pbnRzIHRvIHRoZSBzYW1lIHVuZGVybHlpbmcgb2JqZWN0IGluIG1lbW9yeS4KCi0tLQoKNC4gIEhvdyBtdWNoIHRpbWUgZG9lcyBgbGxfcG9pc3NvbjIoKWAgc2F2ZSBjb21wYXJlZCB0byBgbGxfcG9pc3NvbjEoKWA/CiAgICBVc2UgYGJlbmNoOjptYXJrKClgIHRvIHNlZSBob3cgbXVjaCBmYXN0ZXIgdGhlIG9wdGltaXNhdGlvbiBvY2N1cnMuCiAgICBIb3cgZG9lcyBjaGFuZ2luZyB0aGUgbGVuZ3RoIG9mIGB4YCBjaGFuZ2UgdGhlIHJlc3VsdHM/CgpgYGB7cn0KbGxfcG9pc3NvbjEgPC0gZnVuY3Rpb24oeCkgewogIG4gPC0gbGVuZ3RoKHgpCgogIGZ1bmN0aW9uKGxhbWJkYSkgewogICAgbG9nKGxhbWJkYSkgKiBzdW0oeCkgLSBuICogbGFtYmRhIC0gc3VtKGxmYWN0b3JpYWwoeCkpCiAgfQp9CgpsbF9wb2lzc29uMiA8LSBmdW5jdGlvbih4KSB7CiAgbiA8LSBsZW5ndGgoeCkKICBzdW1feCA8LSBzdW0oeCkKICBjIDwtIHN1bShsZmFjdG9yaWFsKHgpKQoKICBmdW5jdGlvbihsYW1iZGEpIHsKICAgIGxvZyhsYW1iZGEpICogc3VtX3ggLSBuICogbGFtYmRhIC0gYwogIH0KfQoKeDEgPC0gYyg0MSwgMzAsIDMxLCAzOCwgMjksIDI0LCAzMCwgMjksIDMxLCAzOCkKCmJlbmNoOjptYXJrKG9wdGltaXplKGxsX3BvaXNzb24xKHgxKSwgYygwLCAxMDApLCBtYXhpbXVtID0gVFJVRSkpCmJlbmNoOjptYXJrKG9wdGltaXplKGxsX3BvaXNzb24yKHgxKSwgYygwLCAxMDApLCBtYXhpbXVtID0gVFJVRSkpCgp4IDwtIHJwb2lzKDFlMywgMTAwTCkKYmVuY2g6Om1hcmsob3B0aW1pemUobGxfcG9pc3NvbjEoeCksIGMoMCwgMTAwKSwgbWF4aW11bSA9IFRSVUUpKQpiZW5jaDo6bWFyayhvcHRpbWl6ZShsbF9wb2lzc29uMih4KSwgYygwLCAxMDApLCBtYXhpbXVtID0gVFJVRSkpCmBgYAoKCkFuc3dlcjogYGxsX3BvaXNzb24yKClgIGlzIG5lYXJseSB0d2ljZSBhcyBmYXN0IHdpdGggYHgxYCBhbmQgbmVhcmx5IDEwIHRpbWVzIGFzIGZhc3Qgd2hlbiB0aGUgbGVuZ3RoIG9mIGB4YCBpcyAxMDAuCgpOb3RlczogY29uc3VsdGluZyBBUiBTb2x1dGlvbnMgd2FzIG5lZWRlZCB0byB1bmRlcnN0YW5kIGhvdyB0byBiZW5jaG1hcmsgdGhlIHR3byBmdW5jdGlvbnMuCgpBUiBTb2x1dGlvbnM6CgpBIGJlbmNobWFyayBvbiBgeDFgIHJldmVhbHMgYSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudCBvZiBmYWN0b3IgMiBmb3IgYGxsX3BvaXNzb24yKClgIG92ZXIgYGxsX3BvaXNzb24xKClgCgpBcyB0aGUgcmVkdW5kYW50IGNhbGN1bGF0aW9ucyB3aXRoaW4gYGxsX3BvaXNzb24xKClgIGJlY29tZSBtb3JlIGV4cGVuc2l2ZSB3aXRoIGdyb3dpbmcgbGVuZ3RoIG9mIGB4MWAsIHdlIGV4cGVjdCBldmVuIGZ1cnRoZXIgcmVsYXRpdmUgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzIGZvciBgbGxfcG9pc3NvbjIoKWAuIFRoZSBmb2xsb3dpbmcgYmVuY2htYXJrIHJldmVhbHMgYSByZWxhdGl2ZSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudCBvZiBmYWN0b3IgMjAgZm9yIGBsbF9wb2lzc29uMigpYCB3aGVuIGB4MWAgaXMgb2YgbGVuZ3RoIDEwMCwwMDAuCgotLS0KCiMjIDEwLjUuMSBFeGVyY2lzZXMKCjEuIFdoaWNoIG9mIHRoZSBmb2xsb3dpbmcgY29tbWFuZHMgaXMgZXF1aXZhbGVudCB0byBgd2l0aCh4LCBmKHopKWA/CgogICAgKGEpIGB4JGYoeCR6KWAuCiAgICAoYikgYGYoeCR6KWAuCiAgICAoYykgYHgkZih6KWAuCiAgICAoZCkgYGYoeilgLgogICAgKGUpIEl0IGRlcGVuZHMuCgpBbnN3ZXI6IChlKS4gZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBgeGAsIGl0IGNvdWxkIGJlIGFueSBvZiAoYSkgdGhyb3VnaCAoZCkuCgpBUiBTb2x1dGlvbnM6IChlKSAiSXQgZGVwZW5kcyIgaXMgdGhlIGNvcnJlY3QgYW5zd2VyLiBVc3VhbGx5IGB3aXRoKClgIGlzIHVzZWQgd2l0aCBhIGRhdGEgZnJhbWUsIHNvIHlvdSdkIHVzdWFsbHkgZXhwZWN0IChiKSwgYnV0IGlmIGB4YCBpcyBhIGxpc3QsIGl0IGNvdWxkIGJlIGFueSBvZiB0aGUgb3B0aW9ucy4KCi0tLQoKMi4gQ29tcGFyZSBhbmQgY29udHJhc3QgdGhlIGVmZmVjdHMgb2YgYGVudl9iaW5kKClgIHZzLiBgYXR0YWNoKClgIGZvciB0aGUgCiAgIGZvbGxvd2luZyBjb2RlLgoKYGBge3J9CmZ1bnMgPC0gbGlzdCgKICBtZWFuID0gZnVuY3Rpb24oeCkgbWVhbih4LCBuYS5ybSA9IFRSVUUpLAogIHN1bSA9IGZ1bmN0aW9uKHgpIHN1bSh4LCBuYS5ybSA9IFRSVUUpCikKCiMgbm9saW50IHN0YXJ0OiB1bmRlc2lyYWJsZV9mdW5jdGlvbl9saW50ZXIuCmF0dGFjaChmdW5zKQptZWFuIDwtIGZ1bmN0aW9uKHgpIHN0b3AoIkhpISIpCmRldGFjaChmdW5zKQojIG5vbGludCBlbmQKCmVudl9iaW5kKGdsb2JhbGVudigpLCAhISFmdW5zKQptZWFuIDwtIGZ1bmN0aW9uKHgpIHN0b3AoIkhpISIpCmVudl91bmJpbmQoZ2xvYmFsZW52KCksIG5hbWVzKGZ1bnMpKQpgYGAKCkFuc3dlcjogYGF0dGFjaCgpYCBwbGFjZXMgdGhlIGZ1bmN0aW9uIG5hbWVzIGluIHRoZSBzZWFyY2ggcGF0aCwgYW5kIHRoZSBgZW52X2JpbmQoKWAgY29kZSBwbGFjZXMgdGhlIGZ1bmN0aW9uIG5hbWVzIGluIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQuIEJvdGggaGF2ZSB0aGUgZWZmZWN0IG9mIG1hc2tpbmcgYG1lYW4oKWAgYW5kIGBzdW0oKWAsIGJ1dCBhcyB0aGUgY2hhcHRlciBwb2ludHMgb3V0LCB3aGVuIHVuYmluZGluZywgInRoZXJl4oCZcyBubyBndWFyYW50ZWUgdGhhdCB0aGV5IGhhdmVu4oCZdCBiZWVuIHJlYm91bmQgaW4gdGhlIG1lYW50aW1lLCBhbmQgeW91IG1pZ2h0IGJlIGRlbGV0aW5nIGFuIG9iamVjdCB0aGF0IHNvbWVvbmUgZWxzZSBjcmVhdGVkLiIKCkFSIFNvbHV0aW9uczogYGF0dGFjaCgpYCBhZGRzIGBmdW5zYCB0byB0aGUgc2VhcmNoIHBhdGguIFRoZXJlZm9yZSwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgZm91bmQgYmVmb3JlIHRoZWlyIHJlc3BlY3RpdmUgdmVyc2lvbnMgZnJvbSB0aGUgYHtiYXNlfWAgcGFja2FnZS4gRnVydGhlciwgdGhleSBjYW5ub3QgZ2V0IGFjY2lkZW50YWxseSBvdmVyd3JpdHRlbiBieSBzaW1pbGFyIG5hbWVkIGZ1bmN0aW9ucyBpbiB0aGUgZ2xvYmFsIGVudmlyb25tZW50LiBPbmUgYW5ub3lpbmcgZG93bnNpZGUgb2YgdXNpbmcgYGF0dGFjaCgpYCBpcyB0aGUgcG9zc2liaWxpdHkgdG8gYXR0YWNoIHRoZSBzYW1lIG9iamVjdCBtdWx0aXBsZSB0aW1lcywgbWFraW5nIGl0IG5lY2Vzc2FyeSB0byBjYWxsIGBkZXRhY2goKWAgZXF1YWxseSBvZnRlbi4KCkluIGNvbnRyYXN0IGBybGFuZzo6ZW52X2JpbmQoKWAganVzdCBhZGRzIHRoZSBmdW5jdGlvbnMgaW4gYGZ1bmAgdG8gdGhlIGdsb2JhbCBlbnZpcm9ubWVudC4gTm8gZnVydGhlciBzaWRlIGVmZmVjdHMgYXJlIGludHJvZHVjZWQsIGFuZCB0aGUgZnVuY3Rpb25zIGFyZSBvdmVyd3JpdHRlbiB3aGVuIHNpbWlsYXJseSBuYW1lZCBmdW5jdGlvbnMgYXJlIGRlZmluZWQuCgpOb3RlczogQVIgU29sdXRpb25zIHByb3ZpZGVzIGEgbW9yZSBjb21wbGV0ZSBhbnN3ZXIuCgotLS0KCiMgMTEgRnVuY3Rpb24gb3BlcmF0b3JzCgpgYGB7cn0Kcm0obGlzdCA9IGxzKCkpCmBgYAoKSW4gdGhpcyBjaGFwdGVyLCB5b3UnbGwgbGVhcm4gYWJvdXQgZnVuY3Rpb24gb3BlcmF0b3JzLiBBIF9fZnVuY3Rpb24gb3BlcmF0b3JfXyBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgb25lIChvciBtb3JlKSBmdW5jdGlvbnMgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBhcyBvdXRwdXQuIFRoZSBmb2xsb3dpbmcgY29kZSBzaG93cyBhIHNpbXBsZSBmdW5jdGlvbiBvcGVyYXRvciwgYGNoYXR0eSgpYC4gSXQgd3JhcHMgYSBmdW5jdGlvbiwgbWFraW5nIGEgbmV3IGZ1bmN0aW9uIHRoYXQgcHJpbnRzIG91dCBpdHMgZmlyc3QgYXJndW1lbnQuIFlvdSBtaWdodCBjcmVhdGUgYSBmdW5jdGlvbiBsaWtlIHRoaXMgYmVjYXVzZSBpdCBnaXZlcyB5b3UgYSB3aW5kb3cgdG8gc2VlIGhvdyBmdW5jdGlvbmFscywgbGlrZSBgbWFwX2ludCgpYCwgd29yay4KCmBgYHtyLCBldmFsID0gVFJVRX0KY2hhdHR5IDwtIGZ1bmN0aW9uKGYpIHsKICBmb3JjZShmKQoKICBmdW5jdGlvbih4LCAuLi4pIHsKICAgIHJlcyA8LSBmKHgsIC4uLikKICAgIGNhdCgiUHJvY2Vzc2luZyAiLCB4LCAiXG4iLCBzZXAgPSAiIikKICAgIHJlcwogIH0KfQpmIDwtIGZ1bmN0aW9uKHgpIHheMgpzIDwtIGMoMywgMiwgMSkKcHVycnI6Om1hcF9kYmwocywgY2hhdHR5KGYpKQpgYGAKCkZ1bmN0aW9uIG9wZXJhdG9ycyBhcmUgY2xvc2VseSByZWxhdGVkIHRvIGZ1bmN0aW9uIGZhY3RvcmllczsgaW5kZWVkIHRoZXkncmUganVzdCBhIGZ1bmN0aW9uIGZhY3RvcnkgdGhhdCB0YWtlcyBhIGZ1bmN0aW9uIGFzIGlucHV0LiBMaWtlIGZhY3RvcmllcywgdGhlcmUncyBub3RoaW5nIHlvdSBjYW4ndCBkbyB3aXRob3V0IHRoZW0sIGJ1dCB0aGV5IG9mdGVuIGFsbG93IHlvdSB0byBmYWN0b3Igb3V0IGNvbXBsZXhpdHkgaW4gb3JkZXIgdG8gbWFrZSB5b3VyIGNvZGUgbW9yZSByZWFkYWJsZSBhbmQgcmV1c2FibGUuIAoKRnVuY3Rpb24gb3BlcmF0b3JzIGFyZSB0eXBpY2FsbHkgcGFpcmVkIHdpdGggZnVuY3Rpb25hbHMuIElmIHlvdSdyZSB1c2luZyBhIGZvci1sb29wLCB0aGVyZSdzIHJhcmVseSBhIHJlYXNvbiB0byB1c2UgYSBmdW5jdGlvbiBvcGVyYXRvciwgYXMgaXQgd2lsbCBtYWtlIHlvdXIgY29kZSBtb3JlIGNvbXBsZXggZm9yIGxpdHRsZSBnYWluLgoKSWYgeW91J3JlIGZhbWlsaWFyIHdpdGggUHl0aG9uLCBkZWNvcmF0b3JzIGlzIGp1c3QgYW5vdGhlciBuYW1lIGZvciBmdW5jdGlvbiBvcGVyYXRvcnMuCgojIyAxMS4yLjMgRXhlcmNpc2VzCgoxLiAgQmFzZSBSIHByb3ZpZGVzIGEgZnVuY3Rpb24gb3BlcmF0b3IgaW4gdGhlIGZvcm0gb2YgYFZlY3Rvcml6ZSgpYC4gCiAgICBXaGF0IGRvZXMgaXQgZG8/IFdoZW4gbWlnaHQgeW91IHVzZSBpdD8KCkFuc3dlcjogYWNjb3JkaW5nIHRvIHRoZSBSIGRvY3VtZW50YXRpb24sICJgVmVjdG9yaXplYCBjcmVhdGVzIGEgZnVuY3Rpb24gd3JhcHBlciB0aGF0IHZlY3Rvcml6ZXMgdGhlIGFjdGlvbiBvZiBpdHMgYXJndW1lbnQgYEZVTmAuIiAiVGhlIGFyZ3VtZW50cyBuYW1lZCBpbiB0aGUgYHZlY3Rvcml6ZS5hcmdzYCBhcmd1bWVudCB0byBgVmVjdG9yaXplYCBhcmUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW4gdGhlIGAuLi5gIGxpc3QgdG8gYG1hcHBseWAuIE9ubHkgdGhvc2UgdGhhdCBhcmUgYWN0dWFsbHkgcGFzc2VkIHdpbGwgYmUgdmVjdG9yaXplZDsgZGVmYXVsdCB2YWx1ZXMgd2lsbCBub3QuIiBhbmQgcmV0dXJucyAiQSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgRlVOYCwgd3JhcHBpbmcgYSBjYWxsIHRvIGBtYXBwbHlgLiIKCkluIG90aGVyIHdvcmRzLCBpdCBpcyBhIGZ1bmN0aW9uIG9wZXJhdG9yIHRoYXQgdXNlcyBgbWFwcGx5KClgIHRvIGl0ZXJhdGUgYWNyb3NzIHRoZSBhcmd1bWVudHMuIFRoaXMgaXMgcG90ZW50aWFsbHkgc2ltcGxlciB0byB1bmRlcnN0YW5kIHRoYW4gdXNlIG9mIGBtYXBwbHkoKWAuCgpJbiB0aGUgUiBkb2N1bWVudGF0aW9uIGV4YW1wbGUsIHRoZSB2ZWN0b3JpemVkIGByZXAuaW50YCBpcyBjYWxsZWQgZm9yIGVhY2ggcGFpciBvZiB2YWx1ZXM6IAoKYGBge3J9CnZyZXAgPC0gVmVjdG9yaXplKHJlcC5pbnQpCnZyZXAoMTo0LCA0OjEpCmBgYAoKQVIgU29sdXRpb25zOiBJbiBSIGEgbG90IG9mIGZ1bmN0aW9ucyBhcmUgInZlY3RvcmlzZWQiLiBWZWN0b3Jpc2VkIGhhcyB0d28gbWVhbmluZ3MuIEZpcnN0LCBpdCBtZWFucyAoYnJvYWRseSkgdGhhdCBhIGZ1bmN0aW9uIGlucHV0cyBhIHZlY3RvciBvciB2ZWN0b3JzIGFuZCBkb2VzIHNvbWV0aGluZyB0byBlYWNoIGVsZW1lbnQuIFNlY29uZGx5LCBpdCB1c3VhbGx5IGltcGxpZXMgdGhhdCB0aGVzZSBvcGVyYXRpb25zIGFyZSBpbXBsZW1lbnRlZCBpbiBhIGNvbXBpbGVkIGxhbmd1YWdlIHN1Y2ggYXMgQyBvciBGb3J0cmFuLCBzbyB0aGF0IHRoZSBpbXBsZW1lbnRhdGlvbiBpcyB2ZXJ5IGZhc3QuCgpIb3dldmVyLCBkZXNwaXRlIHdoYXQgdGhlIGZ1bmN0aW9uJ3MgbmFtZSBpbXBsaWVzLCBgVmVjdG9yaXplKClgIGlzIG5vdCBhYmxlIHRvIHNwZWVkIHVwIHRoZSBwcm92aWRlZCBmdW5jdGlvbi4gSXQgcmF0aGVyIGNoYW5nZXMgdGhlIGlucHV0IGZvcm1hdCBvZiB0aGUgc3VwcGxpZWQgYXJndW1lbnRzIChgdmVjdG9yaXplLmFyZ3NgKSwgc28gdGhhdCB0aGV5IGNhbiBiZSBpdGVyYXRlZCBvdmVyLgoKYFZlY3Rvcml6ZSgpYCBwcm92aWRlcyBhIGNvbnZlbmllbnQgYW5kIGNvbmNpc2Ugbm90YXRpb24gdG8gaXRlcmF0ZSBvdmVyIG11bHRpcGxlIGFyZ3VtZW50cyBidXQgaGFzIHNvbWUgbWFqb3IgZHJhd2JhY2tzIHRoYXQgbWVhbiB5b3UgZ2VuZXJhbGx5IHNob3VsZG4ndCB1c2UgaXQuIFNlZSBbdGhpcyBwb3N0XShodHRwczovL3d3dy5qaW1oZXN0ZXIuY29tL3Bvc3QvMjAxOC0wNC0xMi12ZWN0b3JpemUvKSBmb3IgbW9yZSBkZXRhaWxzLgoKTm90ZXM6IEppbSBIZXN0ZXIncyBhcnRpY2xlIHBvaW50cyBvdXQgdGhhdCBtb3N0IFIgZnVuY3Rpb25zIGFyZSBhbHJlYWR5IHZlY3Rvcml6ZWQsIGluY2x1ZGluZyBgcGFzdGUoKWAhCgpgYGB7cn0KY29sb3IgPC0gYygiYmx1ZSIsICJyZWQiLCAiZ3JlZW4iKQpvYmplY3QgPC0gYygiYmFsbCIsICJoYXQiLCAiY29hdCIpCm5hbWUgPC0gYygiU2FsbHkiLCAiSGFuayIsICJEYXJsYSIpCgpwYXN0ZSgiQSIsIGNvbG9yLCBvYmplY3QsICJmb3IiLCBuYW1lKQpgYGAKCkl0IGFsc28gYXJndWVzIGFnYWluc3QgdXNlIG9mIGBWZWN0b3JpemUoKWAgYmVjYXVzZSBhKSB0aGUgZnVuY3Rpb25zIGl0IGdlbmVyYXRlcyBhcmUgbm90IHR5cGUgc3RhYmxlLCBiKSBvYmZ1c2NhdGVzIHRoZSBmdW5jdGlvbiBjb2RlLCBjKSBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZSwgYW5kIGQpIGNhbid0IGltcHJvdmUgcGVyZm9ybWFuY2UuCgpIZSByZWNvbW1lbmRzIHVzaW5nIGV4aXN0aW5nIHZlY3Rvcml6ZWQgZnVuY3Rpb25zIGFuZCBlaXRoZXIgYHZhcHBseSgpYCBvciBgbWFwKClgLgoKLS0tCgoyLiAgUmVhZCB0aGUgc291cmNlIGNvZGUgZm9yIGBwb3NzaWJseSgpYC4gSG93IGRvZXMgaXQgd29yaz8KCmBgYHtyfQpwb3NzaWJseQpgYGAKCkFuc3dlcjogYHBvc3NpYmx5KClgIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHVzZXMgYHRyeUNhdGNoKClgIHRvIHJldHVybiBgb3RoZXJ3aXNlYCBpZiB0aGUgbWFwcGVyIGAuZmAgZXJyb3JzLCB1bmxlc3MgaW50ZXJydXB0ZWQsIGZvcmNpbmcgZXZhbHVhdGlvbiBvZiBgb3RoZXJ3aXNlYCBiZWZvcmUgdGhlIG1hcHBlciBpcyBjYWxsZWQuCgpBUiBTb2x1dGlvbnM6IGBwb3NzaWJseSgpYCBtb2RpZmllcyBmdW5jdGlvbnMgdG8gcmV0dXJuIGEgc3BlY2lmaWVkIGRlZmF1bHQgdmFsdWUgKGBvdGhlcndpc2VgKSBpbiBjYXNlIG9mIGFuIGVycm9yIGFuZCB0byBzdXBwcmVzcyBhbnkgZXJyb3IgbWVzc2FnZXMgKGBxdWlldCA9IFRSVUVgKS4KCldoaWxlIHJlYWRpbmcgdGhlIHNvdXJjZSBjb2RlLCB3ZSBub3RpY2UgdGhhdCBgcG9zc2libHkoKWAgaW50ZXJuYWxseSB1c2VzIGBwdXJycjo6YXNfbWFwcGVyKClgLiBUaGlzIGVuYWJsZXMgdXNlcnMgdG8gc3VwcGx5IG5vdCBvbmx5IGZ1bmN0aW9ucywgYnV0IGFsc28gZm9ybXVsYXMgb3IgYXRvbWljcyB2aWEgdGhlIHNhbWUgc3ludGF4IGFzIGtub3duIGZyb20gb3RoZXIgZnVuY3Rpb25zIGluIHRoZSBge3B1cnJyfWAgcGFja2FnZS4gQmVzaWRlcyB0aGlzLCB0aGUgbmV3IGRlZmF1bHQgdmFsdWUgKGBvdGhlcndpc2VgKSBnZXRzIGV2YWx1YXRlZCBvbmNlIHRvIG1ha2UgaXQgKGFsbW9zdCkgaW1tdXRhYmxlLgoKVGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBgcG9zc2libHkoKWAgaXMgcHJvdmlkZWQgYnkgYGJhc2U6OnRyeUNhdGNoKClgLiBJbiB0aGlzIHBhcnQgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIChgLmZgKSBnZXRzIHdyYXBwZWQgYW5kIHRoZSBlcnJvciBhbmQgaW50ZXJydXB0IGhhbmRsaW5nIGFyZSBzcGVjaWZpZWQuCgotLS0KCjMuICBSZWFkIHRoZSBzb3VyY2UgY29kZSBmb3IgYHNhZmVseSgpYC4gSG93IGRvZXMgaXQgd29yaz8KCmBgYHtyfQpzYWZlbHkKcHVycnI6OjpjYXB0dXJlX2Vycm9yICMgbm9saW50OiB1bmRlc2lyYWJsZV9vcGVyYXRvcl9saW50ZXIuCmBgYAoKQW5zd2VyOiBgc2FmZWx5KClgIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhlIGludGVybmFsIGBjYXB0dXJlX2Vycm9yKClgIGZ1bmN0aW9uIHRvIHN0b3JlIHRoZSBldmFsdWF0aW9uIG9mIHRoZSBtYXBwZXIgYC5mYCBpbiBgcmVzdWx0YCwgYW5kIGFueSBlcnJvciBpbiBgZXJyb3JgLgoKQVIgU29sdXRpb25zOiBgc2FmZWx5KClgIG1vZGlmaWVzIGZ1bmN0aW9ucyB0byByZXR1cm4gYSBsaXN0LCBjb250YWluaW5nIHRoZSBlbGVtZW50cyBgcmVzdWx0YCBhbmQgYGVycm9yYC4gSXQgd29ya3MgaW4gYSBzaW1pbGFyIGZhc2hpb24gYXMgYHBvc3NpYmx5KClgIGFuZCBiZXNpZGVzIHVzaW5nIGBhc19tYXBwZXIoKWAsIGBzYWZlbHkoKWAgYWxzbyBwcm92aWRlcyB0aGUgYG90aGVyd2lzZWAgYW5kIGBxdWlldGAgYXJndW1lbnRzLiBIb3dldmVyLCBpbiBvcmRlciB0byBwcm92aWRlIHRoZSByZXN1bHQgYW5kIHRoZSBlcnJvciBpbiBhIGNvbnNpc3RlbnQgd2F5LCB0aGUgYHRyeUNhdGNoKClgIHBhcnQgb2YgdGhlIGltcGxlbWVudGF0aW9uIHJldHVybnMgYSBsaXN0IHdpdGggc2ltaWxhciBzdHJ1Y3R1cmUgZm9yIGJvdGggY2FzZXMuIEluIHRoZSBjYXNlIG9mIHN1Y2Nlc3NmdWwgZXZhbHVhdGlvbiBgZXJyb3JgIGVxdWFscyBgTlVMTGAgYW5kIGluIGNhc2Ugb2YgYW4gZXJyb3IgYHJlc3VsdGAgZXF1YWxzIGBvdGhlcndpc2VgLCB3aGljaCBpcyBgTlVMTGAgYnkgZGVmYXVsdC4KCkFzIHRoZSBgdHJ5Q2F0Y2goKWAgcGFydCBpcyBoaWRkZW4gaW4gdGhlIGludGVybmFsIGBwdXJycjo6OmNhcHR1cmVfb3V0cHV0KClgIGZ1bmN0aW9uLCB3ZSBwcm92aWRlIGl0IGhlcmUgaW4gYWRkaXRpb24gdG8gYHNhZmVseSgpYC4KClRha2UgYSBsb29rIGF0ICpBZHZhbmNlZCBSKiBvciB0aGUgZG9jdW1lbnRhdGlvbiBvZiBgc2FmZWx5KClgIHRvIHNlZSBob3cgeW91IGNhbiB0YWtlIGFkdmFudGFnZSBvZiB0aGlzIGJlaGF2aW91ciwgZS5nLiB3aGVuIGZpdHRpbmcgbWFueSBtb2RlbHMuCgotLS0KCiMjIDExLjMuMSBFeGVyY2lzZXMKCjEuICBXZWlnaCB0aGUgcHJvcyBhbmQgY29ucyBvZiAKICAgIGBkb3dubG9hZC5maWxlICU+JSBkb3RfZXZlcnkoMTApICU+JSBkZWxheV9ieSgwLjEpYCB2ZXJzdXMKICAgIGBkb3dubG9hZC5maWxlICU+JSBkZWxheV9ieSgwLjEpICU+JSBkb3RfZXZlcnkoMTApYC4KCkFuc3dlcjogaW4gdGhlIGZpcnN0IHZlcnNpb24sIGBkb3dubG9hZC5maWxlICU+JSBkb3RfZXZlcnkoMTApICU+JSBkZWxheV9ieSgwLjEpYCwgYGRlbGF5X2J5YCBpcyB0aGUgb3V0ZXIgZnVuY3Rpb24sIHNvIGEgZGVsYXkgaXMgYWRkZWQgYWZ0ZXIgdGhlIGRvdCBpcyB3cml0dGVuLiBJbiB0aGUgc2Vjb25kIHZlcnNpb24sIGEgZG90IGlzIGFkZGVkIGFmdGVyIHRoZSBkZWxheS4gVGhlIGZpcnN0IHZlcnNpb24gc2VlbXMgYmV0dGVyIHNpbmNlIHRoZSBmZWVkYmFjayBkb3RzIGFyZW4ndCBkZWxheWVkLgoKQVIgU29sdXRpb25zOiBCb3RoIGNvbW1hbmRzIHdpbGwgcHJpbnQgYSBkb3QgZXZlcnkgMTAgZG93bmxvYWRzIGFuZCB3aWxsIHRha2UgdGhlIHNhbWUgYW1vdW50IG9mIHRpbWUgdG8gcnVuLCBzbyB0aGUgZGlmZmVyZW5jZXMgbWF5IHNlZW0gcXVpdGUgc3VidGxlLgoKSW4gdGhlIGZpcnN0IGNhc2UsIGZpcnN0IHRoZSBkb3QgZnVuY3Rpb25hbGl0eSBpcyBhZGRlZCB0byBgZG93bmxvYWQuZmlsZSgpYC4gVGhlbiB0aGUgZGVsYXkgaXMgYWRkZWQgdG8gdGhpcyBhbHJlYWR5IHR3ZWFrZWQgZnVuY3Rpb24uIFRoaXMgaW1wbGllcywgdGhhdCB0aGUgcHJpbnRpbmcgb2YgdGhlIGRvdCB3aWxsIGFsc28gYmUgZGVsYXllZCwgYW5kIHRoZSBmaXJzdCBkb3Qgd2lsbCBiZSBwcmludGVkIGFzIHNvb24gYXMgdGhlIGRvd25sb2FkIGZvciB0aGUgMTB0aCBVUkwgc3RhcnRzLgoKSW4gdGhlIGxhdHRlciBjYXNlIHRoZSBkZWxheSBpcyBhZGRlZCBmaXJzdCBhbmQgdGhlIGRvdC1mdW5jdGlvbmFsaXR5IGlzIHdyYXBwZWQgYXJvdW5kIGl0LiBUaGlzIG9yZGVyIHdpbGwgcHJpbnQgdGhlIGZpcnN0IGRvdCBpbW1lZGlhdGVseSBhZnRlciB0aGUgOXRoIGRvd25sb2FkIGlzIGZpbmlzaGVkLCB0aGVuIHRoZSBzaG9ydCBkZWxheSBvY2N1cnMgYmVmb3JlIHRoZSAxMHRoIGRvd25sb2FkIGFjdHVhbGx5IHN0YXJ0cy4KCk5vdGU6IHRoZSBmaXJzdCBjYXNlIHNlZW1zIGxpa2UgdGhlIGJldHRlciBvcHRpb24uCgotLS0KCjIuICBTaG91bGQgeW91IG1lbW9pc2UgYGZpbGUuZG93bmxvYWQoKWA/IFdoeSBvciB3aHkgbm90PwoKQW5zd2VyOiBgZG93bmxvYWQuZmlsZSgpYCBzaG91bGQgbm90IGJlIG1lbW9pc2VkISBBcyBtZW50aW9uZWQgaW4gdGhlIGNoYXB0ZXIsIHRoZSBmdW5jdGlvbiBpcyBub3QgcHVyZSAodGhlIG91dHB1dCBkb2Vzbid0IGRlcGVuZCBvbmx5IG9uIHRoZSBpbnB1dCksIGFuZCBoYXMgc2lkZSBlZmZlY3RzIChzYXZpbmcgYSBmaWxlIHRvIGRpc2spLgoKQVIgU29sdXRpb25zOiBNZW1vaXNpbmcgYGZpbGUuZG93bmxvYWQoKWAgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIGZpbGVzIGFyZSBpbW11dGFibGUsIGkuZS4gaWYgdGhlIGZpbGUgYXQgYSBnaXZlbiBVUkwgaXMgYWx3YXlzIHRoZSBzYW1lLiBUaGVyZSdzIG5vIHBvaW50IG1lbW9pc2luZyB1bmxlc3MgdGhpcyBpcyB0cnVlLiBFdmVuIGlmIHRoaXMgaXMgdHJ1ZSwgaG93ZXZlciwgbWVtb2lzZSBoYXMgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4gbWVtb3J5LCBhbmQgbGFyZ2UgZmlsZXMgd2lsbCBwb3RlbnRpYWxseSB0YWtlIHVwIGEgbG90IG9mIG1lbW9yeS4KClRoaXMgaW1wbGllcyB0aGF0IGl0J3MgcHJvYmFibHkgbm90IGJlbmVmaWNpYWwgdG8gbWVtb2lzZSBgZmlsZS5kb3dubG9hZCgpYCBpbiBtb3N0IGNhc2VzLiBUaGUgb25seSBleGNlcHRpb24gaXMgaWYgeW91IGFyZSBkb3dubG9hZGluZyBzbWFsbCBmaWxlcyBtYW55IHRpbWVzLCBhbmQgdGhlIGZpbGUgYXQgYSBnaXZlbiBVUkwgaXMgZ3VhcmFudGVlZCBub3QgdG8gY2hhbmdlLgoKTm90ZTogQVIgU29sdXRpb25zIG9mZmVycyBhIHJlYXNvbmFibGUgZXhjZXB0aW9uIGNhc2Ugd2hlbiBtZW1vaXNpbmcgbWFrZXMgc2Vuc2UuCgotLS0KCjMuICBDcmVhdGUgYSBmdW5jdGlvbiBvcGVyYXRvciB0aGF0IHJlcG9ydHMgd2hlbmV2ZXIgYSBmaWxlIGlzIGNyZWF0ZWQgb3IgCiAgICBkZWxldGVkIGluIHRoZSB3b3JraW5nIGRpcmVjdG9yeSwgdXNpbmcgYGRpcigpYCBhbmQgYHNldGRpZmYoKWAuIFdoYXQgb3RoZXIgCiAgICBnbG9iYWwgZnVuY3Rpb24gZWZmZWN0cyBtaWdodCB5b3Ugd2FudCB0byB0cmFjaz8KCmBgYHtyfQp3ZF9jaGFuZ2VzIDwtIGZ1bmN0aW9uKGYpIHsKICBmdW5jdGlvbiguLi4pIHsKICAgIGJlZm9yZSA8LSBkaXIoKQogICAgcmV0IDwtIHdpdGhWaXNpYmxlKGYoLi4uKSkKICAgIGFmdGVyIDwtIGRpcigpCiAgICByZW1vdmVkIDwtIHNldGRpZmYoYmVmb3JlLCBhZnRlcikKICAgIGFkZGVkIDwtIHNldGRpZmYoYWZ0ZXIsIGJlZm9yZSkKICAgIGlmIChsZW5ndGgocmVtb3ZlZCkgIT0gMCkgY2F0KCJyZW1vdmVkIGZpbGVzOiAiLCByZW1vdmVkLCAiXG4iKQogICAgaWYgKGxlbmd0aChhZGRlZCkgIT0gMCkgY2F0KCJhZGRlZCBmaWxlczogIiwgYWRkZWQsICJcbiIpCiAgICBpZiAocmV0JHZpc2libGUpIHsKICAgICAgcmV0JHZhbHVlCiAgICB9IGVsc2UgewogICAgICBpbnZpc2libGUocmV0JHZhbHVlKQogICAgfQogIH0KfQpgYGAKCkFuc3dlcjogY29kZSBhYm92ZS4gT3RoZXIgZWZmZWN0cyB5b3UgbWlnaHQgd2FudCB0byB0cmFjayBpbmNsdWRlIGNoYW5nZXMgdG8gdGhlIGdsb2JhbCBlbnZpcm9ubWVudCwgb3V0cHV0LCBhbmQgY29uZGl0aW9ucy4KCkFSIFNvbHV0aW9uczogV2Ugc3RhcnQgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgcmVwb3J0cyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIGNvbnRhaW5pbmcgZmlsZSBuYW1lczoKCmBgYHtyfQpkaXJfY29tcGFyZSA8LSBmdW5jdGlvbihvbGQsIG5ldykgewogIGlmIChzZXRlcXVhbChvbGQsIG5ldykpIHsKICAgIHJldHVybigpCiAgfQoKICBhZGRlZCA8LSBzZXRkaWZmKG5ldywgb2xkKQogIHJlbW92ZWQgPC0gc2V0ZGlmZihvbGQsIG5ldykKCiAgY2hhbmdlcyA8LSBjKAogICAgaWYgKGxlbmd0aChhZGRlZCkgPiAwKSBwYXN0ZTAoIiAqICciLCBhZGRlZCwgIicgd2FzIGFkZGVkIiksCiAgICBpZiAobGVuZ3RoKHJlbW92ZWQpID4gMCkgcGFzdGUwKCIgKiAnIiwgcmVtb3ZlZCwgIicgd2FzIHJlbW92ZWQiKQogICkKICBtZXNzYWdlKHBhc3RlKGNoYW5nZXMsIGNvbGxhcHNlID0gIlxuIikpCn0KZGlyX2NvbXBhcmUoYygieCIsICJ5IiksIGMoIngiLCAieSIpKQpkaXJfY29tcGFyZShjKCJ4IiwgInkiKSwgYygieCIsICJhIikpCmBgYAoKVGhlbiB3ZSB3cmFwIGl0IHVwIGluIGEgZnVuY3Rpb24gb3BlcmF0b3IKCmBgYHtyfQp0cmFja19kaXIgPC0gZnVuY3Rpb24oZikgewogIGZvcmNlKGYpCiAgZnVuY3Rpb24oLi4uKSB7CiAgICBkaXJfb2xkIDwtIGRpcigpCiAgICBvbi5leGl0KGRpcl9jb21wYXJlKGRpcl9vbGQsIGRpcigpKSwgYWRkID0gVFJVRSkKCiAgICBmKC4uLikKICB9Cn0KYGBgCgpBbmQgdHJ5IGl0IG91dCBieSBjcmVhdGluZyB3cmFwcGVycyBhcm91bmQgYGZpbGUuY3JlYXRlKClgIGFuZCBgZmlsZS5yZW1vdmUoKWA6CgpgYGB7cn0KZmlsZV9jcmVhdGUgPC0gdHJhY2tfZGlyKGZpbGUuY3JlYXRlKQpmaWxlX3JlbW92ZSA8LSB0cmFja19kaXIoZmlsZS5yZW1vdmUpCmZpbGVfY3JlYXRlKCJkZWxldGVfbWUiKQpmaWxlX3JlbW92ZSgiZGVsZXRlX21lIikKYGBgCgpUbyBjcmVhdGUgYSBtb3JlIHNlcmlvdXMgdmVyc2lvbiBvZiBgdHJhY2tfZGlyKClgIG9uZSBtaWdodCBwcm92aWRlIG9wdGlvbmFsaXR5IHRvIHNldCB0aGUgYGZ1bGwubmFtZXNgIGFuZCBgcmVjdXJzaXZlYCBhcmd1bWVudHMgb2YgYGRpcigpYCB0byBgVFJVRWAuIFRoaXMgd291bGQgZW5hYmxlIHRvIGFsc28gdHJhY2sgdGhlIGNyZWF0aW9uL2RlbGV0aW9uIG9mIGhpZGRlbiBmaWxlcyBhbmQgZmlsZXMgaW4gZm9sZGVycyBjb250YWluZWQgaW4gdGhlIHdvcmtpbmcgZGlyZWN0b3J5LgoKT3RoZXIgZ2xvYmFsIGVmZmVjdHMgdGhhdCBtaWdodCBiZSB3b3J0aCB0cmFja2luZyBpbmNsdWRlIGNoYW5nZXMgcmVnYXJkaW5nOgoKLSB0aGUgc2VhcmNoIHBhdGggYW5kIHBvc3NpYmx5IGludHJvZHVjZWQgYGNvbmZsaWN0cygpYAotIGBvcHRpb25zKClgIGFuZCBgcGFyKClgIHdoaWNoIG1vZGlmeSBnbG9iYWwgc2V0dGluZ3MKLSB0aGUgcGF0aCBvZiB0aGUgd29ya2luZyBkaXJlY3RvcnkKLSBlbnZpcm9ubWVudCB2YXJpYWJsZXMKCk5vdGVzOiBBUiBTb2x1dGlvbnMgdXNlIG9mIG11bHRpcGxlIGZ1bmN0aW9ucywgbWVzc2FnZXMgYW5kIGBvbi5leGl0YCBpcyBwcmVmZXJhYmxlLgoKLS0tCgo0LiAgV3JpdGUgYSBmdW5jdGlvbiBvcGVyYXRvciB0aGF0IGxvZ3MgYSB0aW1lc3RhbXAgYW5kIG1lc3NhZ2UgdG8gYSBmaWxlIAogICAgZXZlcnkgdGltZSBhIGZ1bmN0aW9uIGlzIHJ1bi4KCmBgYHtyfQpsb2dfY2FsbCA8LSBmdW5jdGlvbihmLCBsb2dmaWxlID0gImxvZ19jYWxsLmxvZyIpIHsKICBuYW1lIDwtIGRlcGFyc2UoZW5leHByKGYpKQogIGZvcmNlKGYpCiAgZm9yY2UobG9nZmlsZSkKCiAgZnVuY3Rpb24oLi4uKSB7CiAgICBtIDwtIHBhc3RlMChTeXMudGltZSgpLCAiIGxvZ19jYWxsOiAiLCBuYW1lKQogICAgd3JpdGUobSwgZmlsZSA9IGxvZ2ZpbGUsIGFwcGVuZCA9IFRSVUUpCiAgICBmKC4uLikKICB9Cn0KYGBgCgpBbnN3ZXI6IGNvZGUgYWJvdmUuCgpBUiBTb2x1dGlvbnM6IE91ciBgbG9nZ2VyKClgIGZ1bmN0aW9uIG9wZXJhdG9yIHRha2VzIGEgZnVuY3Rpb24gYW5kIGEgZmlsZSBwYXRoIGFzIGlucHV0LiBPbmUgdGltZXN0YW1wIGlzIHdyaXR0ZW4gdG8gdGhlIGZpbGUgdW5kZXIgYGxvZ19wYXRoYCB3aGVuIHdlIGNhbGwgYGxvZ2dlcigpYCBhbmQgYW5vdGhlciB0aW1lc3RhbXAgaXMgd3JpdHRlbiB0byB0aGUgc2FtZSBmaWxlIGVhY2ggdGltZSB0aGUgbmV3IGZ1bmN0aW9uIGdldHMgY2FsbGVkLgoKYGBge3J9CmFwcGVuZF9saW5lIDwtIGZ1bmN0aW9uKHBhdGgsIC4uLikgewogIGNhdCguLi4sICJcbiIsIHNlcCA9ICIiLCBmaWxlID0gcGF0aCwgYXBwZW5kID0gVFJVRSkKfQoKbG9nZ2VyIDwtIGZ1bmN0aW9uKGYsIGxvZ19wYXRoKSB7CiAgZm9yY2UoZikKICBmb3JjZShsb2dfcGF0aCkKCiAgYXBwZW5kX2xpbmUobG9nX3BhdGgsICJjcmVhdGVkIGF0OiAiLCBhcy5jaGFyYWN0ZXIoU3lzLnRpbWUoKSkpCiAgZnVuY3Rpb24oLi4uKSB7CiAgICBhcHBlbmRfbGluZShsb2dfcGF0aCwgImNhbGxlZCBhdDogIiwgYXMuY2hhcmFjdGVyKFN5cy50aW1lKCkpKQogICAgZiguLi4pCiAgfQp9CmBgYAoKTm90ZTogQVIgU29sdXRpb25zIGNyZWF0ZXMgYSBmdW5jdGlvbiBgYXBwZW5kX2xpbmUoKWAgaW5zdGVhZCBvZiB1c2luZyBgd3JpdGUoKWAsIGFuZCBhZGRzIGEgImNyZWF0ZWQgYXQ6ICIgdGltZSwgYnV0IGlzIG90aGVyd2lzZSBmdW5jdGlvbmFsbHkgdGhlIHNhbWUuIE15IHNvbHV0aW9uIGFsc28gbG9ncyB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gY2FsbGVkLgoKLS0tCgo1LiAgTW9kaWZ5IGBkZWxheV9ieSgpYCBzbyB0aGF0IGluc3RlYWQgb2YgZGVsYXlpbmcgYnkgYSBmaXhlZCBhbW91bnQgb2YgdGltZSwgCiAgICBpdCBlbnN1cmVzIHRoYXQgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBmdW5jdGlvbiAKICAgIHdhcyBsYXN0IGNhbGxlZC4gVGhhdCBpcywgaWYgeW91IGNhbGxlZCAKICAgIGBnIDwtIGRlbGF5X2J5KDEsIGYpOyBnKCk7IFN5cy5zbGVlcCgyKTsgZygpYCB0aGVyZSBzaG91bGRuJ3QgYmUgYW4gCiAgICBleHRyYSBkZWxheS4KCmBgYHtyfQpzbGVlcF9pZiA8LSBmdW5jdGlvbihzdGFydCwgZW5kLCBkZWxheSkgewogIHNsZWVwX3RpbWUgPC0gZGVsYXkgLSBhcy5udW1lcmljKGVuZCAtIHN0YXJ0KQogIGlmIChzbGVlcF90aW1lID4gMCkgU3lzLnNsZWVwKHNsZWVwX3RpbWUpCn0KCmRlbGF5X2J5IDwtIGZ1bmN0aW9uKGYsIGRlbGF5KSB7CiAgZm9yY2UoZikKICBmb3JjZShkZWxheSkKCiAgbGFzdF9jYWxsZWQgPC0gTlVMTAogIGZ1bmN0aW9uKC4uLikgewogICAgaWYgKCFpcy5udWxsKGxhc3RfY2FsbGVkKSkgewogICAgICBzbGVlcF9pZihsYXN0X2NhbGxlZCwgU3lzLnRpbWUoKSwgZGVsYXkpCiAgICB9CiAgICBvbi5leGl0KGxhc3RfY2FsbGVkIDw8LSBTeXMudGltZSgpLCBhZGQgPSBUUlVFKSAjIG5vbGludDogdW5kZXNpcmFibGVfb3BlcmF0b3JfbGludGVyLgoKICAgIGYoLi4uKQogIH0KfQoKZiA8LSBmdW5jdGlvbigpIHsKICAwCn0KZyA8LSBkZWxheV9ieShmLCAxKQpoIDwtIGRlbGF5X2J5KGYsIDEpCgpzeXN0ZW0udGltZSh7CiAgaCgpCiAgaCgpCn0pCgpzeXN0ZW0udGltZSh7CiAgZygpCiAgU3lzLnNsZWVwKDIpCiAgZygpCn0pCmBgYAoKQW5zd2VyOiBjb2RlIGFib3ZlLgoKQVIgU29sdXRpb25zOgoKVG8gZW5zdXJlIHRoYXQgdGhlIGZ1bmN0aW9uIGNyZWF0ZWQgYnkgYGRlbGF5X2J5KClgIHdhaXRzIHRoYXQgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIGhhcyBwYXNzZWQgc2luY2UgaXRzIGxhc3QgZXhlY3V0aW9uLCB3ZSBpbmNvcnBvcmF0ZSB0aHJlZSBsaXR0bGUgY2hhbmdlcyBpbnRvIG91ciBuZXcgYGRlbGF5X2F0bGVhc3QoKWAgYXMgaW5kaWNhdGVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGNvbW1lbnRzIGJlbG93LgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KZGVsYXlfYXRsZWFzdCA8LSBmdW5jdGlvbihhbW91bnQsIGYpIHsKICBmb3JjZShmKQogIGZvcmNlKGFtb3VudCkKCiAgIyBTdG9yZSB0aGUgbGFzdCB0aW1lIHRoZSBmdW5jdGlvbiB3YXMgcnVuCiAgbGFzdF90aW1lIDwtIE5VTEwKCiAgIyBSZXR1cm4gbW9kaWZpZWQgImRlbGF5LWF3YXJlIiBmdW5jdGlvbgogIGZ1bmN0aW9uKC4uLikgewogICAgaWYgKCFpcy5udWxsKGxhc3RfdGltZSkpIHsKICAgICAgd2FpdCA8LSAobGFzdF90aW1lIC0gU3lzLnRpbWUoKSkgKyBhbW91bnQKICAgICAgaWYgKHdhaXQgPiAwKSB7CiAgICAgICAgU3lzLnNsZWVwKHdhaXQpCiAgICAgIH0KICAgIH0KCiAgICAjIFVwZGF0ZSB0aGUgdGltZSBhZnRlciB0aGUgZnVuY3Rpb24gaGFzIGZpbmlzaGVkCiAgICBvbi5leGl0KGxhc3RfdGltZSA8PC0gU3lzLnRpbWUoKSkgIyBub2xpbnQ6IHVuZGVzaXJhYmxlX29wZXJhdG9yX2xpbnRlci4KCiAgICBmKC4uLikKICB9Cn0KYGBgCgpOb3RlczogdGhpcyB3YXMgdHJpY2t5OyBJIGhhZCB0byBjb25zdWx0IEFSIFNvbHV0aW9ucyBmb3IgYW4gYW5zd2VyLgoKLS0tCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("advanced-r-2.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
